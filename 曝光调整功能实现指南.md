# ä¸“ä¸šçº§æ›å…‰è°ƒæ•´åŠŸèƒ½å®ç°æŒ‡å—

## æ ¸å¿ƒæ¦‚å¿µï¼šæ›å…‰ vs äº®åº¦

### 1. æ›å…‰ (Exposure)

**ç‰©ç†åŸç†**ï¼š
- æ¨¡æ‹Ÿç›¸æœºä¼ æ„Ÿå™¨æ¥æ”¶å…‰çº¿çš„æ—¶é—´å’Œå¼ºåº¦
- æœ¬è´¨æ˜¯ä¸€ä¸ª**ä¹˜æ³•æ“ä½œ**
- å½±å“å›¾åƒçš„åŠ¨æ€èŒƒå›´å’Œå¯¹æ¯”åº¦

**æ•°å­¦è¡¨è¾¾**ï¼š
```
RGB_output = RGB_input Ã— 2^exposure
```

**ç‰¹ç‚¹**ï¼š
- âœ… ä¿æŒé¢œè‰²ç›¸å¯¹å…³ç³»
- âœ… æš—éƒ¨å’Œäº®éƒ¨æŒ‰æ¯”ä¾‹ç¼©æ”¾
- âœ… æ›´è‡ªç„¶ï¼Œæ¥è¿‘çœŸå®æ‘„å½±
- âš ï¸ å¯èƒ½å¯¼è‡´é«˜å…‰æº¢å‡ºï¼ˆclippingï¼‰
- âš ï¸ å¯èƒ½ä¸¢å¤±æš—éƒ¨ç»†èŠ‚

### 2. äº®åº¦ (Brightness/Lightness)

**ç‰©ç†åŸç†**ï¼š
- ç›´æ¥è°ƒæ•´åƒç´ çš„æ˜æš—å€¼
- æœ¬è´¨æ˜¯ä¸€ä¸ª**åŠ æ³•æ“ä½œ**
- åœ¨HSLè‰²å½©ç©ºé—´ä¸­æ“ä½œ

**æ•°å­¦è¡¨è¾¾**ï¼š
```
RGB_output = RGB_input + brightness_offset
æˆ–åœ¨HSLç©ºé—´ï¼š
L_output = L_input + lightness_offset
```

**ç‰¹ç‚¹**ï¼š
- âœ… çº¿æ€§è°ƒæ•´ï¼Œå¯é¢„æµ‹
- âœ… é€‚åˆå±€éƒ¨è°ƒæ•´
- âš ï¸ å¯èƒ½ç ´åé¢œè‰²å…³ç³»
- âš ï¸ å®¹æ˜“äº§ç”Ÿç°è’™è’™çš„æ•ˆæœ

---

## ä¸“ä¸šçº§è°ƒæ•´é¢æ¿è®¾è®¡

### ç•Œé¢å¸ƒå±€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“· Exposure & Tone                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  Exposure        [-2.0 â”â”â—â”â”â”â”â” +2.0]  â”‚
â”‚                   EV 0.0                â”‚
â”‚                                         â”‚
â”‚  Contrast        [-100 â”â”â”â—â”â”â” +100]   â”‚
â”‚                    0%                   â”‚
â”‚                                         â”‚
â”‚  Highlights      [-100 â”â”â”â—â”â”â” +100]   â”‚
â”‚                    0%                   â”‚
â”‚                                         â”‚
â”‚  Shadows         [-100 â”â”â”â—â”â”â” +100]   â”‚
â”‚                    0%                   â”‚
â”‚                                         â”‚
â”‚  Whites          [-100 â”â”â”â—â”â”â” +100]   â”‚
â”‚                    0%                   â”‚
â”‚                                         â”‚
â”‚  Blacks          [-100 â”â”â”â—â”â”â” +100]   â”‚
â”‚                    0%                   â”‚
â”‚                                         â”‚
â”‚  [Reset] [Auto Adjust] [Copy Settings]  â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ§åˆ¶é¡¹è¯´æ˜

| æ§åˆ¶é¡¹ | èŒƒå›´ | å•ä½ | ä½œç”¨ | ç®—æ³•ç±»å‹ |
|--------|------|------|------|----------|
| **Exposure** | -3.0 ~ +3.0 | EV (Exposure Value) | æ•´ä½“æ›å…‰è°ƒæ•´ | ä¹˜æ³• |
| **Contrast** | -100 ~ +100 | % | å¯¹æ¯”åº¦è°ƒæ•´ | Sæ›²çº¿ |
| **Highlights** | -100 ~ +100 | % | é«˜å…‰åŒºåŸŸè°ƒæ•´ | é€‰æ‹©æ€§è°ƒæ•´ |
| **Shadows** | -100 ~ +100 | % | é˜´å½±åŒºåŸŸè°ƒæ•´ | é€‰æ‹©æ€§è°ƒæ•´ |
| **Whites** | -100 ~ +100 | % | ç™½è‰²ç‚¹è°ƒæ•´ | é˜ˆå€¼è°ƒæ•´ |
| **Blacks** | -100 ~ +100 | % | é»‘è‰²ç‚¹è°ƒæ•´ | é˜ˆå€¼è°ƒæ•´ |

---

## æŠ€æœ¯å®ç°

### 1. WebGPUç€è‰²å™¨å®ç°

#### æ–‡ä»¶ç»“æ„
```
demo/src/utils/webgpu/
â”œâ”€â”€ exposure-shaders.ts      # æ›å…‰è°ƒæ•´ç€è‰²å™¨
â”œâ”€â”€ exposure-processor.ts    # WebGPUå¤„ç†å™¨
â””â”€â”€ tone-curve.ts           # è‰²è°ƒæ›²çº¿å·¥å…·
```

#### exposure-shaders.ts

```typescript
/**
 * ä¸“ä¸šçº§æ›å…‰è°ƒæ•´WebGPUç€è‰²å™¨
 */

export const exposureAdjustmentShader = /* wgsl */`
  struct ExposureParams {
    exposure: f32,        // EVå€¼ï¼ŒèŒƒå›´ -3.0 åˆ° +3.0
    contrast: f32,        // å¯¹æ¯”åº¦ï¼ŒèŒƒå›´ -1.0 åˆ° +1.0
    highlights: f32,      // é«˜å…‰è°ƒæ•´ï¼ŒèŒƒå›´ -1.0 åˆ° +1.0
    shadows: f32,         // é˜´å½±è°ƒæ•´ï¼ŒèŒƒå›´ -1.0 åˆ° +1.0
    whites: f32,          // ç™½è‰²ç‚¹ï¼ŒèŒƒå›´ -1.0 åˆ° +1.0
    blacks: f32,          // é»‘è‰²ç‚¹ï¼ŒèŒƒå›´ -1.0 åˆ° +1.0
  }

  @group(0) @binding(0) var<storage, read> inputBuffer: array<u32>;
  @group(0) @binding(1) var<storage, read_write> outputBuffer: array<u32>;
  @group(0) @binding(2) var<uniform> params: ExposureParams;
  @group(0) @binding(3) var<uniform> dimensions: vec2<u32>;

  // è®¡ç®—äº®åº¦ï¼ˆæ„ŸçŸ¥äº®åº¦ï¼‰
  fn getLuminance(rgb: vec3<f32>) -> f32 {
    return dot(rgb, vec3<f32>(0.2126, 0.7152, 0.0722));
  }

  // æ›å…‰è°ƒæ•´ï¼ˆä¹˜æ³•æ“ä½œï¼‰
  fn applyExposure(rgb: vec3<f32>, ev: f32) -> vec3<f32> {
    let multiplier = pow(2.0, ev);
    return rgb * multiplier;
  }

  // å¯¹æ¯”åº¦è°ƒæ•´ï¼ˆSæ›²çº¿ï¼‰
  fn applyContrast(rgb: vec3<f32>, contrast: f32) -> vec3<f32> {
    let midpoint = 0.5;
    let factor = (1.0 + contrast) / (1.0 - contrast + 0.0001);
    return clamp((rgb - midpoint) * factor + midpoint, vec3<f32>(0.0), vec3<f32>(1.0));
  }

  // é«˜å…‰è°ƒæ•´ï¼ˆé’ˆå¯¹äº®éƒ¨åŒºåŸŸï¼‰
  fn applyHighlights(rgb: vec3<f32>, adjustment: f32) -> vec3<f32> {
    let lum = getLuminance(rgb);
    // ä½¿ç”¨æŸ”å’Œçš„æƒé‡æ›²çº¿ï¼Œåªå½±å“é«˜å…‰åŒºåŸŸï¼ˆäº®åº¦ > 0.5ï¼‰
    let weight = smoothstep(0.5, 1.0, lum);
    let adjustedLum = lum + adjustment * weight;
    
    // ä¿æŒé¢œè‰²æ¯”ä¾‹
    let ratio = adjustedLum / (lum + 0.0001);
    return clamp(rgb * ratio, vec3<f32>(0.0), vec3<f32>(1.0));
  }

  // é˜´å½±è°ƒæ•´ï¼ˆé’ˆå¯¹æš—éƒ¨åŒºåŸŸï¼‰
  fn applyShadows(rgb: vec3<f32>, adjustment: f32) -> vec3<f32> {
    let lum = getLuminance(rgb);
    // ä½¿ç”¨æŸ”å’Œçš„æƒé‡æ›²çº¿ï¼Œåªå½±å“é˜´å½±åŒºåŸŸï¼ˆäº®åº¦ < 0.5ï¼‰
    let weight = smoothstep(0.5, 0.0, lum);
    let adjustedLum = lum + adjustment * weight;
    
    // ä¿æŒé¢œè‰²æ¯”ä¾‹
    let ratio = adjustedLum / (lum + 0.0001);
    return clamp(rgb * ratio, vec3<f32>(0.0), vec3<f32>(1.0));
  }

  // ç™½è‰²ç‚¹è°ƒæ•´ï¼ˆæäº®åŒºåŸŸï¼‰
  fn applyWhites(rgb: vec3<f32>, adjustment: f32) -> vec3<f32> {
    let lum = getLuminance(rgb);
    // åªå½±å“æœ€äº®çš„åŒºåŸŸï¼ˆäº®åº¦ > 0.7ï¼‰
    let weight = smoothstep(0.7, 1.0, lum);
    let adjustedLum = lum + adjustment * weight;
    
    let ratio = adjustedLum / (lum + 0.0001);
    return clamp(rgb * ratio, vec3<f32>(0.0), vec3<f32>(1.0));
  }

  // é»‘è‰²ç‚¹è°ƒæ•´ï¼ˆææš—åŒºåŸŸï¼‰
  fn applyBlacks(rgb: vec3<f32>, adjustment: f32) -> vec3<f32> {
    let lum = getLuminance(rgb);
    // åªå½±å“æœ€æš—çš„åŒºåŸŸï¼ˆäº®åº¦ < 0.3ï¼‰
    let weight = smoothstep(0.3, 0.0, lum);
    let adjustedLum = lum + adjustment * weight;
    
    let ratio = adjustedLum / (lum + 0.0001);
    return clamp(rgb * ratio, vec3<f32>(0.0), vec3<f32>(1.0));
  }

  @compute @workgroup_size(8, 8)
  fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let x = global_id.x;
    let y = global_id.y;
    
    if (x >= dimensions.x || y >= dimensions.y) {
      return;
    }
    
    let index = y * dimensions.x + x;
    let pixel = inputBuffer[index];
    
    // è§£åŒ…RGBA
    var r = f32((pixel >> 0u) & 0xFFu) / 255.0;
    var g = f32((pixel >> 8u) & 0xFFu) / 255.0;
    var b = f32((pixel >> 16u) & 0xFFu) / 255.0;
    let a = f32((pixel >> 24u) & 0xFFu) / 255.0;
    
    var rgb = vec3<f32>(r, g, b);
    
    // æŒ‰ä¸“ä¸šé¡ºåºåº”ç”¨è°ƒæ•´
    // 1. æ›å…‰ï¼ˆæœ€å…ˆåº”ç”¨ï¼Œå½±å“æ•´ä½“äº®åº¦ï¼‰
    rgb = applyExposure(rgb, params.exposure);
    
    // 2. é»‘è‰²ç‚¹å’Œç™½è‰²ç‚¹ï¼ˆè°ƒæ•´åŠ¨æ€èŒƒå›´çš„ç«¯ç‚¹ï¼‰
    rgb = applyBlacks(rgb, params.blacks);
    rgb = applyWhites(rgb, params.whites);
    
    // 3. é˜´å½±å’Œé«˜å…‰ï¼ˆå±€éƒ¨è°ƒæ•´ï¼‰
    rgb = applyShadows(rgb, params.shadows);
    rgb = applyHighlights(rgb, params.highlights);
    
    // 4. å¯¹æ¯”åº¦ï¼ˆæœ€ååº”ç”¨ï¼Œè°ƒæ•´æ•´ä½“å¯¹æ¯”ï¼‰
    rgb = applyContrast(rgb, params.contrast);
    
    // æ‰“åŒ…å›RGBA
    let outR = u32(clamp(rgb.r * 255.0, 0.0, 255.0));
    let outG = u32(clamp(rgb.g * 255.0, 0.0, 255.0));
    let outB = u32(clamp(rgb.b * 255.0, 0.0, 255.0));
    let outA = u32(a * 255.0);
    
    outputBuffer[index] = (outA << 24u) | (outB << 16u) | (outG << 8u) | outR;
  }
`
```

#### exposure-processor.ts

```typescript
import { getGPUDevice } from './webgpuDevice'
import { exposureAdjustmentShader } from './exposure-shaders'

export interface ExposureParams {
  exposure: number      // -3.0 åˆ° +3.0 (EV)
  contrast: number      // -100 åˆ° +100 (%)
  highlights: number    // -100 åˆ° +100 (%)
  shadows: number       // -100 åˆ° +100 (%)
  whites: number        // -100 åˆ° +100 (%)
  blacks: number        // -100 åˆ° +100 (%)
}

export class WebGPUExposureProcessor {
  private device: GPUDevice | null = null
  private pipeline: GPUComputePipeline | null = null
  private bindGroupLayout: GPUBindGroupLayout | null = null

  async initialize() {
    this.device = await getGPUDevice()
    if (!this.device) {
      throw new Error('Failed to get WebGPU device')
    }

    // åˆ›å»ºç€è‰²å™¨æ¨¡å—
    const shaderModule = this.device.createShaderModule({
      code: exposureAdjustmentShader,
      label: 'Exposure Adjustment Shader'
    })

    // åˆ›å»ºç»‘å®šç»„å¸ƒå±€
    this.bindGroupLayout = this.device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }
      ],
      label: 'Exposure Bind Group Layout'
    })

    // åˆ›å»ºç®¡çº¿
    this.pipeline = this.device.createComputePipeline({
      layout: this.device.createPipelineLayout({
        bindGroupLayouts: [this.bindGroupLayout]
      }),
      compute: {
        module: shaderModule,
        entryPoint: 'main'
      },
      label: 'Exposure Adjustment Pipeline'
    })
  }

  async process(
    inputBuffer: GPUBuffer,
    width: number,
    height: number,
    params: ExposureParams
  ): Promise<GPUBuffer> {
    if (!this.device || !this.pipeline || !this.bindGroupLayout) {
      throw new Error('Processor not initialized')
    }

    const pixelCount = width * height

    // åˆ›å»ºè¾“å‡ºç¼“å†²åŒº
    const outputBuffer = this.device.createBuffer({
      size: pixelCount * 4,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
      label: 'Exposure Output Buffer'
    })

    // åˆ›å»ºå‚æ•°ç»Ÿä¸€ç¼“å†²åŒºï¼ˆ6ä¸ªfloat32ï¼‰
    const paramsBuffer = this.device.createBuffer({
      size: 6 * 4, // 6 floats
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      label: 'Exposure Params Buffer'
    })

    // å°†ç™¾åˆ†æ¯”è½¬æ¢ä¸º -1.0 åˆ° +1.0 èŒƒå›´
    const paramsData = new Float32Array([
      params.exposure,
      params.contrast / 100.0,
      params.highlights / 100.0,
      params.shadows / 100.0,
      params.whites / 100.0,
      params.blacks / 100.0
    ])
    this.device.queue.writeBuffer(paramsBuffer, 0, paramsData)

    // åˆ›å»ºå°ºå¯¸ç»Ÿä¸€ç¼“å†²åŒº
    const dimensionsBuffer = this.device.createBuffer({
      size: 8, // 2 uint32
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      label: 'Dimensions Buffer'
    })
    const dimensionsData = new Uint32Array([width, height])
    this.device.queue.writeBuffer(dimensionsBuffer, 0, dimensionsData)

    // åˆ›å»ºç»‘å®šç»„
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: inputBuffer } },
        { binding: 1, resource: { buffer: outputBuffer } },
        { binding: 2, resource: { buffer: paramsBuffer } },
        { binding: 3, resource: { buffer: dimensionsBuffer } }
      ],
      label: 'Exposure Bind Group'
    })

    // åˆ›å»ºå‘½ä»¤ç¼–ç å™¨å¹¶æ‰§è¡Œ
    const commandEncoder = this.device.createCommandEncoder()
    const passEncoder = commandEncoder.beginComputePass()
    passEncoder.setPipeline(this.pipeline)
    passEncoder.setBindGroup(0, bindGroup)
    
    const workgroupsX = Math.ceil(width / 8)
    const workgroupsY = Math.ceil(height / 8)
    passEncoder.dispatchWorkgroups(workgroupsX, workgroupsY)
    passEncoder.end()

    this.device.queue.submit([commandEncoder.finish()])

    // æ¸…ç†ä¸´æ—¶ç¼“å†²åŒº
    paramsBuffer.destroy()
    dimensionsBuffer.destroy()

    return outputBuffer
  }

  destroy() {
    this.device = null
    this.pipeline = null
    this.bindGroupLayout = null
  }
}
```

### 2. å›¾åƒå¤„ç†æ­¥éª¤

#### exposureAdjustStep.ts

```typescript
import { WebGPUExposureProcessor, ExposureParams } from './webgpu/exposure-processor'
import { imageDataToGPUBuffer, gpuBufferToImageData } from './webgpu/bufferUtils'

export interface ExposureAdjustmentOptions extends ExposureParams {
  enabled: boolean
}

export class ExposureAdjustProcessStep {
  private processor: WebGPUExposureProcessor

  constructor() {
    this.processor = new WebGPUExposureProcessor()
  }

  async initialize() {
    await this.processor.initialize()
  }

  async execute(
    input: GPUBuffer | ImageData,
    options: ExposureAdjustmentOptions
  ): Promise<GPUBuffer> {
    // å¦‚æœæœªå¯ç”¨ï¼Œç›´æ¥è¿”å›è¾“å…¥
    if (!options.enabled) {
      if (input instanceof ImageData) {
        return await imageDataToGPUBuffer(input)
      }
      return input
    }

    let inputBuffer: GPUBuffer
    let width: number
    let height: number

    if (input instanceof ImageData) {
      width = input.width
      height = input.height
      inputBuffer = await imageDataToGPUBuffer(input)
    } else {
      throw new Error('This step requires ImageData dimensions info')
    }

    // æ‰§è¡Œæ›å…‰è°ƒæ•´
    const outputBuffer = await this.processor.process(
      inputBuffer,
      width,
      height,
      {
        exposure: options.exposure,
        contrast: options.contrast,
        highlights: options.highlights,
        shadows: options.shadows,
        whites: options.whites,
        blacks: options.blacks
      }
    )

    return outputBuffer
  }

  destroy() {
    this.processor.destroy()
  }
}
```

### 3. UIç»„ä»¶

#### ExposurePanel.vue

```vue
<template>
  <div class="exposure-panel">
    <div class="panel-header">
      <div class="header-title">
        <div class="i-carbon-camera" />
        <span>Exposure & Tone</span>
      </div>
      <div class="header-actions">
        <button 
          class="action-btn" 
          @click="resetAll"
          title="Reset All"
        >
          <div class="i-carbon-reset" />
        </button>
        <button 
          class="action-btn" 
          @click="autoAdjust"
          title="Auto Adjust"
        >
          <div class="i-carbon-automatic" />
        </button>
      </div>
    </div>

    <div class="controls-section">
      <!-- æ›å…‰ -->
      <div class="control-group exposure-control">
        <label class="control-label">
          <span>Exposure</span>
          <span class="value-display">{{ formatEV(exposure) }}</span>
        </label>
        <Slider
          :model-value="exposure"
          :min="-3"
          :max="3"
          :step="0.01"
          @update:modelValue="updateExposure"
        />
        <div class="range-labels">
          <span>-3 EV</span>
          <span>0</span>
          <span>+3 EV</span>
        </div>
      </div>

      <!-- å¯¹æ¯”åº¦ -->
      <div class="control-group">
        <label class="control-label">
          <span>Contrast</span>
          <span class="value-display">{{ formatPercent(contrast) }}</span>
        </label>
        <Slider
          :model-value="contrast"
          :min="-100"
          :max="100"
          :step="1"
          @update:modelValue="updateContrast"
        />
      </div>

      <div class="divider" />

      <!-- é«˜å…‰ -->
      <div class="control-group">
        <label class="control-label">
          <span>Highlights</span>
          <span class="value-display">{{ formatPercent(highlights) }}</span>
        </label>
        <Slider
          :model-value="highlights"
          :min="-100"
          :max="100"
          :step="1"
          @update:modelValue="updateHighlights"
        />
      </div>

      <!-- é˜´å½± -->
      <div class="control-group">
        <label class="control-label">
          <span>Shadows</span>
          <span class="value-display">{{ formatPercent(shadows) }}</span>
        </label>
        <Slider
          :model-value="shadows"
          :min="-100"
          :max="100"
          :step="1"
          @update:modelValue="updateShadows"
        />
      </div>

      <div class="divider" />

      <!-- ç™½è‰²ç‚¹ -->
      <div class="control-group">
        <label class="control-label">
          <span>Whites</span>
          <span class="value-display">{{ formatPercent(whites) }}</span>
        </label>
        <Slider
          :model-value="whites"
          :min="-100"
          :max="100"
          :step="1"
          @update:modelValue="updateWhites"
        />
      </div>

      <!-- é»‘è‰²ç‚¹ -->
      <div class="control-group">
        <label class="control-label">
          <span>Blacks</span>
          <span class="value-display">{{ formatPercent(blacks) }}</span>
        </label>
        <Slider
          :model-value="blacks"
          :min="-100"
          :max="100"
          :step="1"
          @update:modelValue="updateBlacks"
        />
      </div>
    </div>

    <!-- ç›´æ–¹å›¾é¢„è§ˆï¼ˆå¯é€‰ï¼‰ -->
    <div v-if="showHistogram" class="histogram-section">
      <HistogramDisplay :image-data="imageData" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue'
import { createUpdateDataEvent } from '../types/controlEvents'
import type { ControlEvent } from '../types/controlEvents'
import Slider from './Slider.vue'
import HistogramDisplay from './HistogramDisplay.vue'

const emit = defineEmits<{
  (e: 'controlEvent', event: ControlEvent): void
}>()

// çŠ¶æ€
const exposure = ref(0)
const contrast = ref(0)
const highlights = ref(0)
const shadows = ref(0)
const whites = ref(0)
const blacks = ref(0)
const showHistogram = ref(false)

// æ ¼å¼åŒ–æ˜¾ç¤º
const formatEV = (value: number): string => {
  const sign = value >= 0 ? '+' : ''
  return `${sign}${value.toFixed(2)} EV`
}

const formatPercent = (value: number): string => {
  const sign = value > 0 ? '+' : ''
  return `${sign}${value}%`
}

// æ›´æ–°å‡½æ•°
const updateExposure = (value: number) => {
  exposure.value = value
  emitExposureChange()
}

const updateContrast = (value: number) => {
  contrast.value = value
  emitExposureChange()
}

const updateHighlights = (value: number) => {
  highlights.value = value
  emitExposureChange()
}

const updateShadows = (value: number) => {
  shadows.value = value
  emitExposureChange()
}

const updateWhites = (value: number) => {
  whites.value = value
  emitExposureChange()
}

const updateBlacks = (value: number) => {
  blacks.value = value
  emitExposureChange()
}

// å‘å°„æ›å…‰å˜åŒ–äº‹ä»¶
const emitExposureChange = () => {
  emit('controlEvent', createUpdateDataEvent('exposure-change', {
    exposure: exposure.value,
    contrast: contrast.value,
    highlights: highlights.value,
    shadows: shadows.value,
    whites: whites.value,
    blacks: blacks.value
  }))
}

// é‡ç½®æ‰€æœ‰å‚æ•°
const resetAll = () => {
  exposure.value = 0
  contrast.value = 0
  highlights.value = 0
  shadows.value = 0
  whites.value = 0
  blacks.value = 0
  emitExposureChange()
}

// è‡ªåŠ¨è°ƒæ•´ï¼ˆåŸºäºç›´æ–¹å›¾åˆ†æï¼‰
const autoAdjust = () => {
  // TODO: å®ç°åŸºäºç›´æ–¹å›¾çš„è‡ªåŠ¨æ›å…‰è°ƒæ•´
  console.log('Auto adjust not yet implemented')
}
</script>

<style scoped>
.exposure-panel {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  padding: 1rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 0.5rem;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
}

.header-title {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 600;
  font-size: 0.95rem;
}

.header-actions {
  display: flex;
  gap: 0.5rem;
}

.action-btn {
  padding: 0.4rem;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  border-radius: 0.25rem;
  cursor: pointer;
  transition: all 0.2s;
}

.action-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: scale(1.05);
}

.controls-section {
  display: flex;
  flex-direction: column;
  gap: 1.2rem;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.control-group.exposure-control {
  padding: 0.75rem;
  background: rgba(255, 200, 100, 0.1);
  border-radius: 0.375rem;
  border: 1px solid rgba(255, 200, 100, 0.3);
}

.control-label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.85rem;
  color: rgba(255, 255, 255, 0.9);
}

.value-display {
  font-family: 'Monaco', 'Consolas', monospace;
  font-size: 0.8rem;
  color: rgba(255, 255, 255, 0.7);
  min-width: 4rem;
  text-align: right;
}

.range-labels {
  display: flex;
  justify-content: space-between;
  font-size: 0.7rem;
  color: rgba(255, 255, 255, 0.5);
  margin-top: -0.25rem;
}

.divider {
  height: 1px;
  background: rgba(255, 255, 255, 0.1);
  margin: 0.5rem 0;
}

.histogram-section {
  margin-top: 1rem;
  padding: 1rem;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 0.375rem;
}
</style>
```

---

## é›†æˆåˆ°åº”ç”¨

### 1. æ·»åŠ äº‹ä»¶ç±»å‹

åœ¨ `demo/src/types/controlEvents.ts`:

```typescript
export type UpdateAction =
  | ... // ç°æœ‰ç±»å‹
  | 'exposure-change'
```

### 2. æ·»åŠ åˆ°æ§åˆ¶é¢æ¿

åœ¨ `demo/src/composables/useControlsLogic.ts`:

```typescript
const groups = [
  // ... å…¶ä»–é¢æ¿
  { id: 'exposure', icon: 'i-carbon-camera', label: 'Exposure', component: 'ExposurePanel' },
]
```

### 3. æ·»åŠ äº‹ä»¶å¤„ç†å™¨

åœ¨ `demo/src/utils/controlEventHandler.ts`:

```typescript
export interface ControlEventHandlerOptions {
  // ... å…¶ä»–å¤„ç†å™¨
  onExposureChange?: (params: ExposureParams) => void
}

// åœ¨ switch ä¸­æ·»åŠ 
case 'exposure-change':
  options.onExposureChange?.(detail.data)
  break
```

### 4. é›†æˆåˆ°å›¾åƒå¤„ç†ç®¡çº¿

åœ¨ `demo/src/composables/useTextureGenerator.ts`:

```typescript
// æ·»åŠ çŠ¶æ€
const exposureParams = ref<ExposureParams>({
  exposure: 0,
  contrast: 0,
  highlights: 0,
  shadows: 0,
  whites: 0,
  blacks: 0
})

// æ·»åŠ å¤„ç†å™¨
onExposureChange: (params: ExposureParams) => {
  exposureParams.value = params
  if (originalImage.value) {
    debouncedProcessImage()
  }
}

// åœ¨ processImageToTileable ä¸­ä¼ é€’å‚æ•°
processedImage.value = await processImageToTileable(
  originalImage.value,
  maxResolution.value,
  borderSize.value,
  // ... å…¶ä»–å‚æ•°
  exposureParams.value
)
```

---

## é«˜çº§åŠŸèƒ½

### 1. ç›´æ–¹å›¾æ˜¾ç¤º

åˆ›å»º `HistogramDisplay.vue` ç»„ä»¶ï¼Œå®æ—¶æ˜¾ç¤ºRGBå’Œäº®åº¦ç›´æ–¹å›¾ï¼š

```vue
<template>
  <div class="histogram-container">
    <canvas ref="canvasRef" :width="width" :height="height" />
    <div class="histogram-legend">
      <span class="legend-item red">Red</span>
      <span class="legend-item green">Green</span>
      <span class="legend-item blue">Blue</span>
      <span class="legend-item lum">Luminance</span>
    </div>
  </div>
</template>

<script setup lang="ts">
// å®ç°ç›´æ–¹å›¾è®¡ç®—å’Œç»˜åˆ¶
// å‚è€ƒ Lightroom/Photoshop çš„ç›´æ–¹å›¾æ ·å¼
</script>
```

### 2. è‡ªåŠ¨æ›å…‰

å®ç°åŸºäºç›´æ–¹å›¾åˆ†æçš„è‡ªåŠ¨æ›å…‰ç®—æ³•ï¼š

```typescript
function autoExposure(imageData: ImageData): ExposureParams {
  // 1. è®¡ç®—ç›´æ–¹å›¾
  const histogram = computeHistogram(imageData)
  
  // 2. åˆ†æäº®åº¦åˆ†å¸ƒ
  const stats = analyzeHistogram(histogram)
  
  // 3. è®¡ç®—å»ºè®®å‚æ•°
  const params: ExposureParams = {
    exposure: calculateOptimalExposure(stats),
    contrast: calculateOptimalContrast(stats),
    highlights: stats.highlightClipping > 0.05 ? -50 : 0,
    shadows: stats.shadowClipping > 0.05 ? 50 : 0,
    whites: 0,
    blacks: 0
  }
  
  return params
}
```

### 3. é¢„è®¾ç®¡ç†

æä¾›å¸¸ç”¨çš„æ›å…‰é¢„è®¾ï¼š

```typescript
export const exposurePresets = {
  'natural': { exposure: 0, contrast: 10, highlights: -10, shadows: 10, whites: 0, blacks: -5 },
  'bright': { exposure: 0.5, contrast: 15, highlights: -20, shadows: 20, whites: 10, blacks: 0 },
  'moody': { exposure: -0.3, contrast: 30, highlights: -30, shadows: -10, whites: -10, blacks: -20 },
  'hdr': { exposure: 0, contrast: -20, highlights: -40, shadows: 40, whites: -20, blacks: 20 },
  'flat': { exposure: 0.2, contrast: -30, highlights: 0, shadows: 0, whites: 0, blacks: 0 }
}
```

---

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å®æ—¶é¢„è§ˆ**ï¼šä½¿ç”¨é˜²æŠ–ï¼ˆ300msï¼‰é¿å…è¿‡åº¦è®¡ç®—
2. **WebGPUç¼“å­˜**ï¼šå¤ç”¨GPUç¼“å†²åŒºå’Œç®¡çº¿
3. **æ¸è¿›å¼å¤„ç†**ï¼šå¤§å›¾å…ˆé™é‡‡æ ·é¢„è§ˆï¼Œç¡®è®¤åå…¨åˆ†è¾¨ç‡å¤„ç†
4. **Web Worker**ï¼šç›´æ–¹å›¾è®¡ç®—åœ¨workerä¸­è¿›è¡Œ

---

## æµ‹è¯•å»ºè®®

### æµ‹è¯•å›¾ç‰‡

- **æ¬ æ›å›¾ç‰‡**ï¼šæµ‹è¯•é˜´å½±æå‡
- **è¿‡æ›å›¾ç‰‡**ï¼šæµ‹è¯•é«˜å…‰æ¢å¤
- **é«˜å¯¹æ¯”åº¦å›¾ç‰‡**ï¼šæµ‹è¯•å¯¹æ¯”åº¦è°ƒæ•´
- **ä½å¯¹æ¯”åº¦å›¾ç‰‡**ï¼šæµ‹è¯•å¯¹æ¯”åº¦å¢å¼º

### éªŒè¯æ ‡å‡†

âœ… æ›å…‰è°ƒæ•´ä¸åº”ç ´åé¢œè‰²å…³ç³»
âœ… é«˜å…‰ä¸åº”è¿‡åº¦æº¢å‡º
âœ… é˜´å½±åº”ä¿æŒç»†èŠ‚
âœ… å¯¹æ¯”åº¦è°ƒæ•´åº”è‡ªç„¶
âœ… æ€§èƒ½åº”æµç•…ï¼ˆ<100ms for 2Kå›¾ï¼‰

---

## å‚è€ƒèµ„æ–™

- [Adobe Camera Raw Documentation](https://helpx.adobe.com/camera-raw/using/exposure-adjustments.html)
- [Lightroom Classic Tone Curve](https://helpx.adobe.com/lightroom-classic/help/tone-curve.html)
- [Understanding Exposure in Digital Photography](https://www.cambridgeincolour.com/tutorials/camera-exposure.htm)
- [WebGPU Compute Shader Best Practices](https://toji.dev/webgpu-best-practices/)

---

## ä¸‹ä¸€æ­¥

å®ŒæˆåŸºç¡€å®ç°åï¼Œå¯ä»¥æ‰©å±•ï¼š

1. **è‰²è°ƒæ›²çº¿ç¼–è¾‘å™¨**ï¼ˆé«˜çº§ç”¨æˆ·ï¼‰
2. **åˆ†åŒºåŸŸæ›å…‰è°ƒæ•´**ï¼ˆæ¸å˜è’™ç‰ˆï¼‰
3. **æ‰¹é‡å¤„ç†å’Œé¢„è®¾åŒæ­¥**
4. **AIé©±åŠ¨çš„æ™ºèƒ½æ›å…‰**

ç¥å®ç°é¡ºåˆ©ï¼ğŸ“·âœ¨
