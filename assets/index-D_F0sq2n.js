var kM=Object.defineProperty;var EM=t=>{throw TypeError(t)};var _M=(t,e,n)=>e in t?kM(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var Wt=(t,e,n)=>_M(t,typeof e!="symbol"?e+"":e,n);var Xw=(t,e,n)=>e.has(t)?EM("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n);function $M(t,e){for(var n=0;n<e.length;n++){const s=e[n];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in t)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(t,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function n(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=n(r);fetch(r.href,i)}})();/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function My(t){const e=Object.create(null);for(const n of t.split(","))e[n]=1;return n=>n in e}const rn={},Iu=[],Fi=()=>{},pI=()=>!1,Ag=t=>t.charCodeAt(0)===111&&t.charCodeAt(1)===110&&(t.charCodeAt(2)>122||t.charCodeAt(2)<97),Ly=t=>t.startsWith("onUpdate:"),ys=Object.assign,Oy=(t,e)=>{const n=t.indexOf(e);n>-1&&t.splice(n,1)},RM=Object.prototype.hasOwnProperty,qt=(t,e)=>RM.call(t,e),ft=Array.isArray,ku=t=>Vd(t)==="[object Map]",Zu=t=>Vd(t)==="[object Set]",qw=t=>Vd(t)==="[object Date]",It=t=>typeof t=="function",In=t=>typeof t=="string",ii=t=>typeof t=="symbol",tn=t=>t!==null&&typeof t=="object",mI=t=>(tn(t)||It(t))&&It(t.then)&&It(t.catch),gI=Object.prototype.toString,Vd=t=>gI.call(t),AM=t=>Vd(t).slice(8,-1),xI=t=>Vd(t)==="[object Object]",Fy=t=>In(t)&&t!=="NaN"&&t[0]!=="-"&&""+parseInt(t,10)===t,Kh=My(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),Pg=t=>{const e=Object.create(null);return n=>e[n]||(e[n]=t(n))},PM=/-\w/g,Hr=Pg(t=>t.replace(PM,e=>e.slice(1).toUpperCase())),DM=/\B([A-Z])/g,Il=Pg(t=>t.replace(DM,"-$1").toLowerCase()),Dg=Pg(t=>t.charAt(0).toUpperCase()+t.slice(1)),rb=Pg(t=>t?`on${Dg(t)}`:""),ta=(t,e)=>!Object.is(t,e),bm=(t,...e)=>{for(let n=0;n<t.length;n++)t[n](...e)},bI=(t,e,n,s=!1)=>{Object.defineProperty(t,e,{configurable:!0,enumerable:!1,writable:s,value:n})},Ng=t=>{const e=parseFloat(t);return isNaN(e)?t:e},NM=t=>{const e=In(t)?Number(t):NaN;return isNaN(e)?t:e};let Yw;const Mg=()=>Yw||(Yw=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function bn(t){if(ft(t)){const e={};for(let n=0;n<t.length;n++){const s=t[n],r=In(s)?FM(s):bn(s);if(r)for(const i in r)e[i]=r[i]}return e}else if(In(t)||tn(t))return t}const MM=/;(?![^(]*\))/g,LM=/:([^]+)/,OM=/\/\*[^]*?\*\//g;function FM(t){const e={};return t.replace(OM,"").split(MM).forEach(n=>{if(n){const s=n.split(LM);s.length>1&&(e[s[0].trim()]=s[1].trim())}}),e}function Q(t){let e="";if(In(t))e=t;else if(ft(t))for(let n=0;n<t.length;n++){const s=Q(t[n]);s&&(e+=s+" ")}else if(tn(t))for(const n in t)t[n]&&(e+=n+" ");return e.trim()}function UM(t){if(!t)return null;let{class:e,style:n}=t;return e&&!In(e)&&(t.class=Q(e)),n&&(t.style=bn(n)),t}const BM="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",zM=My(BM);function yI(t){return!!t||t===""}function GM(t,e){if(t.length!==e.length)return!1;let n=!0;for(let s=0;n&&s<t.length;s++)n=Wd(t[s],e[s]);return n}function Wd(t,e){if(t===e)return!0;let n=qw(t),s=qw(e);if(n||s)return n&&s?t.getTime()===e.getTime():!1;if(n=ii(t),s=ii(e),n||s)return t===e;if(n=ft(t),s=ft(e),n||s)return n&&s?GM(t,e):!1;if(n=tn(t),s=tn(e),n||s){if(!n||!s)return!1;const r=Object.keys(t).length,i=Object.keys(e).length;if(r!==i)return!1;for(const o in t){const a=t.hasOwnProperty(o),l=e.hasOwnProperty(o);if(a&&!l||!a&&l||!Wd(t[o],e[o]))return!1}}return String(t)===String(e)}function Uy(t,e){return t.findIndex(n=>Wd(n,e))}const vI=t=>!!(t&&t.__v_isRef===!0),Le=t=>In(t)?t:t==null?"":ft(t)||tn(t)&&(t.toString===gI||!It(t.toString))?vI(t)?Le(t.value):JSON.stringify(t,wI,2):String(t),wI=(t,e)=>vI(e)?wI(t,e.value):ku(e)?{[`Map(${e.size})`]:[...e.entries()].reduce((n,[s,r],i)=>(n[ib(s,i)+" =>"]=r,n),{})}:Zu(e)?{[`Set(${e.size})`]:[...e.values()].map(n=>ib(n))}:ii(e)?ib(e):tn(e)&&!ft(e)&&!xI(e)?String(e):e,ib=(t,e="")=>{var n;return ii(t)?`Symbol(${(n=t.description)!=null?n:e})`:t};/**
* @vue/reactivity v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let or;class VM{constructor(e=!1){this.detached=e,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=or,!e&&or&&(this.index=(or.scopes||(or.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let e,n;if(this.scopes)for(e=0,n=this.scopes.length;e<n;e++)this.scopes[e].pause();for(e=0,n=this.effects.length;e<n;e++)this.effects[e].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let e,n;if(this.scopes)for(e=0,n=this.scopes.length;e<n;e++)this.scopes[e].resume();for(e=0,n=this.effects.length;e<n;e++)this.effects[e].resume()}}run(e){if(this._active){const n=or;try{return or=this,e()}finally{or=n}}}on(){++this._on===1&&(this.prevScope=or,or=this)}off(){this._on>0&&--this._on===0&&(or=this.prevScope,this.prevScope=void 0)}stop(e){if(this._active){this._active=!1;let n,s;for(n=0,s=this.effects.length;n<s;n++)this.effects[n].stop();for(this.effects.length=0,n=0,s=this.cleanups.length;n<s;n++)this.cleanups[n]();if(this.cleanups.length=0,this.scopes){for(n=0,s=this.scopes.length;n<s;n++)this.scopes[n].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!e){const r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0}}}function WM(){return or}let cn;const ob=new WeakSet;class SI{constructor(e){this.fn=e,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,or&&or.active&&or.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,ob.has(this)&&(ob.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||TI(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,Zw(this),II(this);const e=cn,n=ti;cn=this,ti=!0;try{return this.fn()}finally{kI(this),cn=e,ti=n,this.flags&=-3}}stop(){if(this.flags&1){for(let e=this.deps;e;e=e.nextDep)Gy(e);this.deps=this.depsTail=void 0,Zw(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?ob.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){c1(this)&&this.run()}get dirty(){return c1(this)}}let CI=0,jh,Xh;function TI(t,e=!1){if(t.flags|=8,e){t.next=Xh,Xh=t;return}t.next=jh,jh=t}function By(){CI++}function zy(){if(--CI>0)return;if(Xh){let e=Xh;for(Xh=void 0;e;){const n=e.next;e.next=void 0,e.flags&=-9,e=n}}let t;for(;jh;){let e=jh;for(jh=void 0;e;){const n=e.next;if(e.next=void 0,e.flags&=-9,e.flags&1)try{e.trigger()}catch(s){t||(t=s)}e=n}}if(t)throw t}function II(t){for(let e=t.deps;e;e=e.nextDep)e.version=-1,e.prevActiveLink=e.dep.activeLink,e.dep.activeLink=e}function kI(t){let e,n=t.depsTail,s=n;for(;s;){const r=s.prevDep;s.version===-1?(s===n&&(n=r),Gy(s),HM(s)):e=s,s.dep.activeLink=s.prevActiveLink,s.prevActiveLink=void 0,s=r}t.deps=e,t.depsTail=n}function c1(t){for(let e=t.deps;e;e=e.nextDep)if(e.dep.version!==e.version||e.dep.computed&&(EI(e.dep.computed)||e.dep.version!==e.version))return!0;return!!t._dirty}function EI(t){if(t.flags&4&&!(t.flags&16)||(t.flags&=-17,t.globalVersion===hd)||(t.globalVersion=hd,!t.isSSR&&t.flags&128&&(!t.deps&&!t._dirty||!c1(t))))return;t.flags|=2;const e=t.dep,n=cn,s=ti;cn=t,ti=!0;try{II(t);const r=t.fn(t._value);(e.version===0||ta(r,t._value))&&(t.flags|=128,t._value=r,e.version++)}catch(r){throw e.version++,r}finally{cn=n,ti=s,kI(t),t.flags&=-3}}function Gy(t,e=!1){const{dep:n,prevSub:s,nextSub:r}=t;if(s&&(s.nextSub=r,t.prevSub=void 0),r&&(r.prevSub=s,t.nextSub=void 0),n.subs===t&&(n.subs=s,!s&&n.computed)){n.computed.flags&=-5;for(let i=n.computed.deps;i;i=i.nextDep)Gy(i,!0)}!e&&!--n.sc&&n.map&&n.map.delete(n.key)}function HM(t){const{prevDep:e,nextDep:n}=t;e&&(e.nextDep=n,t.prevDep=void 0),n&&(n.prevDep=e,t.nextDep=void 0)}let ti=!0;const _I=[];function Co(){_I.push(ti),ti=!1}function To(){const t=_I.pop();ti=t===void 0?!0:t}function Zw(t){const{cleanup:e}=t;if(t.cleanup=void 0,e){const n=cn;cn=void 0;try{e()}finally{cn=n}}}let hd=0;class KM{constructor(e,n){this.sub=e,this.dep=n,this.version=n.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class Vy{constructor(e){this.computed=e,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(e){if(!cn||!ti||cn===this.computed)return;let n=this.activeLink;if(n===void 0||n.sub!==cn)n=this.activeLink=new KM(cn,this),cn.deps?(n.prevDep=cn.depsTail,cn.depsTail.nextDep=n,cn.depsTail=n):cn.deps=cn.depsTail=n,$I(n);else if(n.version===-1&&(n.version=this.version,n.nextDep)){const s=n.nextDep;s.prevDep=n.prevDep,n.prevDep&&(n.prevDep.nextDep=s),n.prevDep=cn.depsTail,n.nextDep=void 0,cn.depsTail.nextDep=n,cn.depsTail=n,cn.deps===n&&(cn.deps=s)}return n}trigger(e){this.version++,hd++,this.notify(e)}notify(e){By();try{for(let n=this.subs;n;n=n.prevSub)n.sub.notify()&&n.sub.dep.notify()}finally{zy()}}}function $I(t){if(t.dep.sc++,t.sub.flags&4){const e=t.dep.computed;if(e&&!t.dep.subs){e.flags|=20;for(let s=e.deps;s;s=s.nextDep)$I(s)}const n=t.dep.subs;n!==t&&(t.prevSub=n,n&&(n.nextSub=t)),t.dep.subs=t}}const h1=new WeakMap,Ja=Symbol(""),d1=Symbol(""),dd=Symbol("");function Ps(t,e,n){if(ti&&cn){let s=h1.get(t);s||h1.set(t,s=new Map);let r=s.get(n);r||(s.set(n,r=new Vy),r.map=s,r.key=n),r.track()}}function po(t,e,n,s,r,i){const o=h1.get(t);if(!o){hd++;return}const a=l=>{l&&l.trigger()};if(By(),e==="clear")o.forEach(a);else{const l=ft(t),u=l&&Fy(n);if(l&&n==="length"){const c=Number(s);o.forEach((h,d)=>{(d==="length"||d===dd||!ii(d)&&d>=c)&&a(h)})}else switch((n!==void 0||o.has(void 0))&&a(o.get(n)),u&&a(o.get(dd)),e){case"add":l?u&&a(o.get("length")):(a(o.get(Ja)),ku(t)&&a(o.get(d1)));break;case"delete":l||(a(o.get(Ja)),ku(t)&&a(o.get(d1)));break;case"set":ku(t)&&a(o.get(Ja));break}}zy()}function nu(t){const e=Dt(t);return e===t?e:(Ps(e,"iterate",dd),Wr(t)?e:e.map(oi))}function Lg(t){return Ps(t=Dt(t),"iterate",dd),t}function Go(t,e){return Io(t)?el(t)?Mu(oi(e)):Mu(e):oi(e)}const jM={__proto__:null,[Symbol.iterator](){return ab(this,Symbol.iterator,t=>Go(this,t))},concat(...t){return nu(this).concat(...t.map(e=>ft(e)?nu(e):e))},entries(){return ab(this,"entries",t=>(t[1]=Go(this,t[1]),t))},every(t,e){return ro(this,"every",t,e,void 0,arguments)},filter(t,e){return ro(this,"filter",t,e,n=>n.map(s=>Go(this,s)),arguments)},find(t,e){return ro(this,"find",t,e,n=>Go(this,n),arguments)},findIndex(t,e){return ro(this,"findIndex",t,e,void 0,arguments)},findLast(t,e){return ro(this,"findLast",t,e,n=>Go(this,n),arguments)},findLastIndex(t,e){return ro(this,"findLastIndex",t,e,void 0,arguments)},forEach(t,e){return ro(this,"forEach",t,e,void 0,arguments)},includes(...t){return lb(this,"includes",t)},indexOf(...t){return lb(this,"indexOf",t)},join(t){return nu(this).join(t)},lastIndexOf(...t){return lb(this,"lastIndexOf",t)},map(t,e){return ro(this,"map",t,e,void 0,arguments)},pop(){return mh(this,"pop")},push(...t){return mh(this,"push",t)},reduce(t,...e){return Qw(this,"reduce",t,e)},reduceRight(t,...e){return Qw(this,"reduceRight",t,e)},shift(){return mh(this,"shift")},some(t,e){return ro(this,"some",t,e,void 0,arguments)},splice(...t){return mh(this,"splice",t)},toReversed(){return nu(this).toReversed()},toSorted(t){return nu(this).toSorted(t)},toSpliced(...t){return nu(this).toSpliced(...t)},unshift(...t){return mh(this,"unshift",t)},values(){return ab(this,"values",t=>Go(this,t))}};function ab(t,e,n){const s=Lg(t),r=s[e]();return s!==t&&!Wr(t)&&(r._next=r.next,r.next=()=>{const i=r._next();return i.done||(i.value=n(i.value)),i}),r}const XM=Array.prototype;function ro(t,e,n,s,r,i){const o=Lg(t),a=o!==t&&!Wr(t),l=o[e];if(l!==XM[e]){const h=l.apply(t,i);return a?oi(h):h}let u=n;o!==t&&(a?u=function(h,d){return n.call(this,Go(t,h),d,t)}:n.length>2&&(u=function(h,d){return n.call(this,h,d,t)}));const c=l.call(o,u,s);return a&&r?r(c):c}function Qw(t,e,n,s){const r=Lg(t);let i=n;return r!==t&&(Wr(t)?n.length>3&&(i=function(o,a,l){return n.call(this,o,a,l,t)}):i=function(o,a,l){return n.call(this,o,Go(t,a),l,t)}),r[e](i,...s)}function lb(t,e,n){const s=Dt(t);Ps(s,"iterate",dd);const r=s[e](...n);return(r===-1||r===!1)&&Ky(n[0])?(n[0]=Dt(n[0]),s[e](...n)):r}function mh(t,e,n=[]){Co(),By();const s=Dt(t)[e].apply(t,n);return zy(),To(),s}const qM=My("__proto__,__v_isRef,__isVue"),RI=new Set(Object.getOwnPropertyNames(Symbol).filter(t=>t!=="arguments"&&t!=="caller").map(t=>Symbol[t]).filter(ii));function YM(t){ii(t)||(t=String(t));const e=Dt(this);return Ps(e,"has",t),e.hasOwnProperty(t)}class AI{constructor(e=!1,n=!1){this._isReadonly=e,this._isShallow=n}get(e,n,s){if(n==="__v_skip")return e.__v_skip;const r=this._isReadonly,i=this._isShallow;if(n==="__v_isReactive")return!r;if(n==="__v_isReadonly")return r;if(n==="__v_isShallow")return i;if(n==="__v_raw")return s===(r?i?oL:MI:i?NI:DI).get(e)||Object.getPrototypeOf(e)===Object.getPrototypeOf(s)?e:void 0;const o=ft(e);if(!r){let l;if(o&&(l=jM[n]))return l;if(n==="hasOwnProperty")return YM}const a=Reflect.get(e,n,Yt(e)?e:s);if((ii(n)?RI.has(n):qM(n))||(r||Ps(e,"get",n),i))return a;if(Yt(a)){const l=o&&Fy(n)?a:a.value;return r&&tn(l)?p1(l):l}return tn(a)?r?p1(a):pi(a):a}}class PI extends AI{constructor(e=!1){super(!1,e)}set(e,n,s,r){let i=e[n];const o=ft(e)&&Fy(n);if(!this._isShallow){const u=Io(i);if(!Wr(s)&&!Io(s)&&(i=Dt(i),s=Dt(s)),!o&&Yt(i)&&!Yt(s))return u||(i.value=s),!0}const a=o?Number(n)<e.length:qt(e,n),l=Reflect.set(e,n,s,Yt(e)?e:r);return e===Dt(r)&&(a?ta(s,i)&&po(e,"set",n,s):po(e,"add",n,s)),l}deleteProperty(e,n){const s=qt(e,n);e[n];const r=Reflect.deleteProperty(e,n);return r&&s&&po(e,"delete",n,void 0),r}has(e,n){const s=Reflect.has(e,n);return(!ii(n)||!RI.has(n))&&Ps(e,"has",n),s}ownKeys(e){return Ps(e,"iterate",ft(e)?"length":Ja),Reflect.ownKeys(e)}}class ZM extends AI{constructor(e=!1){super(!0,e)}set(e,n){return!0}deleteProperty(e,n){return!0}}const QM=new PI,JM=new ZM,eL=new PI(!0);const f1=t=>t,Ep=t=>Reflect.getPrototypeOf(t);function tL(t,e,n){return function(...s){const r=this.__v_raw,i=Dt(r),o=ku(i),a=t==="entries"||t===Symbol.iterator&&o,l=t==="keys"&&o,u=r[t](...s),c=n?f1:e?Mu:oi;return!e&&Ps(i,"iterate",l?d1:Ja),{next(){const{value:h,done:d}=u.next();return d?{value:h,done:d}:{value:a?[c(h[0]),c(h[1])]:c(h),done:d}},[Symbol.iterator](){return this}}}}function _p(t){return function(...e){return t==="delete"?!1:t==="clear"?void 0:this}}function nL(t,e){const n={get(r){const i=this.__v_raw,o=Dt(i),a=Dt(r);t||(ta(r,a)&&Ps(o,"get",r),Ps(o,"get",a));const{has:l}=Ep(o),u=e?f1:t?Mu:oi;if(l.call(o,r))return u(i.get(r));if(l.call(o,a))return u(i.get(a));i!==o&&i.get(r)},get size(){const r=this.__v_raw;return!t&&Ps(Dt(r),"iterate",Ja),r.size},has(r){const i=this.__v_raw,o=Dt(i),a=Dt(r);return t||(ta(r,a)&&Ps(o,"has",r),Ps(o,"has",a)),r===a?i.has(r):i.has(r)||i.has(a)},forEach(r,i){const o=this,a=o.__v_raw,l=Dt(a),u=e?f1:t?Mu:oi;return!t&&Ps(l,"iterate",Ja),a.forEach((c,h)=>r.call(i,u(c),u(h),o))}};return ys(n,t?{add:_p("add"),set:_p("set"),delete:_p("delete"),clear:_p("clear")}:{add(r){!e&&!Wr(r)&&!Io(r)&&(r=Dt(r));const i=Dt(this);return Ep(i).has.call(i,r)||(i.add(r),po(i,"add",r,r)),this},set(r,i){!e&&!Wr(i)&&!Io(i)&&(i=Dt(i));const o=Dt(this),{has:a,get:l}=Ep(o);let u=a.call(o,r);u||(r=Dt(r),u=a.call(o,r));const c=l.call(o,r);return o.set(r,i),u?ta(i,c)&&po(o,"set",r,i):po(o,"add",r,i),this},delete(r){const i=Dt(this),{has:o,get:a}=Ep(i);let l=o.call(i,r);l||(r=Dt(r),l=o.call(i,r)),a&&a.call(i,r);const u=i.delete(r);return l&&po(i,"delete",r,void 0),u},clear(){const r=Dt(this),i=r.size!==0,o=r.clear();return i&&po(r,"clear",void 0,void 0),o}}),["keys","values","entries",Symbol.iterator].forEach(r=>{n[r]=tL(r,t,e)}),n}function Wy(t,e){const n=nL(t,e);return(s,r,i)=>r==="__v_isReactive"?!t:r==="__v_isReadonly"?t:r==="__v_raw"?s:Reflect.get(qt(n,r)&&r in s?n:s,r,i)}const sL={get:Wy(!1,!1)},rL={get:Wy(!1,!0)},iL={get:Wy(!0,!1)};const DI=new WeakMap,NI=new WeakMap,MI=new WeakMap,oL=new WeakMap;function aL(t){switch(t){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function lL(t){return t.__v_skip||!Object.isExtensible(t)?0:aL(AM(t))}function pi(t){return Io(t)?t:Hy(t,!1,QM,sL,DI)}function uL(t){return Hy(t,!1,eL,rL,NI)}function p1(t){return Hy(t,!0,JM,iL,MI)}function Hy(t,e,n,s,r){if(!tn(t)||t.__v_raw&&!(e&&t.__v_isReactive))return t;const i=lL(t);if(i===0)return t;const o=r.get(t);if(o)return o;const a=new Proxy(t,i===2?s:n);return r.set(t,a),a}function el(t){return Io(t)?el(t.__v_raw):!!(t&&t.__v_isReactive)}function Io(t){return!!(t&&t.__v_isReadonly)}function Wr(t){return!!(t&&t.__v_isShallow)}function Ky(t){return t?!!t.__v_raw:!1}function Dt(t){const e=t&&t.__v_raw;return e?Dt(e):t}function LI(t){return!qt(t,"__v_skip")&&Object.isExtensible(t)&&bI(t,"__v_skip",!0),t}const oi=t=>tn(t)?pi(t):t,Mu=t=>tn(t)?p1(t):t;function Yt(t){return t?t.__v_isRef===!0:!1}function ce(t){return OI(t,!1)}function Ah(t){return OI(t,!0)}function OI(t,e){return Yt(t)?t:new cL(t,e)}class cL{constructor(e,n){this.dep=new Vy,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=n?e:Dt(e),this._value=n?e:oi(e),this.__v_isShallow=n}get value(){return this.dep.track(),this._value}set value(e){const n=this._rawValue,s=this.__v_isShallow||Wr(e)||Io(e);e=s?e:Dt(e),ta(e,n)&&(this._rawValue=e,this._value=s?e:oi(e),this.dep.trigger())}}function D(t){return Yt(t)?t.value:t}const hL={get:(t,e,n)=>e==="__v_raw"?t:D(Reflect.get(t,e,n)),set:(t,e,n,s)=>{const r=t[e];return Yt(r)&&!Yt(n)?(r.value=n,!0):Reflect.set(t,e,n,s)}};function FI(t){return el(t)?t:new Proxy(t,hL)}class dL{constructor(e,n,s){this.fn=e,this.setter=n,this._value=void 0,this.dep=new Vy(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=hd-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!n,this.isSSR=s}notify(){if(this.flags|=16,!(this.flags&8)&&cn!==this)return TI(this,!0),!0}get value(){const e=this.dep.track();return EI(this),e&&(e.version=this.dep.version),this._value}set value(e){this.setter&&this.setter(e)}}function fL(t,e,n=!1){let s,r;return It(t)?s=t:(s=t.get,r=t.set),new dL(s,r,n)}const $p={},Pm=new WeakMap;let Ua;function pL(t,e=!1,n=Ua){if(n){let s=Pm.get(n);s||Pm.set(n,s=[]),s.push(t)}}function mL(t,e,n=rn){const{immediate:s,deep:r,once:i,scheduler:o,augmentJob:a,call:l}=n,u=y=>r?y:Wr(y)||r===!1||r===0?mo(y,1):mo(y);let c,h,d,f,p=!1,g=!1;if(Yt(t)?(h=()=>t.value,p=Wr(t)):el(t)?(h=()=>u(t),p=!0):ft(t)?(g=!0,p=t.some(y=>el(y)||Wr(y)),h=()=>t.map(y=>{if(Yt(y))return y.value;if(el(y))return u(y);if(It(y))return l?l(y,2):y()})):It(t)?e?h=l?()=>l(t,2):t:h=()=>{if(d){Co();try{d()}finally{To()}}const y=Ua;Ua=c;try{return l?l(t,3,[f]):t(f)}finally{Ua=y}}:h=Fi,e&&r){const y=h,C=r===!0?1/0:r;h=()=>mo(y(),C)}const m=WM(),x=()=>{c.stop(),m&&m.active&&Oy(m.effects,c)};if(i&&e){const y=e;e=(...C)=>{y(...C),x()}}let b=g?new Array(t.length).fill($p):$p;const v=y=>{if(!(!(c.flags&1)||!c.dirty&&!y))if(e){const C=c.run();if(r||p||(g?C.some((I,$)=>ta(I,b[$])):ta(C,b))){d&&d();const I=Ua;Ua=c;try{const $=[C,b===$p?void 0:g&&b[0]===$p?[]:b,f];b=C,l?l(e,3,$):e(...$)}finally{Ua=I}}}else c.run()};return a&&a(v),c=new SI(h),c.scheduler=o?()=>o(v,!1):v,f=y=>pL(y,!1,c),d=c.onStop=()=>{const y=Pm.get(c);if(y){if(l)l(y,4);else for(const C of y)C();Pm.delete(c)}},e?s?v(!0):b=c.run():o?o(v.bind(null,!0),!0):c.run(),x.pause=c.pause.bind(c),x.resume=c.resume.bind(c),x.stop=x,x}function mo(t,e=1/0,n){if(e<=0||!tn(t)||t.__v_skip||(n=n||new Map,(n.get(t)||0)>=e))return t;if(n.set(t,e),e--,Yt(t))mo(t.value,e,n);else if(ft(t))for(let s=0;s<t.length;s++)mo(t[s],e,n);else if(Zu(t)||ku(t))t.forEach(s=>{mo(s,e,n)});else if(xI(t)){for(const s in t)mo(t[s],e,n);for(const s of Object.getOwnPropertySymbols(t))Object.prototype.propertyIsEnumerable.call(t,s)&&mo(t[s],e,n)}return t}/**
* @vue/runtime-core v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Hd(t,e,n,s){try{return s?t(...s):t()}catch(r){Og(r,e,n)}}function ai(t,e,n,s){if(It(t)){const r=Hd(t,e,n,s);return r&&mI(r)&&r.catch(i=>{Og(i,e,n)}),r}if(ft(t)){const r=[];for(let i=0;i<t.length;i++)r.push(ai(t[i],e,n,s));return r}}function Og(t,e,n,s=!0){const r=e?e.vnode:null,{errorHandler:i,throwUnhandledErrorInProduction:o}=e&&e.appContext.config||rn;if(e){let a=e.parent;const l=e.proxy,u=`https://vuejs.org/error-reference/#runtime-${n}`;for(;a;){const c=a.ec;if(c){for(let h=0;h<c.length;h++)if(c[h](t,l,u)===!1)return}a=a.parent}if(i){Co(),Hd(i,null,10,[t,l,u]),To();return}}gL(t,n,r,s,o)}function gL(t,e,n,s=!0,r=!1){if(r)throw t;console.error(t)}const Ks=[];let Ii=-1;const Eu=[];let Vo=null,fu=0;const UI=Promise.resolve();let Dm=null;function tl(t){const e=Dm||UI;return t?e.then(this?t.bind(this):t):e}function xL(t){let e=Ii+1,n=Ks.length;for(;e<n;){const s=e+n>>>1,r=Ks[s],i=fd(r);i<t||i===t&&r.flags&2?e=s+1:n=s}return e}function jy(t){if(!(t.flags&1)){const e=fd(t),n=Ks[Ks.length-1];!n||!(t.flags&2)&&e>=fd(n)?Ks.push(t):Ks.splice(xL(e),0,t),t.flags|=1,BI()}}function BI(){Dm||(Dm=UI.then(GI))}function bL(t){ft(t)?Eu.push(...t):Vo&&t.id===-1?Vo.splice(fu+1,0,t):t.flags&1||(Eu.push(t),t.flags|=1),BI()}function Jw(t,e,n=Ii+1){for(;n<Ks.length;n++){const s=Ks[n];if(s&&s.flags&2){if(t&&s.id!==t.uid)continue;Ks.splice(n,1),n--,s.flags&4&&(s.flags&=-2),s(),s.flags&4||(s.flags&=-2)}}}function zI(t){if(Eu.length){const e=[...new Set(Eu)].sort((n,s)=>fd(n)-fd(s));if(Eu.length=0,Vo){Vo.push(...e);return}for(Vo=e,fu=0;fu<Vo.length;fu++){const n=Vo[fu];n.flags&4&&(n.flags&=-2),n.flags&8||n(),n.flags&=-2}Vo=null,fu=0}}const fd=t=>t.id==null?t.flags&2?-1:1/0:t.id;function GI(t){try{for(Ii=0;Ii<Ks.length;Ii++){const e=Ks[Ii];e&&!(e.flags&8)&&(e.flags&4&&(e.flags&=-2),Hd(e,e.i,e.i?15:14),e.flags&4||(e.flags&=-2))}}finally{for(;Ii<Ks.length;Ii++){const e=Ks[Ii];e&&(e.flags&=-2)}Ii=-1,Ks.length=0,zI(),Dm=null,(Ks.length||Eu.length)&&GI()}}let Cs=null,VI=null;function Nm(t){const e=Cs;return Cs=t,VI=t&&t.type.__scopeId||null,e}function hr(t,e=Cs,n){if(!e||t._n)return t;const s=(...r)=>{s._d&&Fm(-1);const i=Nm(e);let o;try{o=t(...r)}finally{Nm(i),s._d&&Fm(1)}return o};return s._n=!0,s._c=!0,s._d=!0,s}function vt(t,e){if(Cs===null)return t;const n=Kg(Cs),s=t.dirs||(t.dirs=[]);for(let r=0;r<e.length;r++){let[i,o,a,l=rn]=e[r];i&&(It(i)&&(i={mounted:i,updated:i}),i.deep&&mo(o),s.push({dir:i,instance:n,value:o,oldValue:void 0,arg:a,modifiers:l}))}return t}function Pa(t,e,n,s){const r=t.dirs,i=e&&e.dirs;for(let o=0;o<r.length;o++){const a=r[o];i&&(a.oldValue=i[o].value);let l=a.dir[s];l&&(Co(),ai(l,n,8,[t.el,a,t,e]),To())}}const WI=Symbol("_vte"),HI=t=>t.__isTeleport,qh=t=>t&&(t.disabled||t.disabled===""),eS=t=>t&&(t.defer||t.defer===""),tS=t=>typeof SVGElement<"u"&&t instanceof SVGElement,nS=t=>typeof MathMLElement=="function"&&t instanceof MathMLElement,m1=(t,e)=>{const n=t&&t.to;return In(n)?e?e(n):null:n},KI={name:"Teleport",__isTeleport:!0,process(t,e,n,s,r,i,o,a,l,u){const{mc:c,pc:h,pbc:d,o:{insert:f,querySelector:p,createText:g,createComment:m}}=u,x=qh(e.props);let{shapeFlag:b,children:v,dynamicChildren:y}=e;if(t==null){const C=e.el=g(""),I=e.anchor=g("");f(C,n,s),f(I,n,s);const $=(S,E)=>{b&16&&c(v,S,E,r,i,o,a,l)},T=()=>{const S=e.target=m1(e.props,p),E=jI(S,e,g,f);S&&(o!=="svg"&&tS(S)?o="svg":o!=="mathml"&&nS(S)&&(o="mathml"),r&&r.isCE&&(r.ce._teleportTargets||(r.ce._teleportTargets=new Set)).add(S),x||($(S,E),ym(e,!1)))};x&&($(n,I),ym(e,!0)),eS(e.props)?(e.el.__isMounted=!1,Ws(()=>{T(),delete e.el.__isMounted},i)):T()}else{if(eS(e.props)&&t.el.__isMounted===!1){Ws(()=>{KI.process(t,e,n,s,r,i,o,a,l,u)},i);return}e.el=t.el,e.targetStart=t.targetStart;const C=e.anchor=t.anchor,I=e.target=t.target,$=e.targetAnchor=t.targetAnchor,T=qh(t.props),S=T?n:I,E=T?C:$;if(o==="svg"||tS(I)?o="svg":(o==="mathml"||nS(I))&&(o="mathml"),y?(d(t.dynamicChildren,y,S,r,i,o,a),Yy(t,e,!0)):l||h(t,e,S,E,r,i,o,a,!1),x)T?e.props&&t.props&&e.props.to!==t.props.to&&(e.props.to=t.props.to):Rp(e,n,C,u,1);else if((e.props&&e.props.to)!==(t.props&&t.props.to)){const _=e.target=m1(e.props,p);_&&Rp(e,_,null,u,0)}else T&&Rp(e,I,$,u,1);ym(e,x)}},remove(t,e,n,{um:s,o:{remove:r}},i){const{shapeFlag:o,children:a,anchor:l,targetStart:u,targetAnchor:c,target:h,props:d}=t;if(h&&(r(u),r(c)),i&&r(l),o&16){const f=i||!qh(d);for(let p=0;p<a.length;p++){const g=a[p];s(g,e,n,f,!!g.dynamicChildren)}}},move:Rp,hydrate:yL};function Rp(t,e,n,{o:{insert:s},m:r},i=2){i===0&&s(t.targetAnchor,e,n);const{el:o,anchor:a,shapeFlag:l,children:u,props:c}=t,h=i===2;if(h&&s(o,e,n),(!h||qh(c))&&l&16)for(let d=0;d<u.length;d++)r(u[d],e,n,2);h&&s(a,e,n)}function yL(t,e,n,s,r,i,{o:{nextSibling:o,parentNode:a,querySelector:l,insert:u,createText:c}},h){function d(g,m,x,b){m.anchor=h(o(g),m,a(g),n,s,r,i),m.targetStart=x,m.targetAnchor=b}const f=e.target=m1(e.props,l),p=qh(e.props);if(f){const g=f._lpa||f.firstChild;if(e.shapeFlag&16)if(p)d(t,e,g,g&&o(g));else{e.anchor=o(t);let m=g;for(;m;){if(m&&m.nodeType===8){if(m.data==="teleport start anchor")e.targetStart=m;else if(m.data==="teleport anchor"){e.targetAnchor=m,f._lpa=e.targetAnchor&&o(e.targetAnchor);break}}m=o(m)}e.targetAnchor||jI(f,e,c,u),h(g&&o(g),e,f,n,s,r,i)}ym(e,p)}else p&&e.shapeFlag&16&&d(t,e,t,o(t));return e.anchor&&o(e.anchor)}const Fg=KI;function ym(t,e){const n=t.ctx;if(n&&n.ut){let s,r;for(e?(s=t.el,r=t.anchor):(s=t.targetStart,r=t.targetAnchor);s&&s!==r;)s.nodeType===1&&s.setAttribute("data-v-owner",n.uid),s=s.nextSibling;n.ut()}}function jI(t,e,n,s){const r=e.targetStart=n(""),i=e.targetAnchor=n("");return r[WI]=i,t&&(s(r,t),s(i,t)),i}const ho=Symbol("_leaveCb"),Ap=Symbol("_enterCb");function vL(){const t={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return kr(()=>{t.isMounted=!0}),Gg(()=>{t.isUnmounting=!0}),t}const Pr=[Function,Array],XI={mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Pr,onEnter:Pr,onAfterEnter:Pr,onEnterCancelled:Pr,onBeforeLeave:Pr,onLeave:Pr,onAfterLeave:Pr,onLeaveCancelled:Pr,onBeforeAppear:Pr,onAppear:Pr,onAfterAppear:Pr,onAppearCancelled:Pr},qI=t=>{const e=t.subTree;return e.component?qI(e.component):e},wL={name:"BaseTransition",props:XI,setup(t,{slots:e}){const n=Hg(),s=vL();return()=>{const r=e.default&&QI(e.default(),!0);if(!r||!r.length)return;const i=YI(r),o=Dt(t),{mode:a}=o;if(s.isLeaving)return ub(i);const l=sS(i);if(!l)return ub(i);let u=g1(l,o,s,n,h=>u=h);l.type!==Ms&&pd(l,u);let c=n.subTree&&sS(n.subTree);if(c&&c.type!==Ms&&!Va(c,l)&&qI(n).type!==Ms){let h=g1(c,o,s,n);if(pd(c,h),a==="out-in"&&l.type!==Ms)return s.isLeaving=!0,h.afterLeave=()=>{s.isLeaving=!1,n.job.flags&8||n.update(),delete h.afterLeave,c=void 0},ub(i);a==="in-out"&&l.type!==Ms?h.delayLeave=(d,f,p)=>{const g=ZI(s,c);g[String(c.key)]=c,d[ho]=()=>{f(),d[ho]=void 0,delete u.delayedLeave,c=void 0},u.delayedLeave=()=>{p(),delete u.delayedLeave,c=void 0}}:c=void 0}else c&&(c=void 0);return i}}};function YI(t){let e=t[0];if(t.length>1){for(const n of t)if(n.type!==Ms){e=n;break}}return e}const SL=wL;function ZI(t,e){const{leavingVNodes:n}=t;let s=n.get(e.type);return s||(s=Object.create(null),n.set(e.type,s)),s}function g1(t,e,n,s,r){const{appear:i,mode:o,persisted:a=!1,onBeforeEnter:l,onEnter:u,onAfterEnter:c,onEnterCancelled:h,onBeforeLeave:d,onLeave:f,onAfterLeave:p,onLeaveCancelled:g,onBeforeAppear:m,onAppear:x,onAfterAppear:b,onAppearCancelled:v}=e,y=String(t.key),C=ZI(n,t),I=(S,E)=>{S&&ai(S,s,9,E)},$=(S,E)=>{const _=E[1];I(S,E),ft(S)?S.every(N=>N.length<=1)&&_():S.length<=1&&_()},T={mode:o,persisted:a,beforeEnter(S){let E=l;if(!n.isMounted)if(i)E=m||l;else return;S[ho]&&S[ho](!0);const _=C[y];_&&Va(t,_)&&_.el[ho]&&_.el[ho](),I(E,[S])},enter(S){let E=u,_=c,N=h;if(!n.isMounted)if(i)E=x||u,_=b||c,N=v||h;else return;let P=!1;const M=S[Ap]=z=>{P||(P=!0,z?I(N,[S]):I(_,[S]),T.delayedLeave&&T.delayedLeave(),S[Ap]=void 0)};E?$(E,[S,M]):M()},leave(S,E){const _=String(t.key);if(S[Ap]&&S[Ap](!0),n.isUnmounting)return E();I(d,[S]);let N=!1;const P=S[ho]=M=>{N||(N=!0,E(),M?I(g,[S]):I(p,[S]),S[ho]=void 0,C[_]===t&&delete C[_])};C[_]=t,f?$(f,[S,P]):P()},clone(S){const E=g1(S,e,n,s,r);return r&&r(E),E}};return T}function ub(t){if(Ug(t))return t=ia(t),t.children=null,t}function sS(t){if(!Ug(t))return HI(t.type)&&t.children?YI(t.children):t;if(t.component)return t.component.subTree;const{shapeFlag:e,children:n}=t;if(n){if(e&16)return n[0];if(e&32&&It(n.default))return n.default()}}function pd(t,e){t.shapeFlag&6&&t.component?(t.transition=e,pd(t.component.subTree,e)):t.shapeFlag&128?(t.ssContent.transition=e.clone(t.ssContent),t.ssFallback.transition=e.clone(t.ssFallback)):t.transition=e}function QI(t,e=!1,n){let s=[],r=0;for(let i=0;i<t.length;i++){let o=t[i];const a=n==null?o.key:String(n)+String(o.key!=null?o.key:i);o.type===Xe?(o.patchFlag&128&&r++,s=s.concat(QI(o.children,e,a))):(e||o.type!==Ms)&&s.push(a!=null?ia(o,{key:a}):o)}if(r>1)for(let i=0;i<s.length;i++)s[i].patchFlag=-2;return s}function We(t,e){return It(t)?ys({name:t.name},e,{setup:t}):t}function JI(t){t.ids=[t.ids[0]+t.ids[2]+++"-",0,0]}const Mm=new WeakMap;function Yh(t,e,n,s,r=!1){if(ft(t)){t.forEach((p,g)=>Yh(p,e&&(ft(e)?e[g]:e),n,s,r));return}if(_u(s)&&!r){s.shapeFlag&512&&s.type.__asyncResolved&&s.component.subTree.component&&Yh(t,e,n,s.component.subTree);return}const i=s.shapeFlag&4?Kg(s.component):s.el,o=r?null:i,{i:a,r:l}=t,u=e&&e.r,c=a.refs===rn?a.refs={}:a.refs,h=a.setupState,d=Dt(h),f=h===rn?pI:p=>qt(d,p);if(u!=null&&u!==l){if(rS(e),In(u))c[u]=null,f(u)&&(h[u]=null);else if(Yt(u)){u.value=null;const p=e;p.k&&(c[p.k]=null)}}if(It(l))Hd(l,a,12,[o,c]);else{const p=In(l),g=Yt(l);if(p||g){const m=()=>{if(t.f){const x=p?f(l)?h[l]:c[l]:l.value;if(r)ft(x)&&Oy(x,i);else if(ft(x))x.includes(i)||x.push(i);else if(p)c[l]=[i],f(l)&&(h[l]=c[l]);else{const b=[i];l.value=b,t.k&&(c[t.k]=b)}}else p?(c[l]=o,f(l)&&(h[l]=o)):g&&(l.value=o,t.k&&(c[t.k]=o))};if(o){const x=()=>{m(),Mm.delete(t)};x.id=-1,Mm.set(t,x),Ws(x,n)}else rS(t),m()}}}function rS(t){const e=Mm.get(t);e&&(e.flags|=8,Mm.delete(t))}Mg().requestIdleCallback;Mg().cancelIdleCallback;const _u=t=>!!t.type.__asyncLoader,Ug=t=>t.type.__isKeepAlive;function CL(t,e){ek(t,"a",e)}function TL(t,e){ek(t,"da",e)}function ek(t,e,n=Ls){const s=t.__wdc||(t.__wdc=()=>{let r=n;for(;r;){if(r.isDeactivated)return;r=r.parent}return t()});if(Bg(e,s,n),n){let r=n.parent;for(;r&&r.parent;)Ug(r.parent.vnode)&&IL(s,e,n,r),r=r.parent}}function IL(t,e,n,s){const r=Bg(e,t,s,!0);fa(()=>{Oy(s[e],r)},n)}function Bg(t,e,n=Ls,s=!1){if(n){const r=n[t]||(n[t]=[]),i=e.__weh||(e.__weh=(...o)=>{Co();const a=Kd(n),l=ai(e,n,t,o);return a(),To(),l});return s?r.unshift(i):r.push(i),i}}const Ro=t=>(e,n=Ls)=>{(!xd||t==="sp")&&Bg(t,(...s)=>e(...s),n)},kL=Ro("bm"),kr=Ro("m"),tk=Ro("bu"),zg=Ro("u"),Gg=Ro("bum"),fa=Ro("um"),EL=Ro("sp"),_L=Ro("rtg"),$L=Ro("rtc");function RL(t,e=Ls){Bg("ec",t,e)}const nk="components";function su(t,e){return rk(nk,t,!0,e)||t}const sk=Symbol.for("v-ndc");function Lm(t){return In(t)?rk(nk,t,!1)||t:t||sk}function rk(t,e,n=!0,s=!1){const r=Cs||Ls;if(r){const i=r.type;{const a=bO(i,!1);if(a&&(a===e||a===Hr(e)||a===Dg(Hr(e))))return i}const o=iS(r[t]||i[t],e)||iS(r.appContext[t],e);return!o&&s?i:o}}function iS(t,e){return t&&(t[e]||t[Hr(e)]||t[Dg(Hr(e))])}function rt(t,e,n,s){let r;const i=n,o=ft(t);if(o||In(t)){const a=o&&el(t);let l=!1,u=!1;a&&(l=!Wr(t),u=Io(t),t=Lg(t)),r=new Array(t.length);for(let c=0,h=t.length;c<h;c++)r[c]=e(l?u?Mu(oi(t[c])):oi(t[c]):t[c],c,void 0,i)}else if(typeof t=="number"){r=new Array(t);for(let a=0;a<t;a++)r[a]=e(a+1,a,void 0,i)}else if(tn(t))if(t[Symbol.iterator])r=Array.from(t,(a,l)=>e(a,l,void 0,i));else{const a=Object.keys(t);r=new Array(a.length);for(let l=0,u=a.length;l<u;l++){const c=a[l];r[l]=e(t[c],c,l,i)}}else r=[];return r}function AL(t,e,n={},s,r){if(Cs.ce||Cs.parent&&_u(Cs.parent)&&Cs.parent.ce){const u=Object.keys(n).length>0;return F(),st(Xe,null,[we("slot",n,s)],u?-2:64)}let i=t[e];i&&i._c&&(i._d=!1),F();const o=i&&ik(i(n)),a=n.key||o&&o.key,l=st(Xe,{key:(a&&!ii(a)?a:`_${e}`)+(!o&&s?"_fb":"")},o||[],o&&t._===1?64:-2);return l.scopeId&&(l.slotScopeIds=[l.scopeId+"-s"]),i&&i._c&&(i._d=!0),l}function ik(t){return t.some(e=>gd(e)?!(e.type===Ms||e.type===Xe&&!ik(e.children)):!0)?t:null}const x1=t=>t?kk(t)?Kg(t):x1(t.parent):null,Zh=ys(Object.create(null),{$:t=>t,$el:t=>t.vnode.el,$data:t=>t.data,$props:t=>t.props,$attrs:t=>t.attrs,$slots:t=>t.slots,$refs:t=>t.refs,$parent:t=>x1(t.parent),$root:t=>x1(t.root),$host:t=>t.ce,$emit:t=>t.emit,$options:t=>ak(t),$forceUpdate:t=>t.f||(t.f=()=>{jy(t.update)}),$nextTick:t=>t.n||(t.n=tl.bind(t.proxy)),$watch:t=>VL.bind(t)}),cb=(t,e)=>t!==rn&&!t.__isScriptSetup&&qt(t,e),PL={get({_:t},e){if(e==="__v_skip")return!0;const{ctx:n,setupState:s,data:r,props:i,accessCache:o,type:a,appContext:l}=t;if(e[0]!=="$"){const d=o[e];if(d!==void 0)switch(d){case 1:return s[e];case 2:return r[e];case 4:return n[e];case 3:return i[e]}else{if(cb(s,e))return o[e]=1,s[e];if(r!==rn&&qt(r,e))return o[e]=2,r[e];if(qt(i,e))return o[e]=3,i[e];if(n!==rn&&qt(n,e))return o[e]=4,n[e];b1&&(o[e]=0)}}const u=Zh[e];let c,h;if(u)return e==="$attrs"&&Ps(t.attrs,"get",""),u(t);if((c=a.__cssModules)&&(c=c[e]))return c;if(n!==rn&&qt(n,e))return o[e]=4,n[e];if(h=l.config.globalProperties,qt(h,e))return h[e]},set({_:t},e,n){const{data:s,setupState:r,ctx:i}=t;return cb(r,e)?(r[e]=n,!0):s!==rn&&qt(s,e)?(s[e]=n,!0):qt(t.props,e)||e[0]==="$"&&e.slice(1)in t?!1:(i[e]=n,!0)},has({_:{data:t,setupState:e,accessCache:n,ctx:s,appContext:r,props:i,type:o}},a){let l;return!!(n[a]||t!==rn&&a[0]!=="$"&&qt(t,a)||cb(e,a)||qt(i,a)||qt(s,a)||qt(Zh,a)||qt(r.config.globalProperties,a)||(l=o.__cssModules)&&l[a])},defineProperty(t,e,n){return n.get!=null?t._.accessCache[e]=0:qt(n,"value")&&this.set(t,e,n.value,null),Reflect.defineProperty(t,e,n)}};function oS(t){return ft(t)?t.reduce((e,n)=>(e[n]=null,e),{}):t}let b1=!0;function DL(t){const e=ak(t),n=t.proxy,s=t.ctx;b1=!1,e.beforeCreate&&aS(e.beforeCreate,t,"bc");const{data:r,computed:i,methods:o,watch:a,provide:l,inject:u,created:c,beforeMount:h,mounted:d,beforeUpdate:f,updated:p,activated:g,deactivated:m,beforeDestroy:x,beforeUnmount:b,destroyed:v,unmounted:y,render:C,renderTracked:I,renderTriggered:$,errorCaptured:T,serverPrefetch:S,expose:E,inheritAttrs:_,components:N,directives:P,filters:M}=e;if(u&&NL(u,s,null),o)for(const B in o){const L=o[B];It(L)&&(s[B]=L.bind(n))}if(r){const B=r.call(n,n);tn(B)&&(t.data=pi(B))}if(b1=!0,i)for(const B in i){const L=i[B],U=It(L)?L.bind(n,n):It(L.get)?L.get.bind(n,n):Fi,j=!It(L)&&It(L.set)?L.set.bind(n):Fi,Z=ye({get:U,set:j});Object.defineProperty(s,B,{enumerable:!0,configurable:!0,get:()=>Z.value,set:J=>Z.value=J})}if(a)for(const B in a)ok(a[B],s,n,B);if(l){const B=It(l)?l.call(n):l;Reflect.ownKeys(B).forEach(L=>{BL(L,B[L])})}c&&aS(c,t,"c");function A(B,L){ft(L)?L.forEach(U=>B(U.bind(n))):L&&B(L.bind(n))}if(A(kL,h),A(kr,d),A(tk,f),A(zg,p),A(CL,g),A(TL,m),A(RL,T),A($L,I),A(_L,$),A(Gg,b),A(fa,y),A(EL,S),ft(E))if(E.length){const B=t.exposed||(t.exposed={});E.forEach(L=>{Object.defineProperty(B,L,{get:()=>n[L],set:U=>n[L]=U,enumerable:!0})})}else t.exposed||(t.exposed={});C&&t.render===Fi&&(t.render=C),_!=null&&(t.inheritAttrs=_),N&&(t.components=N),P&&(t.directives=P),S&&JI(t)}function NL(t,e,n=Fi){ft(t)&&(t=y1(t));for(const s in t){const r=t[s];let i;tn(r)?"default"in r?i=vm(r.from||s,r.default,!0):i=vm(r.from||s):i=vm(r),Yt(i)?Object.defineProperty(e,s,{enumerable:!0,configurable:!0,get:()=>i.value,set:o=>i.value=o}):e[s]=i}}function aS(t,e,n){ai(ft(t)?t.map(s=>s.bind(e.proxy)):t.bind(e.proxy),e,n)}function ok(t,e,n,s){let r=s.includes(".")?ck(n,s):()=>n[s];if(In(t)){const i=e[t];It(i)&&_t(r,i)}else if(It(t))_t(r,t.bind(n));else if(tn(t))if(ft(t))t.forEach(i=>ok(i,e,n,s));else{const i=It(t.handler)?t.handler.bind(n):e[t.handler];It(i)&&_t(r,i,t)}}function ak(t){const e=t.type,{mixins:n,extends:s}=e,{mixins:r,optionsCache:i,config:{optionMergeStrategies:o}}=t.appContext,a=i.get(e);let l;return a?l=a:!r.length&&!n&&!s?l=e:(l={},r.length&&r.forEach(u=>Om(l,u,o,!0)),Om(l,e,o)),tn(e)&&i.set(e,l),l}function Om(t,e,n,s=!1){const{mixins:r,extends:i}=e;i&&Om(t,i,n,!0),r&&r.forEach(o=>Om(t,o,n,!0));for(const o in e)if(!(s&&o==="expose")){const a=ML[o]||n&&n[o];t[o]=a?a(t[o],e[o]):e[o]}return t}const ML={data:lS,props:uS,emits:uS,methods:Ph,computed:Ph,beforeCreate:Vs,created:Vs,beforeMount:Vs,mounted:Vs,beforeUpdate:Vs,updated:Vs,beforeDestroy:Vs,beforeUnmount:Vs,destroyed:Vs,unmounted:Vs,activated:Vs,deactivated:Vs,errorCaptured:Vs,serverPrefetch:Vs,components:Ph,directives:Ph,watch:OL,provide:lS,inject:LL};function lS(t,e){return e?t?function(){return ys(It(t)?t.call(this,this):t,It(e)?e.call(this,this):e)}:e:t}function LL(t,e){return Ph(y1(t),y1(e))}function y1(t){if(ft(t)){const e={};for(let n=0;n<t.length;n++)e[t[n]]=t[n];return e}return t}function Vs(t,e){return t?[...new Set([].concat(t,e))]:e}function Ph(t,e){return t?ys(Object.create(null),t,e):e}function uS(t,e){return t?ft(t)&&ft(e)?[...new Set([...t,...e])]:ys(Object.create(null),oS(t),oS(e??{})):e}function OL(t,e){if(!t)return e;if(!e)return t;const n=ys(Object.create(null),t);for(const s in e)n[s]=Vs(t[s],e[s]);return n}function lk(){return{app:null,config:{isNativeTag:pI,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let FL=0;function UL(t,e){return function(s,r=null){It(s)||(s=ys({},s)),r!=null&&!tn(r)&&(r=null);const i=lk(),o=new WeakSet,a=[];let l=!1;const u=i.app={_uid:FL++,_component:s,_props:r,_container:null,_context:i,_instance:null,version:vO,get config(){return i.config},set config(c){},use(c,...h){return o.has(c)||(c&&It(c.install)?(o.add(c),c.install(u,...h)):It(c)&&(o.add(c),c(u,...h))),u},mixin(c){return i.mixins.includes(c)||i.mixins.push(c),u},component(c,h){return h?(i.components[c]=h,u):i.components[c]},directive(c,h){return h?(i.directives[c]=h,u):i.directives[c]},mount(c,h,d){if(!l){const f=u._ceVNode||we(s,r);return f.appContext=i,d===!0?d="svg":d===!1&&(d=void 0),t(f,c,d),l=!0,u._container=c,c.__vue_app__=u,Kg(f.component)}},onUnmount(c){a.push(c)},unmount(){l&&(ai(a,u._instance,16),t(null,u._container),delete u._container.__vue_app__)},provide(c,h){return i.provides[c]=h,u},runWithContext(c){const h=$u;$u=u;try{return c()}finally{$u=h}}};return u}}let $u=null;function BL(t,e){if(Ls){let n=Ls.provides;const s=Ls.parent&&Ls.parent.provides;s===n&&(n=Ls.provides=Object.create(s)),n[t]=e}}function vm(t,e,n=!1){const s=Hg();if(s||$u){let r=$u?$u._context.provides:s?s.parent==null||s.ce?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides:void 0;if(r&&t in r)return r[t];if(arguments.length>1)return n&&It(e)?e.call(s&&s.proxy):e}}const zL=Symbol.for("v-scx"),GL=()=>vm(zL);function _t(t,e,n){return uk(t,e,n)}function uk(t,e,n=rn){const{immediate:s,deep:r,flush:i,once:o}=n,a=ys({},n),l=e&&s||!e&&i!=="post";let u;if(xd){if(i==="sync"){const f=GL();u=f.__watcherHandles||(f.__watcherHandles=[])}else if(!l){const f=()=>{};return f.stop=Fi,f.resume=Fi,f.pause=Fi,f}}const c=Ls;a.call=(f,p,g)=>ai(f,c,p,g);let h=!1;i==="post"?a.scheduler=f=>{Ws(f,c&&c.suspense)}:i!=="sync"&&(h=!0,a.scheduler=(f,p)=>{p?f():jy(f)}),a.augmentJob=f=>{e&&(f.flags|=4),h&&(f.flags|=2,c&&(f.id=c.uid,f.i=c))};const d=mL(t,e,a);return xd&&(u?u.push(d):l&&d()),d}function VL(t,e,n){const s=this.proxy,r=In(t)?t.includes(".")?ck(s,t):()=>s[t]:t.bind(s,s);let i;It(e)?i=e:(i=e.handler,n=e);const o=Kd(this),a=uk(r,i.bind(s),n);return o(),a}function ck(t,e){const n=e.split(".");return()=>{let s=t;for(let r=0;r<n.length&&s;r++)s=s[n[r]];return s}}const WL=(t,e)=>e==="modelValue"||e==="model-value"?t.modelModifiers:t[`${e}Modifiers`]||t[`${Hr(e)}Modifiers`]||t[`${Il(e)}Modifiers`];function HL(t,e,...n){if(t.isUnmounted)return;const s=t.vnode.props||rn;let r=n;const i=e.startsWith("update:"),o=i&&WL(s,e.slice(7));o&&(o.trim&&(r=n.map(c=>In(c)?c.trim():c)),o.number&&(r=n.map(Ng)));let a,l=s[a=rb(e)]||s[a=rb(Hr(e))];!l&&i&&(l=s[a=rb(Il(e))]),l&&ai(l,t,6,r);const u=s[a+"Once"];if(u){if(!t.emitted)t.emitted={};else if(t.emitted[a])return;t.emitted[a]=!0,ai(u,t,6,r)}}const KL=new WeakMap;function hk(t,e,n=!1){const s=n?KL:e.emitsCache,r=s.get(t);if(r!==void 0)return r;const i=t.emits;let o={},a=!1;if(!It(t)){const l=u=>{const c=hk(u,e,!0);c&&(a=!0,ys(o,c))};!n&&e.mixins.length&&e.mixins.forEach(l),t.extends&&l(t.extends),t.mixins&&t.mixins.forEach(l)}return!i&&!a?(tn(t)&&s.set(t,null),null):(ft(i)?i.forEach(l=>o[l]=null):ys(o,i),tn(t)&&s.set(t,o),o)}function Vg(t,e){return!t||!Ag(e)?!1:(e=e.slice(2).replace(/Once$/,""),qt(t,e[0].toLowerCase()+e.slice(1))||qt(t,Il(e))||qt(t,e))}function cS(t){const{type:e,vnode:n,proxy:s,withProxy:r,propsOptions:[i],slots:o,attrs:a,emit:l,render:u,renderCache:c,props:h,data:d,setupState:f,ctx:p,inheritAttrs:g}=t,m=Nm(t);let x,b;try{if(n.shapeFlag&4){const y=r||s,C=y;x=Ri(u.call(C,y,c,h,f,d,p)),b=a}else{const y=e;x=Ri(y.length>1?y(h,{attrs:a,slots:o,emit:l}):y(h,null)),b=e.props?a:jL(a)}}catch(y){Qh.length=0,Og(y,t,1),x=we(Ms)}let v=x;if(b&&g!==!1){const y=Object.keys(b),{shapeFlag:C}=v;y.length&&C&7&&(i&&y.some(Ly)&&(b=XL(b,i)),v=ia(v,b,!1,!0))}return n.dirs&&(v=ia(v,null,!1,!0),v.dirs=v.dirs?v.dirs.concat(n.dirs):n.dirs),n.transition&&pd(v,n.transition),x=v,Nm(m),x}const jL=t=>{let e;for(const n in t)(n==="class"||n==="style"||Ag(n))&&((e||(e={}))[n]=t[n]);return e},XL=(t,e)=>{const n={};for(const s in t)(!Ly(s)||!(s.slice(9)in e))&&(n[s]=t[s]);return n};function qL(t,e,n){const{props:s,children:r,component:i}=t,{props:o,children:a,patchFlag:l}=e,u=i.emitsOptions;if(e.dirs||e.transition)return!0;if(n&&l>=0){if(l&1024)return!0;if(l&16)return s?hS(s,o,u):!!o;if(l&8){const c=e.dynamicProps;for(let h=0;h<c.length;h++){const d=c[h];if(o[d]!==s[d]&&!Vg(u,d))return!0}}}else return(r||a)&&(!a||!a.$stable)?!0:s===o?!1:s?o?hS(s,o,u):!0:!!o;return!1}function hS(t,e,n){const s=Object.keys(e);if(s.length!==Object.keys(t).length)return!0;for(let r=0;r<s.length;r++){const i=s[r];if(e[i]!==t[i]&&!Vg(n,i))return!0}return!1}function YL({vnode:t,parent:e},n){for(;e;){const s=e.subTree;if(s.suspense&&s.suspense.activeBranch===t&&(s.el=t.el),s===t)(t=e.vnode).el=n,e=e.parent;else break}}const dk={},fk=()=>Object.create(dk),pk=t=>Object.getPrototypeOf(t)===dk;function ZL(t,e,n,s=!1){const r={},i=fk();t.propsDefaults=Object.create(null),mk(t,e,r,i);for(const o in t.propsOptions[0])o in r||(r[o]=void 0);n?t.props=s?r:uL(r):t.type.props?t.props=r:t.props=i,t.attrs=i}function QL(t,e,n,s){const{props:r,attrs:i,vnode:{patchFlag:o}}=t,a=Dt(r),[l]=t.propsOptions;let u=!1;if((s||o>0)&&!(o&16)){if(o&8){const c=t.vnode.dynamicProps;for(let h=0;h<c.length;h++){let d=c[h];if(Vg(t.emitsOptions,d))continue;const f=e[d];if(l)if(qt(i,d))f!==i[d]&&(i[d]=f,u=!0);else{const p=Hr(d);r[p]=v1(l,a,p,f,t,!1)}else f!==i[d]&&(i[d]=f,u=!0)}}}else{mk(t,e,r,i)&&(u=!0);let c;for(const h in a)(!e||!qt(e,h)&&((c=Il(h))===h||!qt(e,c)))&&(l?n&&(n[h]!==void 0||n[c]!==void 0)&&(r[h]=v1(l,a,h,void 0,t,!0)):delete r[h]);if(i!==a)for(const h in i)(!e||!qt(e,h))&&(delete i[h],u=!0)}u&&po(t.attrs,"set","")}function mk(t,e,n,s){const[r,i]=t.propsOptions;let o=!1,a;if(e)for(let l in e){if(Kh(l))continue;const u=e[l];let c;r&&qt(r,c=Hr(l))?!i||!i.includes(c)?n[c]=u:(a||(a={}))[c]=u:Vg(t.emitsOptions,l)||(!(l in s)||u!==s[l])&&(s[l]=u,o=!0)}if(i){const l=Dt(n),u=a||rn;for(let c=0;c<i.length;c++){const h=i[c];n[h]=v1(r,l,h,u[h],t,!qt(u,h))}}return o}function v1(t,e,n,s,r,i){const o=t[n];if(o!=null){const a=qt(o,"default");if(a&&s===void 0){const l=o.default;if(o.type!==Function&&!o.skipFactory&&It(l)){const{propsDefaults:u}=r;if(n in u)s=u[n];else{const c=Kd(r);s=u[n]=l.call(null,e),c()}}else s=l;r.ce&&r.ce._setProp(n,s)}o[0]&&(i&&!a?s=!1:o[1]&&(s===""||s===Il(n))&&(s=!0))}return s}const JL=new WeakMap;function gk(t,e,n=!1){const s=n?JL:e.propsCache,r=s.get(t);if(r)return r;const i=t.props,o={},a=[];let l=!1;if(!It(t)){const c=h=>{l=!0;const[d,f]=gk(h,e,!0);ys(o,d),f&&a.push(...f)};!n&&e.mixins.length&&e.mixins.forEach(c),t.extends&&c(t.extends),t.mixins&&t.mixins.forEach(c)}if(!i&&!l)return tn(t)&&s.set(t,Iu),Iu;if(ft(i))for(let c=0;c<i.length;c++){const h=Hr(i[c]);dS(h)&&(o[h]=rn)}else if(i)for(const c in i){const h=Hr(c);if(dS(h)){const d=i[c],f=o[h]=ft(d)||It(d)?{type:d}:ys({},d),p=f.type;let g=!1,m=!0;if(ft(p))for(let x=0;x<p.length;++x){const b=p[x],v=It(b)&&b.name;if(v==="Boolean"){g=!0;break}else v==="String"&&(m=!1)}else g=It(p)&&p.name==="Boolean";f[0]=g,f[1]=m,(g||qt(f,"default"))&&a.push(h)}}const u=[o,a];return tn(t)&&s.set(t,u),u}function dS(t){return t[0]!=="$"&&!Kh(t)}const Xy=t=>t==="_"||t==="_ctx"||t==="$stable",qy=t=>ft(t)?t.map(Ri):[Ri(t)],eO=(t,e,n)=>{if(e._n)return e;const s=hr((...r)=>qy(e(...r)),n);return s._c=!1,s},xk=(t,e,n)=>{const s=t._ctx;for(const r in t){if(Xy(r))continue;const i=t[r];if(It(i))e[r]=eO(r,i,s);else if(i!=null){const o=qy(i);e[r]=()=>o}}},bk=(t,e)=>{const n=qy(e);t.slots.default=()=>n},yk=(t,e,n)=>{for(const s in e)(n||!Xy(s))&&(t[s]=e[s])},tO=(t,e,n)=>{const s=t.slots=fk();if(t.vnode.shapeFlag&32){const r=e._;r?(yk(s,e,n),n&&bI(s,"_",r,!0)):xk(e,s)}else e&&bk(t,e)},nO=(t,e,n)=>{const{vnode:s,slots:r}=t;let i=!0,o=rn;if(s.shapeFlag&32){const a=e._;a?n&&a===1?i=!1:yk(r,e,n):(i=!e.$stable,xk(e,r)),o=e}else e&&(bk(t,e),o={default:1});if(i)for(const a in r)!Xy(a)&&o[a]==null&&delete r[a]},Ws=aO;function sO(t){return rO(t)}function rO(t,e){const n=Mg();n.__VUE__=!0;const{insert:s,remove:r,patchProp:i,createElement:o,createText:a,createComment:l,setText:u,setElementText:c,parentNode:h,nextSibling:d,setScopeId:f=Fi,insertStaticContent:p}=t,g=(H,K,re,pe=null,me=null,xe=null,Te=void 0,De=null,Re=!!K.dynamicChildren)=>{if(H===K)return;H&&!Va(H,K)&&(pe=Pe(H),J(H,me,xe,!0),H=null),K.patchFlag===-2&&(Re=!1,K.dynamicChildren=null);const{type:_e,ref:nt,shapeFlag:Ae}=K;switch(_e){case Wg:m(H,K,re,pe);break;case Ms:x(H,K,re,pe);break;case wm:H==null&&b(K,re,pe,Te);break;case Xe:N(H,K,re,pe,me,xe,Te,De,Re);break;default:Ae&1?C(H,K,re,pe,me,xe,Te,De,Re):Ae&6?P(H,K,re,pe,me,xe,Te,De,Re):(Ae&64||Ae&128)&&_e.process(H,K,re,pe,me,xe,Te,De,Re,ze)}nt!=null&&me?Yh(nt,H&&H.ref,xe,K||H,!K):nt==null&&H&&H.ref!=null&&Yh(H.ref,null,xe,H,!0)},m=(H,K,re,pe)=>{if(H==null)s(K.el=a(K.children),re,pe);else{const me=K.el=H.el;K.children!==H.children&&u(me,K.children)}},x=(H,K,re,pe)=>{H==null?s(K.el=l(K.children||""),re,pe):K.el=H.el},b=(H,K,re,pe)=>{[H.el,H.anchor]=p(H.children,K,re,pe,H.el,H.anchor)},v=({el:H,anchor:K},re,pe)=>{let me;for(;H&&H!==K;)me=d(H),s(H,re,pe),H=me;s(K,re,pe)},y=({el:H,anchor:K})=>{let re;for(;H&&H!==K;)re=d(H),r(H),H=re;r(K)},C=(H,K,re,pe,me,xe,Te,De,Re)=>{if(K.type==="svg"?Te="svg":K.type==="math"&&(Te="mathml"),H==null)I(K,re,pe,me,xe,Te,De,Re);else{const _e=H.el&&H.el._isVueCE?H.el:null;try{_e&&_e._beginPatch(),S(H,K,me,xe,Te,De,Re)}finally{_e&&_e._endPatch()}}},I=(H,K,re,pe,me,xe,Te,De)=>{let Re,_e;const{props:nt,shapeFlag:Ae,transition:Je,dirs:tt}=H;if(Re=H.el=o(H.type,xe,nt&&nt.is,nt),Ae&8?c(Re,H.children):Ae&16&&T(H.children,Re,null,pe,me,hb(H,xe),Te,De),tt&&Pa(H,null,pe,"created"),$(Re,H,H.scopeId,Te,pe),nt){for(const $t in nt)$t!=="value"&&!Kh($t)&&i(Re,$t,null,nt[$t],xe,pe);"value"in nt&&i(Re,"value",null,nt.value,xe),(_e=nt.onVnodeBeforeMount)&&vi(_e,pe,H)}tt&&Pa(H,null,pe,"beforeMount");const Tt=iO(me,Je);Tt&&Je.beforeEnter(Re),s(Re,K,re),((_e=nt&&nt.onVnodeMounted)||Tt||tt)&&Ws(()=>{_e&&vi(_e,pe,H),Tt&&Je.enter(Re),tt&&Pa(H,null,pe,"mounted")},me)},$=(H,K,re,pe,me)=>{if(re&&f(H,re),pe)for(let xe=0;xe<pe.length;xe++)f(H,pe[xe]);if(me){let xe=me.subTree;if(K===xe||wk(xe.type)&&(xe.ssContent===K||xe.ssFallback===K)){const Te=me.vnode;$(H,Te,Te.scopeId,Te.slotScopeIds,me.parent)}}},T=(H,K,re,pe,me,xe,Te,De,Re=0)=>{for(let _e=Re;_e<H.length;_e++){const nt=H[_e]=De?Wo(H[_e]):Ri(H[_e]);g(null,nt,K,re,pe,me,xe,Te,De)}},S=(H,K,re,pe,me,xe,Te)=>{const De=K.el=H.el;let{patchFlag:Re,dynamicChildren:_e,dirs:nt}=K;Re|=H.patchFlag&16;const Ae=H.props||rn,Je=K.props||rn;let tt;if(re&&Da(re,!1),(tt=Je.onVnodeBeforeUpdate)&&vi(tt,re,K,H),nt&&Pa(K,H,re,"beforeUpdate"),re&&Da(re,!0),(Ae.innerHTML&&Je.innerHTML==null||Ae.textContent&&Je.textContent==null)&&c(De,""),_e?E(H.dynamicChildren,_e,De,re,pe,hb(K,me),xe):Te||L(H,K,De,null,re,pe,hb(K,me),xe,!1),Re>0){if(Re&16)_(De,Ae,Je,re,me);else if(Re&2&&Ae.class!==Je.class&&i(De,"class",null,Je.class,me),Re&4&&i(De,"style",Ae.style,Je.style,me),Re&8){const Tt=K.dynamicProps;for(let $t=0;$t<Tt.length;$t++){const Ke=Tt[$t],Sn=Ae[Ke],Zn=Je[Ke];(Zn!==Sn||Ke==="value")&&i(De,Ke,Sn,Zn,me,re)}}Re&1&&H.children!==K.children&&c(De,K.children)}else!Te&&_e==null&&_(De,Ae,Je,re,me);((tt=Je.onVnodeUpdated)||nt)&&Ws(()=>{tt&&vi(tt,re,K,H),nt&&Pa(K,H,re,"updated")},pe)},E=(H,K,re,pe,me,xe,Te)=>{for(let De=0;De<K.length;De++){const Re=H[De],_e=K[De],nt=Re.el&&(Re.type===Xe||!Va(Re,_e)||Re.shapeFlag&198)?h(Re.el):re;g(Re,_e,nt,null,pe,me,xe,Te,!0)}},_=(H,K,re,pe,me)=>{if(K!==re){if(K!==rn)for(const xe in K)!Kh(xe)&&!(xe in re)&&i(H,xe,K[xe],null,me,pe);for(const xe in re){if(Kh(xe))continue;const Te=re[xe],De=K[xe];Te!==De&&xe!=="value"&&i(H,xe,De,Te,me,pe)}"value"in re&&i(H,"value",K.value,re.value,me)}},N=(H,K,re,pe,me,xe,Te,De,Re)=>{const _e=K.el=H?H.el:a(""),nt=K.anchor=H?H.anchor:a("");let{patchFlag:Ae,dynamicChildren:Je,slotScopeIds:tt}=K;tt&&(De=De?De.concat(tt):tt),H==null?(s(_e,re,pe),s(nt,re,pe),T(K.children||[],re,nt,me,xe,Te,De,Re)):Ae>0&&Ae&64&&Je&&H.dynamicChildren?(E(H.dynamicChildren,Je,re,me,xe,Te,De),(K.key!=null||me&&K===me.subTree)&&Yy(H,K,!0)):L(H,K,re,nt,me,xe,Te,De,Re)},P=(H,K,re,pe,me,xe,Te,De,Re)=>{K.slotScopeIds=De,H==null?K.shapeFlag&512?me.ctx.activate(K,re,pe,Te,Re):M(K,re,pe,me,xe,Te,Re):z(H,K,Re)},M=(H,K,re,pe,me,xe,Te)=>{const De=H.component=fO(H,pe,me);if(Ug(H)&&(De.ctx.renderer=ze),pO(De,!1,Te),De.asyncDep){if(me&&me.registerDep(De,A,Te),!H.el){const Re=De.subTree=we(Ms);x(null,Re,K,re),H.placeholder=Re.el}}else A(De,H,K,re,me,xe,Te)},z=(H,K,re)=>{const pe=K.component=H.component;if(qL(H,K,re))if(pe.asyncDep&&!pe.asyncResolved){B(pe,K,re);return}else pe.next=K,pe.update();else K.el=H.el,pe.vnode=K},A=(H,K,re,pe,me,xe,Te)=>{const De=()=>{if(H.isMounted){let{next:Ae,bu:Je,u:tt,parent:Tt,vnode:$t}=H;{const ms=vk(H);if(ms){Ae&&(Ae.el=$t.el,B(H,Ae,Te)),ms.asyncDep.then(()=>{H.isUnmounted||De()});return}}let Ke=Ae,Sn;Da(H,!1),Ae?(Ae.el=$t.el,B(H,Ae,Te)):Ae=$t,Je&&bm(Je),(Sn=Ae.props&&Ae.props.onVnodeBeforeUpdate)&&vi(Sn,Tt,Ae,$t),Da(H,!0);const Zn=cS(H),$s=H.subTree;H.subTree=Zn,g($s,Zn,h($s.el),Pe($s),H,me,xe),Ae.el=Zn.el,Ke===null&&YL(H,Zn.el),tt&&Ws(tt,me),(Sn=Ae.props&&Ae.props.onVnodeUpdated)&&Ws(()=>vi(Sn,Tt,Ae,$t),me)}else{let Ae;const{el:Je,props:tt}=K,{bm:Tt,m:$t,parent:Ke,root:Sn,type:Zn}=H,$s=_u(K);Da(H,!1),Tt&&bm(Tt),!$s&&(Ae=tt&&tt.onVnodeBeforeMount)&&vi(Ae,Ke,K),Da(H,!0);{Sn.ce&&Sn.ce._def.shadowRoot!==!1&&Sn.ce._injectChildStyle(Zn);const ms=H.subTree=cS(H);g(null,ms,re,pe,H,me,xe),K.el=ms.el}if($t&&Ws($t,me),!$s&&(Ae=tt&&tt.onVnodeMounted)){const ms=K;Ws(()=>vi(Ae,Ke,ms),me)}(K.shapeFlag&256||Ke&&_u(Ke.vnode)&&Ke.vnode.shapeFlag&256)&&H.a&&Ws(H.a,me),H.isMounted=!0,K=re=pe=null}};H.scope.on();const Re=H.effect=new SI(De);H.scope.off();const _e=H.update=Re.run.bind(Re),nt=H.job=Re.runIfDirty.bind(Re);nt.i=H,nt.id=H.uid,Re.scheduler=()=>jy(nt),Da(H,!0),_e()},B=(H,K,re)=>{K.component=H;const pe=H.vnode.props;H.vnode=K,H.next=null,QL(H,K.props,pe,re),nO(H,K.children,re),Co(),Jw(H),To()},L=(H,K,re,pe,me,xe,Te,De,Re=!1)=>{const _e=H&&H.children,nt=H?H.shapeFlag:0,Ae=K.children,{patchFlag:Je,shapeFlag:tt}=K;if(Je>0){if(Je&128){j(_e,Ae,re,pe,me,xe,Te,De,Re);return}else if(Je&256){U(_e,Ae,re,pe,me,xe,Te,De,Re);return}}tt&8?(nt&16&&ve(_e,me,xe),Ae!==_e&&c(re,Ae)):nt&16?tt&16?j(_e,Ae,re,pe,me,xe,Te,De,Re):ve(_e,me,xe,!0):(nt&8&&c(re,""),tt&16&&T(Ae,re,pe,me,xe,Te,De,Re))},U=(H,K,re,pe,me,xe,Te,De,Re)=>{H=H||Iu,K=K||Iu;const _e=H.length,nt=K.length,Ae=Math.min(_e,nt);let Je;for(Je=0;Je<Ae;Je++){const tt=K[Je]=Re?Wo(K[Je]):Ri(K[Je]);g(H[Je],tt,re,null,me,xe,Te,De,Re)}_e>nt?ve(H,me,xe,!0,!1,Ae):T(K,re,pe,me,xe,Te,De,Re,Ae)},j=(H,K,re,pe,me,xe,Te,De,Re)=>{let _e=0;const nt=K.length;let Ae=H.length-1,Je=nt-1;for(;_e<=Ae&&_e<=Je;){const tt=H[_e],Tt=K[_e]=Re?Wo(K[_e]):Ri(K[_e]);if(Va(tt,Tt))g(tt,Tt,re,null,me,xe,Te,De,Re);else break;_e++}for(;_e<=Ae&&_e<=Je;){const tt=H[Ae],Tt=K[Je]=Re?Wo(K[Je]):Ri(K[Je]);if(Va(tt,Tt))g(tt,Tt,re,null,me,xe,Te,De,Re);else break;Ae--,Je--}if(_e>Ae){if(_e<=Je){const tt=Je+1,Tt=tt<nt?K[tt].el:pe;for(;_e<=Je;)g(null,K[_e]=Re?Wo(K[_e]):Ri(K[_e]),re,Tt,me,xe,Te,De,Re),_e++}}else if(_e>Je)for(;_e<=Ae;)J(H[_e],me,xe,!0),_e++;else{const tt=_e,Tt=_e,$t=new Map;for(_e=Tt;_e<=Je;_e++){const xn=K[_e]=Re?Wo(K[_e]):Ri(K[_e]);xn.key!=null&&$t.set(xn.key,_e)}let Ke,Sn=0;const Zn=Je-Tt+1;let $s=!1,ms=0;const nr=new Array(Zn);for(_e=0;_e<Zn;_e++)nr[_e]=0;for(_e=tt;_e<=Ae;_e++){const xn=H[_e];if(Sn>=Zn){J(xn,me,xe,!0);continue}let yt;if(xn.key!=null)yt=$t.get(xn.key);else for(Ke=Tt;Ke<=Je;Ke++)if(nr[Ke-Tt]===0&&Va(xn,K[Ke])){yt=Ke;break}yt===void 0?J(xn,me,xe,!0):(nr[yt-Tt]=_e+1,yt>=ms?ms=yt:$s=!0,g(xn,K[yt],re,null,me,xe,Te,De,Re),Sn++)}const $a=$s?oO(nr):Iu;for(Ke=$a.length-1,_e=Zn-1;_e>=0;_e--){const xn=Tt+_e,yt=K[xn],vp=K[xn+1],Ra=xn+1<nt?vp.el||vp.placeholder:pe;nr[_e]===0?g(null,yt,re,Ra,me,xe,Te,De,Re):$s&&(Ke<0||_e!==$a[Ke]?Z(yt,re,Ra,2):Ke--)}}},Z=(H,K,re,pe,me=null)=>{const{el:xe,type:Te,transition:De,children:Re,shapeFlag:_e}=H;if(_e&6){Z(H.component.subTree,K,re,pe);return}if(_e&128){H.suspense.move(K,re,pe);return}if(_e&64){Te.move(H,K,re,ze);return}if(Te===Xe){s(xe,K,re);for(let Ae=0;Ae<Re.length;Ae++)Z(Re[Ae],K,re,pe);s(H.anchor,K,re);return}if(Te===wm){v(H,K,re);return}if(pe!==2&&_e&1&&De)if(pe===0)De.beforeEnter(xe),s(xe,K,re),Ws(()=>De.enter(xe),me);else{const{leave:Ae,delayLeave:Je,afterLeave:tt}=De,Tt=()=>{H.ctx.isUnmounted?r(xe):s(xe,K,re)},$t=()=>{xe._isLeaving&&xe[ho](!0),Ae(xe,()=>{Tt(),tt&&tt()})};Je?Je(xe,Tt,$t):$t()}else s(xe,K,re)},J=(H,K,re,pe=!1,me=!1)=>{const{type:xe,props:Te,ref:De,children:Re,dynamicChildren:_e,shapeFlag:nt,patchFlag:Ae,dirs:Je,cacheIndex:tt}=H;if(Ae===-2&&(me=!1),De!=null&&(Co(),Yh(De,null,re,H,!0),To()),tt!=null&&(K.renderCache[tt]=void 0),nt&256){K.ctx.deactivate(H);return}const Tt=nt&1&&Je,$t=!_u(H);let Ke;if($t&&(Ke=Te&&Te.onVnodeBeforeUnmount)&&vi(Ke,K,H),nt&6)he(H.component,re,pe);else{if(nt&128){H.suspense.unmount(re,pe);return}Tt&&Pa(H,null,K,"beforeUnmount"),nt&64?H.type.remove(H,K,re,ze,pe):_e&&!_e.hasOnce&&(xe!==Xe||Ae>0&&Ae&64)?ve(_e,K,re,!1,!0):(xe===Xe&&Ae&384||!me&&nt&16)&&ve(Re,K,re),pe&&se(H)}($t&&(Ke=Te&&Te.onVnodeUnmounted)||Tt)&&Ws(()=>{Ke&&vi(Ke,K,H),Tt&&Pa(H,null,K,"unmounted")},re)},se=H=>{const{type:K,el:re,anchor:pe,transition:me}=H;if(K===Xe){fe(re,pe);return}if(K===wm){y(H);return}const xe=()=>{r(re),me&&!me.persisted&&me.afterLeave&&me.afterLeave()};if(H.shapeFlag&1&&me&&!me.persisted){const{leave:Te,delayLeave:De}=me,Re=()=>Te(re,xe);De?De(H.el,xe,Re):Re()}else xe()},fe=(H,K)=>{let re;for(;H!==K;)re=d(H),r(H),H=re;r(K)},he=(H,K,re)=>{const{bum:pe,scope:me,job:xe,subTree:Te,um:De,m:Re,a:_e}=H;fS(Re),fS(_e),pe&&bm(pe),me.stop(),xe&&(xe.flags|=8,J(Te,H,K,re)),De&&Ws(De,K),Ws(()=>{H.isUnmounted=!0},K)},ve=(H,K,re,pe=!1,me=!1,xe=0)=>{for(let Te=xe;Te<H.length;Te++)J(H[Te],K,re,pe,me)},Pe=H=>{if(H.shapeFlag&6)return Pe(H.component.subTree);if(H.shapeFlag&128)return H.suspense.next();const K=d(H.anchor||H.el),re=K&&K[WI];return re?d(re):K};let Ee=!1;const Se=(H,K,re)=>{H==null?K._vnode&&J(K._vnode,null,null,!0):g(K._vnode||null,H,K,null,null,null,re),K._vnode=H,Ee||(Ee=!0,Jw(),zI(),Ee=!1)},ze={p:g,um:J,m:Z,r:se,mt:M,mc:T,pc:L,pbc:E,n:Pe,o:t};return{render:Se,hydrate:void 0,createApp:UL(Se)}}function hb({type:t,props:e},n){return n==="svg"&&t==="foreignObject"||n==="mathml"&&t==="annotation-xml"&&e&&e.encoding&&e.encoding.includes("html")?void 0:n}function Da({effect:t,job:e},n){n?(t.flags|=32,e.flags|=4):(t.flags&=-33,e.flags&=-5)}function iO(t,e){return(!t||t&&!t.pendingBranch)&&e&&!e.persisted}function Yy(t,e,n=!1){const s=t.children,r=e.children;if(ft(s)&&ft(r))for(let i=0;i<s.length;i++){const o=s[i];let a=r[i];a.shapeFlag&1&&!a.dynamicChildren&&((a.patchFlag<=0||a.patchFlag===32)&&(a=r[i]=Wo(r[i]),a.el=o.el),!n&&a.patchFlag!==-2&&Yy(o,a)),a.type===Wg&&a.patchFlag!==-1&&(a.el=o.el),a.type===Ms&&!a.el&&(a.el=o.el)}}function oO(t){const e=t.slice(),n=[0];let s,r,i,o,a;const l=t.length;for(s=0;s<l;s++){const u=t[s];if(u!==0){if(r=n[n.length-1],t[r]<u){e[s]=r,n.push(s);continue}for(i=0,o=n.length-1;i<o;)a=i+o>>1,t[n[a]]<u?i=a+1:o=a;u<t[n[i]]&&(i>0&&(e[s]=n[i-1]),n[i]=s)}}for(i=n.length,o=n[i-1];i-- >0;)n[i]=o,o=e[o];return n}function vk(t){const e=t.subTree.component;if(e)return e.asyncDep&&!e.asyncResolved?e:vk(e)}function fS(t){if(t)for(let e=0;e<t.length;e++)t[e].flags|=8}const wk=t=>t.__isSuspense;function aO(t,e){e&&e.pendingBranch?ft(t)?e.effects.push(...t):e.effects.push(t):bL(t)}const Xe=Symbol.for("v-fgt"),Wg=Symbol.for("v-txt"),Ms=Symbol.for("v-cmt"),wm=Symbol.for("v-stc"),Qh=[];let wr=null;function F(t=!1){Qh.push(wr=t?null:[])}function lO(){Qh.pop(),wr=Qh[Qh.length-1]||null}let md=1;function Fm(t,e=!1){md+=t,t<0&&wr&&e&&(wr.hasOnce=!0)}function Sk(t){return t.dynamicChildren=md>0?wr||Iu:null,lO(),md>0&&wr&&wr.push(t),t}function V(t,e,n,s,r,i){return Sk(k(t,e,n,s,r,i,!0))}function st(t,e,n,s,r){return Sk(we(t,e,n,s,r,!0))}function gd(t){return t?t.__v_isVNode===!0:!1}function Va(t,e){return t.type===e.type&&t.key===e.key}const Ck=({key:t})=>t??null,Sm=({ref:t,ref_key:e,ref_for:n})=>(typeof t=="number"&&(t=""+t),t!=null?In(t)||Yt(t)||It(t)?{i:Cs,r:t,k:e,f:!!n}:t:null);function k(t,e=null,n=null,s=0,r=null,i=t===Xe?0:1,o=!1,a=!1){const l={__v_isVNode:!0,__v_skip:!0,type:t,props:e,key:e&&Ck(e),ref:e&&Sm(e),scopeId:VI,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:i,patchFlag:s,dynamicProps:r,dynamicChildren:null,appContext:null,ctx:Cs};return a?(Zy(l,n),i&128&&t.normalize(l)):n&&(l.shapeFlag|=In(n)?8:16),md>0&&!o&&wr&&(l.patchFlag>0||i&6)&&l.patchFlag!==32&&wr.push(l),l}const we=uO;function uO(t,e=null,n=null,s=0,r=null,i=!1){if((!t||t===sk)&&(t=Ms),gd(t)){const a=ia(t,e,!0);return n&&Zy(a,n),md>0&&!i&&wr&&(a.shapeFlag&6?wr[wr.indexOf(t)]=a:wr.push(a)),a.patchFlag=-2,a}if(yO(t)&&(t=t.__vccOpts),e){e=Tk(e);let{class:a,style:l}=e;a&&!In(a)&&(e.class=Q(a)),tn(l)&&(Ky(l)&&!ft(l)&&(l=ys({},l)),e.style=bn(l))}const o=In(t)?1:wk(t)?128:HI(t)?64:tn(t)?4:It(t)?2:0;return k(t,e,n,s,r,o,i,!0)}function Tk(t){return t?Ky(t)||pk(t)?ys({},t):t:null}function ia(t,e,n=!1,s=!1){const{props:r,ref:i,patchFlag:o,children:a,transition:l}=t,u=e?cO(r||{},e):r,c={__v_isVNode:!0,__v_skip:!0,type:t.type,props:u,key:u&&Ck(u),ref:e&&e.ref?n&&i?ft(i)?i.concat(Sm(e)):[i,Sm(e)]:Sm(e):i,scopeId:t.scopeId,slotScopeIds:t.slotScopeIds,children:a,target:t.target,targetStart:t.targetStart,targetAnchor:t.targetAnchor,staticCount:t.staticCount,shapeFlag:t.shapeFlag,patchFlag:e&&t.type!==Xe?o===-1?16:o|16:o,dynamicProps:t.dynamicProps,dynamicChildren:t.dynamicChildren,appContext:t.appContext,dirs:t.dirs,transition:l,component:t.component,suspense:t.suspense,ssContent:t.ssContent&&ia(t.ssContent),ssFallback:t.ssFallback&&ia(t.ssFallback),placeholder:t.placeholder,el:t.el,anchor:t.anchor,ctx:t.ctx,ce:t.ce};return l&&s&&pd(c,l.clone(c)),c}function Tn(t=" ",e=0){return we(Wg,null,t,e)}function Ik(t,e){const n=we(wm,null,t);return n.staticCount=e,n}function Ue(t="",e=!1){return e?(F(),st(Ms,null,t)):we(Ms,null,t)}function Ri(t){return t==null||typeof t=="boolean"?we(Ms):ft(t)?we(Xe,null,t.slice()):gd(t)?Wo(t):we(Wg,null,String(t))}function Wo(t){return t.el===null&&t.patchFlag!==-1||t.memo?t:ia(t)}function Zy(t,e){let n=0;const{shapeFlag:s}=t;if(e==null)e=null;else if(ft(e))n=16;else if(typeof e=="object")if(s&65){const r=e.default;r&&(r._c&&(r._d=!1),Zy(t,r()),r._c&&(r._d=!0));return}else{n=32;const r=e._;!r&&!pk(e)?e._ctx=Cs:r===3&&Cs&&(Cs.slots._===1?e._=1:(e._=2,t.patchFlag|=1024))}else It(e)?(e={default:e,_ctx:Cs},n=32):(e=String(e),s&64?(n=16,e=[Tn(e)]):n=8);t.children=e,t.shapeFlag|=n}function cO(...t){const e={};for(let n=0;n<t.length;n++){const s=t[n];for(const r in s)if(r==="class")e.class!==s.class&&(e.class=Q([e.class,s.class]));else if(r==="style")e.style=bn([e.style,s.style]);else if(Ag(r)){const i=e[r],o=s[r];o&&i!==o&&!(ft(i)&&i.includes(o))&&(e[r]=i?[].concat(i,o):o)}else r!==""&&(e[r]=s[r])}return e}function vi(t,e,n,s=null){ai(t,e,7,[n,s])}const hO=lk();let dO=0;function fO(t,e,n){const s=t.type,r=(e?e.appContext:t.appContext)||hO,i={uid:dO++,vnode:t,type:s,parent:e,appContext:r,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new VM(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:e?e.provides:Object.create(r.provides),ids:e?e.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:gk(s,r),emitsOptions:hk(s,r),emit:null,emitted:null,propsDefaults:rn,inheritAttrs:s.inheritAttrs,ctx:rn,data:rn,props:rn,attrs:rn,slots:rn,refs:rn,setupState:rn,setupContext:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return i.ctx={_:i},i.root=e?e.root:i,i.emit=HL.bind(null,i),t.ce&&t.ce(i),i}let Ls=null;const Hg=()=>Ls||Cs;let Um,w1;{const t=Mg(),e=(n,s)=>{let r;return(r=t[n])||(r=t[n]=[]),r.push(s),i=>{r.length>1?r.forEach(o=>o(i)):r[0](i)}};Um=e("__VUE_INSTANCE_SETTERS__",n=>Ls=n),w1=e("__VUE_SSR_SETTERS__",n=>xd=n)}const Kd=t=>{const e=Ls;return Um(t),t.scope.on(),()=>{t.scope.off(),Um(e)}},pS=()=>{Ls&&Ls.scope.off(),Um(null)};function kk(t){return t.vnode.shapeFlag&4}let xd=!1;function pO(t,e=!1,n=!1){e&&w1(e);const{props:s,children:r}=t.vnode,i=kk(t);ZL(t,s,i,e),tO(t,r,n||e);const o=i?mO(t,e):void 0;return e&&w1(!1),o}function mO(t,e){const n=t.type;t.accessCache=Object.create(null),t.proxy=new Proxy(t.ctx,PL);const{setup:s}=n;if(s){Co();const r=t.setupContext=s.length>1?xO(t):null,i=Kd(t),o=Hd(s,t,0,[t.props,r]),a=mI(o);if(To(),i(),(a||t.sp)&&!_u(t)&&JI(t),a){if(o.then(pS,pS),e)return o.then(l=>{mS(t,l)}).catch(l=>{Og(l,t,0)});t.asyncDep=o}else mS(t,o)}else Ek(t)}function mS(t,e,n){It(e)?t.type.__ssrInlineRender?t.ssrRender=e:t.render=e:tn(e)&&(t.setupState=FI(e)),Ek(t)}function Ek(t,e,n){const s=t.type;t.render||(t.render=s.render||Fi);{const r=Kd(t);Co();try{DL(t)}finally{To(),r()}}}const gO={get(t,e){return Ps(t,"get",""),t[e]}};function xO(t){const e=n=>{t.exposed=n||{}};return{attrs:new Proxy(t.attrs,gO),slots:t.slots,emit:t.emit,expose:e}}function Kg(t){return t.exposed?t.exposeProxy||(t.exposeProxy=new Proxy(FI(LI(t.exposed)),{get(e,n){if(n in e)return e[n];if(n in Zh)return Zh[n](t)},has(e,n){return n in e||n in Zh}})):t.proxy}function bO(t,e=!0){return It(t)?t.displayName||t.name:t.name||e&&t.__name}function yO(t){return It(t)&&"__vccOpts"in t}const ye=(t,e)=>fL(t,e,xd);function bd(t,e,n){try{Fm(-1);const s=arguments.length;return s===2?tn(e)&&!ft(e)?gd(e)?we(t,null,[e]):we(t,e):we(t,null,e):(s>3?n=Array.prototype.slice.call(arguments,2):s===3&&gd(n)&&(n=[n]),we(t,e,n))}finally{Fm(1)}}const vO="3.5.25";/**
* @vue/runtime-dom v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let S1;const gS=typeof window<"u"&&window.trustedTypes;if(gS)try{S1=gS.createPolicy("vue",{createHTML:t=>t})}catch{}const _k=S1?t=>S1.createHTML(t):t=>t,wO="http://www.w3.org/2000/svg",SO="http://www.w3.org/1998/Math/MathML",uo=typeof document<"u"?document:null,xS=uo&&uo.createElement("template"),CO={insert:(t,e,n)=>{e.insertBefore(t,n||null)},remove:t=>{const e=t.parentNode;e&&e.removeChild(t)},createElement:(t,e,n,s)=>{const r=e==="svg"?uo.createElementNS(wO,t):e==="mathml"?uo.createElementNS(SO,t):n?uo.createElement(t,{is:n}):uo.createElement(t);return t==="select"&&s&&s.multiple!=null&&r.setAttribute("multiple",s.multiple),r},createText:t=>uo.createTextNode(t),createComment:t=>uo.createComment(t),setText:(t,e)=>{t.nodeValue=e},setElementText:(t,e)=>{t.textContent=e},parentNode:t=>t.parentNode,nextSibling:t=>t.nextSibling,querySelector:t=>uo.querySelector(t),setScopeId(t,e){t.setAttribute(e,"")},insertStaticContent(t,e,n,s,r,i){const o=n?n.previousSibling:e.lastChild;if(r&&(r===i||r.nextSibling))for(;e.insertBefore(r.cloneNode(!0),n),!(r===i||!(r=r.nextSibling)););else{xS.innerHTML=_k(s==="svg"?`<svg>${t}</svg>`:s==="mathml"?`<math>${t}</math>`:t);const a=xS.content;if(s==="svg"||s==="mathml"){const l=a.firstChild;for(;l.firstChild;)a.appendChild(l.firstChild);a.removeChild(l)}e.insertBefore(a,n)}return[o?o.nextSibling:e.firstChild,n?n.previousSibling:e.lastChild]}},Fo="transition",gh="animation",yd=Symbol("_vtc"),$k={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},TO=ys({},XI,$k),IO=t=>(t.displayName="Transition",t.props=TO,t),kO=IO((t,{slots:e})=>bd(SL,EO(t),e)),Na=(t,e=[])=>{ft(t)?t.forEach(n=>n(...e)):t&&t(...e)},bS=t=>t?ft(t)?t.some(e=>e.length>1):t.length>1:!1;function EO(t){const e={};for(const N in t)N in $k||(e[N]=t[N]);if(t.css===!1)return e;const{name:n="v",type:s,duration:r,enterFromClass:i=`${n}-enter-from`,enterActiveClass:o=`${n}-enter-active`,enterToClass:a=`${n}-enter-to`,appearFromClass:l=i,appearActiveClass:u=o,appearToClass:c=a,leaveFromClass:h=`${n}-leave-from`,leaveActiveClass:d=`${n}-leave-active`,leaveToClass:f=`${n}-leave-to`}=t,p=_O(r),g=p&&p[0],m=p&&p[1],{onBeforeEnter:x,onEnter:b,onEnterCancelled:v,onLeave:y,onLeaveCancelled:C,onBeforeAppear:I=x,onAppear:$=b,onAppearCancelled:T=v}=e,S=(N,P,M,z)=>{N._enterCancelled=z,Ma(N,P?c:a),Ma(N,P?u:o),M&&M()},E=(N,P)=>{N._isLeaving=!1,Ma(N,h),Ma(N,f),Ma(N,d),P&&P()},_=N=>(P,M)=>{const z=N?$:b,A=()=>S(P,N,M);Na(z,[P,A]),yS(()=>{Ma(P,N?l:i),io(P,N?c:a),bS(z)||vS(P,s,g,A)})};return ys(e,{onBeforeEnter(N){Na(x,[N]),io(N,i),io(N,o)},onBeforeAppear(N){Na(I,[N]),io(N,l),io(N,u)},onEnter:_(!1),onAppear:_(!0),onLeave(N,P){N._isLeaving=!0;const M=()=>E(N,P);io(N,h),N._enterCancelled?(io(N,d),CS(N)):(CS(N),io(N,d)),yS(()=>{N._isLeaving&&(Ma(N,h),io(N,f),bS(y)||vS(N,s,m,M))}),Na(y,[N,M])},onEnterCancelled(N){S(N,!1,void 0,!0),Na(v,[N])},onAppearCancelled(N){S(N,!0,void 0,!0),Na(T,[N])},onLeaveCancelled(N){E(N),Na(C,[N])}})}function _O(t){if(t==null)return null;if(tn(t))return[db(t.enter),db(t.leave)];{const e=db(t);return[e,e]}}function db(t){return NM(t)}function io(t,e){e.split(/\s+/).forEach(n=>n&&t.classList.add(n)),(t[yd]||(t[yd]=new Set)).add(e)}function Ma(t,e){e.split(/\s+/).forEach(s=>s&&t.classList.remove(s));const n=t[yd];n&&(n.delete(e),n.size||(t[yd]=void 0))}function yS(t){requestAnimationFrame(()=>{requestAnimationFrame(t)})}let $O=0;function vS(t,e,n,s){const r=t._endId=++$O,i=()=>{r===t._endId&&s()};if(n!=null)return setTimeout(i,n);const{type:o,timeout:a,propCount:l}=RO(t,e);if(!o)return s();const u=o+"end";let c=0;const h=()=>{t.removeEventListener(u,d),i()},d=f=>{f.target===t&&++c>=l&&h()};setTimeout(()=>{c<l&&h()},a+1),t.addEventListener(u,d)}function RO(t,e){const n=window.getComputedStyle(t),s=p=>(n[p]||"").split(", "),r=s(`${Fo}Delay`),i=s(`${Fo}Duration`),o=wS(r,i),a=s(`${gh}Delay`),l=s(`${gh}Duration`),u=wS(a,l);let c=null,h=0,d=0;e===Fo?o>0&&(c=Fo,h=o,d=i.length):e===gh?u>0&&(c=gh,h=u,d=l.length):(h=Math.max(o,u),c=h>0?o>u?Fo:gh:null,d=c?c===Fo?i.length:l.length:0);const f=c===Fo&&/\b(?:transform|all)(?:,|$)/.test(s(`${Fo}Property`).toString());return{type:c,timeout:h,propCount:d,hasTransform:f}}function wS(t,e){for(;t.length<e.length;)t=t.concat(t);return Math.max(...e.map((n,s)=>SS(n)+SS(t[s])))}function SS(t){return t==="auto"?0:Number(t.slice(0,-1).replace(",","."))*1e3}function CS(t){return(t?t.ownerDocument:document).body.offsetHeight}function AO(t,e,n){const s=t[yd];s&&(e=(e?[e,...s]:[...s]).join(" ")),e==null?t.removeAttribute("class"):n?t.setAttribute("class",e):t.className=e}const Bm=Symbol("_vod"),Rk=Symbol("_vsh"),Gt={name:"show",beforeMount(t,{value:e},{transition:n}){t[Bm]=t.style.display==="none"?"":t.style.display,n&&e?n.beforeEnter(t):xh(t,e)},mounted(t,{value:e},{transition:n}){n&&e&&n.enter(t)},updated(t,{value:e,oldValue:n},{transition:s}){!e!=!n&&(s?e?(s.beforeEnter(t),xh(t,!0),s.enter(t)):s.leave(t,()=>{xh(t,!1)}):xh(t,e))},beforeUnmount(t,{value:e}){xh(t,e)}};function xh(t,e){t.style.display=e?t[Bm]:"none",t[Rk]=!e}const PO=Symbol(""),DO=/(?:^|;)\s*display\s*:/;function NO(t,e,n){const s=t.style,r=In(n);let i=!1;if(n&&!r){if(e)if(In(e))for(const o of e.split(";")){const a=o.slice(0,o.indexOf(":")).trim();n[a]==null&&Cm(s,a,"")}else for(const o in e)n[o]==null&&Cm(s,o,"");for(const o in n)o==="display"&&(i=!0),Cm(s,o,n[o])}else if(r){if(e!==n){const o=s[PO];o&&(n+=";"+o),s.cssText=n,i=DO.test(n)}}else e&&t.removeAttribute("style");Bm in t&&(t[Bm]=i?s.display:"",t[Rk]&&(s.display="none"))}const TS=/\s*!important$/;function Cm(t,e,n){if(ft(n))n.forEach(s=>Cm(t,e,s));else if(n==null&&(n=""),e.startsWith("--"))t.setProperty(e,n);else{const s=MO(t,e);TS.test(n)?t.setProperty(Il(s),n.replace(TS,""),"important"):t[s]=n}}const IS=["Webkit","Moz","ms"],fb={};function MO(t,e){const n=fb[e];if(n)return n;let s=Hr(e);if(s!=="filter"&&s in t)return fb[e]=s;s=Dg(s);for(let r=0;r<IS.length;r++){const i=IS[r]+s;if(i in t)return fb[e]=i}return e}const kS="http://www.w3.org/1999/xlink";function ES(t,e,n,s,r,i=zM(e)){s&&e.startsWith("xlink:")?n==null?t.removeAttributeNS(kS,e.slice(6,e.length)):t.setAttributeNS(kS,e,n):n==null||i&&!yI(n)?t.removeAttribute(e):t.setAttribute(e,i?"":ii(n)?String(n):n)}function _S(t,e,n,s,r){if(e==="innerHTML"||e==="textContent"){n!=null&&(t[e]=e==="innerHTML"?_k(n):n);return}const i=t.tagName;if(e==="value"&&i!=="PROGRESS"&&!i.includes("-")){const a=i==="OPTION"?t.getAttribute("value")||"":t.value,l=n==null?t.type==="checkbox"?"on":"":String(n);(a!==l||!("_value"in t))&&(t.value=l),n==null&&t.removeAttribute(e),t._value=n;return}let o=!1;if(n===""||n==null){const a=typeof t[e];a==="boolean"?n=yI(n):n==null&&a==="string"?(n="",o=!0):a==="number"&&(n=0,o=!0)}try{t[e]=n}catch{}o&&t.removeAttribute(r||e)}function Ko(t,e,n,s){t.addEventListener(e,n,s)}function LO(t,e,n,s){t.removeEventListener(e,n,s)}const $S=Symbol("_vei");function OO(t,e,n,s,r=null){const i=t[$S]||(t[$S]={}),o=i[e];if(s&&o)o.value=s;else{const[a,l]=FO(e);if(s){const u=i[e]=zO(s,r);Ko(t,a,u,l)}else o&&(LO(t,a,o,l),i[e]=void 0)}}const RS=/(?:Once|Passive|Capture)$/;function FO(t){let e;if(RS.test(t)){e={};let s;for(;s=t.match(RS);)t=t.slice(0,t.length-s[0].length),e[s[0].toLowerCase()]=!0}return[t[2]===":"?t.slice(3):Il(t.slice(2)),e]}let pb=0;const UO=Promise.resolve(),BO=()=>pb||(UO.then(()=>pb=0),pb=Date.now());function zO(t,e){const n=s=>{if(!s._vts)s._vts=Date.now();else if(s._vts<=n.attached)return;ai(GO(s,n.value),e,5,[s])};return n.value=t,n.attached=BO(),n}function GO(t,e){if(ft(e)){const n=t.stopImmediatePropagation;return t.stopImmediatePropagation=()=>{n.call(t),t._stopped=!0},e.map(s=>r=>!r._stopped&&s&&s(r))}else return e}const AS=t=>t.charCodeAt(0)===111&&t.charCodeAt(1)===110&&t.charCodeAt(2)>96&&t.charCodeAt(2)<123,VO=(t,e,n,s,r,i)=>{const o=r==="svg";e==="class"?AO(t,s,o):e==="style"?NO(t,n,s):Ag(e)?Ly(e)||OO(t,e,n,s,i):(e[0]==="."?(e=e.slice(1),!0):e[0]==="^"?(e=e.slice(1),!1):WO(t,e,s,o))?(_S(t,e,s),!t.tagName.includes("-")&&(e==="value"||e==="checked"||e==="selected")&&ES(t,e,s,o,i,e!=="value")):t._isVueCE&&(/[A-Z]/.test(e)||!In(s))?_S(t,Hr(e),s,i,e):(e==="true-value"?t._trueValue=s:e==="false-value"&&(t._falseValue=s),ES(t,e,s,o))};function WO(t,e,n,s){if(s)return!!(e==="innerHTML"||e==="textContent"||e in t&&AS(e)&&It(n));if(e==="spellcheck"||e==="draggable"||e==="translate"||e==="autocorrect"||e==="sandbox"&&t.tagName==="IFRAME"||e==="form"||e==="list"&&t.tagName==="INPUT"||e==="type"&&t.tagName==="TEXTAREA")return!1;if(e==="width"||e==="height"){const r=t.tagName;if(r==="IMG"||r==="VIDEO"||r==="CANVAS"||r==="SOURCE")return!1}return AS(e)&&In(n)?!1:e in t}const Lu=t=>{const e=t.props["onUpdate:modelValue"]||!1;return ft(e)?n=>bm(e,n):e};function HO(t){t.target.composing=!0}function PS(t){const e=t.target;e.composing&&(e.composing=!1,e.dispatchEvent(new Event("input")))}const bo=Symbol("_assign");function DS(t,e,n){return e&&(t=t.trim()),n&&(t=Ng(t)),t}const Lr={created(t,{modifiers:{lazy:e,trim:n,number:s}},r){t[bo]=Lu(r);const i=s||r.props&&r.props.type==="number";Ko(t,e?"change":"input",o=>{o.target.composing||t[bo](DS(t.value,n,i))}),(n||i)&&Ko(t,"change",()=>{t.value=DS(t.value,n,i)}),e||(Ko(t,"compositionstart",HO),Ko(t,"compositionend",PS),Ko(t,"change",PS))},mounted(t,{value:e}){t.value=e??""},beforeUpdate(t,{value:e,oldValue:n,modifiers:{lazy:s,trim:r,number:i}},o){if(t[bo]=Lu(o),t.composing)return;const a=(i||t.type==="number")&&!/^0\d/.test(t.value)?Ng(t.value):t.value,l=e??"";a!==l&&(document.activeElement===t&&t.type!=="range"&&(s&&e===n||r&&t.value.trim()===l)||(t.value=l))}},KO={deep:!0,created(t,e,n){t[bo]=Lu(n),Ko(t,"change",()=>{const s=t._modelValue,r=vd(t),i=t.checked,o=t[bo];if(ft(s)){const a=Uy(s,r),l=a!==-1;if(i&&!l)o(s.concat(r));else if(!i&&l){const u=[...s];u.splice(a,1),o(u)}}else if(Zu(s)){const a=new Set(s);i?a.add(r):a.delete(r),o(a)}else o(Ak(t,i))})},mounted:NS,beforeUpdate(t,e,n){t[bo]=Lu(n),NS(t,e,n)}};function NS(t,{value:e,oldValue:n},s){t._modelValue=e;let r;if(ft(e))r=Uy(e,s.props.value)>-1;else if(Zu(e))r=e.has(s.props.value);else{if(e===n)return;r=Wd(e,Ak(t,!0))}t.checked!==r&&(t.checked=r)}const jO={deep:!0,created(t,{value:e,modifiers:{number:n}},s){const r=Zu(e);Ko(t,"change",()=>{const i=Array.prototype.filter.call(t.options,o=>o.selected).map(o=>n?Ng(vd(o)):vd(o));t[bo](t.multiple?r?new Set(i):i:i[0]),t._assigning=!0,tl(()=>{t._assigning=!1})}),t[bo]=Lu(s)},mounted(t,{value:e}){MS(t,e)},beforeUpdate(t,e,n){t[bo]=Lu(n)},updated(t,{value:e}){t._assigning||MS(t,e)}};function MS(t,e){const n=t.multiple,s=ft(e);if(!(n&&!s&&!Zu(e))){for(let r=0,i=t.options.length;r<i;r++){const o=t.options[r],a=vd(o);if(n)if(s){const l=typeof a;l==="string"||l==="number"?o.selected=e.some(u=>String(u)===String(a)):o.selected=Uy(e,a)>-1}else o.selected=e.has(a);else if(Wd(vd(o),e)){t.selectedIndex!==r&&(t.selectedIndex=r);return}}!n&&t.selectedIndex!==-1&&(t.selectedIndex=-1)}}function vd(t){return"_value"in t?t._value:t.value}function Ak(t,e){const n=e?"_trueValue":"_falseValue";return n in t?t[n]:e}const XO=["ctrl","shift","alt","meta"],qO={stop:t=>t.stopPropagation(),prevent:t=>t.preventDefault(),self:t=>t.target!==t.currentTarget,ctrl:t=>!t.ctrlKey,shift:t=>!t.shiftKey,alt:t=>!t.altKey,meta:t=>!t.metaKey,left:t=>"button"in t&&t.button!==0,middle:t=>"button"in t&&t.button!==1,right:t=>"button"in t&&t.button!==2,exact:(t,e)=>XO.some(n=>t[`${n}Key`]&&!e.includes(n))},gs=(t,e)=>{const n=t._withMods||(t._withMods={}),s=e.join(".");return n[s]||(n[s]=(r,...i)=>{for(let o=0;o<e.length;o++){const a=qO[e[o]];if(a&&a(r,e))return}return t(r,...i)})},YO=ys({patchProp:VO},CO);let LS;function ZO(){return LS||(LS=sO(YO))}const QO=(...t)=>{const e=ZO().createApp(...t),{mount:n}=e;return e.mount=s=>{const r=eF(s);if(!r)return;const i=e._component;!It(i)&&!i.render&&!i.template&&(i.template=r.innerHTML),r.nodeType===1&&(r.textContent="");const o=n(r,!1,JO(r));return r instanceof Element&&(r.removeAttribute("v-cloak"),r.setAttribute("data-v-app","")),o},e};function JO(t){if(t instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&t instanceof MathMLElement)return"mathml"}function eF(t){return In(t)?document.querySelector(t):t}const oo=t=>({type:"button-click",detail:{action:t}}),Nn=(t,e)=>({type:"update-data",detail:{action:t,data:e}});function Pk(t,e){const n=ce("inputs"),s=ce(new Set(["inputs"]));_t(n,E=>{s.value.add(E)});const r=[{id:"contact",icon:"i-carbon-favorite",label:"Contact & Sponsor",component:"ContactPanel"},{id:"inputs",icon:"i-carbon-image-search",label:"Inputs",component:"InputsPanel"},{id:"crop",icon:"i-carbon-crop",label:"Crop",component:"CropPanel"},{id:"lut",icon:"i-carbon-color-palette",label:"LUT",component:"LUTPanel"},{id:"hsl",icon:"i-custom:hsl",label:"HSL",component:"HSLPanel"},{id:"exposure",icon:"i-carbon-sun",label:"Exposure",component:"ExposurePanel"},{id:"dehaze",icon:"i-carbon-fog",label:"Dehaze",component:"DehazePanel"},{id:"clarity",icon:"i-custom:clarity",label:"Clarity",component:"ClarityPanel"},{id:"luminance",icon:"i-carbon-contrast",label:"Luminance",component:"LuminancePanel"},{id:"tileablesettings",icon:"i-carbon-settings-adjust",label:"Settings",component:"SettingsPanel"},{id:"view",icon:"i-carbon-view",label:"View",component:"ViewPanel"},{id:"save",icon:"i-carbon-save",label:"Save",component:"SavePanel"}],i=ye(()=>t.originalImage?[{id:"max-resolution",label:"Max Res",value:t.maxResolution,min:512,max:4096,step:128,valuePosition:"after",showRuler:!1}]:[]),o=ye(()=>t.originalImage?[{id:"border-size",label:"Border (%)",value:t.borderSize,min:0,max:100,step:1,valuePosition:"after",showRuler:!1}]:[]),a=ye(()=>!t.originalImage||!t.lutEnabled?[]:[{id:"lut-intensity",label:"Intensity",value:t.lutIntensity,min:0,max:1,step:.01,valuePosition:"after",showRuler:!1}]),l=ye(()=>{const E=[];return t.originalImage&&E.push({id:"zoom-level",label:"Zoom",value:t.zoomLevel,min:.01,max:5,step:.01,valuePosition:"after",showRuler:!1}),t.processedImage&&E.push({id:"split-position",label:"Split Pos",value:t.splitPosition,min:0,max:1,step:.01,valuePosition:"after",showRuler:!1}),E}),u=E=>{e("controlEvent",Nn("image-upload",E))},c=()=>{e("controlEvent",oo("load-sample-image"))},h=E=>{e("controlEvent",Nn("max-resolution",E))},d=E=>{e("controlEvent",Nn("border-size",E))},f=()=>{e("controlEvent",oo("process-image"))},p=E=>{e("controlEvent",Nn("split-position",E))},g=()=>{e("controlEvent",oo("toggle-magnifier"))},m=E=>{e("controlEvent",Nn("zoom-level",E))};return{activeGroup:n,visitedGroups:s,groups:r,inputSliderItems:i,settingsSliderItems:o,lutSliderItems:a,viewSliderItems:l,handleImageUpload:u,loadSampleImage:c,updateMaxResolution:h,updateBorderSize:d,processImage:f,updateSplitPosition:p,toggleMagnifier:g,updateZoomLevel:m,handleSliderUpdate:({id:E,value:_})=>{switch(E){case"max-resolution":h(_);break;case"border-size":d(_);break;case"split-position":p(_);break;case"zoom-level":m(_);break;case"lut-intensity":e("controlEvent",Nn("lut-intensity",_));break}},resetZoom:()=>{e("controlEvent",oo("reset-zoom"))},openSamplingEditor:()=>{e("controlEvent",oo("open-sampling-editor"))},saveOriginal:()=>{e("controlEvent",oo("save-original"))},saveResult:()=>{e("controlEvent",oo("save-result"))},toggleLUT:()=>{e("controlEvent",oo("toggle-lut"))},handleLUTFileChange:E=>{e("controlEvent",Nn("lut-file-change",E))},clearLUT:()=>{e("controlEvent",oo("clear-lut"))},handleMaskUpdate:E=>{e("controlEvent",Nn("mask-update",E))},setImage:E=>{e("controlEvent",Nn("set-image",E))},handleControlEvent:E=>{e("controlEvent",E)}}}function Dk(t){return typeof t=="number"&&!isNaN(t)}const tF=t=>{const e=t.currentTarget;return e instanceof HTMLElement?e:null},nF=[/Android/i,/webOS/i,/iPhone/i,/iPad/i,/iPod/i,/BlackBerry/i,/IEMobile/i,/Opera Mini/i];function Qy(){const t=navigator.userAgent;return nF.some(e=>e.test(t))}function sF(){const t=Qy(),e="capture"in document.createElement("input");return t&&e}function Nk(t){const e=tF(t);if(!e)return;const n=e.scrollWidth-e.clientWidth,s=t.deltaY+t.deltaX,r=e.scrollLeft+s;if(r>0&&r<n){t.preventDefault(),e.scrollLeft=r;return}const i=s<0,o=r<=0&&!i,a=r>=n&&i;if(o){t.preventDefault(),e.scrollLeft=r;return}if(a){t.preventDefault(),e.scrollLeft=r;return}e.scrollLeft=r<=0?0:n}var kl=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function rF(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function iF(t){if(t.__esModule)return t;var e=t.default;if(typeof e=="function"){var n=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach(function(s){var r=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(n,s,r.get?r:{enumerable:!0,get:function(){return t[s]}})}),n}ce(!1);const oF={class:"flex flex-col gap-4"},Mk=We({__name:"ContactPanel",props:{isMobile:{type:Boolean}},setup(t){const e=t,n=ye(()=>e.isMobile?" rounded-2xl p-5 border border-white/5 flex flex-col gap-4":" rounded-2xl p-6 border border-white/5 flex flex-col gap-4"),s=ye(()=>e.isMobile?"text-gray-300 text-sm leading-relaxed":"text-gray-300 leading-relaxed"),r=ye(()=>e.isMobile?"glass-btn  flex-center gap-3 py-3 rounded-xl transition-all group min-w-0":"glass-btn flex-center gap-3 py-4 transition-all group min-w-0"),i=ye(()=>e.isMobile?"text-xl flex-shrink-0":"text-2xl flex-shrink-0"),o=ye(()=>e.isMobile?"text-sm font-medium truncate":"font-medium truncate");return(a,l)=>(F(),V("div",oF,[k("div",{class:Q(n.value)},[k("p",{class:Q(s.value)},"  ",2),k("a",{href:"https://unity-grenoble.github.io/website/demo/2020/10/16/demo-histogram-preserving-blend-make-tileable.html",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-blue-500/10 hover:bg-blue-500/20 border-blue-500/20 hover:border-blue-500/30 overflow-hidden"])},[k("div",{class:Q(["i-carbon-link text-blue-400 group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([[o.value,"text-blue-100"],"overflow-hidden text-ellipsis whitespace-nowrap"])},"",2)],2),k("p",{class:Q(s.value)},"  ",2),k("a",{href:"https://leolee9086.github.io/cc-panoviewer/",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-purple-500/10 hover:bg-purple-500/20 border-purple-500/20 hover:border-purple-500/30 overflow-hidden"])},[k("div",{class:Q(["i-carbon-view text-purple-400 group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([[o.value,"text-purple-100"],"overflow-hidden text-ellipsis whitespace-nowrap"])},"",2)],2),k("p",{class:Q(s.value)},"  ",2),k("a",{href:"https://afdian.com/a/leolee9086",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-orange-500/10 hover:bg-orange-500/20 border-orange-500/20 hover:border-orange-500/30 overflow-hidden"])},[k("div",{class:Q(["i-carbon-cafe text-orange-400 group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([[o.value,"text-orange-100"],"overflow-hidden text-ellipsis whitespace-nowrap"])},"",2)],2),k("p",{class:Q(s.value)},"  ",2),k("a",{href:"https://qm.qq.com/cgi-bin/qm/qr?k=1qXJ8mK8wK8mK8wK8mK8wK8",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-green-500/10 hover:bg-green-500/20 border-green-500/20 hover:border-green-500/30 overflow-hidden"])},[k("div",{class:Q(["i-carbon-chat text-green-400 group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([[o.value,"text-green-100"],"overflow-hidden text-ellipsis whitespace-nowrap"])},"QQ: 1017854502",2)],2),k("p",{class:Q(s.value)},"  ",2),k("a",{href:"https://b3log.org/siyuan/",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-indigo-500/10 hover:bg-indigo-500/20 border-indigo-500/20 hover:border-indigo-500/30 overflow-hidden"])},[k("div",{class:Q(["i-carbon-notebook text-indigo-400 group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([[o.value,"text-indigo-100"],"overflow-hidden text-ellipsis whitespace-nowrap"])},"",2)],2),k("p",{class:Q(s.value)},"  ",2),k("a",{href:"https://github.com/leolee9086/cc-panoviewer",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-gray-500/10 hover:bg-gray-500/20 border-gray-500/20 hover:border-gray-500/30 overflow-hidden"])},[k("div",{class:Q(["i-carbon-code text-gray-400 group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([[o.value,"text-gray-100"],"overflow-hidden text-ellipsis whitespace-nowrap"])},"GitHub",2)],2),k("a",{href:"https://www.zhihu.com/people/wen-zhi-dao-56",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-blue-600/10 hover:bg-blue-600/20 border-blue-600/20 hover:border-blue-600/30 overflow-hidden"])},[k("div",{class:Q(["i-carbon-logo-zhihu text-blue-500 group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([[o.value,"text-blue-200"],"overflow-hidden text-ellipsis whitespace-nowrap"])},"",2)],2),k("a",{href:"https://www.xiaohongshu.com/discovery/item/688064050000000017033b0f?source=webshare&xhsshare=pc_web&xsec_token=ABwffSm9tG8q7n3DsTW7VqWGAk6LToL0vxg5r6xQpncLw=&xsec_source=pc_share",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-red-500/10 hover:bg-red-500/20 border-red-500/20 hover:border-red-500/30 overflow-hidden"])},[k("div",{class:Q(["i-carbon-logo-xiaohongshu text-red-400 group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([[o.value,"text-red-100"],"overflow-hidden text-ellipsis whitespace-nowrap"])},"",2)],2),k("a",{href:"https://space.bilibili.com/71034467?spm_id_from=333.1007.0.0",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-pink-600/10 hover:bg-pink-600/20 border-pink-600/20 hover:border-pink-600/30 overflow-hidden"])},[k("div",{class:Q(["i-carbon-logo-bilibili text-pink-500 group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([[o.value,"text-pink-200"],"overflow-hidden text-ellipsis whitespace-nowrap"])},"B",2)],2),k("a",{href:"https://qm.qq.com/q/oq68sOKWQg",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-teal-500/10 hover:bg-teal-500/20 border-teal-500/20 hover:border-teal-500/30 overflow-hidden"])},[k("div",{class:Q(["i-carbon-group-chat text-teal-400 group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([[o.value,"text-teal-100"],"overflow-hidden text-ellipsis whitespace-nowrap"])},"",2)],2),l[0]||(l[0]=k("div",{class:"border-t border-white/10 my-4"},null,-1)),k("p",{class:Q(s.value)}," If you like this project, consider supporting its development. ",2),k("a",{href:"https://github.com/leolee9086/seamless-texture-generator",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-white/5 hover:bg-white/10 border-white/10 hover:border-white/20 overflow-hidden"])},[k("div",{class:Q(["i-carbon-logo-github text-white group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([o.value,"overflow-hidden text-ellipsis whitespace-nowrap"])},"GitHub Repository",2)],2),k("a",{href:"https://github.com/sponsors/leolee9086",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-pink-500/10 hover:bg-pink-500/20 border-pink-500/20 hover:border-pink-500/30 overflow-hidden"])},[k("div",{class:Q(["i-carbon-favorite text-pink-400 group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([[o.value,"text-pink-100"],"overflow-hidden text-ellipsis whitespace-nowrap"])},Le(t.isMobile?"Sponsor":`Sponsor on
                    GitHub`),3)],2),t.isMobile?Ue("",!0):(F(),V("a",{key:0,href:"mailto:leolee9086@example.com",target:"_blank",rel:"noopener noreferrer",class:Q([r.value,"bg-emerald-500/10 hover:bg-emerald-500/20 border-emerald-500/20 hover:border-emerald-500/30 overflow-hidden"])},[k("div",{class:Q(["i-carbon-email text-emerald-400 group-hover:scale-110 transition-transform",i.value])},null,2),k("span",{class:Q([[o.value,"text-emerald-100"],"overflow-hidden text-ellipsis whitespace-nowrap"])},"Contact via Email",2)],2))],2)]))}}),aF={class:"flex flex-col gap-3"},lF={class:"flex items-center justify-between"},uF={class:"text-xs font-medium text-white/60"},cF={class:"flex flex-col gap-3"},yo=We({__name:"CollapsiblePanel",props:{title:{},modelValue:{type:Boolean,default:!0}},emits:["update:modelValue"],setup(t,{emit:e}){const n=t,s=e,r=ce(n.modelValue),i=()=>{r.value=!r.value,s("update:modelValue",r.value)};return _t(()=>n.modelValue,o=>{r.value=o}),(o,a)=>(F(),V("div",aF,[k("div",lF,[k("span",uF,Le(t.title),1),k("button",{onClick:i,class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":r.value}])},null,2)])]),vt(k("div",cF,[AL(o.$slots,"default")],512),[[Gt,r.value]])]))}}),hF={class:"flex flex-col w-full gap-3"},dF=["onMouseenter","onMouseleave","aria-label","aria-disabled","aria-readonly","aria-valuemin","aria-valuemax","aria-valuenow","aria-valuetext"],fF=["innerHTML"],pF={key:2,class:"absolute inset-0 pointer-events-none"},mF={class:"bg-gray-900 text-white px-2 py-1 rounded shadow-lg text-sm whitespace-nowrap"},gF=["id","value","min","max","step","disabled","readonly","onInput","onChange","onKeydown","onMouseenter","onMouseleave"],xF=["id","onMousedown","onTouchstart","onKeydown","onMouseenter","onMouseleave","tabindex","aria-label","aria-disabled","aria-readonly","aria-valuemin","aria-valuemax","aria-valuenow","aria-valuetext"],St=We({__name:"Slider",props:{items:{type:Array,required:!0,default:()=>[]}},emits:["updateValue"],setup(t,{emit:e}){const n={toInteger(A,B){const L=Math.pow(10,B);return Math.round(A*L)},fromInteger(A,B){const L=Math.pow(10,B);return A/L},add(A,B,L){const U=this.toInteger(A,L),j=this.toInteger(B,L);return this.fromInteger(U+j,L)},subtract(A,B,L){const U=this.toInteger(A,L),j=this.toInteger(B,L);return this.fromInteger(U-j,L)},multiply(A,B,L){const U=this.toInteger(A,L),j=this.toInteger(B,L),Z=Math.pow(10,L);return U*j/(Z*Z)},divide(A,B,L){if(B===0)return 0;const U=this.toInteger(A,L),j=this.toInteger(B,L);return U/j},round(A,B){const L=this.toInteger(A,B);return this.fromInteger(L,B)},getPrecisionFromStep(A){if(A>=1)return 0;const B=A.toString();if(B.indexOf(".")!==-1){const L=B.split(".")[1];return L?L.length:0}if(B.indexOf("e-")!==-1){const L=B.split("e-")[1];return L?parseInt(L,10):0}return 0}},s=t,r=e,i=ce(new Map),o=ce(new Map),a=ce(new Set),l=ce(null),u=A=>{const B=A.value;let L=A.precision!==void 0?A.precision:0;L===0&&A.step&&A.step<1&&(L=n.getPrecisionFromStep(A.step));const U=n.round(B,L);return L>0?U.toFixed(L):U.toString()},c=(A,B)=>{if(B.step===void 0||B.step<=0)return A;const L=B.step,U=B.min;let j=B.precision!==void 0?B.precision:n.getPrecisionFromStep(L);const Z=n.subtract(A,U,j),J=n.round(n.divide(Z,L,j),0)*L,se=n.add(U,J,j);return Math.max(B.min,Math.min(B.max,se))},h=(A,B)=>{const L=B.target,U=s.items.find(j=>j.id===A);if(U){let j=Number(L.value);j=c(j,U),U.liveUpdate!==!1&&r("updateValue",{id:A,value:j})}},d=(A,B)=>{const L=B.target,U=s.items.find(j=>j.id===A);if(U&&U.liveUpdate===!1){let j=Number(L.value);j=c(j,U),r("updateValue",{id:A,value:j})}},f=(A,B)=>{const L=s.items.find(Z=>Z.id===A);if(!L||!L.keyboardSupport)return;let U=L.value;const j=L.step||1;switch(B.key){case"ArrowLeft":case"ArrowDown":U=Math.max(L.min,U-j);break;case"ArrowRight":case"ArrowUp":U=Math.min(L.max,U+j);break;case"Home":U=L.min;break;case"End":U=L.max;break;case"PageDown":U=Math.max(L.min,U-j*10);break;case"PageUp":U=Math.min(L.max,U+j*10);break;default:return}B.preventDefault(),U=c(U,L),r("updateValue",{id:A,value:U})},p=A=>{const B=A.min,L=A.max;let U=(A.value-B)/(L-B)*100;return A.reverse&&(U=100-U),U},g=A=>A.vertical?{backgroundImage:`
        repeating-linear-gradient(0deg, rgba(255, 255, 255, 0.5) 0, rgba(255, 255, 255, 0.5) 1px, transparent 1px, transparent 10%),
        repeating-linear-gradient(0deg, rgba(255, 255, 255, 0.3) 0, rgba(255, 255, 255, 0.3) 1px, transparent 1px, transparent 2%)
      `,backgroundSize:"8px 100%, 5px 100%",backgroundPosition:"top left, top left",backgroundRepeat:"no-repeat"}:{backgroundImage:`
      repeating-linear-gradient(90deg, rgba(255, 255, 255, 0.5) 0, rgba(255, 255, 255, 0.5) 1px, transparent 1px, transparent 10%),
      repeating-linear-gradient(90deg, rgba(255, 255, 255, 0.3) 0, rgba(255, 255, 255, 0.3) 1px, transparent 1px, transparent 2%)
    `,backgroundSize:"100% 8px, 100% 5px",backgroundPosition:"top left, top left",backgroundRepeat:"no-repeat"},m=(A,B)=>{let L=(B.value-A.min)/(A.max-A.min)*100;return A.reverse&&(L=100-L),A.vertical?{bottom:`${L}%`,left:"50%",...B.style}:{left:`${L}%`,top:"50%",...B.style}},x=A=>{const B=p(A);return A.vertical?{bottom:`${B}%`}:{left:`${B}%`}},b=A=>A.tooltipFormatter?A.tooltipFormatter(A.value,A.label):`${A.label}: ${A.value}`,v=A=>{const B=p(A),L=A.tooltipPosition||"top",U={},j=document.getElementById(A.id);if(j){const Z=j.getBoundingClientRect(),J=window.pageYOffset||document.documentElement.scrollTop,se=window.pageXOffset||document.documentElement.scrollLeft;L==="top"?(U.left=`${Z.left+se+Z.width*B/100}px`,U.top=`${Z.top+J-8}px`,U.transform="translateX(-50%) translateY(-100%)"):L==="bottom"?(U.left=`${Z.left+se+Z.width*B/100}px`,U.top=`${Z.top+J+Z.height+8}px`,U.transform="translateX(-50%)"):L==="left"?(U.left=`${Z.left+se+Z.width*B/100-8}px`,U.top=`${Z.top+J+Z.height/2}px`,U.transform="translateX(-100%) translateY(-50%)"):L==="right"&&(U.left=`${Z.left+se+Z.width*B/100+8}px`,U.top=`${Z.top+J+Z.height/2}px`,U.transform="translateY(-50%)")}return U},y=A=>{a.value.add(A)},C=A=>{a.value.delete(A)};_t(()=>s.items,A=>{A.forEach(B=>{const L=i.value.get(B.id);L&&L.value!==String(B.value)&&(L.value=String(B.value))})},{deep:!0});const I=(A,B)=>{B?i.value.set(A,B):i.value.delete(A)},$=(A,B)=>{B?o.value.set(A,B):o.value.delete(A)},T=(A,B)=>{const L=o.value.get(A.id);if(!L)return A.value;const U=L.getBoundingClientRect(),j=B-U.top,Z=Math.max(0,Math.min(1,1-j/U.height));let J=A.precision!==void 0?A.precision:0;J===0&&A.step&&A.step<1&&(J=n.getPrecisionFromStep(A.step));const se=n.subtract(A.max,A.min,J);let fe=n.add(A.min,n.multiply(Z,se,J),J);return fe=c(fe,A),Math.max(A.min,Math.min(A.max,fe))},S=(A,B)=>{const L=s.items.find(j=>j.id===A);if(!L||L.disabled||L.readonly)return;B.preventDefault(),l.value=A;const U=T(L,B.clientY);r("updateValue",{id:A,value:U}),document.addEventListener("mousemove",_),document.addEventListener("mouseup",P)},E=(A,B)=>{const L=s.items.find(j=>j.id===A);if(!L||L.disabled||L.readonly)return;B.preventDefault(),l.value=A;const U=B.touches[0];if(U){const j=T(L,U.clientY);r("updateValue",{id:A,value:j})}document.addEventListener("touchmove",N,{passive:!1}),document.addEventListener("touchend",M)},_=A=>{if(!l.value)return;const B=s.items.find(U=>U.id===l.value);if(!B)return;const L=T(B,A.clientY);r("updateValue",{id:l.value,value:L})},N=A=>{if(!l.value)return;A.preventDefault();const B=s.items.find(U=>U.id===l.value);if(!B)return;const L=A.touches[0];if(L){const U=T(B,L.clientY);r("updateValue",{id:l.value,value:U})}},P=()=>{l.value=null,document.removeEventListener("mousemove",_),document.removeEventListener("mouseup",P)},M=()=>{l.value=null,document.removeEventListener("touchmove",N),document.removeEventListener("touchend",M)},z=(A,B)=>{const L=s.items.find(Z=>Z.id===A);if(!L||!L.keyboardSupport||L.disabled||L.readonly)return;let U=L.value;const j=L.step||1;switch(B.key){case"ArrowUp":U=Math.min(L.max,U+j);break;case"ArrowDown":U=Math.max(L.min,U-j);break;case"Home":U=L.max;break;case"End":U=L.min;break;case"PageUp":U=Math.min(L.max,U+j*10);break;case"PageDown":U=Math.max(L.min,U-j*10);break;default:return}B.preventDefault(),U=c(U,L),r("updateValue",{id:A,value:U})};return fa(()=>{document.removeEventListener("mousemove",_),document.removeEventListener("mouseup",P),document.removeEventListener("touchmove",N),document.removeEventListener("touchend",M)}),(A,B)=>(F(),V("div",hF,[(F(!0),V(Xe,null,rt(t.items,L=>(F(),V("div",{key:L.id,class:"w-full"},[k("div",{class:Q(["relative rounded-lg overflow-hidden bg-[#333] group",{"w-full h-9":!L.vertical,"h-48 w-9":L.vertical,"opacity-50 cursor-not-allowed":L.disabled,"cursor-ew-resize":!L.disabled&&!L.vertical,"cursor-ns-resize":!L.disabled&&L.vertical}]),onMouseenter:()=>y(L.id),onMouseleave:()=>C(L.id),"aria-label":L.ariaLabel||L.label,"aria-disabled":L.disabled,"aria-readonly":L.readonly,"aria-valuemin":L.min,"aria-valuemax":L.max,"aria-valuenow":L.value,"aria-valuetext":`${L.label}: ${u(L)}`},[k("div",{class:Q(["absolute inset-0 z-10",{"w-full h-full":!L.vertical,"h-full w-full":L.vertical}]),style:bn({background:L.gradient})},[L.backgroundSvg?(F(),V("div",{key:0,class:"absolute inset-0 opacity-50 pointer-events-none",innerHTML:L.backgroundSvg},null,8,fF)):Ue("",!0),L.showRuler?(F(),V("div",{key:1,class:Q(["absolute inset-0 pointer-events-none opacity-0 transition-opacity duration-200 ease-in-out",{"opacity-100":L.showRuler&&L.rulerMode==="always","group-hover:opacity-100":L.showRuler&&L.rulerMode==="hover"}]),style:bn(g(L))},null,6)):Ue("",!0),L.marks&&L.marks.length>0?(F(),V("div",pF,[(F(!0),V(Xe,null,rt(L.marks,U=>(F(),V("div",{key:U.value,class:Q(["absolute w-2 h-2 bg-white rounded-full transform -translate-x-1/2 -translate-y-1/2",{"w-1 h-1":L.size==="small","w-3 h-3":L.size==="large"}]),style:bn(m(L,U))},[U.label?(F(),V("span",{key:0,class:Q(["absolute text-xs text-white whitespace-nowrap",{"top-4 left-1/2 transform -translate-x-1/2":!L.vertical,"left-4 top-1/2 transform -translate-y-1/2":L.vertical}]),style:bn(U.style)},Le(U.label),7)):Ue("",!0)],6))),128))])):Ue("",!0),k("div",{class:Q(["absolute bg-white/90 pointer-events-none z-20",{"top-0 bottom-0 w-0.5 -translate-x-1/2":!L.vertical,"left-0 right-0 h-0.5 -translate-y-1/2":L.vertical}]),style:bn(x(L))},null,6)],6),k("div",{class:Q(["absolute inset-0 flex justify-between items-center px-3 z-30 pointer-events-none box-border",{"w-full h-full flex-row":!L.vertical,"h-full w-full flex-col":L.vertical}])},[k("span",{class:Q(["text-sm font-medium text-white/90",{"text-xs":L.size==="small","text-base":L.size==="large"}]),style:{"text-shadow":"0 1px 2px rgba(0,0,0,0.6)"}},Le(L.label),3),k("span",{class:Q(["font-semibold font-mono text-white/90",{"text-sm":L.size==="small","text-lg":L.size==="large","text-base":!L.size||L.size==="medium"}]),style:{"text-shadow":"0 1px 2px rgba(0,0,0,0.6)"}},Le(u(L)),3)],2),(F(),st(Fg,{to:"body"},[L.showTooltip?(F(),V("div",{key:0,class:Q(["absolute z-[200] pointer-events-none transition-opacity duration-200 ease-in-out opacity-0",{"opacity-100":L.tooltipMode==="always"||a.value.has(L.id)}]),style:bn(v(L))},[k("div",mF,Le(b(L)),1)],6)):Ue("",!0)])),L.vertical?(F(),V("div",{key:1,id:L.id,class:Q(["absolute inset-0 opacity-0 z-[100] m-0 p-0",{"h-full w-full":L.vertical,"cursor-not-allowed":L.disabled,"cursor-ns-resize":!L.disabled&&L.vertical}]),ref_for:!0,ref:U=>$(L.id,U),onMousedown:U=>S(L.id,U),onTouchstart:U=>E(L.id,U),onKeydown:U=>z(L.id,U),onMouseenter:()=>y(L.id),onMouseleave:()=>C(L.id),tabindex:L.disabled||L.readonly?-1:0,"aria-label":L.ariaLabel||L.label,"aria-disabled":L.disabled,"aria-readonly":L.readonly,"aria-valuemin":L.min,"aria-valuemax":L.max,"aria-valuenow":L.value,"aria-valuetext":`${L.label}: ${u(L)}`},null,42,xF)):(F(),V("input",{key:0,id:L.id,value:L.value,type:"range",class:Q(["absolute inset-0 opacity-0 z-[100] m-0 p-0",{"w-full h-full":!L.vertical,"cursor-not-allowed":L.disabled,"cursor-ew-resize":!L.disabled&&!L.vertical}]),min:L.min,max:L.max,step:L.step||1,disabled:L.disabled,readonly:L.readonly,ref_for:!0,ref:U=>I(L.id,U),onInput:U=>h(L.id,U),onChange:U=>d(L.id,U),onKeydown:U=>f(L.id,U),onMouseenter:()=>y(L.id),onMouseleave:()=>C(L.id)},null,42,gF))],42,dF)]))),128))]))}}),Lk=We({__name:"SliderParameterGroup",props:{sliderItems:{}},emits:["update-value"],setup(t,{emit:e}){const n=e,s=r=>{n("update-value",r)};return(r,i)=>(F(!0),V(Xe,null,rt(t.sliderItems,o=>(F(),st(D(St),{key:o.id,items:[o],onUpdateValue:s},null,8,["items"]))),128))}}),bF={class:"grid grid-cols-2 gap-2"},yF=["onClick"],Ok=We({__name:"PresetSelector",props:{presets:{}},emits:["apply-preset"],setup(t,{emit:e}){const n=e,s=r=>{n("apply-preset",r)};return(r,i)=>(F(),V("div",bF,[(F(!0),V(Xe,null,rt(t.presets,(o,a)=>(F(),V("button",{key:a,onClick:l=>s(o),class:"glass-btn text-xs py-2 px-2 rounded bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 transition-colors"},Le(a),9,yF))),128))]))}}),vF=["disabled"],wF={key:0,class:"i-carbon-circle-dash animate-spin text-lg"},SF={key:1,class:"i-carbon-magic-wand text-lg"},Fk=We({__name:"GenerateButton",props:{isGenerating:{type:Boolean},disabled:{type:Boolean},buttonText:{default:"Generate"},generatingText:{default:"Generating..."}},emits:["click"],setup(t,{emit:e}){const n=e,s=()=>{n("click")};return(r,i)=>(F(),V("button",{onClick:s,disabled:t.disabled||t.isGenerating,class:"glass-btn w-full py-2.5 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 text-white/60 hover:text-white/90 text-sm font-medium transition-all flex items-center justify-center gap-2 disabled:opacity-50"},[t.isGenerating?(F(),V("div",wF)):(F(),V("div",SF)),Tn(" "+Le(t.isGenerating?t.generatingText:t.buttonText),1)],8,vF))}}),CF={class:"gradient-editor select-none"},TF=["onMousedown","onContextmenu"],IF={class:"absolute top-full mt-1 left-1/2 -translate-x-1/2 flex flex-col items-center"},kF={class:"relative mt-0.5"},EF=["value","onInput"],_F=We({__name:"GradientEditor",props:{modelValue:{}},emits:["update:modelValue"],setup(t,{emit:e}){const n=t,s=e,r=ce(null),i=ce(null),o=ye(()=>[...n.modelValue].sort((p,g)=>p.offset-g.offset)),a=ye(()=>`linear-gradient(to right, ${o.value.map(g=>`${g.color} ${g.offset*100}%`).join(", ")})`),l=p=>{if(!r.value)return;const g=r.value.getBoundingClientRect(),m=Math.max(0,Math.min(1,(p.clientX-g.left)/g.width)),x=[...n.modelValue,{offset:m,color:"#ffffff"}];s("update:modelValue",x)},u=p=>{if(n.modelValue.length<=2)return;const g=[...n.modelValue],m=o.value[p],x=n.modelValue.indexOf(m);x!==-1&&(g.splice(x,1),s("update:modelValue",g))},c=(p,g)=>{const m=o.value[p],x=n.modelValue.indexOf(m);if(x!==-1){const b=[...n.modelValue];b[x]={...b[x],color:g},s("update:modelValue",b)}},h=(p,g)=>{const m=o.value[g],x=n.modelValue.indexOf(m);i.value=x,window.addEventListener("mousemove",d),window.addEventListener("mouseup",f)},d=p=>{if(i.value===null||!r.value)return;const g=r.value.getBoundingClientRect();let m=(p.clientX-g.left)/g.width;m=Math.max(0,Math.min(1,m));const x=[...n.modelValue];x[i.value]={...x[i.value],offset:m},s("update:modelValue",x)},f=()=>{i.value=null,window.removeEventListener("mousemove",d),window.removeEventListener("mouseup",f)};return(p,g)=>(F(),V("div",CF,[k("div",{class:"relative h-8 rounded-lg cursor-crosshair border border-white/10 mb-6",style:bn({background:a.value}),onClick:gs(l,["self"]),ref_key:"barRef",ref:r},[(F(!0),V(Xe,null,rt(o.value,(m,x)=>(F(),V("div",{key:x,class:"absolute top-0 h-full w-1 cursor-ew-resize group",style:bn({left:`${m.offset*100}%`,transform:"translateX(-50%)"}),onMousedown:gs(b=>h(b,x),["stop"]),onContextmenu:gs(b=>u(x),["prevent","stop"])},[g[1]||(g[1]=k("div",{class:"absolute -top-1.5 left-1/2 -translate-x-1/2 w-3 h-3 bg-white border-2 border-gray-800 rounded-full shadow-sm group-hover:scale-125 transition-transform z-10"},null,-1)),k("div",IF,[g[0]||(g[0]=k("div",{class:"w-0 h-0 border-l-[6px] border-l-transparent border-r-[6px] border-r-transparent border-b-[6px] border-b-white/20"},null,-1)),k("div",kF,[k("input",{type:"color",value:m.color,onInput:b=>c(x,b.target.value),class:"w-6 h-6 rounded overflow-hidden cursor-pointer border-0 p-0 bg-transparent"},null,40,EF)])])],44,TF))),128))],4),g[2]||(g[2]=k("div",{class:"text-xs text-white/40 flex justify-between px-1"},[k("span",null,"Click bar to add stop"),k("span",null,"Right-click handle to remove")],-1))]))}}),Zi=(t,e)=>{const n=t.__vccOpts||t;for(const[s,r]of e)n[s]=r;return n},jd=Zi(_F,[["__scopeId","data-v-5fc90951"]]),$F="webgpu_cache",RF=(t,e)=>{const n=t;return n[e]||(n[e]={:null,:null}),n[e]},AF=Symbol.for($F),PF=async()=>{const t=RF(window,AF);if(t.)return t.;if(!navigator.gpu)throw new Error("WebGPU ");if(t.=await navigator.gpu.requestAdapter(),!t.)throw new Error(" WebGPU ");const e=t..limits,n=Math.min(e.maxStorageBufferBindingSize||134217728,2147483644);if(t.=await t..requestDevice({requiredLimits:{maxStorageBufferBindingSize:n}}),!t.)throw new Error(" WebGPU ");return t.},Ts=PF,Uk=`
// 
fn hash3_periodic(p: vec3<f32>, period: vec3<f32>) -> vec3<f32> {
    let wrappedP = p % period;
    var q = vec3<f32>(dot(wrappedP, vec3<f32>(127.1, 311.7, 74.7)),
                      dot(wrappedP, vec3<f32>(269.5, 183.3, 246.1)),
                      dot(wrappedP, vec3<f32>(113.5, 271.9, 124.6)));
    return -1.0 + 2.0 * fract(sin(q) * 43758.5453123);
}

fn hash2_periodic(p: vec2<f32>, period: vec2<f32>) -> vec2<f32> {
    let wrappedP = p % period;
    var q = vec2<f32>(dot(wrappedP, vec2<f32>(127.1, 311.7)),
                      dot(wrappedP, vec2<f32>(269.5, 183.3)));
    return -1.0 + 2.0 * fract(sin(q) * 43758.5453123);
}

//  Gradient Noise
fn periodicNoise(p: vec3<f32>, period: f32) -> f32 {
    let p_vec = vec3<f32>(period);
    let i = floor(p);
    let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f); // Hermite 

    return mix(mix(mix(dot(hash3_periodic(i + vec3<f32>(0.0,0.0,0.0), p_vec), f - vec3<f32>(0.0,0.0,0.0)),
                       dot(hash3_periodic(i + vec3<f32>(1.0,0.0,0.0), p_vec), f - vec3<f32>(1.0,0.0,0.0)), u.x),
                   mix(dot(hash3_periodic(i + vec3<f32>(0.0,1.0,0.0), p_vec), f - vec3<f32>(0.0,1.0,0.0)),
                       dot(hash3_periodic(i + vec3<f32>(1.0,1.0,0.0), p_vec), f - vec3<f32>(1.0,1.0,0.0)), u.x), u.y),
               mix(mix(dot(hash3_periodic(i + vec3<f32>(0.0,0.0,1.0), p_vec), f - vec3<f32>(0.0,0.0,1.0)),
                       dot(hash3_periodic(i + vec3<f32>(1.0,0.0,1.0), p_vec), f - vec3<f32>(1.0,0.0,1.0)), u.x),
                   mix(dot(hash3_periodic(i + vec3<f32>(0.0,1.0,1.0), p_vec), f - vec3<f32>(0.0,1.0,1.0)),
                       dot(hash3_periodic(i + vec3<f32>(1.0,1.0,1.0), p_vec), f - vec3<f32>(1.0,1.0,1.0)), u.x), u.y), u.z);
}

fn periodicNoise2D(p: vec2<f32>, period: f32) -> f32 {
    let p_vec = vec2<f32>(period);
    let i = floor(p);
    let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f);

    return mix(mix(dot(hash2_periodic(i + vec2<f32>(0.0,0.0), p_vec), f - vec2<f32>(0.0,0.0)),
                   dot(hash2_periodic(i + vec2<f32>(1.0,0.0), p_vec), f - vec2<f32>(1.0,0.0)), u.x),
               mix(dot(hash2_periodic(i + vec2<f32>(0.0,1.0), p_vec), f - vec2<f32>(0.0,1.0)),
                   dot(hash2_periodic(i + vec2<f32>(1.0,1.0), p_vec), f - vec2<f32>(1.0,1.0)), u.x), u.y);
}

//  FBM
fn periodicFbm(p: vec3<f32>, octaves: i32, period: f32, initialAmplitude: f32) -> f32 {
    var value = 0.0;
    var amplitude = initialAmplitude;
    var currentPeriod = period;
    var pos = p;
    
    for (var i = 0; i < 5; i++) {
        if (i >= octaves) { break; }
        value = value + periodicNoise(pos, currentPeriod) * amplitude;
        pos = pos * 2.0;
        currentPeriod = currentPeriod * 2.0;
        amplitude = amplitude * 0.5;
    }
    return value;
}

fn periodicFbm2D(p: vec2<f32>, octaves: i32, period: f32, initialAmplitude: f32) -> f32 {
    var value = 0.0;
    var amplitude = initialAmplitude;
    var currentPeriod = period;
    var pos = p;
    
    for (var i = 0; i < 5; i++) {
        if (i >= octaves) { break; }
        value = value + periodicNoise2D(pos, currentPeriod) * amplitude;
        pos = pos * 2.0;
        currentPeriod = currentPeriod * 2.0;
        amplitude = amplitude * 0.5;
    }
    return value;
}
`,DF=`
struct Uniforms {
    viewMatrix : mat4x4<f32>,
    tileSize : f32,
    threadDensity : f32,
    threadThickness : f32,
    warpWeftRatio : f32,
    threadTwist : f32,
    fiberDetail : f32,
    fuzziness : f32,
    weaveTightness : f32,
    threadUnevenness : f32,
    weaveImperfection : f32,
    padding1 : f32,
    fbmOctaves : f32,
    fbmAmplitude : f32,
    noiseFrequency : f32,
    colorVariation : f32,
    warpSheen : f32,
    weftSheen : f32,
    roughnessMin : f32,
    roughnessMax : f32,
    normalStrength : f32,
    threadHeightScale : f32,
    threadShadowStrength : f32,
    padding2 : f32,
};

@group(0) @binding(0) var<uniform> u : Uniforms;
@group(0) @binding(1) var gradientTexture : texture_2d<f32>;
@group(0) @binding(2) var gradientSampler : sampler;

struct VertexOutput {
    @builtin(position) Position : vec4<f32>,
    @location(0) uv : vec2<f32>,
};

${Uk}

// -----------------------------------------------------------
//  (Revised)
// -----------------------------------------------------------

fn threadProfile(t: f32, thickness: f32, tightness: f32) -> f32 {
    let centered = (t - 0.5) * 2.0 / thickness;
    if (abs(centered) > 1.0) { return 0.0; }
    // Super-ellipse like shape for flatter or rounder threads
    // tightness 0 -> round, 1 -> flat boxy?
    // Let's stick to cosine for smoothness but power it
    let base = cos(centered * 1.5707963);
    return pow(base, 0.5 + tightness); 
}

fn threadTwistPattern(pos: vec2<f32>, direction: vec2<f32>, twist: f32, scale: f32) -> f32 {
    let alongThread = dot(pos, direction);
    let twistPhase = sin(alongThread * scale * 2.0 + twist * 20.0); // Increased frequency
    return twistPhase * 0.5 + 0.5;
}

fn fiberDetail(pos: vec2<f32>, direction: vec2<f32>, detail: f32, scale: f32, period: f32) -> f32 {
    let perpDir = vec2<f32>(-direction.y, direction.x);
    // Stretch noise along thread direction
    let fiberPos = vec2<f32>(dot(pos, direction), dot(pos, perpDir) * 10.0); 
    let noise1 = periodicNoise2D(fiberPos * 10.0 * scale, period * 10.0 * scale);
    return noise1 * detail;
}

fn fuzzEffect(pos: vec2<f32>, fuzz: f32, scale: f32, period: f32) -> f32 {
    if (fuzz < 0.01) { return 0.0; }
    let fuzzNoise = periodicNoise2D(pos * 80.0 * scale, period * 80.0 * scale);
    return smoothstep(0.6, 1.0, fuzzNoise) * fuzz;
}

fn getPlainWeaveDetail(uv: vec2<f32>) -> vec4<f32> {
    let scale = u.tileSize;
    let pos = uv * scale;
    
    let warpDensity = u.threadDensity;
    let weftDensity = u.threadDensity * u.warpWeftRatio;
    
    let u_coord = pos.x * warpDensity;
    let v_coord = pos.y * weftDensity;
    
    let i = floor(u_coord);
    let j = floor(v_coord);
    
    let u_local = fract(u_coord);
    let v_local = fract(v_coord);
    
    // Imperfections
    let imperfection = periodicNoise2D(vec2<f32>(i, j), scale * warpDensity) * u.weaveImperfection * 0.2;
    
    // Thread centers
    let warpCenter = 0.5 + imperfection;
    let weftCenter = 0.5 + imperfection; // Simplified, could be separate
    
    let dist_warp = abs(u_local - warpCenter);
    let dist_weft = abs(v_local - weftCenter);
    
    // Unevenness
    let warpThickVar = 1.0 + periodicNoise2D(vec2<f32>(i * 0.5, 0.0), scale * warpDensity * 0.5) * u.threadUnevenness * 0.3;
    let weftThickVar = 1.0 + periodicNoise2D(vec2<f32>(0.0, j * 0.5), scale * weftDensity * 0.5) * u.threadUnevenness * 0.3;
    
    let warpThick = u.threadThickness * warpThickVar;
    let weftThick = u.threadThickness * weftThickVar;
    
    // Profiles
    let warpP = threadProfile(u_local - imperfection, warpThick, u.weaveTightness);
    let weftP = threadProfile(v_local - imperfection, weftThick, u.weaveTightness);
    
    // Undulation (The Weave)
    // Warp goes over if (i+j) is even
    let isWarpOver = ((i + j) % 2.0) < 0.5; // Check parity
    
    // Sinusoidal paths
    // Warp Z varies along V
    // If warp is over at j, it should be high.
    // sin(v * PI) peaks at 0.5. 
    // If i+j even -> Warp High -> sin(v_local * PI)
    // If i+j odd -> Warp Low -> -sin(v_local * PI)
    // Wait, if it's low, it goes UNDER the weft.
    // The path should be continuous.
    // Let's use the global coordinate for phase?
    // Warp Path: sin(v_coord * PI) ?
    // At v=0.5 (j=0), sin(0.5PI) = 1.
    // At v=1.5 (j=1), sin(1.5PI) = -1.
    // So if i is even:
    //   j=0 -> Warp High (1). Correct (0+0 even).
    //   j=1 -> Warp Low (-1). Correct (0+1 odd).
    // So for even i, sin(v_coord * PI) works.
    // If i is odd:
    //   j=0 -> Warp Low (-1). (1+0 odd).
    //   j=1 -> Warp High (1). (1+1 even).
    //   sin(v_coord * PI) gives 1 at j=0. We need -1.
    //   So -sin(v_coord * PI) or sin(v_coord * PI + PI).
    
    let warpSign = select(-1.0, 1.0, (i % 2.0) < 0.5);
    let warpPath = sin(v_coord * 3.14159265) * warpSign;
    
    // Weft Path
    // Weft Z varies along U.
    // If i+j even -> Weft Low (under Warp).
    // If i+j odd -> Weft High (over Warp).
    // At u=0.5 (i=0):
    //   j=0 -> Weft Low (-1). (0+0 even).
    //   j=1 -> Weft High (1). (0+1 odd).
    //   We need -1 at j=0? No, we need -1 at i=0, j=0.
    //   Weft depends on u.
    //   At i=0 (u=0.5), we need Low (-1) if j is even?
    //   Wait, "Weft Low if i+j even".
    //   If j is even: i=0 -> Low (-1). i=1 -> High (1).
    //   sin(u_coord * PI) at u=0.5 is 1.
    //   So we need -sin(u_coord * PI) if j is even.
    //   If j is odd: i=0 -> High (1). i=1 -> Low (-1).
    //   We need sin(u_coord * PI) if j is odd.
    
    let weftSign = select(1.0, -1.0, (j % 2.0) < 0.5);
    let weftPath = sin(u_coord * 3.14159265) * weftSign;
    
    // Combine Path and Profile
    // The thread is a tube following the path.
    // Height = Path * Amplitude + Profile * Thickness/2
    
    let amp = u.threadHeightScale * 0.5;
    let warpH = warpPath * amp + warpP * u.threadHeightScale;
    let weftH = weftPath * amp + weftP * u.threadHeightScale;
    
    // Determine which is on top
    var h = 0.0;
    var isWarp = true;
    
    // Gap handling
    let noWarp = warpP < 0.01;
    let noWeft = weftP < 0.01;
    
    if (noWarp && noWeft) {
        h = 0.0; // Base level
    } else if (noWarp) {
        h = weftH;
        isWarp = false;
    } else if (noWeft) {
        h = warpH;
        isWarp = true;
    } else {
        // Soft blend or hard max? Hard max is more physically correct for opaque threads.
        if (warpH > weftH) {
            h = warpH;
            isWarp = true;
        } else {
            h = weftH;
            isWarp = false;
        }
    }
    
    // Shading & Details
    var density = h;
    
    // Twist
    var twistVal = 0.0;
    if (isWarp) {
        twistVal = threadTwistPattern(pos, vec2<f32>(0.0, 1.0), u.threadTwist, warpDensity);
    } else {
        twistVal = threadTwistPattern(pos, vec2<f32>(1.0, 0.0), u.threadTwist, weftDensity);
    }
    
    // Fiber
    var fiberVal = 0.0;
    if (isWarp) {
        fiberVal = fiberDetail(pos, vec2<f32>(0.0, 1.0), u.fiberDetail, warpDensity, scale * warpDensity);
    } else {
        fiberVal = fiberDetail(pos, vec2<f32>(1.0, 0.0), u.fiberDetail, weftDensity, scale * weftDensity);
    }
    
    // Fuzz
    let fuzzVal = fuzzEffect(pos, u.fuzziness, max(warpDensity, weftDensity), scale * max(warpDensity, weftDensity));
    
    // AO / Shadow at crossings
    // If the difference between warp and weft height is small, we are at a crossing/contact point.
    // Or simply, if we are deep (low h), it's darker.
    // Also, emphasize the edges where one thread goes under another.
    let depth = 1.0 - h;
    let shadow = depth * u.threadShadowStrength * 0.5;
    
    density = density * (0.9 + twistVal * 0.2);
    density = density + fiberVal * 0.1;
    density = density + fuzzVal * 0.1;
    density = density - shadow;
    
    // Color variation
    let colorNoise = periodicFbm(vec3<f32>(pos * u.noiseFrequency, 0.0), i32(u.fbmOctaves), scale * u.noiseFrequency, u.fbmAmplitude);
    density = density + colorNoise * u.colorVariation;
    
    density = clamp(density, 0.0, 1.0);
    
    // Sheen
    let sheen = select(u.weftSheen, u.warpSheen, isWarp);
    
    return vec4<f32>(density, h, sheen, twistVal);
}

@vertex
fn vs_main(@location(0) position : vec3<f32>, @location(1) uv : vec2<f32>) -> VertexOutput {
    var output : VertexOutput;
    output.Position = vec4<f32>(position, 1.0);
    output.uv = uv;
    return output;
}

@fragment
fn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {
    let data = getPlainWeaveDetail(in.uv);
    let density = data.x;
    let height = data.y;
    let sheen = data.z;
    
    let albedo = textureSample(gradientTexture, gradientSampler, vec2<f32>(density, 0.5)).rgb;
    
    let roughness = mix(u.roughnessMin, u.roughnessMax, 1.0 - sheen * 0.8); // Adjusted
    
    let dHdUV = vec2<f32>(dpdx(height), dpdy(height));
    let normal = normalize(vec3<f32>(-dHdUV.x * u.normalStrength, -dHdUV.y * u.normalStrength, 1.0));
    
    let lightDir = normalize(vec3<f32>(0.5, 0.5, 1.0));
    let diff = max(dot(normal, lightDir), 0.0);
    
    let viewDir = vec3<f32>(0.0, 0.0, 1.0);
    let halfDir = normalize(lightDir + viewDir);
    let spec = pow(max(dot(normal, halfDir), 0.0), 32.0 * (1.0 - roughness)) * sheen;
    
    let finalColor = albedo * (0.3 + 0.7 * diff) + vec3<f32>(spec * 0.6);
    
    return vec4<f32>(finalColor, 1.0);
}
`;function NF(t,e){const r=document.createElement("canvas");r.width=256,r.height=1;const i=r.getContext("2d");if(!i)throw new Error("Could not get 2d context");const o=i.createLinearGradient(0,0,256,0),a=[...e].sort((c,h)=>c.offset-h.offset);for(const c of a)o.addColorStop(c.offset,c.color);i.fillStyle=o,i.fillRect(0,0,256,1);const l=i.getImageData(0,0,256,1),u=t.createTexture({size:[256,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});return t.queue.writeTexture({texture:u},l.data,{bytesPerRow:256*4},[256,1]),u}function MF(t,e){const n=new Float32Array(44);n[0]=1,n[5]=1,n[10]=1,n[15]=1,n[16]=e.tileSize,n[17]=e.threadDensity,n[18]=e.threadThickness,n[19]=e.warpWeftRatio,n[20]=e.threadTwist,n[21]=e.fiberDetail,n[22]=e.fuzziness,n[23]=e.weaveTightness,n[24]=e.threadUnevenness,n[25]=e.weaveImperfection,n[26]=0,n[27]=e.fbmOctaves,n[28]=e.fbmAmplitude,n[29]=e.noiseFrequency,n[30]=e.colorVariation,n[31]=e.warpSheen,n[32]=e.weftSheen,n[33]=e.roughnessMin,n[34]=e.roughnessMax,n[35]=e.normalStrength,n[36]=e.threadHeightScale,n[37]=e.threadShadowStrength;const s=t.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return t.queue.writeBuffer(s,0,n),s}function LF(t){const e=t.createShaderModule({code:DF});return t.createRenderPipeline({layout:"auto",vertex:{module:e,entryPoint:"vs_main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}]}]},fragment:{module:e,entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}})}function OF(t,e){const n=MF(t,e),s=NF(t,e.gradientStops),r=t.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),i=LF(t),o=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n}},{binding:1,resource:s.createView()},{binding:2,resource:r}]});return{pipeline:i,bindGroup:o}}function Bk(t){const e=new Float32Array([-1,-1,0,0,1,1,-1,0,1,1,-1,1,0,0,0,-1,1,0,0,0,1,-1,0,1,1,1,1,0,1,0]),n=t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});return t.queue.writeBuffer(n,0,e),n}function zk(t,e){const{texture:n,pipeline:s,bindGroup:r,vertexBuffer:i}=e,o=t.createCommandEncoder(),a=o.beginRenderPass({colorAttachments:[{view:n.createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]});a.setPipeline(s),a.setBindGroup(0,r),a.setVertexBuffer(0,i),a.draw(6,1,0,0),a.end(),t.queue.submit([o.finish()])}async function Gk(t){const{device:e,texture:n,width:s,height:r}=t,o=s*4,a=256,l=Math.ceil(o/a)*a,u=e.createBuffer({size:l*r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),c=e.createCommandEncoder();c.copyTextureToBuffer({texture:n},{buffer:u,bytesPerRow:l},[s,r]),e.queue.submit([c.finish()]),await u.mapAsync(GPUMapMode.READ);const h=u.getMappedRange(),d=document.createElement("canvas");d.width=s,d.height=r;const f=d.getContext("2d");if(!f)throw new Error("Could not get 2d context");const p=new Uint8Array(h),g=f.createImageData(s,r);for(let m=0;m<r;m++){const x=m*l,b=m*s*4;for(let v=0;v<s;v++){const y=x+v*4,C=b+v*4;g.data[C]=p[y+2],g.data[C+1]=p[y+1],g.data[C+2]=p[y],g.data[C+3]=p[y+3]}}return f.putImageData(g,0,0),u.unmap(),d.toDataURL("image/png")}async function FF(t,e,n){const s=await Ts();if(!s)throw new Error("WebGPU not supported");const r=s.createTexture({size:[e,n],format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),{pipeline:i,bindGroup:o}=OF(s,t),a=Bk(s);return zk(s,{texture:r,pipeline:i,bindGroup:o,vertexBuffer:a}),await Gk({device:s,texture:r,width:e,height:n})}const UF=`

struct Uniforms {
    viewMatrix : mat4x4<f32>,
    tileSize : f32,
    threadDensity : f32,
    threadThickness : f32,
    warpWeftRatio : f32,
    threadTwist : f32,
    fiberDetail : f32,
    fuzziness : f32,
    
    // Twill Specific
    twillRepeat : f32,
    herringboneScale : f32,
    waleDepth : f32,
    padding1 : f32,

    weaveTightness : f32,
    threadUnevenness : f32,
    weaveImperfection : f32,
    
    // Advanced
    fbmOctaves : f32,
    fbmAmplitude : f32,
    noiseFrequency : f32,
    colorVariation : f32,
    
    // Material
    warpSheen : f32,
    weftSheen : f32,
    roughnessMin : f32,
    roughnessMax : f32,
    normalStrength : f32,
    threadHeightScale : f32,
    threadShadowStrength : f32,
    padding2 : f32,
};

@group(0) @binding(0) var<uniform> u : Uniforms;
@group(0) @binding(1) var gradientTexture : texture_2d<f32>;
@group(0) @binding(2) var gradientSampler : sampler;

struct VertexOutput {
    @builtin(position) Position : vec4<f32>,
    @location(0) uv : vec2<f32>,
};

// --- Noise Functions (Keep generic noise functions from previous implementation) ---
// 
fn hash3_periodic(p: vec3<f32>, period: vec3<f32>) -> vec3<f32> {
    let wrappedP = p % period;
    var q = vec3<f32>(dot(wrappedP, vec3<f32>(127.1, 311.7, 74.7)),
                      dot(wrappedP, vec3<f32>(269.5, 183.3, 246.1)),
                      dot(wrappedP, vec3<f32>(113.5, 271.9, 124.6)));
    return -1.0 + 2.0 * fract(sin(q) * 43758.5453123);
}

fn hash2_periodic(p: vec2<f32>, period: vec2<f32>) -> vec2<f32> {
    let wrappedP = p % period;
    var q = vec2<f32>(dot(wrappedP, vec2<f32>(127.1, 311.7)),
                      dot(wrappedP, vec2<f32>(269.5, 183.3)));
    return -1.0 + 2.0 * fract(sin(q) * 43758.5453123);
}

//  Gradient Noise
fn periodicNoise(p: vec3<f32>, period: f32) -> f32 {
    let p_vec = vec3<f32>(period);
    let i = floor(p);
    let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f); // Hermite 

    return mix(mix(mix(dot(hash3_periodic(i + vec3<f32>(0.0,0.0,0.0), p_vec), f - vec3<f32>(0.0,0.0,0.0)),
                       dot(hash3_periodic(i + vec3<f32>(1.0,0.0,0.0), p_vec), f - vec3<f32>(1.0,0.0,0.0)), u.x),
                   mix(dot(hash3_periodic(i + vec3<f32>(0.0,1.0,0.0), p_vec), f - vec3<f32>(0.0,1.0,0.0)),
                       dot(hash3_periodic(i + vec3<f32>(1.0,1.0,0.0), p_vec), f - vec3<f32>(1.0,1.0,0.0)), u.x), u.y),
               mix(mix(dot(hash3_periodic(i + vec3<f32>(0.0,0.0,1.0), p_vec), f - vec3<f32>(0.0,0.0,1.0)),
                       dot(hash3_periodic(i + vec3<f32>(1.0,0.0,1.0), p_vec), f - vec3<f32>(1.0,0.0,1.0)), u.x),
                   mix(dot(hash3_periodic(i + vec3<f32>(0.0,1.0,1.0), p_vec), f - vec3<f32>(0.0,1.0,1.0)),
                       dot(hash3_periodic(i + vec3<f32>(1.0,1.0,1.0), p_vec), f - vec3<f32>(1.0,1.0,1.0)), u.x), u.y), u.z);
}

fn periodicNoise2D(p: vec2<f32>, period: f32) -> f32 {
    let p_vec = vec2<f32>(period);
    let i = floor(p);
    let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f);

    return mix(mix(dot(hash2_periodic(i + vec2<f32>(0.0,0.0), p_vec), f - vec2<f32>(0.0,0.0)),
                   dot(hash2_periodic(i + vec2<f32>(1.0,0.0), p_vec), f - vec2<f32>(1.0,0.0)), u.x),
               mix(dot(hash2_periodic(i + vec2<f32>(0.0,1.0), p_vec), f - vec2<f32>(0.0,1.0)),
                   dot(hash2_periodic(i + vec2<f32>(1.0,1.0), p_vec), f - vec2<f32>(1.0,1.0)), u.x), u.y);
}

//  FBM
fn periodicFbm(p: vec3<f32>, octaves: i32, period: f32, initialAmplitude: f32) -> f32 {
    var value = 0.0;
    var amplitude = initialAmplitude;
    var currentPeriod = period;
    var pos = p;
    
    for (var i = 0; i < 5; i++) {
        if (i >= octaves) { break; }
        value = value + periodicNoise(pos, currentPeriod) * amplitude;
        pos = pos * 2.0;
        currentPeriod = currentPeriod * 2.0;
        amplitude = amplitude * 0.5;
    }
    return value;
}

fn periodicFbm2D(p: vec2<f32>, octaves: i32, period: f32, initialAmplitude: f32) -> f32 {
    var value = 0.0;
    var amplitude = initialAmplitude;
    var currentPeriod = period;
    var pos = p;
    
    for (var i = 0; i < 5; i++) {
        if (i >= octaves) { break; }
        value = value + periodicNoise2D(pos, currentPeriod) * amplitude;
        pos = pos * 2.0;
        currentPeriod = currentPeriod * 2.0;
        amplitude = amplitude * 0.5;
    }
    return value;
}




// -----------------------------------------------------------------------------


fn threadProfile(t: f32, thickness: f32, tightness: f32) -> f32 {
    let centered = (t - 0.5) * 2.0 / thickness;
    if (abs(centered) > 1.0) { return 0.0; }
    let base = cos(centered * 1.5707963);
    return pow(base, 0.5 + tightness); 
}

fn threadTwistPattern(pos: vec2<f32>, direction: vec2<f32>, twist: f32, scale: f32) -> f32 {
    let alongThread = dot(pos, direction);
    //  "Z"  "S" 
    let twistPhase = sin(alongThread * scale * 2.5 + twist * 25.0); 
    return twistPhase * 0.5 + 0.5;
}

fn fuzzEffect(pos: vec2<f32>, fuzz: f32, scale: f32, period: f32) -> f32 {
    if (fuzz < 0.01) { return 0.0; }
    let fuzzNoise = periodicNoise2D(pos * 60.0 * scale, period * 60.0 * scale);
    return smoothstep(0.5, 1.0, fuzzNoise) * fuzz;
}

fn getTwillWeaveDetail(uv: vec2<f32>) -> vec4<f32> {
    let scale = u.tileSize;
    let pos = uv * scale;
    
    let warpDensity = u.threadDensity;
    let weftDensity = u.threadDensity * u.warpWeftRatio;
    
    let u_coord = pos.x * warpDensity;
    let v_coord = pos.y * weftDensity;
    
    let i = floor(u_coord);
    let j = floor(v_coord);
    
    let u_local = fract(u_coord);
    let v_local = fract(v_coord);

    // --- Twill / Herringbone Logic ---
    
    //  (Shift)
    // :  ji  1
    // :  i 
    
    var offset_j = j;
    
    if (u.herringboneScale > 1.0) {
        //  (Column Block) 
        // floor(i / scale)  "Zig"  "Zag" 
        let zone = floor(i / u.herringboneScale);
        if (zone % 2.0 > 0.5) {
            // 
            offset_j = -j;
        }
    }
    
    // (i + j) % Repeat
    //  3/1  (Denim): Repeat=4. 0,1,2=Warp(Indio), 3=Weft(White)
    //  offset_j 
    let patternIndex = (i + offset_j) % u.twillRepeat;
    
    // 
    let pIndex = select(patternIndex, patternIndex + u.twillRepeat, patternIndex < 0.0);
    
    //  (Warp)  (Weft) 
    //  3/1 index < 3  Warp
    let isWarpOver = pIndex < (u.twillRepeat - 1.0);

    // --- Thread Variations & Imperfections ---
    
    let imperfection = periodicNoise2D(vec2<f32>(i, j), scale * warpDensity) * u.weaveImperfection * 0.2;
    
    // Thread width variation
    let warpThickVar = 1.0 + periodicNoise2D(vec2<f32>(i * 0.5, 0.0), scale * warpDensity * 0.5) * u.threadUnevenness * 0.3;
    let weftThickVar = 1.0 + periodicNoise2D(vec2<f32>(0.0, j * 0.5), scale * weftDensity * 0.5) * u.threadUnevenness * 0.3;
    
    let warpThick = u.threadThickness * warpThickVar;
    let weftThick = u.threadThickness * weftThickVar;
    
    // Profiles
    let warpP = threadProfile(u_local - imperfection, warpThick, u.weaveTightness);
    let weftP = threadProfile(v_local - imperfection, weftThick, u.weaveTightness);
    
    // --- Height / Undulation Calculation ---
    
    //  (Floating). 
    //  Warp OverWarp Weft 
    //  (Interlacing point)
    
    // 
    // Base Height based on Who is On Top
    // Add sinusoidal curve only near the transition edges?
    // Or simpler: Global sine waves adjusted by "Who is on top".
    
    let amp = u.threadHeightScale * 0.5 * u.waleDepth; // 
    
    // 
    var warpH = 0.0;
    var weftH = 0.0;
    
    if (isWarpOver) {
        // Warp is floating over. It's high.
        warpH = 1.0; 
        // Weft is buried under.
        weftH = -0.5; 
    } else {
        // Weft is floating over (short float usually).
        warpH = -0.5;
        weftH = 1.0;
    }
    
    // Add profile shape to height
    warpH = warpH * amp + warpP * u.threadHeightScale;
    weftH = weftH * amp + weftP * u.threadHeightScale;
    
    // Gap Logic
    var h = 0.0;
    var isWarpFinal = isWarpOver;
    
    if (warpP < 0.01 && weftP < 0.01) {
        h = -1.0; // Hole
    } else if (warpP < 0.01) {
        h = weftH;
        isWarpFinal = false;
    } else if (weftP < 0.01) {
        h = warpH;
        isWarpFinal = true;
    } else {
        // Smooth intersection? No, fabrics are physically stacked.
        if (warpH > weftH) {
            h = warpH;
            isWarpFinal = true;
        } else {
            h = weftH;
            isWarpFinal = false;
        }
    }
    
    // --- Shading & Details ---
    
    var density = h; // Map height to color density base
    
    // Twist & Fiber
    var twistVal = 0.0;
    // Warp goes vertical (along Y), Weft horizontal (along X)
    if (isWarpFinal) {
        twistVal = threadTwistPattern(pos, vec2<f32>(0.0, 1.0), u.threadTwist, warpDensity);
        // Warp 
        density = density + periodicNoise2D(pos * 200.0, 10.0) * u.fiberDetail * 0.1;
    } else {
        twistVal = threadTwistPattern(pos, vec2<f32>(1.0, 0.0), u.threadTwist, weftDensity);
        density = density + periodicNoise2D(pos * 200.0, 10.0) * u.fiberDetail * 0.15; // Weft often fluffier
    }
    
    // Fuzz
    let fuzzVal = fuzzEffect(pos, u.fuzziness, max(warpDensity, weftDensity), scale);
    
    // Shadow / Occlusion (Deep parts get darker)
    // 
    let occlusion = smoothstep(0.0, -0.8, h); 
    density = density - occlusion * u.threadShadowStrength;
    
    // Twist influence on lighting
    density = density + (twistVal - 0.5) * 0.1;
    
    // Fuzz adds lightness usually (scattering)
    density = density + fuzzVal * 0.15;
    
    density = clamp(density, 0.0, 1.0);
    
    // Color Noise Variation (Denim wash effect)
    // Use lower frequency noise for "wash" look
    let washNoise = periodicNoise2D(pos * u.noiseFrequency * 0.5, scale);
    density = density + washNoise * u.colorVariation;
    
    // Sheen
    let sheen = select(u.weftSheen, u.warpSheen, isWarpFinal);
    
    return vec4<f32>(density, h, sheen, twistVal);
}

@vertex
fn vs_main(@location(0) position : vec3<f32>, @location(1) uv : vec2<f32>) -> VertexOutput {
    var output : VertexOutput;
    output.Position = vec4<f32>(position, 1.0);
    output.uv = uv;
    return output;
}

@fragment
fn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {
    let data = getTwillWeaveDetail(in.uv);
    let density = data.x;
    let height = data.y;
    let sheen = data.z;
    let twist = data.w;
    
    // Sampling Gradient
    // For Denim: High density (Warp top) -> Blue. Low density (Weft top or Shadow) -> White/Dark.
    let albedo = textureSample(gradientTexture, gradientSampler, vec2<f32>(clamp(density, 0.01, 0.99), 0.5)).rgb;
    
    let roughness = mix(u.roughnessMin, u.roughnessMax, 1.0 - sheen);
    
    // Normal Map Generation
    let dHdUV = vec2<f32>(dpdx(height), dpdy(height));
    // Add micro-normal from twist
    let twistNormal = (twist - 0.5) * 0.5; 
    
    let normal = normalize(vec3<f32>(
        -dHdUV.x * u.normalStrength, 
        -dHdUV.y * u.normalStrength + twistNormal, // Twist affects Y normal for Warp
        1.0
    ));
    
    // Simple Lighting
    let lightDir = normalize(vec3<f32>(0.5, 0.5, 1.0));
    let NdotL = max(dot(normal, lightDir), 0.0);
    
    // Anisotropic Highlight (Crucial for Twill)
    // Approximate anisotropy by modifying roughness based on view angle vs thread direction
    // Simplified Blinn-Phong here
    let viewDir = vec3<f32>(0.0, 0.0, 1.0);
    let halfDir = normalize(lightDir + viewDir);
    let spec = pow(max(dot(normal, halfDir), 0.0), 48.0 * (1.0 - roughness)) * sheen;
    
    let finalColor = albedo * (0.2 + 0.8 * NdotL) + vec3<f32>(spec);
    
    return vec4<f32>(finalColor, 1.0);
}
`;function BF(t,e){const r=document.createElement("canvas");r.width=256,r.height=1;const i=r.getContext("2d");if(!i)throw new Error("Could not get 2d context");const o=i.createLinearGradient(0,0,256,0);[...e].sort((c,h)=>c.offset-h.offset).forEach(c=>{o.addColorStop(c.offset,c.color)}),i.fillStyle=o,i.fillRect(0,0,256,1);const l=i.getImageData(0,0,256,1),u=t.createTexture({size:[256,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});return t.queue.writeTexture({texture:u},l.data,{bytesPerRow:256*4},[256,1]),u}async function zF(t,e,n){const s=await Ts();if(!s)throw new Error("WebGPU not supported");const r=s.createTexture({size:[e,n],format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),i=44,o=new Float32Array(i);o[0]=1,o[5]=1,o[10]=1,o[15]=1,o[16]=t.tileSize,o[17]=t.threadDensity,o[18]=t.threadThickness,o[19]=t.warpWeftRatio,o[20]=t.threadTwist,o[21]=t.fiberDetail,o[22]=t.fuzziness,o[23]=t.twillRepeat,o[24]=t.herringboneScale,o[25]=t.waleDepth,o[26]=0,o[27]=t.weaveTightness,o[28]=t.threadUnevenness,o[29]=t.weaveImperfection,o[30]=t.fbmOctaves,o[31]=t.fbmAmplitude,o[32]=t.noiseFrequency,o[33]=t.colorVariation,o[34]=t.warpSheen,o[35]=t.weftSheen,o[36]=t.roughnessMin,o[37]=t.roughnessMax,o[38]=t.normalStrength,o[39]=t.threadHeightScale,o[40]=t.threadShadowStrength;const a=s.createBuffer({size:o.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(a,0,o);const l=BF(s,t.gradientStops),u=s.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),c=s.createShaderModule({code:UF}),h=s.createRenderPipeline({layout:"auto",vertex:{module:c,entryPoint:"vs_main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}]}]},fragment:{module:c,entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}}),d=s.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:l.createView()},{binding:2,resource:u}]}),f=new Float32Array([-1,-1,0,0,1,1,-1,0,1,1,-1,1,0,0,0,-1,1,0,0,0,1,-1,0,1,1,1,1,0,1,0]),p=s.createBuffer({size:f.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(p,0,f);const g=s.createCommandEncoder(),m=g.beginRenderPass({colorAttachments:[{view:r.createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]});m.setPipeline(h),m.setBindGroup(0,d),m.setVertexBuffer(0,p),m.draw(6,1,0,0),m.end();const b=e*4,v=256,y=Math.ceil(b/v)*v,C=s.createBuffer({size:y*n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});g.copyTextureToBuffer({texture:r},{buffer:C,bytesPerRow:y},[e,n]),s.queue.submit([g.finish()]),await C.mapAsync(GPUMapMode.READ);const I=C.getMappedRange(),$=document.createElement("canvas");$.width=e,$.height=n;const T=$.getContext("2d");if(!T)throw new Error("Could not get 2d context");const S=new Uint8Array(I),E=T.createImageData(e,n);for(let _=0;_<n;_++){const N=_*y,P=_*e*4;for(let M=0;M<e;M++){const z=N+M*4,A=P+M*4;E.data[A]=S[z+2],E.data[A+1]=S[z+1],E.data[A+2]=S[z],E.data[A+3]=S[z+3]}}return T.putImageData(E,0,0),C.unmap(),$.toDataURL("image/png")}const GF=`

struct Uniforms {
    viewMatrix : mat4x4<f32>, // 
    tileSize : f32,
    pileHeight : f32,
    pileDensity : f32,
    pileSlant : f32,
    slantDirection : f32,
    crushStrength : f32,
    crushScale : f32,
    crushDetail : f32,
    fiberGrain : f32,
    stripes : f32,
    stripeFrequency : f32,
    fbmOctaves : f32,
    noiseRoughness : f32,
    sheenIntensity : f32,
    sheenFalloff : f32,
    ambientOcclusion : f32,
    colorVariation : f32,
    lightSourceX : f32,
    lightSourceY : f32,
    baseColorR : f32,
    baseColorG : f32,
    baseColorB : f32,
    sheenColorR : f32,
    sheenColorG : f32,
    sheenColorB : f32,
    padding1 : f32, // Padding for 16-byte alignment
};

@group(0) @binding(0) var<uniform> u : Uniforms;

struct VertexOutput {
    @builtin(position) Position : vec4<f32>,
    @location(0) uv : vec2<f32>,
};

// --- Noise Functions ---

fn hash2(p: vec2<f32>) -> f32 {
    return fract(sin(dot(p, vec2<f32>(127.1, 311.7))) * 43758.5453123);
}

fn hash2_periodic(p: vec2<f32>, period: vec2<f32>) -> vec2<f32> {
    let wrappedP = p % period;
    var q = vec2<f32>(dot(wrappedP, vec2<f32>(127.1, 311.7)),
                      dot(wrappedP, vec2<f32>(269.5, 183.3)));
    return -1.0 + 2.0 * fract(sin(q) * 43758.5453123);
}

fn periodicNoise2D(p: vec2<f32>, period: f32) -> f32 {
    let p_vec = vec2<f32>(period);
    let i = floor(p);
    let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f);

    return mix(mix(dot(hash2_periodic(i + vec2<f32>(0.0,0.0), p_vec), f - vec2<f32>(0.0,0.0)),
                   dot(hash2_periodic(i + vec2<f32>(1.0,0.0), p_vec), f - vec2<f32>(1.0,0.0)), u.x),
               mix(dot(hash2_periodic(i + vec2<f32>(0.0,1.0), p_vec), f - vec2<f32>(0.0,1.0)),
                   dot(hash2_periodic(i + vec2<f32>(1.0,1.0), p_vec), f - vec2<f32>(1.0,1.0)), u.x), u.y);
}

// Flow Noise for Crushed Velvet (Rotational distortion)
fn flowFbm(p: vec2<f32>, octaves: i32, period: f32, persistence: f32) -> f32 {
    var value = 0.0;
    var amplitude = 1.0;
    var currentPeriod = period;
    var pos = p;
    var totalAmp = 0.0;
    
    for (var i = 0; i < 5; i++) {
        if (i >= octaves) { break; }
        value = value + periodicNoise2D(pos, currentPeriod) * amplitude;
        totalAmp = totalAmp + amplitude;
        pos = pos * 2.0;
        currentPeriod = currentPeriod * 2.0;
        amplitude = amplitude * persistence;
    }
    return value / totalAmp;
}

// --- Velvet Logic ---

fn rotateVector(v: vec3<f32>, axis: vec3<f32>, angle: f32) -> vec3<f32> {
    let c = cos(angle);
    let s = sin(angle);
    return v * c + cross(axis, v) * s + axis * dot(axis, v) * (1.0 - c);
}

// Charlie Sheen NDF approximation for velvet
fn charlieD(NdotH: f32, roughness: f32) -> f32 {
    let invAlpha = 1.0 / roughness;
    let cos2h = NdotH * NdotH;
    let sin2h = 1.0 - cos2h;
    return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * 3.14159);
}

@vertex
fn vs_main(@location(0) position : vec3<f32>, @location(1) uv : vec2<f32>) -> VertexOutput {
    var output : VertexOutput;
    output.Position = vec4<f32>(position, 1.0);
    output.uv = uv;
    return output;
}

@fragment
fn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {
    let uv = in.uv;
    let scale = u.tileSize;
    let pos = uv * scale;
    
    // 1. Generate "Crush" Map (The flow of the velvet fibers)
    // Velvet fibers aren't perfectly straight up. They lean.
    // Crushed velvet has regions leaning in chaotic directions.
    
    let crushPeriod = 10.0 * u.crushScale;
    let noise1 = flowFbm(pos * u.crushScale * 5.0, i32(u.fbmOctaves), crushPeriod, 0.5);
    let noise2 = flowFbm((pos + vec2<f32>(5.2, 1.3)) * u.crushScale * 5.0, i32(u.fbmOctaves), crushPeriod, 0.5);
    
    // Base slant direction (Global grain)
    let rad = radians(u.slantDirection);
    var fiberDir = vec3<f32>(cos(rad), sin(rad), 0.0);
    
    // Perturb fiber direction based on crush noise
    let randomAngle = (noise1 * 2.0 * 3.14159) * u.crushStrength;
    fiberDir = rotateVector(fiberDir, vec3<f32>(0.0, 0.0, 1.0), randomAngle);
    
    // 2. High Frequency "Micro-Fiber" Noise
    // Real velvet has millions of fibers. Standard perlin is too smooth.
    // We use a high frequency hash to simulate the random orientation of individual tips.
    let fiberFreq = 800.0 * (1.0 + u.pileDensity); // Very high frequency
    let microNoise = hash2(pos * fiberFreq); // 0.0 to 1.0 white noise
    
    // 3. Normal Construction
    // Combine macro lean (crush) with micro variation
    
    let leanAmount = u.pileSlant * (0.5 + 0.5 * noise2 * u.crushDetail); 
    
    // The "Macro" normal of the pile tuft
    var macroNormal = normalize(vec3<f32>(fiberDir.x * leanAmount, fiberDir.y * leanAmount, 1.0 - leanAmount * 0.5));
    
    // Apply Corduroy/Stripes
    if (u.stripes > 0.0) {
        let stripePattern = sin(dot(uv, vec2<f32>(cos(rad), sin(rad))) * u.stripeFrequency * 100.0);
        let stripeH = smoothstep(-0.5, 0.5, stripePattern);
        macroNormal = normalize(mix(macroNormal, vec3<f32>(0.0,0.0,1.0), (1.0 - stripeH) * u.stripes * 0.7));
    }
    
    // Perturb with micro-noise to get "fuzzy" normal
    // The fibers don't all point exactly the same way
    let grainStrength = u.fiberGrain * 0.3;
    // Map 0..1 to -1..1
    let microPerturb = (microNoise - 0.5) * 2.0; 
    var N = normalize(macroNormal + vec3<f32>(microPerturb * grainStrength, microPerturb * grainStrength, 0.0));
    
    // 4. Lighting Calculation
    
    let lightDir = normalize(vec3<f32>(u.lightSourceX, u.lightSourceY, 1.0));
    // View dir is top down
    let V = vec3<f32>(0.0, 0.0, 1.0); 
    let L = lightDir;
    let H = normalize(L + V);
    
    let NdotL = max(dot(N, L), 0.0);
    let NdotV = max(dot(N, V), 0.0);
    let NdotH = max(dot(N, H), 0.0);
    let VdotH = max(dot(V, H), 0.0);
    
    // A. Base Diffuse (Deep Scattering)
    // Velvet is dark when viewed straight on (light gets trapped) and bright at edges
    // But color also depends on light alignment.
    // We use a modified diffuse that is softer
    let diffuse = pow(NdotL, 1.0 + u.pileHeight) * (0.5 + 0.5 * u.ambientOcclusion);
    
    // B. Velvet Sheen
    // The "fuzzy" look comes from backscattering at grazing angles.
    // We approximate this using a term that gets stronger as N is perpendicular to V
    // or as L aligns with the fibers.
    
    // 1. Term dependent on View Angle (Rim / Grazing)
    // As NdotV approaches 0 (grazing), velvet gets brighter/sheenier.
    let grazing = 1.0 - NdotV;
    let rimSheen = pow(grazing, u.sheenFalloff);
    
    // 2. Term dependent on Light Angle relative to Fiber Normals (Backscatter)
    // "Charlie" Sheen like distribution
    let roughness = mix(0.3, 1.0, u.noiseRoughness);
    let sheenDist = charlieD(NdotH, roughness);
    
    // Combine terms
    let sheenFactor = (rimSheen + sheenDist * 0.5) * u.sheenIntensity;
    
    // 5. Color Composition
    let baseCol = vec3<f32>(u.baseColorR, u.baseColorG, u.baseColorB);
    let sheenCol = vec3<f32>(u.sheenColorR, u.sheenColorG, u.sheenColorB);
    
    // Color Variation (Large scale)
    let colVarNoise = flowFbm(pos * u.crushScale * 2.0, 2, crushPeriod, 0.5);
    // Darken the valleys/deep parts more
    let depth = 1.0 - (noise2 * 0.5 + 0.5); 
    let variedBase = baseCol * (1.0 + colVarNoise * u.colorVariation) * (mix(1.0, depth, u.ambientOcclusion * 0.5));
    
    // Mix Base and Sheen
    // Start with base
    var finalColor = variedBase * diffuse;
    
    // Add sheen (Additive)
    // Sheen should be masked by shadows, but velvet sheen often glows a bit even in soft light
    // We'll multiply by a soft shadow term
    let softShadow = smoothstep(-0.1, 0.2, NdotL); 
    finalColor = finalColor + sheenCol * sheenFactor * softShadow;
    
    // High frequency sparkle/grain (Simulates individual fiber tips catching light)
    // This is distinct from the normal map "grain", this is specular highlights on tips
    let sparkle = step(0.98 - u.pileDensity * 0.05, microNoise) * NdotL;
    // Sparkle is subtle
    finalColor = finalColor + sheenCol * sparkle * u.sheenIntensity * 0.2;
    
    return vec4<f32>(finalColor, 1.0);
}
`;function OS(t){const e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);return e?{r:parseInt(e[1],16)/255,g:parseInt(e[2],16)/255,b:parseInt(e[3],16)/255}:{r:0,g:0,b:0}}async function VF(t,e,n){const s=await Ts();if(!s)throw new Error("WebGPU not supported");const r=s.createTexture({size:[e,n],format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),i=new Float32Array(44),o=OS(t.baseColor),a=OS(t.sheenColor);let l=0;i.set([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],0),l+=16,i[l++]=t.tileSize,i[l++]=t.pileHeight,i[l++]=t.pileDensity,i[l++]=t.pileSlant,i[l++]=t.slantDirection,i[l++]=t.crushStrength,i[l++]=t.crushScale,i[l++]=t.crushDetail,i[l++]=t.fiberGrain,i[l++]=t.stripes,i[l++]=t.stripeFrequency,i[l++]=t.fbmOctaves,i[l++]=t.noiseRoughness,i[l++]=t.sheenIntensity,i[l++]=t.sheenFalloff,i[l++]=t.ambientOcclusion,i[l++]=t.colorVariation,i[l++]=t.lightSourceX,i[l++]=t.lightSourceY,i[l++]=o.r,i[l++]=o.g,i[l++]=o.b,i[l++]=a.r,i[l++]=a.g,i[l++]=a.b,i[l++]=0;const u=s.createBuffer({size:i.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(u,0,i);const c=s.createShaderModule({code:GF}),h=s.createRenderPipeline({layout:"auto",vertex:{module:c,entryPoint:"vs_main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}]}]},fragment:{module:c,entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}}),d=s.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:u}}]}),f=new Float32Array([-1,-1,0,0,1,1,-1,0,1,1,-1,1,0,0,0,-1,1,0,0,0,1,-1,0,1,1,1,1,0,1,0]),p=s.createBuffer({size:f.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(p,0,f);const g=s.createCommandEncoder(),m=g.beginRenderPass({colorAttachments:[{view:r.createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]});m.setPipeline(h),m.setBindGroup(0,d),m.setVertexBuffer(0,p),m.draw(6,1,0,0),m.end();const b=e*4,v=256,y=Math.ceil(b/v)*v,C=s.createBuffer({size:y*n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});g.copyTextureToBuffer({texture:r},{buffer:C,bytesPerRow:y},[e,n]),s.queue.submit([g.finish()]),await C.mapAsync(GPUMapMode.READ);const I=C.getMappedRange(),$=document.createElement("canvas");$.width=e,$.height=n;const T=$.getContext("2d");if(!T)throw new Error("Could not get 2d context");const S=new Uint8Array(I),E=T.createImageData(e,n);for(let _=0;_<n;_++){const N=_*y,P=_*e*4;for(let M=0;M<e;M++){const z=N+M*4,A=P+M*4;E.data[A]=S[z+2],E.data[A+1]=S[z+1],E.data[A+2]=S[z],E.data[A+3]=S[z+3]}}return T.putImageData(E,0,0),C.unmap(),$.toDataURL("image/png")}const WF=`

struct Uniforms {
    viewMatrix : mat4x4<f32>, // Unused but required for compatibility
    
    tileSize : f32,
    cellScale : f32,
    cellRandomness : f32,
    cellStretch : f32,
    cellStretchAngle : f32,
    
    grooveWidth : f32,
    grooveDepth : f32,
    grooveProfile : f32,
    
    wrinkleScale : f32,
    wrinkleIntensity : f32,
    poreDensity : f32,
    poreDepth : f32,
    poreVisibility : f32,
    
    creaseIntensity : f32,
    creaseFrequency : f32,
    wearLevel : f32,
    scratchCount : f32,
    scratchIntensity : f32,
    
    roughnessMin : f32,
    roughnessMax : f32,
    normalStrength : f32,

    fiberScale : f32,
    fiberStrength : f32,
    fiberDetail : f32,
    fiberDirectionality : f32,
    fiberRandomness : f32,
    
    patinaStrength : f32,
    colorVariation : f32,
    
    // Padding to ensure 16-byte alignment if needed, 
    // but we will carefully pack in the generator.
    padding1 : f32,
    padding2 : f32,
};

@group(0) @binding(0) var<uniform> u : Uniforms;
@group(0) @binding(1) var gradientTexture : texture_2d<f32>;
@group(0) @binding(2) var gradientSampler : sampler;

struct VertexOutput {
    @builtin(position) Position : vec4<f32>,
    @location(0) uv : vec2<f32>,
};

// --- Utilities ---

fn hash2(p: vec2<f32>) -> vec2<f32> {
    var h = vec2<f32>(dot(p, vec2<f32>(127.1, 311.7)),
                      dot(p, vec2<f32>(269.5, 183.3)));
    return -1.0 + 2.0 * fract(sin(h) * 43758.5453123);
}

// Seamless Periodic Hash
fn hash2_periodic(p: vec2<f32>, period: vec2<f32>) -> vec2<f32> {
    let wrappedP = p % period;
    var h = vec2<f32>(dot(wrappedP, vec2<f32>(127.1, 311.7)),
                      dot(wrappedP, vec2<f32>(269.5, 183.3)));
    return -1.0 + 2.0 * fract(sin(h) * 43758.5453123);
}

// Pseudo-random value 0-1
fn rand2_periodic(p: vec2<f32>, period: vec2<f32>) -> f32 {
    let wrappedP = p % period;
    return fract(sin(dot(wrappedP, vec2<f32>(12.9898, 78.233))) * 43758.5453);
}

// --- Gradient Noise for seamless Micro-Details ---
fn periodicNoise(p: vec2<f32>, period: f32) -> f32 {
    let p_vec = vec2<f32>(period);
    let i = floor(p);
    let f = fract(p);
    let t = f * f * (3.0 - 2.0 * f);

    let v00 = dot(hash2_periodic(i + vec2<f32>(0.0,0.0), p_vec), f - vec2<f32>(0.0,0.0));
    let v10 = dot(hash2_periodic(i + vec2<f32>(1.0,0.0), p_vec), f - vec2<f32>(1.0,0.0));
    let v01 = dot(hash2_periodic(i + vec2<f32>(0.0,1.0), p_vec), f - vec2<f32>(0.0,1.0));
    let v11 = dot(hash2_periodic(i + vec2<f32>(1.0,1.0), p_vec), f - vec2<f32>(1.0,1.0));

    return mix(mix(v00, v10, t.x), mix(v01, v11, t.x), t.y);
}

fn periodicFbm(p: vec2<f32>, octaves: i32, period: f32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var currentPeriod = period;
    var pos = p;
    
    for (var i = 0; i < 5; i++) {
        if (i >= octaves) { break; }
        value = value + periodicNoise(pos, currentPeriod) * amplitude;
        pos = pos * 2.0;
        currentPeriod = currentPeriod * 2.0;
        amplitude = amplitude * 0.5;
    }
    return value;
}

// --- Advanced Voronoi ---
// Returns:
// x: Distance to closest center (F1)
// y: Distance to second closest center (F2)
// z: Hash/ID of the closest cell (0-1)
fn voronoi_advanced(p: vec2<f32>, period: f32, randomness: f32) -> vec3<f32> {
    let ip = floor(p);
    let fp = fract(p);
    
    var d1 = 8.0;
    var d2 = 8.0;
    var cellID = 0.0;
    
    // Check 3x3 neighbor cells
    for(var j=-1; j<=1; j++) {
        for(var i=-1; i<=1; i++) {
            let neighbor = vec2<f32>(f32(i), f32(j));
            
            // Random point in neighbor cell
            // We must use periodic hash for position to ensure tiling
            let rnd = hash2_periodic(ip + neighbor, vec2<f32>(period));
            
            // Jitter position based on randomness param
            // if randomness is 0, point is at center (0.5), if 1, point is anywhere
            let pointPos = neighbor + 0.5 + rnd * 0.5 * randomness;
            
            let dist = length(pointPos - fp); // Euclidean distance
            
            if(dist < d1) {
                d2 = d1;
                d1 = dist;
                // Store cell ID for color variation
                cellID = rand2_periodic(ip + neighbor, vec2<f32>(period));
            } else if(dist < d2) {
                d2 = dist;
            }
        }
    }
    return vec3<f32>(d1, d2, cellID);
}

// Rotates UV coordinates
fn rotateUV(uv: vec2<f32>, angle: f32) -> vec2<f32> {
    let s = sin(angle);
    let c = cos(angle);
    return vec2<f32>(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
}

// --- Flow Noise for Fibers ---

fn rot2d(angle: f32) -> mat2x2<f32> {
    let s = sin(angle);
    let c = cos(angle);
    return mat2x2<f32>(c, -s, s, c);
}

// Directional flow noise
fn flowNoise(p: vec2<f32>, scale: f32, directionality: f32, randomness: f32, period: f32) -> f32 {
    // 1. Generate flow field "angle"
    // Use low frequency noise to determine direction
    let flowAngle = periodicNoise(p * 0.5, period * 0.5) * 6.28318 * randomness;
    
    // 2. Rotate coordinate system based on flow angle
    // If directionality is high, we stretch the noise along X before rotating
    // Base coordinate
    var q = p;
    
    // Apply local rotation
    let rot = rot2d(flowAngle);
    // Rotating the coordinate effectively rotates the "grain" if the grain is anisotropic
    
    // Anisotropy: Stretch X, Shrink Y (or vice versa)
    // Strong fibers = High stretching
    let stretchFactor = 1.0 + directionality * 4.0;
    
    // We want to sample noise that is stretched.
    // So we scale the coordinate: q.x * stretch, q.y / stretch?
    // Actually simpler:
    // 1. Rotate P by angle.
    // 2. Scale P.x by stretch.
    // 3. Sample noise.
    
    var localP = p;
    if (directionality > 0.01) {
       // Center of rotation? Just 0,0 is fine for noise field.
       localP = rot * p;
       localP = vec2<f32>(localP.x * stretchFactor, localP.y);
    }
    
    // Scale must adapt to 'scale' param
    return periodicFbm(localP * scale, 3, period * scale);
}

// -----------------------------------------------------------
// Core Logic: Leather Generation
// -----------------------------------------------------------

fn getLeatherDetail(uv: vec2<f32>) -> vec4<f32> {
    let scale = u.tileSize;
    var pos = uv * scale;
    
    // 1. Domain Warping for Organic Feel
    // Leather cells are never perfectly straight grid.
    let warpFreq = 3.0; // Fixed large scale warping
    let warp = vec2<f32>(
        periodicNoise(pos * warpFreq, scale * warpFreq),
        periodicNoise(pos * warpFreq + 5.2, scale * warpFreq)
    ) * 0.1; // Strength of warp
    
    var grainPos = pos + warp;
    
    // 2. Anisotropy / Stretch
    // Rotate, then stretch one axis
    if (abs(u.cellStretch) > 0.01) {
        let center = vec2<f32>(scale * 0.5);
        // Relative to center for rotation? Actually texture space is infinite periodic.
        // Just rotate the coords.
        let rotPos = rotateUV(grainPos, u.cellStretchAngle);
        // Stretch: multiply one axis to make cells appear longer in that direction
        // Effectively, we scale coordinates DOWN in one axis, so freq decreases, shapes get larger/longer.
        grainPos = vec2<f32>(rotPos.x * (1.0 - u.cellStretch * 0.5), rotPos.y);
    }

    // 3. Voronoi Grain (Scales)
    // Scale is driven by cellScale
    let vScale = u.cellScale;
    let vData = voronoi_advanced(grainPos * vScale, scale * vScale, u.cellRandomness);
    let f1 = vData.x;
    let f2 = vData.y;
    let cellID = vData.z;
    
    // 4. Groove Calculation
    // Grooves are at the boundaries where f1 approx f2
    // Border distance = f2 - f1
    let borderDist = f2 - f1;
    
    // Create groove profile
    // sharp V-shape or softer U-shape
    let grooveSoftness = mix(0.01, 0.2, u.grooveProfile);
    let groove = smoothstep(u.grooveWidth * 0.5, u.grooveWidth * 0.5 + grooveSoftness, borderDist);
    
    // Cell height (pillow effect)
    // Cells are higher in the center (f1 close to 0) and lower at edges
    // But leather scales are usually flat-topped
    let cellHeight = smoothstep(0.0, 0.5, borderDist); 
    
    // 5. Micro-Detail (Papillary Grain)
    // High frequency noise on top of scales
    let microNoise = periodicFbm(pos * u.wrinkleScale, 3, scale * u.wrinkleScale);
    let microDetail = microNoise * u.wrinkleIntensity * 0.2;
    
    // 6. Pores
    // Typically periodic dots.
    // Use high freq Worley or just Thresholded noise?
    let poreFreq = u.poreDensity * 5.0;
    let poreNoise = periodicNoise(pos * poreFreq, scale * poreFreq);
    let poreMask = smoothstep(0.4, 0.45, poreNoise - (1.0 - u.poreVisibility)*0.5);
    // Pores are holes, so we subtract height
    let poreIndent = poreMask * u.poreDepth;
    
    // 7. Larger Creases / Folds
    let creaseNoise = periodicFbm(pos * u.creaseFrequency, 2, scale * u.creaseFrequency);
    // Ridge noise for sharp creases
    let creaseVal = 1.0 - abs(creaseNoise); 
    // Threshold to verify sparse creases
    let creaseLine = smoothstep(0.7, 0.8, creaseVal) * u.creaseIntensity;
    
    // 8. Combine Height / Density
    // Base is the groove pattern
    var h = 1.0;
    // Apply Grooves (darker/deeper)
    h = h * groove; 
    // Apply Pores
    h = h - poreIndent;
    // Apply Microdetail (additve/subtractive)
    h = h + microDetail;
    // Apply Creases
    h = h - creaseLine;
    
    // 8.5. Apply Fibers (NEW)
    // Fibers are very fine, directional.
    // Base fiber noise
    let fiberVal = flowNoise(pos, u.fiberScale, u.fiberDirectionality, u.fiberRandomness, scale);
    // Detail layer
    let fiberDetailVal = periodicFbm(pos * u.fiberScale * 2.0, 2, scale * u.fiberScale * 2.0);
    
    // Composite fiber
    let fiberInfo = (fiberVal + fiberDetailVal * u.fiberDetail) * 0.5;
    // Fibers add roughness/normals but shouldn't affect height too massively or it looks like fur.
    // But for normal map, we need height variation.
    let fibers = fiberInfo * u.fiberStrength * 0.1;
    
    // Fibers are usually subtractive (gaps between fibers) and additive (fiber strands).
    h = h + fibers;
    
    h = clamp(h, 0.0, 1.0);
    
    // 9. Wear / Aging Logic
    // Wear happens on high spots (h > 0.8 say)
    // Dirt accumulates in low spots (h < 0.2)
    
    // 'Patina' Mask (Low spots)
    let patinaMask = 1.0 - smoothstep(0.0, 0.5, h);
    
    // 'Rub' Mask (High spots)
    let rubMask = smoothstep(0.7, 1.0, h) * u.wearLevel;
    
    // --- Return Data ---
    // x: Final Density (Color lookup)
    // y: Height (Normal map gen)
    // z: Roughness Mix (0=Smooth/Rubbed, 1=Rough/Groove)
    // w: Cell ID (for color variation)
    
    // Density maps to gradient.
    // Base is h.
    // Patina makes it darker (density -> 0 for dark wood? No, check gradient stops).
    // Usually gradient 0 is dark/recessed, 1 is light/raised.
    var density = h;
    
    // Add per-cell variation to density so different scales pick slightly different colors
    density = density + (cellID - 0.5) * u.colorVariation;
    
    // Apply Patina (darken low spots further or shift towards dark end)
    density = density - patinaMask * u.patinaStrength * 0.5;
    
    // Apply Rub (lighten high spots?) 
    // Assuming light color is at 1.0.
    density = density + rubMask * 0.3;
    
    density = clamp(density, 0.0, 1.0);
    
    // Roughness logic
    // Grooves/Pores are rougher (1.0)
    // High spots are smoother (0.0), especially if worn
    let roughnessMix = 1.0 - h; // Low h = High roughness mix
    // Modify by wear: rubbed areas are even smoother
    let finalRoughnessLogic = roughnessMix - rubMask * 0.5;
    
    return vec4<f32>(density, h, clamp(finalRoughnessLogic, 0.0, 1.0), cellID);
}

@vertex
fn vs_main(@location(0) position : vec3<f32>, @location(1) uv : vec2<f32>) -> VertexOutput {
    var output : VertexOutput;
    output.Position = vec4<f32>(position, 1.0);
    output.uv = uv;
    return output;
}

@fragment
fn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {
    let data = getLeatherDetail(in.uv);
    let density = data.x;
    let height = data.y;
    let roughnessMix = data.z;
    let cellID = data.w;
    
    // 1. Color Lookup
    let albedo = textureSample(gradientTexture, gradientSampler, vec2<f32>(density, 0.5)).rgb;
    
    // 2. Normal Map Calculation
    // Use derivatives of height
    // Note: Height is purely procedural 0-1.
    // Needs scaling by normalStrength.
    let dHdUV = vec2<f32>(dpdx(height), dpdy(height));
    let normal = normalize(vec3<f32>(-dHdUV.x * u.normalStrength, -dHdUV.y * u.normalStrength, 1.0));
    
    // 3. Roughness
    let roughness = mix(u.roughnessMin, u.roughnessMax, roughnessMix);
    
    // 4. Simple Lighting (Preview)
    let lightDir = normalize(vec3<f32>(0.5, 0.5, 1.0));
    let diff = max(dot(normal, lightDir), 0.0);
    
    let viewDir = vec3<f32>(0.0, 0.0, 1.0);
    let halfDir = normalize(lightDir + viewDir);
    let spec = pow(max(dot(normal, halfDir), 0.0), 32.0 * (1.0 - roughness));
    
    // Add slight environment sheen (faked)
    let sheen = (1.0 - roughness) * 0.2;
    
    let finalColor = albedo * (0.3 + 0.7 * diff) + vec3<f32>(spec + sheen);
    
    return vec4<f32>(finalColor, 1.0);
}
`,HF={tileSize:1,cellScale:15,cellRandomness:.7,cellStretch:0,cellStretchAngle:0,grooveWidth:.15,grooveDepth:1,grooveProfile:.5,wrinkleScale:8,wrinkleIntensity:.5,poreDensity:2,poreDepth:.3,poreVisibility:.6,creaseIntensity:0,creaseFrequency:1.5,wearLevel:0,scratchCount:0,scratchIntensity:.5,roughnessMin:.4,roughnessMax:.7,normalStrength:8,fiberScale:20,fiberStrength:.5,fiberDetail:.5,fiberDirectionality:.2,fiberRandomness:.5,patinaStrength:.2,colorVariation:.1,gradientStops:[{offset:0,color:"#3E2723"},{offset:1,color:"#8D6E63"}]};function KF(t,e){const r=document.createElement("canvas");r.width=256,r.height=1;const i=r.getContext("2d");if(!i)throw new Error("Could not get 2d context");const o=i.createLinearGradient(0,0,256,0);[...e].sort((c,h)=>c.offset-h.offset).forEach(c=>{o.addColorStop(c.offset,c.color)}),i.fillStyle=o,i.fillRect(0,0,256,1);const l=i.getImageData(0,0,256,1),u=t.createTexture({size:[256,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});return t.queue.writeTexture({texture:u},l.data,{bytesPerRow:256*4},[256,1]),u}async function jF(t,e,n){const s=await Ts();if(!s)throw new Error("WebGPU not supported");const r=s.createTexture({size:[e,n],format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),i=new Float32Array(48);i[0]=1,i[5]=1,i[10]=1,i[15]=1;let o=16;i[o++]=t.tileSize,i[o++]=t.cellScale,i[o++]=t.cellRandomness,i[o++]=t.cellStretch,i[o++]=t.cellStretchAngle,i[o++]=t.grooveWidth,i[o++]=t.grooveDepth,i[o++]=t.grooveProfile,i[o++]=t.wrinkleScale,i[o++]=t.wrinkleIntensity,i[o++]=t.poreDensity,i[o++]=t.poreDepth,i[o++]=t.poreVisibility,i[o++]=t.creaseIntensity,i[o++]=t.creaseFrequency,i[o++]=t.wearLevel,i[o++]=t.scratchCount,i[o++]=t.scratchIntensity,i[o++]=t.roughnessMin,i[o++]=t.roughnessMax,i[o++]=t.normalStrength,i[o++]=t.fiberScale,i[o++]=t.fiberStrength,i[o++]=t.fiberDetail,i[o++]=t.fiberDirectionality,i[o++]=t.fiberRandomness,i[o++]=t.patinaStrength,i[o++]=t.colorVariation,i[o++]=0,i[o++]=0,i[o++]=0,i[o++]=0;const a=s.createBuffer({size:i.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(a,0,i);const l=KF(s,t.gradientStops),u=s.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),c=s.createShaderModule({code:WF}),h=s.createRenderPipeline({layout:"auto",vertex:{module:c,entryPoint:"vs_main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}]}]},fragment:{module:c,entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}}),d=s.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:l.createView()},{binding:2,resource:u}]}),f=new Float32Array([-1,-1,0,0,1,1,-1,0,1,1,-1,1,0,0,0,-1,1,0,0,0,1,-1,0,1,1,1,1,0,1,0]),p=s.createBuffer({size:f.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(p,0,f);const g=s.createCommandEncoder(),m=g.beginRenderPass({colorAttachments:[{view:r.createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]});m.setPipeline(h),m.setBindGroup(0,d),m.setVertexBuffer(0,p),m.draw(6,1,0,0),m.end();const b=e*4,v=256,y=Math.ceil(b/v)*v,C=s.createBuffer({size:y*n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});g.copyTextureToBuffer({texture:r},{buffer:C,bytesPerRow:y},[e,n]),s.queue.submit([g.finish()]),await C.mapAsync(GPUMapMode.READ);const I=C.getMappedRange(),$=document.createElement("canvas");$.width=e,$.height=n;const T=$.getContext("2d");if(!T)throw new Error("Could not get 2d context");const S=new Uint8Array(I),E=T.createImageData(e,n);for(let _=0;_<n;_++){const N=_*y,P=_*e*4;for(let M=0;M<e;M++){const z=N+M*4,A=P+M*4;E.data[A]=S[z+2],E.data[A+1]=S[z+1],E.data[A+2]=S[z],E.data[A+3]=S[z+3]}}return T.putImageData(E,0,0),C.unmap(),$.toDataURL("image/png")}const XF=`
struct Uniforms {
    viewMatrix : mat4x4<f32>, // 
    
    // ---  ---
    tileSize : f32,         // 
    ringScale : f32,
    ringDistortion : f32,
    knotIntensity : f32,
    latewoodBias : f32,     //  ( vs )
    rayStrength : f32,
    poreDensity : f32,
    
    padding : f32, 
    
    // ---  ---
    fbmOctaves : f32,
    fbmAmplitude : f32,
    knotFrequency : f32,
    distortionFreq : f32,
    ringNoiseFreq : f32,
    rayFrequencyX : f32,
    rayFrequencyY : f32,
    knotThresholdMin : f32,
    knotThresholdMax : f32,
    normalStrength : f32,
    roughnessMin : f32,
    roughnessMax : f32,
    
    // ---  ---
    poreScale : f32,
    poreThresholdEarly : f32,
    poreThresholdLate : f32,
    poreThresholdRange : f32,
    poreStrength : f32,
};

struct VertexOutput {
    @builtin(position) Position : vec4<f32>,
    @location(0) uv : vec2<f32>,
};

// 
fn hash3_periodic(p: vec3<f32>, period: vec3<f32>) -> vec3<f32> {
    let wrappedP = p % period; 
    
    var q = vec3<f32>(dot(wrappedP, vec3<f32>(127.1, 311.7, 74.7)),
                      dot(wrappedP, vec3<f32>(269.5, 183.3, 246.1)),
                      dot(wrappedP, vec3<f32>(113.5, 271.9, 124.6)));
    return -1.0 + 2.0 * fract(sin(q) * 43758.5453123);
}

//  Gradient Noise
fn periodicNoise(p: vec3<f32>, period: f32) -> f32 {
    let p_vec = vec3<f32>(period);
    let i = floor(p);
    let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f);

    return mix(mix(mix(dot(hash3_periodic(i + vec3<f32>(0.0,0.0,0.0), p_vec), f - vec3<f32>(0.0,0.0,0.0)),
                       dot(hash3_periodic(i + vec3<f32>(1.0,0.0,0.0), p_vec), f - vec3<f32>(1.0,0.0,0.0)), u.x),
                   mix(dot(hash3_periodic(i + vec3<f32>(0.0,1.0,0.0), p_vec), f - vec3<f32>(0.0,1.0,0.0)),
                       dot(hash3_periodic(i + vec3<f32>(1.0,1.0,0.0), p_vec), f - vec3<f32>(1.0,1.0,0.0)), u.x), u.y),
               mix(mix(dot(hash3_periodic(i + vec3<f32>(0.0,0.0,1.0), p_vec), f - vec3<f32>(0.0,0.0,1.0)),
                       dot(hash3_periodic(i + vec3<f32>(1.0,0.0,1.0), p_vec), f - vec3<f32>(1.0,0.0,1.0)), u.x),
                   mix(dot(hash3_periodic(i + vec3<f32>(0.0,1.0,1.0), p_vec), f - vec3<f32>(0.0,1.0,1.0)),
                       dot(hash3_periodic(i + vec3<f32>(1.0,1.0,1.0), p_vec), f - vec3<f32>(1.0,1.0,1.0)), u.x), u.y), u.z);
}

//  FBM
fn periodicFbm(p: vec3<f32>, octaves: i32, period: f32, initialAmplitude: f32) -> f32 {
    var value = 0.0;
    var amplitude = initialAmplitude;
    var currentPeriod = period;
    var pos = p;
    
    for (var i = 0; i < 5; i++) {
        if (i >= octaves) { break; }
        value = value + periodicNoise(pos, currentPeriod) * amplitude;
        pos = pos * 2.0;
        currentPeriod = currentPeriod * 2.0;
        amplitude = amplitude * 0.5;
    }
    return value;
}

// 
//  vec4: (finalDensity, ringSignal, pores, raysVisible)
fn getWoodDetail(uv: vec2<f32>, u: Uniforms) -> vec4<f32> {
    let scale = u.tileSize;
    var pos = vec3<f32>(uv * scale, 0.0);
    
    // 1. 
    let knotNoise = periodicNoise(pos * u.knotFrequency, scale * u.knotFrequency);
    let knotFactor = smoothstep(u.knotThresholdMin, u.knotThresholdMax, abs(knotNoise)) * u.knotIntensity;
    
    // 2. 
    let octaves = i32(u.fbmOctaves);
    var distortion = periodicFbm(pos * u.distortionFreq, octaves, scale * u.distortionFreq, u.fbmAmplitude);
    let finalPos = pos + vec3<f32>(distortion, distortion, 0.0) * (u.ringDistortion + knotFactor * 4.0);
    
    // 3. 
    let dist = finalPos.x; 
    
    // 4. 
    let ringPhase = dist * u.ringScale;
    let ringCycle = ringPhase - floor(ringPhase);
    let ringProfile = pow(ringCycle, u.latewoodBias);
    
    let ringNoise = periodicNoise(pos * u.ringNoiseFreq, scale * u.ringNoiseFreq);
    let ringSignal = smoothstep(0.1, 0.9, ringProfile + ringNoise * 0.1);
    
    let colorVariation = periodicNoise(pos * 3.0, scale * 3.0) * 0.08;

    // 5. 
    let rayNoise = periodicNoise(vec3<f32>(pos.x * u.rayFrequencyX * 2.0, pos.y * u.rayFrequencyY, 0.0), scale * u.rayFrequencyX * 2.0);
    let rayPattern = abs(rayNoise);
    let rays = smoothstep(0.1, 0.3, rayPattern) * u.rayStrength;
    let earlywoodWeight = ringSignal;
    let raysVisible = rays * (0.1 + earlywoodWeight * 0.9);
    
    // 6.  - 
    let poreFreq = u.poreDensity * u.poreScale;
    // 
    let poreNoise1 = periodicNoise(pos * poreFreq * 3.0, scale * poreFreq * 3.0);
    let poreNoise2 = periodicNoise(pos * poreFreq * 6.0 + vec3<f32>(0.5, 0.5, 0.0), scale * poreFreq * 6.0);
    let poreNoise3 = periodicNoise(pos * poreFreq * 12.0 + vec3<f32>(0.2, 0.8, 0.0), scale * poreFreq * 12.0);
    
    // 
    let poreNoiseMixed = (poreNoise1 * 0.5 + poreNoise2 * 0.8 + poreNoise3 * 1.2) / 2.5;
    let poreNoise01 = poreNoiseMixed * 0.5 + 0.5;
    
    // 
    let poreThresholdMin = mix(u.poreThresholdLate, u.poreThresholdEarly, earlywoodWeight);
    let poreThresholdMax = poreThresholdMin + u.poreThresholdRange;
    
    // smoothstep
    let porePattern = smoothstep(poreThresholdMin, poreThresholdMax, poreNoise01);
    // 1.02.5
    let pores = porePattern * u.poreStrength * 2.5;

    // 
    var finalDensity = ringSignal + colorVariation;
    // 
    finalDensity = finalDensity - pores;
    // 
    finalDensity = finalDensity + raysVisible * 0.3;
    finalDensity = clamp(finalDensity, 0.0, 1.0);

    return vec4<f32>(finalDensity, ringSignal, pores, raysVisible);
}
`,qF=`
${XF}

@group(0) @binding(0) var<uniform> u : Uniforms;

struct GrayscaleOutput {
    @location(0) grayscale : vec4<f32>,   // RfinalDensity
    @location(1) structure : vec4<f32>,   // RGBA(ringSignal, pores, rays, unused)
};

@vertex
fn vs_main(@location(0) position : vec3<f32>, @location(1) uv : vec2<f32>) -> VertexOutput {
    var output : VertexOutput;
    output.Position = vec4<f32>(position, 1.0);
    output.uv = uv;
    return output;
}

@fragment
fn fs_main(in : VertexOutput) -> GrayscaleOutput {
    let data = getWoodDetail(in.uv, u);
    
    var output : GrayscaleOutput;
    // finalDensityRGB
    output.grayscale = vec4<f32>(data.x, data.x, data.x, 1.0);
    // 
    output.structure = data;
    
    return output;
}
`,YF=`
struct VertexOutput {
    @builtin(position) Position : vec4<f32>,
    @location(0) uv : vec2<f32>,
};

@group(0) @binding(0) var grayscaleTexture : texture_2d<f32>;
@group(0) @binding(1) var textureSampler : sampler;
@group(0) @binding(2) var gradientTexture : texture_2d<f32>;
@group(0) @binding(3) var gradientSampler : sampler;

@vertex
fn vs_main(@location(0) position : vec3<f32>, @location(1) uv : vec2<f32>) -> VertexOutput {
    var output : VertexOutput;
    output.Position = vec4<f32>(position, 1.0);
    output.uv = uv;
    return output;
}

@fragment
fn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {
    // 
    let density = textureSample(grayscaleTexture, textureSampler, in.uv).r;
    
    // 
    let albedo = textureSample(gradientTexture, gradientSampler, vec2<f32>(density, 0.5));
    
    return albedo;
}
`,ZF=`
struct Uniforms {
    normalStrength : f32,
    roughnessMin : f32,
    roughnessMax : f32,
    padding : f32,
};

struct VertexOutput {
    @builtin(position) Position : vec4<f32>,
    @location(0) uv : vec2<f32>,
};

@group(0) @binding(0) var<uniform> u : Uniforms;
@group(0) @binding(1) var grayscaleTexture : texture_2d<f32>;
@group(0) @binding(2) var structureTexture : texture_2d<f32>;
@group(0) @binding(3) var textureSampler : sampler;

struct PBROutput {
    @location(0) normal : vec4<f32>,
    @location(1) roughness : vec4<f32>,
};

@vertex
fn vs_main(@location(0) position : vec3<f32>, @location(1) uv : vec2<f32>) -> VertexOutput {
    var output : VertexOutput;
    output.Position = vec4<f32>(position, 1.0);
    output.uv = uv;
    return output;
}

@fragment
fn fs_main(in : VertexOutput) -> PBROutput {
    let density = textureSample(grayscaleTexture, textureSampler, in.uv).r;
    let structure = textureSample(structureTexture, textureSampler, in.uv);
    
    // ringSignal
    let roughness = mix(u.roughnessMin, u.roughnessMax, structure.y);
    
    // 
    let height = density * 0.1 - structure.z * 0.05;
    
    // 
    let dHdUV = vec2<f32>(dpdx(height), dpdy(height));
    let normal = normalize(vec3<f32>(-dHdUV.x * u.normalStrength, -dHdUV.y * u.normalStrength, 1.0));
    
    // [0,1]
    let encodedNormal = normal * 0.5 + 0.5;
    
    var output : PBROutput;
    output.normal = vec4<f32>(encodedNormal, 1.0);
    output.roughness = vec4<f32>(roughness, roughness, roughness, 1.0);
    
    return output;
}
`,Vk={tileSize:1,ringScale:8,ringDistortion:1,knotIntensity:1,latewoodBias:.8,rayStrength:.6,poreDensity:20,gradientStops:[{offset:0,color:"#734F33"},{offset:1,color:"#DCC8A9"}],fbmOctaves:3,fbmAmplitude:.5,knotFrequency:.8,distortionFreq:1.5,ringNoiseFreq:5,rayFrequencyX:30,rayFrequencyY:8,knotThresholdMin:.4,knotThresholdMax:.8,normalStrength:8,roughnessMin:.35,roughnessMax:.7,poreScale:1,poreThresholdEarly:.45,poreThresholdLate:.65,poreThresholdRange:.15,poreStrength:.2};function QF(t,e){const r=document.createElement("canvas");r.width=256,r.height=1;const i=r.getContext("2d");if(!i)throw new Error("Could not get 2d context");const o=i.createLinearGradient(0,0,256,0);[...e].sort((c,h)=>c.offset-h.offset).forEach(c=>{o.addColorStop(c.offset,c.color)}),i.fillStyle=o,i.fillRect(0,0,256,1);const l=i.getImageData(0,0,256,1),u=t.createTexture({size:[256,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});return t.queue.writeTexture({texture:u},l.data,{bytesPerRow:256*4},[256,1]),u}function Jy(t){const e=new Float32Array([-1,-1,0,0,1,1,-1,0,1,1,-1,1,0,0,0,-1,1,0,0,0,1,-1,0,1,1,1,1,0,1,0]),n=t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});return t.queue.writeBuffer(n,0,e),n}function JF(t,e){const n=new Float32Array(44);n[0]=1,n[5]=1,n[10]=1,n[15]=1,n[16]=e.tileSize,n[17]=e.ringScale,n[18]=e.ringDistortion,n[19]=e.knotIntensity,n[20]=e.latewoodBias,n[21]=e.rayStrength,n[22]=e.poreDensity,n[23]=0,n[24]=e.fbmOctaves,n[25]=e.fbmAmplitude,n[26]=e.knotFrequency,n[27]=e.distortionFreq,n[28]=e.ringNoiseFreq,n[29]=e.rayFrequencyX,n[30]=e.rayFrequencyY,n[31]=e.knotThresholdMin,n[32]=e.knotThresholdMax,n[33]=e.normalStrength,n[34]=e.roughnessMin,n[35]=e.roughnessMax,n[36]=e.poreScale,n[37]=e.poreThresholdEarly,n[38]=e.poreThresholdLate,n[39]=e.poreThresholdRange,n[40]=e.poreStrength,n[41]=0,n[42]=0,n[43]=0;const s=t.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return t.queue.writeBuffer(s,0,n),s}async function e5(t,e,n,s){const i=n*4,o=256,a=Math.ceil(i/o)*o,l=t.createBuffer({size:a*s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),u=t.createCommandEncoder();u.copyTextureToBuffer({texture:e},{buffer:l,bytesPerRow:a},[n,s]),t.queue.submit([u.finish()]),await l.mapAsync(GPUMapMode.READ);const c=l.getMappedRange(),h=document.createElement("canvas");h.width=n,h.height=s;const d=h.getContext("2d");if(!d)throw new Error("Could not get 2d context");const f=new Uint8Array(c),p=d.createImageData(n,s);for(let g=0;g<s;g++){const m=g*a,x=g*n*4;for(let b=0;b<n;b++){const v=m+b*4,y=x+b*4;p.data[y]=f[v+2],p.data[y+1]=f[v+1],p.data[y+2]=f[v],p.data[y+3]=f[v+3]}}return d.putImageData(p,0,0),l.unmap(),h.toDataURL("image/png")}async function t5(t,e,n,s){const r=t.createTexture({size:[n,s],format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),i=t.createTexture({size:[n,s],format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),o=JF(t,e),a=Jy(t),l=t.createShaderModule({code:qF}),u=t.createRenderPipeline({layout:"auto",vertex:{module:l,entryPoint:"vs_main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}]}]},fragment:{module:l,entryPoint:"fs_main",targets:[{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list"}}),c=t.createBindGroup({layout:u.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:o}}]}),h=t.createCommandEncoder(),d=h.beginRenderPass({colorAttachments:[{view:r.createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"},{view:i.createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]});return d.setPipeline(u),d.setBindGroup(0,c),d.setVertexBuffer(0,a),d.draw(6,1,0,0),d.end(),t.queue.submit([h.finish()]),{grayscale:r,structure:i}}async function n5(t,e,n,s,r){const i=t.createTexture({size:[s,r],format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),o=QF(t,e.gradientStops),a=Jy(t),l=t.createSampler({magFilter:"linear",minFilter:"linear"}),u=t.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),c=t.createShaderModule({code:YF}),h=t.createRenderPipeline({layout:"auto",vertex:{module:c,entryPoint:"vs_main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}]}]},fragment:{module:c,entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}}),d=t.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:n.createView()},{binding:1,resource:l},{binding:2,resource:o.createView()},{binding:3,resource:u}]}),f=t.createCommandEncoder(),p=f.beginRenderPass({colorAttachments:[{view:i.createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]});return p.setPipeline(h),p.setBindGroup(0,d),p.setVertexBuffer(0,a),p.draw(6,1,0,0),p.end(),t.queue.submit([f.finish()]),i}async function s5(t,e,n,s,r,i){const o=t.createTexture({size:[r,i],format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),a=t.createTexture({size:[r,i],format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),l=new Float32Array(4);l[0]=e.normalStrength,l[1]=e.roughnessMin,l[2]=e.roughnessMax,l[3]=0;const u=t.createBuffer({size:l.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});t.queue.writeBuffer(u,0,l);const c=Jy(t),h=t.createSampler({magFilter:"linear",minFilter:"linear"}),d=t.createShaderModule({code:ZF}),f=t.createRenderPipeline({layout:"auto",vertex:{module:d,entryPoint:"vs_main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}]}]},fragment:{module:d,entryPoint:"fs_main",targets:[{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list"}}),p=t.createBindGroup({layout:f.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:u}},{binding:1,resource:n.createView()},{binding:2,resource:s.createView()},{binding:3,resource:h}]}),g=t.createCommandEncoder(),m=g.beginRenderPass({colorAttachments:[{view:o.createView(),loadOp:"clear",clearValue:{r:.5,g:.5,b:1,a:1},storeOp:"store"},{view:a.createView(),loadOp:"clear",clearValue:{r:.5,g:.5,b:.5,a:1},storeOp:"store"}]});return m.setPipeline(f),m.setBindGroup(0,p),m.setVertexBuffer(0,c),m.draw(6,1,0,0),m.end(),t.queue.submit([g.finish()]),{normal:o,roughness:a}}async function r5(t,e,n,s={}){const r=await Ts();if(!r)throw new Error("WebGPU not supported");const{grayscale:i,structure:o}=await t5(r,t,e,n),a=await n5(r,t,i,e,n),l={grayscale:{buffer:i,width:e,height:n},structure:{buffer:o,width:e,height:n},albedo:{buffer:a,width:e,height:n}};if(s.includePBR){const{normal:u,roughness:c}=await s5(r,t,i,o,e,n);l.normal={buffer:u,width:e,height:n},l.roughness={buffer:c,width:e,height:n}}return l}async function i5(t,e,n){const s=await Ts();if(!s)throw new Error("WebGPU not supported");const r=await r5(t,e,n,{includePBR:!1});return e5(s,r.albedo.buffer,e,n)}const jg=`
fn hash22(p: vec2<f32>) -> vec2<f32> {
    var p3 = fract(vec3<f32>(p.xyx) * vec3<f32>(.1031, .1030, .0973));
    p3 = p3 + dot(p3, p3.yzx + 33.33);
    return fract((p3.xx+p3.yz)*p3.zy);
}

//  - 
fn hash22Periodic(p: vec2<f32>, period: vec2<f32>) -> vec2<f32> {
    let wrapped = ((p % period) + period) % period;
    var p3 = fract(vec3<f32>(wrapped.xyx) * vec3<f32>(.1031, .1030, .0973));
    p3 = p3 + dot(p3, p3.yzx + 33.33);
    return fract((p3.xx+p3.yz)*p3.zy);
}

fn gradientNoise(p: vec2<f32>, scale: f32) -> f32 {
    let i = floor(p * scale);
    let f = fract(p * scale);
    let u = f * f * (3.0 - 2.0 * f);
    
    let g00 = hash22(i + vec2<f32>(0.0,0.0)) * 2.0 - 1.0;
    let g10 = hash22(i + vec2<f32>(1.0,0.0)) * 2.0 - 1.0;
    let g01 = hash22(i + vec2<f32>(0.0,1.0)) * 2.0 - 1.0;
    let g11 = hash22(i + vec2<f32>(1.0,1.0)) * 2.0 - 1.0;
    
    let val = mix(
        mix(dot(g00, f - vec2<f32>(0.0,0.0)), dot(g10, f - vec2<f32>(1.0,0.0)), u.x),
        mix(dot(g01, f - vec2<f32>(0.0,1.0)), dot(g11, f - vec2<f32>(1.0,1.0)), u.x),
        u.y);
    return 0.5 + 0.5 * val;
}

//  - 
fn periodicGradientNoise(p: vec2<f32>, scale: f32, period: vec2<f32>) -> f32 {
    let scaledP = p * scale;
    let i = floor(scaledP);
    let f = fract(scaledP);
    let u = f * f * (3.0 - 2.0 * f);
    
    // 
    let periodScaled = period * scale;
    
    let i00 = ((i + vec2<f32>(0.0,0.0)) % periodScaled + periodScaled) % periodScaled;
    let i10 = ((i + vec2<f32>(1.0,0.0)) % periodScaled + periodScaled) % periodScaled;
    let i01 = ((i + vec2<f32>(0.0,1.0)) % periodScaled + periodScaled) % periodScaled;
    let i11 = ((i + vec2<f32>(1.0,1.0)) % periodScaled + periodScaled) % periodScaled;
    
    let g00 = hash22Periodic(i00, periodScaled) * 2.0 - 1.0;
    let g10 = hash22Periodic(i10, periodScaled) * 2.0 - 1.0;
    let g01 = hash22Periodic(i01, periodScaled) * 2.0 - 1.0;
    let g11 = hash22Periodic(i11, periodScaled) * 2.0 - 1.0;
    
    let val = mix(
        mix(dot(g00, f - vec2<f32>(0.0,0.0)), dot(g10, f - vec2<f32>(1.0,0.0)), u.x),
        mix(dot(g01, f - vec2<f32>(0.0,1.0)), dot(g11, f - vec2<f32>(1.0,1.0)), u.x),
        u.y);
    return 0.5 + 0.5 * val;
}

fn voronoi(uv: vec2<f32>, density: f32) -> f32 {
    let p = uv * density;
    let i = floor(p);
    let f = fract(p);
    var minDist = 1.0;
    for(var y=-1; y<=1; y++) {
        for(var x=-1; x<=1; x++) {
            let neighbor = vec2<f32>(f32(x), f32(y));
            let point = hash22(i + neighbor);
            let diff = neighbor + point - f;
            let dist = length(diff);
            minDist = min(minDist, dist);
        }
    }
    return smoothstep(0.0, 0.4, minDist);
}


fn sampleBilinear(tex: texture_2d<f32>, uv: vec2<f32>) -> vec4<f32> {
    let dims = vec2<f32>(textureDimensions(tex));
    let st = uv * dims - 0.5;
    let iuv = floor(st);
    let fuv = fract(st);
    let dimi = vec2<i32>(dims);
    
    let p00_raw = vec2<i32>(iuv);
    let p10_raw = p00_raw + vec2<i32>(1, 0);
    let p01_raw = p00_raw + vec2<i32>(0, 1);
    let p11_raw = p00_raw + vec2<i32>(1, 1);

    let c00 = ((p00_raw % dimi) + dimi) % dimi;
    let c10 = ((p10_raw % dimi) + dimi) % dimi;
    let c01 = ((p01_raw % dimi) + dimi) % dimi;
    let c11 = ((p11_raw % dimi) + dimi) % dimi;

    let v00 = textureLoad(tex, c00, 0);
    let v10 = textureLoad(tex, c10, 0);
    let v01 = textureLoad(tex, c01, 0);
    let v11 = textureLoad(tex, c11, 0);

    return mix(
        mix(v00, v10, fuv.x),
        mix(v01, v11, fuv.x),
        fuv.y
    );
}
`,o5=jg+`

struct SimParams {
    actRadius: f32, inhRadius: f32,
    curvature: f32, anisotropy: f32,
    angle: f32, 
    varScale: f32, varStr: f32,
    seed: f32,
    padding1: f32, padding2: f32, padding3: f32
};

@group(0) @binding(0) var<uniform> sim : SimParams;
// Binding 1 skipped (inputTex not needed for init)
@group(0) @binding(2) var outputTex : texture_storage_2d<rgba32float, write>;

fn rotate(v: vec2<f32>, a: f32) -> vec2<f32> {
    let s = sin(a);
    let c = cos(a);
    return vec2<f32>(v.x * c - v.y * s, v.x * s + v.y * c);
}

@compute @workgroup_size(8, 8)
fn init_main(@builtin(global_invocation_id) id : vec3<u32>) {
    let dims = textureDimensions(outputTex);
    let coords = vec2<i32>(id.xy);
    if (coords.x >= i32(dims.x) || coords.y >= i32(dims.y)) { return; }
    
    // 
    let uv = vec2<f32>(coords) / vec2<f32>(dims);
    let period = vec2<f32>(1.0, 1.0); // 1.0UV
    
    // 
    let n1 = periodicGradientNoise(uv + vec2<f32>(sim.seed), 8.0, period);
    let n2 = periodicGradientNoise(uv + vec2<f32>(sim.seed * 1.7), 16.0, period);
    let n = n1 * 0.6 + n2 * 0.4;
    // 0.3-0.7,
    let centered = 0.5 + (n - 0.5) * 0.4;
    
    textureStore(outputTex, coords, vec4<f32>(centered, 0.0, 0.0, 1.0));
}
`,a5=jg+`

struct SimParams {
    actRadius: f32, inhRadius: f32,
    curvature: f32, anisotropy: f32,
    angle: f32, 
    varScale: f32, varStr: f32,
    seed: f32,
    padding1: f32, padding2: f32, padding3: f32
};

@group(0) @binding(0) var<uniform> sim : SimParams;
@group(0) @binding(1) var inputTex : texture_2d<f32>;
@group(0) @binding(2) var outputTex : texture_storage_2d<rgba32float, write>;

fn rotate(v: vec2<f32>, a: f32) -> vec2<f32> {
    let s = sin(a);
    let c = cos(a);
    return vec2<f32>(v.x * c - v.y * s, v.x * s + v.y * c);
}

@compute @workgroup_size(8, 8)
fn cs_main(@builtin(global_invocation_id) id : vec3<u32>) {
    let dims = textureDimensions(inputTex);
    let coords = vec2<i32>(id.xy);
    if (coords.x >= i32(dims.x) || coords.y >= i32(dims.y)) { return; }

    let current = textureLoad(inputTex, coords, 0).r;
    let uv = vec2<f32>(coords) / vec2<f32>(dims);

    //  - 
    let period = vec2<f32>(1.0, 1.0);
    let noiseVar = periodicGradientNoise(uv, sim.varScale, period);
    let localActR = sim.actRadius * (1.0 + (noiseVar - 0.5) * sim.varStr);
    let localInhR = sim.inhRadius * (1.0 - (noiseVar - 0.5) * sim.varStr);

    // 
    var sumAct = 0.0;
    var sumInh = 0.0;
    let sampleCount = 32;
    let step = 6.28318 / f32(sampleCount);
    
    let rot = -sim.angle;
    let stretch = 1.0 + sim.anisotropy * 2.0;
    
    for(var i = 0; i < sampleCount; i++) {
        let angle = f32(i) * step;
        var offset = vec2<f32>(cos(angle), sin(angle));
        offset = rotate(offset, rot);
        offset.y *= stretch;

        let posAct = vec2<f32>(coords) + offset * localActR;
        let pAct = vec2<i32>(round(posAct));
        let dimi = vec2<i32>(dims);
        let wAct = ((pAct % dimi) + dimi) % dimi;
        sumAct += textureLoad(inputTex, wAct, 0).r;

        let posInh = vec2<f32>(coords) + offset * localInhR;
        let pInh = vec2<i32>(round(posInh));
        let wInh = ((pInh % dimi) + dimi) % dimi;
        sumInh += textureLoad(inputTex, wInh, 0).r;
    }

    let avgAct = sumAct / f32(sampleCount);
    let avgInh = sumInh / f32(sampleCount);

    var variation = avgAct - avgInh;
    
    // 
    let delta = variation * 0.02;
    let newVal = current + delta;
    
    // tanh
    // : 0.50.5
    let bounded = 0.5 + 0.5 * tanh(2.0 * (newVal - 0.5));

    textureStore(outputTex, coords, vec4<f32>(bounded, abs(variation) * 10.0, 0.0, 1.0));
}
`,l5=`
@group(0) @binding(0) var sourceTex : texture_2d<f32>;
@group(0) @binding(1) var<storage, read_write> minMax : array<atomic<i32>, 2>;

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) id : vec3<u32>) {
    let dims = textureDimensions(sourceTex);
    if (id.x >= dims.x || id.y >= dims.y) { return; }
    
    let val = textureLoad(sourceTex, vec2<i32>(id.xy), 0).r;
    
    // Map float [0.0, 1.0] to int [0, 1000000] for atomic operations
    let valInt = i32(val * 1000000.0);
    
    atomicMin(&minMax[0], valInt);
    atomicMax(&minMax[1], valInt);
}
`,u5=jg+`
struct RenderUniforms {
    tileSize : f32,
    contrast: f32, 
    bias: f32,
    padding1: f32
};

@group(0) @binding(0) var<uniform> u : RenderUniforms;
@group(0) @binding(1) var simTex : texture_2d<f32>;
@group(0) @binding(2) var smp : sampler;
// 
@group(0) @binding(3) var<storage, read> minMaxBuf : array<i32, 2>;

struct VertexOutput {
    @builtin(position) Pos : vec4<f32>,
    @location(0) uv : vec2<f32>,
};

@vertex
fn vs_main(@location(0) pos : vec3<f32>, @location(1) uv : vec2<f32>) -> VertexOutput {
    var out : VertexOutput;
    out.Pos = vec4<f32>(pos, 1.0);
    out.uv = uv;
    return out;
}

@fragment
fn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {
    let dims = vec2<f32>(textureDimensions(simTex));
    let coords = vec2<i32>(in.uv * dims);
    let simData = textureLoad(simTex, coords, 0);
    
    //  (G abs(variation) * 10.0)
    // 
    let variation = simData.g;
    
    //  R 
    let pattern = simData.r;
    
    //  variation  pattern
    return vec4<f32>(variation, variation, variation, 1.0);
}
`,c5=jg+`
struct MaterialUniforms {
    tileSize : f32,
    contrast: f32, 
    bias: f32,
    padding1: f32
};

@group(0) @binding(0) var<uniform> u : MaterialUniforms;
@group(0) @binding(1) var grayTex : texture_2d<f32>;  // 
@group(0) @binding(2) var smp : sampler;
@group(0) @binding(3) var<storage, read> minMaxBuf : array<i32, 2>; // Just for layout compatibility

struct VertexOutput {
    @builtin(position) Pos : vec4<f32>,
    @location(0) uv : vec2<f32>,
};

@vertex
fn vs_main(@location(0) pos : vec3<f32>, @location(1) uv : vec2<f32>) -> VertexOutput {
    var out : VertexOutput;
    out.Pos = vec4<f32>(pos, 1.0);
    out.uv = uv;
    return out;
}

@fragment
fn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {
    // 1. Just sample the gray texture
    let dims = vec2<f32>(textureDimensions(grayTex));
    let coords = vec2<i32>(in.uv * dims);
    let gray = textureLoad(grayTex, coords, 0).r;
    
    // Passthrough
    return vec4<f32>(gray, gray, gray, 1.0);
}
`,h5={tileSize:1,simulationSteps:100,activatorRadius:1.5,inhibitorRadius:4,curvature:.55,diffusionAnisotropy:.2,flowDirection:0,variationScale:1.5,variationStrength:.5,contrast:1,bias:0};async function d5(t,e,n){const s=await Ts();if(!s)throw new Error("WebGPU Unsupported");const r={size:[e,n],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST},i=s.createTexture(r),o=s.createTexture(r),a=12*4,l=s.createBuffer({size:Math.ceil(a/16)*16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),u=new Float32Array(l.getMappedRange());u[0]=t.activatorRadius,u[1]=t.inhibitorRadius,u[2]=t.curvature,u[3]=t.diffusionAnisotropy,u[4]=t.flowDirection,u[5]=t.variationScale,u[6]=t.variationStrength,u[7]=Math.random()*1e3,l.unmap();const c=4*4,h=s.createBuffer({size:c,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),d=new Float32Array(h.getMappedRange());d[0]=t.tileSize&&t.tileSize>0?t.tileSize:1,d[1]=t.contrast,d[2]=t.bias,d[3]=0,h.unmap();const f=s.createBuffer({size:8,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Int32Array(f.getMappedRange()).set([2147483647,-2147483647]),f.unmap();const p=s.createShaderModule({code:o5}),g=s.createShaderModule({code:a5}),m=s.createShaderModule({code:u5}),x=s.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float"}}]}),b=s.createComputePipeline({layout:s.createPipelineLayout({bindGroupLayouts:[x]}),compute:{module:p,entryPoint:"init_main"}}),v=s.createBindGroup({layout:x,entries:[{binding:0,resource:{buffer:l}},{binding:2,resource:i.createView()}]}),y=s.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float"}}]}),C=s.createComputePipeline({layout:s.createPipelineLayout({bindGroupLayouts:[y]}),compute:{module:g,entryPoint:"cs_main"}}),I=s.createBindGroup({layout:y,entries:[{binding:0,resource:{buffer:l}},{binding:1,resource:i.createView()},{binding:2,resource:o.createView()}]}),$=s.createBindGroup({layout:y,entries:[{binding:0,resource:{buffer:l}},{binding:1,resource:o.createView()},{binding:2,resource:i.createView()}]}),T=s.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"non-filtering"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]}),S=s.createShaderModule({code:l5}),E=s.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),_=s.createComputePipeline({layout:s.createPipelineLayout({bindGroupLayouts:[E]}),compute:{module:S,entryPoint:"main"}}),N=s.createRenderPipeline({layout:s.createPipelineLayout({bindGroupLayouts:[T]}),vertex:{module:m,entryPoint:"vs_main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}]}]},fragment:{module:m,entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}}),P=s.createShaderModule({code:c5}),M=s.createRenderPipeline({layout:s.createPipelineLayout({bindGroupLayouts:[T]}),vertex:{module:P,entryPoint:"vs_main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}]}]},fragment:{module:P,entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}}),z=Math.ceil(e/8),A=Math.ceil(n/8),B=s.createCommandEncoder();{const pe=B.beginComputePass();pe.setPipeline(b),pe.setBindGroup(0,v),pe.dispatchWorkgroups(z,A),pe.end()}const L=t.simulationSteps>0?t.simulationSteps:100;for(let pe=0;pe<L;pe++){const me=B.beginComputePass();me.setPipeline(C),pe%2===0?me.setBindGroup(0,I):me.setBindGroup(0,$),me.dispatchWorkgroups(z,A),me.end()}const U=L%2===0?i:o;{const pe=new Int32Array([2147483647,-2147483647]);s.queue.writeBuffer(f,0,pe);const me=s.createBindGroup({layout:E,entries:[{binding:0,resource:U.createView()},{binding:1,resource:{buffer:f}}]}),xe=B.beginComputePass();xe.setPipeline(_),xe.setBindGroup(0,me),xe.dispatchWorkgroups(Math.ceil(e/16),Math.ceil(n/16)),xe.end()}const j=s.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"repeat",addressModeV:"repeat"}),Z=s.createTexture({size:[e,n],format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),J=s.createTexture({size:[e,n],format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),se=new Float32Array([-1,-1,0,0,1,1,-1,0,1,1,-1,1,0,0,0,-1,1,0,0,0,1,-1,0,1,1,1,1,0,1,0]),fe=s.createBuffer({size:se.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(fe.getMappedRange()).set(se),fe.unmap();const he=B.beginRenderPass({colorAttachments:[{view:Z.createView(),loadOp:"clear",clearValue:{r:1,g:0,b:0,a:1},storeOp:"store"}]}),ve=s.createBindGroup({layout:T,entries:[{binding:0,resource:{buffer:h}},{binding:1,resource:U.createView()},{binding:2,resource:j},{binding:3,resource:{buffer:f}}]});he.setPipeline(N),he.setBindGroup(0,ve),he.setVertexBuffer(0,fe),he.draw(6,1,0,0),he.end();const Pe=B.beginRenderPass({colorAttachments:[{view:J.createView(),loadOp:"clear",clearValue:{r:0,g:0,b:1,a:1},storeOp:"store"}]}),Ee=s.createBindGroup({layout:T,entries:[{binding:0,resource:{buffer:h}},{binding:1,resource:Z.createView()},{binding:2,resource:j},{binding:3,resource:{buffer:f}}]});Pe.setPipeline(M),Pe.setBindGroup(0,Ee),Pe.setVertexBuffer(0,fe),Pe.draw(6,1,0,0),Pe.end();const Se=Math.ceil(e*4/256)*256,ze=s.createBuffer({size:Se*n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});B.copyTextureToBuffer({texture:J},{buffer:ze,bytesPerRow:Se},[e,n]),s.queue.submit([B.finish()]),await s.queue.onSubmittedWorkDone(),await ze.mapAsync(GPUMapMode.READ);const ke=document.createElement("canvas");ke.width=e,ke.height=n;const H=ke.getContext("2d"),K=H.createImageData(e,n),re=new Uint8Array(ze.getMappedRange());for(let pe=0;pe<n;pe++){const me=pe*Se,xe=pe*e*4;for(let Te=0;Te<e;Te++)K.data[xe+Te*4+0]=re[me+Te*4+2],K.data[xe+Te*4+1]=re[me+Te*4+1],K.data[xe+Te*4+2]=re[me+Te*4+0],K.data[xe+Te*4+3]=255}return H.putImageData(K,0,0),ze.unmap(),ke.toDataURL("image/png")}function f5(t,e,n){e(t),n==null||n("")}function p5(t,e){e(!t)}const wi={LOAD_SAMPLE_IMAGE:"load-sample-image",PROCESS_IMAGE:"process-image",TOGGLE_MAGNIFIER:"toggle-magnifier",RESET_ZOOM:"reset-zoom",SAVE_RESULT:"save-result",SAVE_ORIGINAL:"save-original",OPEN_SAMPLING_EDITOR:"open-sampling-editor",TOGGLE_CAMERA:"toggle-camera",TOGGLE_LUT:"toggle-lut",CLEAR_LUT:"clear-lut"},Pn={IMAGE_UPLOAD:"image-upload",PHOTO_CAPTURED:"photo-captured",CAMERA_ERROR:"camera-error",MAX_RESOLUTION:"max-resolution",BORDER_SIZE:"border-size",SPLIT_POSITION:"split-position",ZOOM_LEVEL:"zoom-level",LUT_INTENSITY:"lut-intensity",LUT_FILE_CHANGE:"lut-file-change",MASK_UPDATE:"mask-update",SET_PREVIEW_OVERLAY:"set-preview-overlay",GLOBAL_HSL_CHANGE:"global-hsl-change",ADD_HSL_LAYER:"add-hsl-layer",UPDATE_HSL_LAYER:"update-hsl-layer",REMOVE_HSL_LAYER:"remove-hsl-layer",EXPOSURE_STRENGTH:"exposure-strength",EXPOSURE_MANUAL:"exposure-manual",DEHAZE_CHANGE:"dehaze-change",CLARITY_ADJUSTMENT:"clarity-adjustment",LUMINANCE_ADJUSTMENT:"luminance-adjustment",SET_IMAGE:"set-image"},FS={BUTTON_CLICK:"button-click",UPDATE_DATA:"update-data"},mb={[wi.LOAD_SAMPLE_IMAGE]:t=>{var e;return(e=t.onLoadSampleImage)==null?void 0:e.call(t)},[wi.PROCESS_IMAGE]:t=>{var e;return(e=t.onProcessImage)==null?void 0:e.call(t)},[wi.TOGGLE_MAGNIFIER]:t=>{var e;return(e=t.onToggleMagnifier)==null?void 0:e.call(t)},[wi.RESET_ZOOM]:t=>{var e;return(e=t.onResetZoom)==null?void 0:e.call(t)},[wi.SAVE_RESULT]:t=>{var e;return(e=t.onSaveResult)==null?void 0:e.call(t)},[wi.SAVE_ORIGINAL]:t=>{var e;return(e=t.onSaveOriginal)==null?void 0:e.call(t)},[wi.OPEN_SAMPLING_EDITOR]:t=>{var e;return(e=t.onOpenSamplingEditor)==null?void 0:e.call(t)},[wi.TOGGLE_CAMERA]:t=>{var e;return(e=t.onToggleCamera)==null?void 0:e.call(t)},[wi.TOGGLE_LUT]:t=>{var e;return(e=t.onToggleLUT)==null?void 0:e.call(t)},[wi.CLEAR_LUT]:t=>{var e;return(e=t.onClearLUT)==null?void 0:e.call(t)}};function m5(t,e){var n;(n=mb[e])==null||n.call(mb,t)}function g5(t,e){var r,i,o,a,l,u,c,h,d,f,p,g,m,x,b,v,y,C,I,$,T;const{action:n,data:s}=e;if(n===Pn.IMAGE_UPLOAD){(r=t.onImageUpload)==null||r.call(t,s);return}if(n===Pn.PHOTO_CAPTURED){(i=t.onPhotoCaptured)==null||i.call(t,s);return}if(n===Pn.CAMERA_ERROR){(o=t.onCameraError)==null||o.call(t,s);return}if(n===Pn.MAX_RESOLUTION){(a=t.onMaxResolution)==null||a.call(t,s);return}if(n===Pn.BORDER_SIZE){(l=t.onBorderSize)==null||l.call(t,s);return}if(n===Pn.SPLIT_POSITION){(u=t.onSplitPosition)==null||u.call(t,s);return}if(n===Pn.ZOOM_LEVEL){(c=t.onZoomLevel)==null||c.call(t,s);return}if(n===Pn.LUT_INTENSITY){(h=t.onLUTIntensity)==null||h.call(t,s);return}if(n===Pn.LUT_FILE_CHANGE){(d=t.onLUTFileChange)==null||d.call(t,s);return}if(n===Pn.MASK_UPDATE){(f=t.onMaskUpdate)==null||f.call(t,s);return}if(n===Pn.SET_PREVIEW_OVERLAY&&s&&typeof s=="object"&&"data"in s&&"component"in s){(p=t.onSetPreviewOverlay)==null||p.call(t,s.data,s.component);return}if(n!==Pn.SET_PREVIEW_OVERLAY){if(n===Pn.GLOBAL_HSL_CHANGE){(g=t.onGlobalHSLChange)==null||g.call(t,s);return}if(n===Pn.ADD_HSL_LAYER){(m=t.onAddHSLLayer)==null||m.call(t,s);return}if(n===Pn.UPDATE_HSL_LAYER){(x=t.onUpdateHSLLayer)==null||x.call(t,s.id,s.updates);return}if(n===Pn.REMOVE_HSL_LAYER){(b=t.onRemoveHSLLayer)==null||b.call(t,s);return}if(n===Pn.EXPOSURE_STRENGTH){(v=t.onExposureStrength)==null||v.call(t,s);return}if(n===Pn.EXPOSURE_MANUAL){(y=t.onExposureManual)==null||y.call(t,s);return}if(n===Pn.DEHAZE_CHANGE){(C=t.onDehazeChange)==null||C.call(t,s);return}if(n===Pn.CLARITY_ADJUSTMENT){(I=t.onClarityAdjustment)==null||I.call(t,s);return}if(n===Pn.LUMINANCE_ADJUSTMENT){($=t.onLuminanceAdjustment)==null||$.call(t,s);return}if(n===Pn.SET_IMAGE){(T=t.onSetImage)==null||T.call(t,s);return}}}function x5(t){return e=>{const{type:n,detail:s}=e;if(n===FS.BUTTON_CLICK){m5(t,s.action);return}n===FS.UPDATE_DATA&&g5(t,s)}}const b5=`
struct Uniforms {
    viewMatrix : mat4x4<f32>,
    tileSize : f32,
    
    warpDensity : f32,
    weftDensity : f32,
    
    threadThickness : f32,
    threadTwist : f32,
    fiberDetail : f32,
    fuzziness : f32,
    
    weaveTightness : f32,
    threadUnevenness : f32,
    weaveImperfection : f32,
    
    warpColor : vec4<f32>, // Using vec4 for alignment, alpha ignored
    weftColor : vec4<f32>,
    
    fbmOctaves : f32,
    fbmAmplitude : f32,
    noiseFrequency : f32,
    colorVariation : f32,
    
    warpSheen : f32,
    weftSheen : f32,
    roughnessMin : f32,
    roughnessMax : f32,
    normalStrength : f32,
    
    threadHeightScale : f32,
    threadShadowStrength : f32,
    padding1: f32,
    
    backgroundColor: vec4<f32>,
    backgroundOpacity: f32,
    padding2: f32,
    padding3: f32,
    padding4: f32,
};

@group(0) @binding(0) var<uniform> u : Uniforms;
// Removed gradient texture bindings

struct VertexOutput {
    @builtin(position) Position : vec4<f32>,
    @location(0) uv : vec2<f32>,
};

${Uk}

// -----------------------------------------------------------
//  (Advanced)
// -----------------------------------------------------------

fn threadProfile(t: f32, thickness: f32, tightness: f32) -> f32 {
    let centered = (t - 0.5) * 2.0 / thickness;
    if (abs(centered) > 1.0) { return 0.0; }
    let base = cos(centered * 1.5707963);
    return pow(base, 0.5 + tightness); 
}

fn threadTwistPattern(pos: vec2<f32>, direction: vec2<f32>, twist: f32, scale: f32) -> f32 {
    let alongThread = dot(pos, direction);
    let twistPhase = sin(alongThread * scale * 2.0 + twist * 20.0);
    return twistPhase * 0.5 + 0.5;
}

fn fiberDetail(pos: vec2<f32>, direction: vec2<f32>, detail: f32, scale: f32, period: f32) -> f32 {
    let perpDir = vec2<f32>(-direction.y, direction.x);
    let fiberPos = vec2<f32>(dot(pos, direction), dot(pos, perpDir) * 10.0); 
    let noise1 = periodicNoise2D(fiberPos * 10.0 * scale, period * 10.0 * scale);
    return noise1 * detail;
}

fn fuzzEffect(pos: vec2<f32>, fuzz: f32, scale: f32, period: f32) -> f32 {
    if (fuzz < 0.01) { return 0.0; }
    let fuzzNoise = periodicNoise2D(pos * 80.0 * scale, period * 80.0 * scale);
    return smoothstep(0.6, 1.0, fuzzNoise) * fuzz;
}

struct WeaveData {
    density : f32,
    height : f32,
    sheen : f32,
    isWarp : bool,
}

fn getPlainWeaveDetail(uv: vec2<f32>) -> WeaveData {
    let scale = u.tileSize;
    let pos = uv * scale;
    
    let warpDensity = u.warpDensity;
    let weftDensity = u.weftDensity;
    
    let u_coord = pos.x * warpDensity;
    let v_coord = pos.y * weftDensity;
    
    let i = floor(u_coord);
    let j = floor(v_coord);
    
    let u_local = fract(u_coord);
    let v_local = fract(v_coord);
    
    // Imperfections
    let imperfection = periodicNoise2D(vec2<f32>(i, j), scale * max(warpDensity, weftDensity)) * u.weaveImperfection * 0.2;
    
    // Thread centers
    let warpCenter = 0.5 + imperfection;
    let weftCenter = 0.5 + imperfection;
    
    let dist_warp = abs(u_local - warpCenter);
    let dist_weft = abs(v_local - weftCenter);
    
    // Unevenness
    let warpThickVar = 1.0 + periodicNoise2D(vec2<f32>(i * 0.5, 0.0), scale * warpDensity * 0.5) * u.threadUnevenness * 0.3;
    let weftThickVar = 1.0 + periodicNoise2D(vec2<f32>(0.0, j * 0.5), scale * weftDensity * 0.5) * u.threadUnevenness * 0.3;
    
    let warpThick = u.threadThickness * warpThickVar;
    let weftThick = u.threadThickness * weftThickVar;
    
    // Profiles
    let warpP = threadProfile(u_local - imperfection, warpThick, u.weaveTightness);
    let weftP = threadProfile(v_local - imperfection, weftThick, u.weaveTightness);
    
    // Undulation
    let warpSign = select(-1.0, 1.0, (i % 2.0) < 0.5);
    let warpPath = sin(v_coord * 3.14159265) * warpSign;
    
    let weftSign = select(1.0, -1.0, (j % 2.0) < 0.5);
    let weftPath = sin(u_coord * 3.14159265) * weftSign;
    
    // Combine
    let amp = u.threadHeightScale * 0.5;
    let warpH = warpPath * amp + warpP * u.threadHeightScale;
    let weftH = weftPath * amp + weftP * u.threadHeightScale;
    
    var h = 0.0;
    var isWarp = true;
    
    let noWarp = warpP < 0.01;
    let noWeft = weftP < 0.01;
    
    if (noWarp && noWeft) {
        h = 0.0;
    } else if (noWarp) {
        h = weftH;
        isWarp = false;
    } else if (noWeft) {
        h = warpH;
        isWarp = true;
    } else {
        if (warpH > weftH) {
            h = warpH;
            isWarp = true;
        } else {
            h = weftH;
            isWarp = false;
        }
    }
    
    // Shading & Details
    var density = h;
    
    // Twist
    var twistVal = 0.0;
    if (isWarp) {
        twistVal = threadTwistPattern(pos, vec2<f32>(0.0, 1.0), u.threadTwist, warpDensity);
    } else {
        twistVal = threadTwistPattern(pos, vec2<f32>(1.0, 0.0), u.threadTwist, weftDensity);
    }
    
    // Fiber
    var fiberVal = 0.0;
    if (isWarp) {
        fiberVal = fiberDetail(pos, vec2<f32>(0.0, 1.0), u.fiberDetail, warpDensity, scale * warpDensity);
    } else {
        fiberVal = fiberDetail(pos, vec2<f32>(1.0, 0.0), u.fiberDetail, weftDensity, scale * weftDensity);
    }
    
    // Fuzz
    let fuzzVal = fuzzEffect(pos, u.fuzziness, max(warpDensity, weftDensity), scale * max(warpDensity, weftDensity));
    
    let depth = 1.0 - h;
    let shadow = depth * u.threadShadowStrength * 0.5;
    
    density = density * (0.9 + twistVal * 0.2);
    density = density + fiberVal * 0.1;
    density = density + fuzzVal * 0.1;
    density = density - shadow;
    
    // Color variation noise
    let colorNoise = periodicFbm(vec3<f32>(pos * u.noiseFrequency, 0.0), i32(u.fbmOctaves), scale * u.noiseFrequency, u.fbmAmplitude);
    density = density + colorNoise * u.colorVariation;
    
    density = clamp(density, 0.0, 1.0);
    
    let sheen = select(u.weftSheen, u.warpSheen, isWarp);
    
    return WeaveData(density, h, sheen, isWarp);
}

@vertex
fn vs_main(@location(0) position : vec3<f32>, @location(1) uv : vec2<f32>) -> VertexOutput {
    var output : VertexOutput;
    output.Position = vec4<f32>(position, 1.0);
    output.uv = uv;
    return output;
}

@fragment
fn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {
    let data = getPlainWeaveDetail(in.uv);
    let density = data.density;
    let height = data.height;
    let sheen = data.sheen;
    let isWarp = data.isWarp;
    
    // Base Color Selection
    let baseColor = select(u.weftColor.rgb, u.warpColor.rgb, isWarp);
    
    // Apply density as scalar lighting/shading
    let albedo = baseColor * density;
    
    let roughness = mix(u.roughnessMin, u.roughnessMax, 1.0 - sheen * 0.8);
    
    let dHdUV = vec2<f32>(dpdx(height), dpdy(height));
    let normal = normalize(vec3<f32>(-dHdUV.x * u.normalStrength, -dHdUV.y * u.normalStrength, 1.0));
    
    let lightDir = normalize(vec3<f32>(0.5, 0.5, 1.0));
    let diff = max(dot(normal, lightDir), 0.0);
    
    let viewDir = vec3<f32>(0.0, 0.0, 1.0);
    let halfDir = normalize(lightDir + viewDir);
    let spec = pow(max(dot(normal, halfDir), 0.0), 32.0 * (1.0 - roughness)) * sheen;
    
    let finalColor = albedo * (0.3 + 0.7 * diff) + vec3<f32>(spec * 0.6);
    
    // Mix with background color
    // Calculate thread coverage/opacity based on density and thread gaps
    // A simple approximation: if density is high, we see thread. If low, we might see background.
    // However, the current 'density' model is more like ambient occlusion + albedo factor.
    // We strictly defined h=0 where there is no thread? 
    // In threadProfile, if abs(centered)>1.0 return 0.0. 
    // In getPlainWeaveDetail logic:
    // if (noWarp && noWeft) h = 0.0.
    
    // Let's use h (height) to determine opacity. 
    // If h is very small, it's a hole.
    
    let threadAlpha = smoothstep(0.0, 0.2, height); // Soft transition at edges
    
    // Also consider background opacity parameter
    let bgBase = u.backgroundColor.rgb;
    let bgAlpha = u.backgroundOpacity; // This is the opacity OF THE BACKGROUND layer itself? 
    // Usually "background opacity" means valid alpha in output if we want transparent PNGs.
    // Or it means "opacity of background color" blended over black?
    // Assuming the user wants to control the alpha of the FINAL image in the gaps.
    
    // If we want the background ITSELF to be transparent:
    // finalAlpha = mix(bgAlpha, 1.0, threadAlpha);
    // output color = mix(bgBase, threadColor, threadAlpha);
    
    // Combine thread color (finalColor) with background
    let outColor = mix(bgBase, finalColor, threadAlpha);
    let outAlpha = mix(bgAlpha, 1.0, threadAlpha);
    
    return vec4<f32>(outColor, outAlpha);
}
`;function gb(t){const e=parseInt(t.slice(1,3),16)/255,n=parseInt(t.slice(3,5),16)/255,s=parseInt(t.slice(5,7),16)/255;return[e,n,s,1]}function y5(t,e){const n=new Float32Array(64);n[0]=1,n[5]=1,n[10]=1,n[15]=1,n[16]=e.tileSize,n[17]=e.warpDensity,n[18]=e.weftDensity,n[19]=e.threadThickness,n[20]=e.threadTwist,n[21]=e.fiberDetail,n[22]=e.fuzziness,n[23]=e.weaveTightness,n[24]=e.threadUnevenness,n[25]=e.weaveImperfection,n[26]=0,n[27]=0;const s=gb(e.warpColor);n[28]=s[0],n[29]=s[1],n[30]=s[2],n[31]=s[3];const r=gb(e.weftColor);n[32]=r[0],n[33]=r[1],n[34]=r[2],n[35]=r[3],n[36]=e.fbmOctaves,n[37]=e.fbmAmplitude,n[38]=e.noiseFrequency,n[39]=e.colorVariation,n[40]=e.warpSheen,n[41]=e.weftSheen,n[42]=e.roughnessMin,n[43]=e.roughnessMax,n[44]=e.normalStrength,n[45]=e.threadHeightScale,n[46]=e.threadShadowStrength;const i=gb(e.backgroundColor);n[48]=i[0],n[49]=i[1],n[50]=i[2],n[51]=i[3],n[52]=e.backgroundOpacity;const o=t.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return t.queue.writeBuffer(o,0,n),o}function v5(t){const e=t.createShaderModule({code:b5});return t.createRenderPipeline({layout:"auto",vertex:{module:e,entryPoint:"vs_main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}]}]},fragment:{module:e,entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}})}function w5(t,e){const n=y5(t,e),s=v5(t),r=t.createBindGroup({layout:s.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n}}]});return{pipeline:s,bindGroup:r}}const Qu={tileSize:1,warpDensity:20,weftDensity:20,threadThickness:.45,threadTwist:.5,fiberDetail:.3,fuzziness:.2,weaveTightness:.7,threadUnevenness:.15,weaveImperfection:.1,warpColor:"#D4C8B8",weftColor:"#F0E8DC",backgroundColor:"#000000",backgroundOpacity:1,fbmOctaves:3,fbmAmplitude:.3,noiseFrequency:2,colorVariation:.05,warpSheen:.3,weftSheen:.25,roughnessMin:.4,roughnessMax:.8,normalStrength:5,threadHeightScale:1,threadShadowStrength:.3};async function S5(t,e,n){const s=await Ts();if(!s)throw new Error("WebGPU not supported");const r=s.createTexture({size:[e,n],format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),{pipeline:i,bindGroup:o}=w5(s,t),a=Bk(s);return zk(s,{texture:r,pipeline:i,bindGroup:o,vertexBuffer:a}),await Gk({device:s,texture:r,width:e,height:n})}const Wk="procedural-texture-state",pu={WOOD:"Wood",PLAIN_WEAVE:"PlainWeave",PLAIN_WEAVE_ADVANCED:"Plain Weave Advanced",TWILL_WEAVE:"TwillWeave",VELVET:"Velvet"},C5={UPLOAD:"Upload"},Uo={PLAIN_WEAVE_WARP:"#D4C8B8",PLAIN_WEAVE_WEFT:"#F0E8DC",TWILL_WEAVE_STOP_0:"#1a1a2e",TWILL_WEAVE_STOP_1:"#e0e0d0",TWILL_WEAVE_STOP_2:"#2c3e50",VELVET_STOP_0:"#2a0845",VELVET_STOP_1:"#5a3a7a",VELVET_STOP_2:"#8a6a9a"},ev={LOAD_FAILED:"Failed to load procedural texture state from localStorage:",SAVE_FAILED:"Failed to save procedural texture state to localStorage:",UNKNOWN_TYPE:"Unknown texture type:"},Ss={activeTab:C5.UPLOAD,proceduralType:pu.WOOD,woodParams:{...Vk},plainWeaveParams:{tileSize:1,threadDensity:20,threadThickness:.45,warpWeftRatio:1,threadTwist:.5,fiberDetail:.3,fuzziness:.2,weaveTightness:.7,threadUnevenness:.15,weaveImperfection:.1,gradientStops:[{offset:0,color:Uo.PLAIN_WEAVE_WARP},{offset:1,color:Uo.PLAIN_WEAVE_WEFT}],warpSheen:.3,weftSheen:.25,fbmOctaves:3,fbmAmplitude:.3,noiseFrequency:2,colorVariation:.1,threadHeightScale:1,threadShadowStrength:.5,normalStrength:5,roughnessMin:.3,roughnessMax:.8},plainWeaveAdvancedParams:{...Qu},twillWeaveParams:{tileSize:1,threadDensity:40,threadThickness:.8,warpWeftRatio:1,threadTwist:.7,fiberDetail:.4,fuzziness:.3,twillRepeat:4,herringboneScale:0,waleDepth:1.2,weaveTightness:.85,threadUnevenness:.15,weaveImperfection:.1,gradientStops:[{offset:0,color:Uo.TWILL_WEAVE_STOP_0},{offset:.3,color:Uo.TWILL_WEAVE_STOP_1},{offset:.6,color:Uo.TWILL_WEAVE_STOP_2}],warpSheen:.4,weftSheen:.25,roughnessMin:.5,roughnessMax:.9,normalStrength:8,threadHeightScale:1.2,threadShadowStrength:.6,fbmOctaves:4,fbmAmplitude:.4,noiseFrequency:3,colorVariation:.15},velvetParams:{tileSize:1,fiberDensity:30,fiberLength:.8,fiberThickness:.15,fiberStiffness:.3,pileHeight:.6,pileDirection:0,sheenIntensity:.7,sheenDirection:0,colorVariation:.1,gradientStops:[{offset:0,color:Uo.VELVET_STOP_0},{offset:.5,color:Uo.VELVET_STOP_1},{offset:1,color:Uo.VELVET_STOP_2}],roughnessMin:.1,roughnessMax:.9,normalStrength:5},uiState:{woodPanel:{showColors:!0,showBasicParams:!0,showPoreParams:!1,showAdvancedParams:!1,showMaterialParams:!1,showPresets:!1},plainWeavePanel:{showColors:!0,showBasicParams:!0,showThreadParams:!1,showAdvancedParams:!1,showMaterialParams:!1,showPresets:!1},plainWeaveAdvancedPanel:{showColors:!0,showBasicParams:!0,showThreadParams:!1,showAdvancedParams:!1,showMaterialParams:!1,showPresets:!1},twillWeavePanel:{showColors:!0,showBasicParams:!0,showTwillParams:!0,showThreadParams:!1,showAdvancedParams:!1,showMaterialParams:!1,showPresets:!1},velvetPanel:{showColors:!0,showBasicParams:!0,showFiberParams:!1,showPileParams:!1,showAdvancedParams:!1,showMaterialParams:!1,showPresets:!1}}};function T5(){var t,e,n,s,r;try{const i=localStorage.getItem(Wk);if(!i)return{...Ss};const o=JSON.parse(i);return{...Ss,...o,woodParams:{...Ss.woodParams,...o.woodParams},plainWeaveParams:{...Ss.plainWeaveParams,...o.plainWeaveParams},plainWeaveAdvancedParams:{...Ss.plainWeaveAdvancedParams,...o.plainWeaveAdvancedParams||{}},twillWeaveParams:{...Ss.twillWeaveParams,...o.twillWeaveParams},velvetParams:{...Ss.velvetParams,...o.velvetParams},uiState:{woodPanel:{...Ss.uiState.woodPanel,...(t=o.uiState)==null?void 0:t.woodPanel},plainWeavePanel:{...Ss.uiState.plainWeavePanel,...(e=o.uiState)==null?void 0:e.plainWeavePanel},plainWeaveAdvancedPanel:{...Ss.uiState.plainWeaveAdvancedPanel,...((n=o.uiState)==null?void 0:n.plainWeaveAdvancedPanel)||{}},twillWeavePanel:{...Ss.uiState.twillWeavePanel,...(s=o.uiState)==null?void 0:s.twillWeavePanel},velvetPanel:{...Ss.uiState.velvetPanel,...(r=o.uiState)==null?void 0:r.velvetPanel}}}}catch(i){return console.warn(ev.LOAD_FAILED,i),{...Ss}}}const Hk=t=>{try{localStorage.setItem(Wk,JSON.stringify(t))}catch(e){console.warn(ev.SAVE_FAILED,e)}},Mi=pi(T5());_t(Mi,()=>{Hk(Mi)},{deep:!0});const I5=()=>{Object.assign(Mi,Ss),Hk(Mi)},k5={[pu.WOOD]:()=>{Mi.woodParams={...Vk}},[pu.PLAIN_WEAVE]:()=>{Mi.plainWeaveParams={...Ss.plainWeaveParams}},[pu.PLAIN_WEAVE_ADVANCED]:()=>{Mi.plainWeaveAdvancedParams={...Qu}},[pu.TWILL_WEAVE]:()=>{Mi.twillWeaveParams={...Ss.twillWeaveParams}},[pu.VELVET]:()=>{Mi.velvetParams={...Ss.velvetParams}}},E5=t=>{const e=k5[t];if(!e){console.warn(`${ev.UNKNOWN_TYPE} ${t}`);return}e()};function is(){return{state:Mi,resetState:I5,resetTextureParams:E5}}function _5(t,e){const n=u=>{const c=`quantized-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;t.value.push({id:c,name:`Color RGB(${u.r},${u.g},${u.b})`,type:"quantized",visible:!0,intensity:1,blendMode:"max",color:{...u},tolerance:30}),e.value=c},s=u=>{const c=`hsl-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;t.value.push({id:c,name:u.name||"Custom HSL",type:"hsl",visible:!0,intensity:1,blendMode:"max",hslRange:{...u}}),e.value=c};return{addColorLayer:n,addHslLayer:s,removeLayer:u=>{const c=t.value.findIndex(h=>h.id===u);c>-1&&(t.value.splice(c,1),e.value===u&&(e.value=null))},selectLayer:u=>{e.value=u},updateLayer:(u,c)=>{const h=t.value.find(d=>d.id===u);h&&Object.assign(h,c)},toggleColorBlock:(u,c)=>{n(c)},toggleHslBlock:(u,c)=>{s(c)}}}const $5=(t,e)=>new Promise((n,s)=>{t.onload=()=>{try{e!=null&&e.onload,n(t)}catch(r){s(r instanceof Error?r:new Error(String(r)))}},t.onerror=()=>{const r=new Error("");try{e!=null&&e.onerror,s(r)}catch(i){s(i instanceof Error?i:new Error(String(i)))}}}),zm=async(t,e)=>{const n=new Image;return n.src=t,await $5(n,e),n},R5=t=>{const e=document.createElement("canvas"),n=e.getContext("2d");if(!n)throw new Error("2D");return e.width=t.width,e.height=t.height,n.drawImage(t,0,0),n.getImageData(0,0,t.width,t.height)},A5=(t,e,n,s,r)=>{const i=new Uint8Array(s*r);for(let o=0;o<r;o++)for(let a=0;a<s;a++){const l=Math.floor(a/s*e),u=Math.floor(o/r*n),c=Math.min(Math.max(l,0),e-1),d=Math.min(Math.max(u,0),n-1)*e+c,f=o*s+a;i[f]=t[d]}return i},P5=(t,e)=>{const n=t*e*4,s=new Uint8Array(n);for(let r=0;r<n;r+=4)s[r]=255,s[r+1]=255,s[r+2]=255,s[r+3]=255;return s},D5=(t,...e)=>isNaN(t)?[]:e.map(n=>Math.round(n*t)),N5=(t,...e)=>{if(e.length===0)return 1;if(t<=0)return 0;const n=Math.max(...e);return n<=0?1:Math.min(1,t/n)},M5=async(t,e=512)=>{const n=N5(e,t.width,t.height),[s,r]=D5(n,t.width,t.height);let i=t.width,o=t.height;n<1&&(i=s,o=r);const a=document.createElement("canvas"),l=a.getContext("2d");return a.width=i,a.height=o,l.drawImage(t,0,0,i,o),{imageData:l.getImageData(0,0,i,o),scale:n,targetWidth:i,targetHeight:o}},L5=t=>{let e=255,n=0;for(let i=0;i<t.length;i++)e=Math.min(e,t[i]),n=Math.max(n,t[i]);const s=n-e,r=s>0?255/s:1;return{minValue:e,maxValue:n,range:s,maskScale:r}},O5=(t,e,n)=>{const s=t.width/e,r=t.height/n;return{scaleX:s,scaleY:r}},F5=(t,e)=>{const{minValue:n,range:s,maskScale:r}=e;return(s>0?(t-n)*r:t)/255},U5=(t,e,n)=>{t.data[e]=255,t.data[e+1]=0,t.data[e+2]=0,t.data[e+3]=Math.round(n*128)},C1=(t,e,n,s)=>{const r=L5(t),{scaleX:i,scaleY:o}=O5(e,n,s),a=new ImageData(n,s);for(let l=0;l<s;l++)for(let u=0;u<n;u++){const c=Math.floor(u*i),h=Math.floor(l*o);if(c>=e.width||h>=e.height)continue;const d=(h*e.width+c)*4,p=255-t[d],g=F5(p,r),m=(l*n+u)*4;U5(a,m,g)}return a};function B5(t,e,n){return{generateColorBlockMask:async r=>{if(!e.value)return null;const i=await zm(r),o=t.value.filter(a=>a.visible);if(o.length===0)return P5(i.width,i.height);try{const{imageData:a,scale:l}=await M5(i),u=[];for(const h of o){let d=null;if(h.type==="hsl"&&h.hslRange?(e.value.updateOptions({useQuantization:!1,useHslMask:!0,hslRange:h.hslRange,maskOptions:n.value}),d=(await e.value.generateAdjustmentRangeMask(a)).mask):h.type==="quantized"&&h.color&&(e.value.updateOptions({useQuantization:!0,useHslMask:!1,selectedColors:[h.color],colorTolerance:h.tolerance||30,maskOptions:n.value}),d=(await e.value.generateAdjustmentRangeMask(a)).mask),d){if(h.intensity<1)for(let f=0;f<d.length;f++)d[f]=Math.round(d[f]*h.intensity);u.push(d)}}let c=z5(u,o,a.width*a.height);return l<1&&(c=A5(c,a.width,a.height,i.width,i.height)),G5(c)}catch(a){return console.error(":",a),null}}}}function z5(t,e,n){if(t.length===0)return new Uint8Array(n);if(t.length===1)return t[0];const s=new Uint8Array(t[0]);for(let r=1;r<t.length;r++){const i=e[r],o=t[r],a=i.blendMode||"max";for(let l=0;l<s.length;l++){const u=s[l],c=o[l];a==="add"?s[l]=Math.min(255,u+c):a==="multiply"?s[l]=Math.round(u*c/255):a==="max"?s[l]=Math.max(u,c):a==="min"&&(s[l]=Math.min(u,c))}}return s}function G5(t){const e=new Uint8Array(t.length*4);for(let n=0;n<t.length;n++){const s=t[n];e[n*4]=s,e[n*4+1]=s,e[n*4+2]=s,e[n*4+3]=255}return e}const Kk=(t,e,n="source-over")=>{if(!t)throw new Error("ImageData");if(!e)throw new Error("Canvas");const s=document.createElement("canvas"),r=s.getContext("2d");if(!r)throw new Error("2D");s.width=e.width,s.height=e.height,r.putImageData(t,0,0);const i=e.getContext("2d");if(!i)throw new Error("2D");const o=i.globalCompositeOperation;i.globalCompositeOperation=n,i.drawImage(s,0,0),i.globalCompositeOperation=o},V5="2d",W5="",H5=(t,e)=>{if(!t.getContext(V5))throw new Error(W5);const{width:s,height:r}=t,i=Math.round(s*e),o=Math.round(r*e);return t.width=i,t.height=o,{success:!0,detail:{ratio:e,resultWidth:i,resultHeight:o,originalWidth:s,originalHeight:r}}},K5=(t,e,n)=>{const{width:s,height:r}=t,i=Math.min(1,Math.min(e/s,n/r));return H5(t,i)};function j5(t,e,n){return{updateMaskPreview:async(i,o)=>{const a=o||e.value;if(!(!a||!i||t.value.length===0))try{const l=await n(i);if(!l)return;const u=await zm(i),c=a.getContext("2d");if(!c)return;const h=200,{detail:{resultWidth:d,resultHeight:f}}=K5(a,h,h);c.drawImage(u,0,0,d,f);const p=C1(l,u,d,f);Kk(p,a,"source-over")}catch(l){console.error(":",l)}},generateMaskPreviewImageDataUrl:async i=>{if(!i||t.value.length===0)return null;try{const o=await n(i);if(!o)return null;const a=await zm(i),l=400,u=document.createElement("canvas"),c=u.getContext("2d");if(!c)return null;const h=Math.min(1,l/Math.max(a.width,a.height)),d=Math.round(a.width*h),f=Math.round(a.height*h);u.width=d,u.height=f,c.drawImage(a,0,0,d,f);const p=C1(o,a,d,f);return c.putImageData(p,0,0),u.toDataURL("image/png")}catch(o){return console.error(":",o),null}}}}function xb(t,e,n){t/=255,e/=255,n/=255;const s=Math.max(t,e,n),r=Math.min(t,e,n);let i=0,o=0;const a=(s+r)/2;if(s!==r){const l=s-r;switch(o=a>.5?l/(2-s-r):l/(s+r),s){case t:i=(e-n)/l+(e<n?6:0);break;case e:i=(n-t)/l+2;break;case n:i=(t-e)/l+4;break}i/=6}return{h:i*360,s:o*100,l:a*100}}class Gm{constructor(e=0){Wt(this,"children",new Array(8).fill(null));Wt(this,"colors",[]);Wt(this,"isLeaf",!0);Wt(this,"level",0);this.level=e}addColor(e){this.colors.push(e)}split(){if(this.colors.length<=1)return;const e=this.colors.reduce((r,i)=>r+i.r,0)/this.colors.length,n=this.colors.reduce((r,i)=>r+i.g,0)/this.colors.length,s=this.colors.reduce((r,i)=>r+i.b,0)/this.colors.length;for(const r of this.colors){const i=this.getChildIndex(r,e,n,s);this.children[i]||(this.children[i]=new Gm(this.level+1)),this.children[i].addColor(r)}this.isLeaf=!1,this.colors=[]}getChildIndex(e,n,s,r){let i=0;return e.r>n&&(i|=1),e.g>s&&(i|=2),e.b>r&&(i|=4),i}getAverageColor(){if(this.colors.length===0)return{r:0,g:0,b:0,count:0};const e=this.colors.reduce((i,o)=>i+o.count,0),n=this.colors.reduce((i,o)=>i+o.r*o.count,0)/e,s=this.colors.reduce((i,o)=>i+o.g*o.count,0)/e,r=this.colors.reduce((i,o)=>i+o.b*o.count,0)/e;return{r:Math.round(n),g:Math.round(s),b:Math.round(r),count:e}}}class bb{constructor(e=256){Wt(this,"root");Wt(this,"maxColors");this.root=new Gm,this.maxColors=e}quantize(e){const n=new Map,{data:s,width:r,height:i}=e;for(let l=0;l<s.length;l+=4){const u=s[l],c=s[l+1],h=s[l+2],d=`${u},${c},${h}`;n.has(d)?n.get(d).count++:n.set(d,{r:u,g:c,b:h,count:1})}for(const l of n.values())this.addColorToOctree(l);this.reduceColors();const o=this.generatePalette(),a=this.createColorMap(o,n);return{palette:o,colorMap:a,totalColors:o.length,originalColors:n.size}}addColorToOctree(e){let n=this.root,s=0;for(;s<8;){if(n.isLeaf){n.addColor(e);break}const r=n.colors.reduce((l,u)=>l+u.r,0)/n.colors.length,i=n.colors.reduce((l,u)=>l+u.g,0)/n.colors.length,o=n.colors.reduce((l,u)=>l+u.b,0)/n.colors.length,a=this.getChildIndex(e,r,i,o);n.children[a]||(n.children[a]=new Gm(s+1)),n=n.children[a],s++}}getChildIndex(e,n,s,r){let i=0;return e.r>n&&(i|=1),e.g>s&&(i|=2),e.b>r&&(i|=4),i}reduceColors(){let e=this.countLeaves(this.root);for(;e>this.maxColors;){const n=this.findNodeToMerge(this.root);if(n)this.mergeNode(n),e=this.countLeaves(this.root);else break}e<8&&this.ensureMinimumColors(8)}ensureMinimumColors(e){let n=this.countLeaves(this.root);for(;n<e;){const s=this.findLargestLeaf(this.root);if(s&&s.colors.length>1)s.split(),n=this.countLeaves(this.root);else{this.createVirtualColors(e-n);break}}}findLargestLeaf(e){if(e.isLeaf)return e.colors.length>1?e:null;let n=null,s=0;for(const r of e.children)if(r){const i=this.findLargestLeaf(r);i&&i.colors.length>s&&(n=i,s=i.colors.length)}return n}createVirtualColors(e){const n=this.generatePalette();for(let s=0;s<e;s++){const r=n[s%n.length],i={r:Math.max(0,Math.min(255,r.r+s*30%100)),g:Math.max(0,Math.min(255,r.g+s*40%100)),b:Math.max(0,Math.min(255,r.b+s*50%100)),count:1};this.root.addColor(i)}}countLeaves(e){return e.isLeaf?1:e.children.reduce((n,s)=>n+(s?this.countLeaves(s):0),0)}findNodeToMerge(e){if(e.isLeaf)return null;let n=null,s=1/0;for(const r of e.children)r&&r.isLeaf&&r.colors.length<s&&(s=r.colors.length,n=r);return n}mergeNode(e){const n=this.findParent(this.root,e);if(n){for(const r of e.colors)n.addColor(r);const s=n.children.indexOf(e);s!==-1&&(n.children[s]=null)}}findParent(e,n){for(const s of e.children){if(s===n)return e;if(s&&!s.isLeaf){const r=this.findParent(s,n);if(r)return r}}return null}generatePalette(){const e=[];return this.collectLeaves(this.root,e),e}collectLeaves(e,n){if(e.isLeaf)n.push(e.getAverageColor());else for(const s of e.children)s&&this.collectLeaves(s,n)}createColorMap(e,n){const s=new Map;for(const[r,i]of n){const o=this.findClosestColor(i,e);s.set(r,o)}return s}findClosestColor(e,n){let s=n[0],r=this.colorDistance(e,s);for(const i of n){const o=this.colorDistance(e,i);o<r&&(r=o,s=i)}return s}colorDistance(e,n){const s=e.r-n.r,r=e.g-n.g,i=e.b-n.b;return s*s+r*r+i*i}}class X5{constructor(e=256){Wt(this,"maxColors");this.maxColors=e}quantize(e){const n=new Map,{data:s,width:r,height:i}=e;for(let u=0;u<s.length;u+=4){const c=s[u],h=s[u+1],d=s[u+2],f=`${c},${h},${d}`;n.has(f)?n.get(f).count++:n.set(f,{r:c,g:h,b:d,count:1})}const o=Array.from(n.values()),a=this.medianCut(o,this.maxColors),l=this.createColorMap(a,n);return{palette:a,colorMap:l,totalColors:a.length,originalColors:n.size}}medianCut(e,n){if(e.length<=n)return e.map(i=>({...i}));const s=[e],r=[];for(;s.length<n&&s.some(i=>i.length>1);){const i=this.findLargestBucket(s),o=s[i],[a,l]=this.splitBucket(o);s[i]=a,s.push(l)}for(const i of s)i.length>0&&r.push(this.getAverageColor(i));return r}findLargestBucket(e){let n=0,s=e[0].length;for(let r=1;r<e.length;r++)e[r].length>s&&(s=e[r].length,n=r);return n}splitBucket(e){const n=this.getColorRanges(e),s=Math.max(n.r,n.g,n.b);let r;s===n.r?r="r":s===n.g?r="g":r="b",e.sort((o,a)=>o[r]-a[r]);const i=Math.floor(e.length/2);return[e.slice(0,i),e.slice(i)]}getColorRanges(e){const n=Math.min(...e.map(l=>l.r)),s=Math.max(...e.map(l=>l.r)),r=Math.min(...e.map(l=>l.g)),i=Math.max(...e.map(l=>l.g)),o=Math.min(...e.map(l=>l.b)),a=Math.max(...e.map(l=>l.b));return{r:s-n,g:i-r,b:a-o}}getAverageColor(e){const n=e.reduce((o,a)=>o+a.count,0),s=e.reduce((o,a)=>o+a.r*a.count,0)/n,r=e.reduce((o,a)=>o+a.g*a.count,0)/n,i=e.reduce((o,a)=>o+a.b*a.count,0)/n;return{r:Math.round(s),g:Math.round(r),b:Math.round(i),count:n}}createColorMap(e,n){const s=new Map;for(const[r,i]of n){const o=this.findClosestColor(i,e);s.set(r,o)}return s}findClosestColor(e,n){let s=n[0],r=this.colorDistance(e,s);for(const i of n){const o=this.colorDistance(e,i);o<r&&(r=o,s=i)}return s}colorDistance(e,n){const s=e.r-n.r,r=e.g-n.g,i=e.b-n.b;return s*s+r*r+i*i}}class Pp{static generateMask(e,n){const{data:s,width:r,height:i}=e,o=new Uint8Array(r*i);for(let l=0;l<s.length;l+=4){const u=s[l],c=s[l+1],h=s[l+2],d=xb(u,c,h),f=this.computeHslDistance(d,n.hslRange);o[l/4]=Math.round(f*255)}n.threshold!==void 0&&this.applyThreshold(o,n.threshold),n.smooth&&this.smoothMask(o,r,i,n.smoothRadius||1),n.invert&&this.invertMask(o);const a=this.computeMaskStatistics(o);return{mask:o,width:r,height:i,statistics:a}}static computeHslDistance(e,n){const s=this.computeHueDistance(e.h,n.hue,n.hueTolerance),r=Math.abs(e.s-n.saturation)/n.saturationTolerance,i=Math.abs(e.l-n.lightness)/n.lightnessTolerance,o=Math.sqrt(s*s+r*r+i*i),a=(1-o)*(1-n.feather)+n.feather*Math.exp(-o*2);return Math.max(0,Math.min(1,a))}static computeHueDistance(e,n,s){let r=Math.abs(e-n);return r=Math.min(r,360-r),Math.min(1,r/s)}static applyThreshold(e,n){for(let s=0;s<e.length;s++)e[s]=e[s]>n?255:0}static smoothMask(e,n,s,r){const i=new Uint8Array(e.length);for(let o=0;o<s;o++)for(let a=0;a<n;a++){let l=0,u=0;for(let c=-r;c<=r;c++)for(let h=-r;h<=r;h++){const d=a+h,f=o+c;d>=0&&d<n&&f>=0&&f<s&&(l+=e[f*n+d],u++)}i[o*n+a]=Math.round(l/u)}e.set(i)}static invertMask(e){for(let n=0;n<e.length;n++)e[n]=255-e[n]}static computeMaskStatistics(e){const n=e.length;let s=0,r=0;for(let i=0;i<e.length;i++)e[i]>0&&s++,r+=e[i];return{totalPixels:n,maskedPixels:s,maskRatio:s/n,averageIntensity:r/n}}static combineMasks(e,n,s,r="max"){if(e.length===0)return new Uint8Array(n*s);if(e.length===1)return new Uint8Array(e[0]);const i=new Uint8Array(n*s);for(let o=0;o<i.length;o++){let a=e[0][o];for(let l=1;l<e.length;l++)switch(r){case"add":a=Math.min(255,a+e[l][o]);break;case"multiply":a=Math.round(a*e[l][o]/255);break;case"max":a=Math.max(a,e[l][o]);break;case"min":a=Math.min(a,e[l][o]);break}i[o]=a}return i}static autoSelectHslRange(e,n,s,r=10){const{data:i,width:o,height:a}=e,l=[];for(let x=-r;x<=r;x++)for(let b=-r;b<=r;b++){const v=n+b,y=s+x;if(v>=0&&v<o&&y>=0&&y<a){const C=(y*o+v)*4,I=i[C],$=i[C+1],T=i[C+2];l.push(xb(I,$,T))}}const u=(s*o+n)*4,c=i[u],h=i[u+1],d=i[u+2],f=xb(c,h,d),p=this.computeAdaptiveTolerance(l,"hue"),g=this.computeAdaptiveTolerance(l,"saturation"),m=this.computeAdaptiveTolerance(l,"lightness");return{hue:f.h,hueTolerance:Math.max(5,Math.min(90,p)),saturation:f.s,saturationTolerance:Math.max(5,Math.min(50,g)),lightness:f.l,lightnessTolerance:Math.max(5,Math.min(50,m)),feather:.3}}static computeAdaptiveTolerance(e,n){if(e.length===0)return 20;const s=e.map(l=>l[n]),r=s.reduce((l,u)=>l+u,0)/s.length,i=s.reduce((l,u)=>l+Math.pow(u-r,2),0)/s.length,a=Math.sqrt(i)*2;switch(n){case"hue":return Math.max(5,Math.min(90,a));case"saturation":case"lightness":return Math.max(5,Math.min(50,a));default:return 20}}static generateMaskFromQuantization(e,n,s,r={}){const{data:i,width:o,height:a}=e,l=new Uint8Array(o*a);new Set(s.map(c=>`${c.r},${c.g},${c.b}`));for(let c=0;c<i.length;c+=4){const h=i[c],d=i[c+1],f=i[c+2],p={r:h,g:d,b:f,count:0};let g=1/0;for(const C of s){const I=this.colorDistance(p,C);g=Math.min(g,I)}const x=Math.max(0,Math.min(255,Math.round(255*(1-Math.sqrt(g)/100)))),b=c/4%o,y=Math.floor(c/4/o)*o+b;l[y]=x}r.smooth&&this.smoothMask(l,o,a,r.smoothRadius||1),r.invert&&this.invertMask(l);const u=this.computeMaskStatistics(l);return{mask:l,width:o,height:a,statistics:u}}static findClosestColor(e,n){let s=n[0],r=this.colorDistance(e,s);for(const i of n){const o=this.colorDistance(e,i);o<r&&(r=o,s=i)}return s}static colorDistance(e,n){const s=e.r-n.r,r=e.g-n.g,i=e.b-n.b;return s*s+r*r+i*i}}class Dp{constructor(e={}){Wt(this,"options");this.options={quantizationAlgorithm:"octree",maxColors:64,hslRange:{hue:0,hueTolerance:30,saturation:50,saturationTolerance:30,lightness:50,lightnessTolerance:30,feather:.3},maskOptions:{smooth:!0,smoothRadius:1,threshold:void 0,invert:!1},useQuantization:!0,useHslMask:!0,blendMode:"max",autoSelectColors:!1,selectedColors:[],colorTolerance:30,...e}}async generateAdjustmentRangeMask(e){const n=[];let s,r;if(this.options.useQuantization&&(s=await this.performQuantization(e),this.options.autoSelectColors&&(this.options.selectedColors=this.autoSelectColors(s.palette)),this.options.selectedColors.length>0)){const a=Pp.generateMaskFromQuantization(e,s.palette,this.options.selectedColors,this.options.maskOptions);n.push(a.mask)}this.options.useHslMask&&(r=Pp.generateMask(e,{hslRange:this.options.hslRange,...this.options.maskOptions}),n.push(r.mask));let i;n.length===0?i=new Uint8Array(e.width*e.height):n.length===1?i=new Uint8Array(n[0]):i=Pp.combineMasks(n,e.width,e.height,this.options.blendMode);const o=this.computeFinalStatistics(i,this.options.selectedColors);return{mask:i,width:e.width,height:e.height,quantizationResult:s,hslMaskResult:r,statistics:o}}async performQuantization(e){let n;switch(this.options.quantizationAlgorithm){case"octree":n=new bb(this.options.maxColors);break;case"median-cut":n=new X5(this.options.maxColors);break;default:n=new bb(this.options.maxColors)}return n.quantize(e)}autoSelectColors(e){if(e.length===0)return[];const n=[...e].sort((r,i)=>i.count-r.count),s=Math.max(3,Math.min(10,Math.ceil(e.length*.2)));return n.slice(0,s)}computeFinalStatistics(e,n){const s=e.length;let r=0,i=0;for(let o=0;o<e.length;o++)e[o]>0&&r++,i+=e[o];return{totalPixels:s,maskedPixels:r,maskRatio:r/s,averageIntensity:i/s,selectedColors:[...n]}}updateOptions(e){this.options={...this.options,...e}}getOptions(){return{...this.options}}autoGenerateHslRange(e,n,s,r=10){const i=Pp.autoSelectHslRange(e,n,s,r);this.options.hslRange=i}autoSelectColorsFromClick(e,n,s,r=30){const{data:i,width:o,height:a}=e,l=(s*o+n)*4,u=i[l],c=i[l+1],h=i[l+2],d={r:u,g:c,b:h,count:0};this.performQuantization(e).then(f=>{const p=f.palette.filter(g=>this.colorDistance(d,g)<=r*r);this.options.selectedColors=p})}colorDistance(e,n){const s=e.r-n.r,r=e.g-n.g,i=e.b-n.b;return s*s+r*r+i*i}exportMaskAsImageData(e,n,s){const r=new ImageData(n,s);for(let i=0;i<e.length;i++){const o=e[i],a=i*4;r.data[a]=o,r.data[a+1]=o,r.data[a+2]=o,r.data[a+3]=255}return r}applyMaskToImage(e,n,s=1){const r=new ImageData(e.width,e.height);for(let i=0;i<e.data.length;i+=4){const o=i/4,l=n[o]/255*s;r.data[i]=e.data[i],r.data[i+1]=e.data[i+1],r.data[i+2]=e.data[i+2],r.data[i+3]=Math.round(e.data[i+3]*l)}return r}static generateQuantizedColorBlocks(e,n=8){return new bb(n).quantize(e).palette}static generateCommonHslBlocks(){return[{name:"",hue:30,hueTolerance:20,saturation:40,saturationTolerance:30,lightness:60,lightnessTolerance:25,feather:.1},{name:"",hue:210,hueTolerance:30,saturation:60,saturationTolerance:40,lightness:70,lightnessTolerance:30,feather:.1},{name:"",hue:120,hueTolerance:40,saturation:50,saturationTolerance:35,lightness:45,lightnessTolerance:35,feather:.1},{name:"",hue:0,hueTolerance:15,saturation:70,saturationTolerance:30,lightness:50,lightnessTolerance:30,feather:.1},{name:"",hue:60,hueTolerance:20,saturation:80,saturationTolerance:20,lightness:60,lightnessTolerance:25,feather:.1},{name:"",hue:270,hueTolerance:25,saturation:50,saturationTolerance:35,lightness:45,lightnessTolerance:30,feather:.3},{name:"",hue:0,hueTolerance:360,saturation:0,saturationTolerance:100,lightness:80,lightnessTolerance:20,feather:.2},{name:"",hue:0,hueTolerance:360,saturation:0,saturationTolerance:100,lightness:30,lightnessTolerance:20,feather:.2}]}static createPreset(e){switch(e){case"skin-tone":return{hslRange:{hue:30,hueTolerance:20,saturation:40,saturationTolerance:30,lightness:60,lightnessTolerance:25,feather:.4},useQuantization:!0,useHslMask:!0,blendMode:"max"};case"sky-blue":return{hslRange:{hue:210,hueTolerance:30,saturation:60,saturationTolerance:40,lightness:70,lightnessTolerance:30,feather:.3},useQuantization:!0,useHslMask:!0,blendMode:"max"};case"greens":return{hslRange:{hue:120,hueTolerance:40,saturation:50,saturationTolerance:35,lightness:45,lightnessTolerance:35,feather:.3},useQuantization:!0,useHslMask:!0,blendMode:"max"};case"highlights":return{hslRange:{hue:0,hueTolerance:360,saturation:0,saturationTolerance:100,lightness:80,lightnessTolerance:20,feather:.2},useQuantization:!1,useHslMask:!0,blendMode:"max"};case"shadows":return{hslRange:{hue:0,hueTolerance:360,saturation:0,saturationTolerance:100,lightness:30,lightnessTolerance:20,feather:.2},useQuantization:!1,useHslMask:!0,blendMode:"max"};default:return{}}}}function q5(t,e,n){return{generateColorBlocks:async r=>{try{const i=r instanceof File?URL.createObjectURL(r):r,o=await zm(i),a=R5(o),u=Math.min(1,512/Math.max(o.width,o.height));if(u<1){const c=document.createElement("canvas"),h=c.getContext("2d"),d=Math.round(o.width*u),f=Math.round(o.height*u);c.width=d,c.height=f,h.drawImage(o,0,0,d,f);const p=h.getImageData(0,0,d,f);t.value=Dp.generateQuantizedColorBlocks(p,8)}else t.value=Dp.generateQuantizedColorBlocks(a,8);e.value=Dp.generateCommonHslBlocks(),n.value=new Dp}catch(i){console.error(":",i)}}}}const Y5=()=>{const t=ce([]),e=ce([]),n=ce([]),s=ce({smooth:!0,invert:!0}),r=Ah(null),i=ce(null),o=ce([]),a=ce(null),l={quantizedColorBlocks:t,commonHslBlocks:e,selectedColorBlocks:n,maskOptions:s,maskManager:r,maskPreviewCanvas:i,layers:o,activeLayerId:a},u=_5(o,a),c=B5(o,r,s),h=j5(o,i,c.generateColorBlockMask),d=q5(t,e,r);return{states:l,generator:d,layerManager:u,maskGen:c,preview:h}},yb=(t,e,n)=>(n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+(e-t)*6*n:n<1/2?e:n<2/3?t+(e-t)*(2/3-n)*6:t),jk=t=>{const e=t.hue/360,n=t.saturation/100,s=t.lightness/100;let r,i,o;if(n===0)r=i=o=s;else{const l=s<.5?s*(1+n):s+n-s*n,u=2*s-l;r=yb(u,l,e+1/3),i=yb(u,l,e),o=yb(u,l,e-1/3)}const a=[Math.round(r*255),Math.round(i*255),Math.round(o*255)];return`rgb(${a[0]}, ${a[1]}, ${a[2]})`};function Z5(t){return typeof t=="string"}function Q5(t){return t instanceof FileReader}function Xk(t){return t instanceof HTMLInputElement}function J5(t,e){var s;if(!Xk(t.target))return;const n=(s=t.target.files)==null?void 0:s[0];if(n){const r=new FileReader;r.onload=i=>{if(!Q5(i.target))return;const o=i.target.result;Z5(o)&&e(o)},r.onerror=()=>{console.error("",{fileName:n.name,fileSize:n.size})},r.readAsDataURL(n)}}function eU(t,e){t(),e!=null&&e.value&&e.value.resetZoom()}function US(t,e){t&&e(t)}const Ui="[ComponentWrapper]",ul={PROPS_VALIDATION_FAILED:"Props validation failed",PROPS_TRANSFORMATION_ERROR:"Props transformation error",EMIT_ERROR:"Emit error",RENDER_ERROR:"Render error",COMPONENT_RENDER_ERROR:"Component render error"},Vm={PROPS_TRANSFORMED:"Props transformed:",EVENT_INTERCEPTED:"Event intercepted:",EVENT_EMITTED:"Event emitted:",RENDER_TIME:"Render time: {time}ms"},tU={UPDATE_MODEL_VALUE:"update:modelValue"},nU={ERROR:"error"},Ds={WRAPPED_PREFIX:"Wrapped",ON_PREFIX:"on",UPDATE_MODEL_VALUE_HANDLER:"onUpdate:modelValue",COLON:":",SPACE:" ",DIV_TAG:"div",TIME_PLACEHOLDER:"{time}",DOT:"."},sU={createWrappedComponentName:t=>Ds.WRAPPED_PREFIX+t,createEventHandlerName:t=>Ds.ON_PREFIX+t.charAt(0).toUpperCase()+t.slice(1)};function rU(t){return typeof t=="object"&&t!==null&&"emits"in t&&(Xg(t.emits)||Zk(t.emits))}function qk(t){return typeof t=="function"}function Yk(t){return typeof t=="string"}function Xg(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)}function Zk(t){return Array.isArray(t)}function iU(t){return Xg(t)&&"key"in t&&"value"in t&&Yk(t.key)}function oU(t){return Yk(t)}function aU(t){return qk(t)}function lU(t){return qk(t)}function uU(t){return Xg(t)}function cU(t){return rU(t)?t.emits:{}}function tv(t){return Xg(t)}function Qk(t,e){return tv(t)?t[e]:void 0}function hU(t,e){return iU(t)&&t.key===e}function qg(t){return uU(t)?t:null}function dU(t,e){return qg(t)||e}function fU(){return{}}const vb=new WeakMap;function pU(t){return cU(t)}function mU(t,e){return e?{...e,...t}:t}function gU(t,e){if(!e)return t;for(const[n,s]of Object.entries(e))n in t&&lU(s)&&(t[n]=s(t[n]));return t}function xU(t,e){if(!e)return t;const n=qg(t);if(n){const s=e(n);return{...t,...s}}return t}function bU(t,e){if(!e)return;const n=e(t);if(n===!1){console.warn(Ui+ul.PROPS_VALIDATION_FAILED);return}oU(n)&&console.warn(Ui+ul.PROPS_VALIDATION_FAILED+Ds.COLON,n)}function yU(t,e,n){let s=t;return e&&(s=e+t),n&&(s=t+n),s}function vU(t,e){return!e||!tv(e)?t:Qk(e,t)||t}function wU(t,e,n){if(!n||!tv(n))return e;const s=Qk(n,t);return aU(s)?s(...e):e}function SU(t,e){const n=Zk(t)?t:Object.keys(t),s={};for(const r of n){const i=sU.createEventHandlerName(r);s[i]=(...o)=>e(r,...o)}return s}function CU(t,e,n){return ye(()=>{const s=JSON.stringify(t),r=vb.has(t)?vb.get(t):null;if(r&&hU(r,s))return r.value;let i={...t};try{i=mU(i,e==null?void 0:e.defaults),i=gU(i,e==null?void 0:e.transform),i=xU(i,e==null?void 0:e.intercept);const o=qg(i);return o&&bU(o,e==null?void 0:e.validate),vb.set(t,{key:s,value:i}),n!=null&&n.enableLogging&&console.warn(Ui+Ds.SPACE+Vm.PROPS_TRANSFORMED,{original:t,transformed:i}),i}catch(o){return console.error(Ui+Ds.SPACE+ul.PROPS_TRANSFORMATION_ERROR+Ds.COLON,o),t}})}function TU(t,e,n){return(s,...r)=>{try{let i=yU(s,e==null?void 0:e.prefix,e==null?void 0:e.suffix);if(i=vU(i,e==null?void 0:e.map),e!=null&&e.intercept,!(e!=null&&e.intercept?e.intercept(s,...r):!0)){n!=null&&n.enableLogging&&console.warn(Ui+Ds.SPACE+Vm.EVENT_INTERCEPTED,s);return}const a=wU(i,r,e==null?void 0:e.transform);n!=null&&n.enableLogging&&console.warn(Ui+Ds.SPACE+Vm.EVENT_EMITTED,{original:s,final:i,args:a}),t(i,...a)}catch(i){console.error(Ui+Ds.SPACE+ul.EMIT_ERROR+Ds.COLON,i)}}}function IU(t,e){t!=null&&t.beforeMount&&t.beforeMount(e.value),kr(()=>{t!=null&&t.afterMount&&t.afterMount(e.value)}),Gg(()=>{t!=null&&t.beforeUnmount&&t.beforeUnmount()}),tk(()=>{t!=null&&t.beforeUpdate&&t.beforeUpdate(e.value)}),zg(()=>{t!=null&&t.afterUpdate&&t.afterUpdate(e.value)})}function kU(t){return()=>{var n,s;const e=(n=t.debug)!=null&&n.enablePerformance?performance.now():0;try{const r=SU(t.componentEmits,t.proxyEmit);r[Ds.UPDATE_MODEL_VALUE_HANDLER]=(...o)=>t.proxyEmit(tU.UPDATE_MODEL_VALUE,...o);const i=bd(t.component,{...t.transformedProps.value,...r});if((s=t.debug)!=null&&s.enablePerformance){const o=performance.now();console.warn(Ui+Ds.SPACE+Vm.RENDER_TIME.replace(Ds.TIME_PLACEHOLDER,String(o-e)))}return i}catch(r){return console.error(Ui+Ds.SPACE+ul.RENDER_ERROR+Ds.COLON,r),bd(Ds.DIV_TAG,{class:nU.ERROR},ul.COMPONENT_RENDER_ERROR)}}}function nv(t,e={}){const{propsInterceptor:n,emitInterceptor:s,hooks:r,debug:i}=e,o=pU(t);return LI(We({setup(l,{emit:u}){const c=CU(l,n,i),h=TU(u,s,i),d=fU(),f=dU(c.value,d);return qg(c.value)||console.warn(Ui+ul.PROPS_VALIDATION_FAILED,"Failed to cast props to expected type"),IU(r,{value:f}),kU({component:t,componentEmits:o,transformedProps:c,proxyEmit:h,debug:i})}}))}const EU=t=>{const e=t.split(","),n=e[0].match(/:(.*?);/),s=(n==null?void 0:n[1])||"image/png",r=atob(e[1]);let i=r.length;const o=new Uint8Array(i);for(;i--;)o[i]=r.charCodeAt(i);return new Blob([o],{type:s})},Jk=(t,e="image",n="png")=>{if(t)try{let s,r;if(typeof t=="string"){s=t;const o=t.match(/data:([^;]+);/);return r=(o==null?void 0:o[1])||`image/${n}`,BS({dataURL:s,mimeType:r,fileName:e,format:n})}r=n==="jpg"||n==="jpeg"?"image/jpeg":"image/png";const i=n==="jpg"||n==="jpeg"?1:void 0;s=t.toDataURL(r,i),BS({dataURL:s,mimeType:r,fileName:e,format:n})}catch(s){console.error(":",s)}},BS=t=>{const{dataURL:e,fileName:n,format:s}=t,r=EU(e),i=URL.createObjectURL(r),o=document.createElement("a");o.href=i,o.download=`${n}-${Date.now()}.${s}`,document.body.appendChild(o),o.click(),document.body.removeChild(o),URL.revokeObjectURL(i)},eE=t=>{Jk(t,"original-image","png")},tE=t=>{Jk(t,"seamless-texture","png")},_U={class:"flex flex-col gap-2"},$U=["onClick"],RU=We({__name:"horizontalScrollButtons",props:{activeType:{},textureTypes:{}},emits:["type-change"],setup(t){const e=n=>{Nk(n)};return(n,s)=>(F(),V("div",_U,[s[0]||(s[0]=k("span",{class:"text-xs font-medium text-white/60"},"Type",-1)),k("div",{class:"flex gap-2 overflow-x-auto pb-2 scrollbar-thin scrollbar-thumb-white/20 scrollbar-track-white/5 hover:scrollbar-thumb-white/30",onWheel:e,style:{"scrollbar-width":"thin","-webkit-overflow-scrolling":"touch","flex-wrap":"nowrap","padding-bottom":"8px"}},[(F(!0),V(Xe,null,rt(t.textureTypes,r=>(F(),V("button",{key:r,onClick:i=>n.$emit("type-change",r),class:Q(["glass-btn py-2 px-4 text-xs font-medium rounded-lg transition-all duration-300 whitespace-nowrap flex-shrink-0",t.activeType===r?"bg-white/10 text-white shadow-sm":"text-white/40 hover:text-white/60"])},Le(r),11,$U))),128))],32)]))}}),nE={Pine:{tileSize:1,ringScale:5,ringDistortion:.8,knotIntensity:1.2,latewoodBias:.5,rayStrength:.1,poreDensity:0,gradientStops:[{offset:0,color:"#A6734D"},{offset:1,color:"#EBD9AD"}],fbmOctaves:3,fbmAmplitude:.5,knotFrequency:.8,distortionFreq:1.2,ringNoiseFreq:4,rayFrequencyX:40,rayFrequencyY:1.5,knotThresholdMin:.4,knotThresholdMax:.8,normalStrength:6,roughnessMin:.4,roughnessMax:.8,poreScale:.8,poreThresholdEarly:.6,poreThresholdLate:.75,poreThresholdRange:.2,poreStrength:.12},"White Oak":{tileSize:1,ringScale:12,ringDistortion:1.2,knotIntensity:.8,latewoodBias:3,rayStrength:.8,poreDensity:20,gradientStops:[{offset:0,color:"#735940"},{offset:1,color:"#DBC7A6"}],fbmOctaves:4,fbmAmplitude:.6,knotFrequency:1,distortionFreq:1.8,ringNoiseFreq:6,rayFrequencyX:60,rayFrequencyY:2.5,knotThresholdMin:.3,knotThresholdMax:.7,normalStrength:10,roughnessMin:.3,roughnessMax:.7,poreScale:1,poreThresholdEarly:.55,poreThresholdLate:.7,poreThresholdRange:.2,poreStrength:.16},Walnut:{tileSize:1,ringScale:8,ringDistortion:1.5,knotIntensity:1,latewoodBias:1.5,rayStrength:.3,poreDensity:5,gradientStops:[{offset:0,color:"#40261A"},{offset:1,color:"#8C6640"}],fbmOctaves:3,fbmAmplitude:.7,knotFrequency:1.2,distortionFreq:2,ringNoiseFreq:5,rayFrequencyX:45,rayFrequencyY:2,knotThresholdMin:.5,knotThresholdMax:.9,normalStrength:8,roughnessMin:.35,roughnessMax:.65,poreScale:.6,poreThresholdEarly:.65,poreThresholdLate:.75,poreThresholdRange:.15,poreStrength:.1}};function AU(t,e){const n=ce(!1),s=ce(!1),r=async()=>{if(s.value){n.value=!0;return}s.value=!0;try{do{n.value=!1;const l=await i5(t.value,1024,1024);e("set-image",l)}while(n.value)}catch(l){console.error("Failed to generate wood texture:",l)}finally{s.value=!1}};let i=null;const o=()=>{i&&clearTimeout(i),i=window.setTimeout(()=>{r()},50)},a=l=>{Object.assign(t.value,l)};return _t(t,()=>{o()},{deep:!0}),{pendingGeneration:n,localIsGenerating:s,generateWood:r,applyPreset:a,woodPresets:nE}}const PU="tileSize",DU="Tile Size",NU="ringScale",MU="Ring Scale",LU="ringDistortion",OU="Distortion",FU="knotIntensity",UU="Knots",BU="latewoodBias",zU="Sharpness",GU="rayStrength",VU="Rays",WU="poreDensity",HU="Pores",KU="fbmOctaves",jU="FBM Octaves",XU="fbmAmplitude",qU="FBM Amplitude",YU="knotFrequency",ZU="Knot Frequency",QU="distortionFreq",JU="Distortion Frequency",eB="ringNoiseFreq",tB="Ring Noise Frequency",nB="rayFrequencyX",sB="Ray Frequency X",rB="rayFrequencyY",iB="Ray Frequency Y",oB="knotThresholdMin",aB="Knot Threshold Min",lB="knotThresholdMax",uB="Knot Threshold Max",cB="poreScale",hB="Pore Size",dB="poreThresholdEarly",fB="Early Wood Threshold",pB="poreThresholdLate",mB="Late Wood Threshold",gB="poreThresholdRange",xB="Threshold Range",bB="poreStrength",yB="Pore Strength",vB="normalStrength",wB="Normal Strength",SB="roughnessMin",CB="Min Roughness",TB="roughnessMax",IB="Max Roughness",kB=(t,e)=>n=>({id:t.id,label:t.label,value:e(n),min:t.min,max:t.max,step:t.step,valuePosition:t.valuePosition||"after",showRuler:t.showRuler||!1}),EB=t=>e=>t.map(n=>n(e)),_B=t=>e=>ye(()=>t(e)),Yg=(t,e)=>{const n=t.map((r,i)=>kB(r,e[i])),s=EB(n);return _B(s)},$B=[{id:PU,label:DU,min:.1,max:5,step:.1},{id:NU,label:MU,min:1,max:20,step:.5},{id:LU,label:OU,min:0,max:3,step:.1},{id:FU,label:UU,min:0,max:5,step:.1},{id:BU,label:zU,min:.1,max:5,step:.1},{id:GU,label:VU,min:0,max:10,step:.05},{id:WU,label:HU,min:0,max:150,step:.01}],RB=[t=>t.woodParams.tileSize,t=>t.woodParams.ringScale,t=>t.woodParams.ringDistortion,t=>t.woodParams.knotIntensity,t=>t.woodParams.latewoodBias,t=>t.woodParams.rayStrength,t=>t.woodParams.poreDensity],AB=Yg($B,RB),PB=[{id:KU,label:jU,min:1,max:5,step:1},{id:XU,label:qU,min:.1,max:1,step:.05},{id:YU,label:ZU,min:.5,max:2,step:.1},{id:QU,label:JU,min:1,max:3,step:.1},{id:eB,label:tB,min:3,max:10,step:.5},{id:nB,label:sB,min:10,max:300,step:5},{id:rB,label:iB,min:1,max:50,step:.5},{id:oB,label:aB,min:0,max:1,step:.05},{id:lB,label:uB,min:0,max:1,step:.05}],DB=[t=>t.woodParams.fbmOctaves,t=>t.woodParams.fbmAmplitude,t=>t.woodParams.knotFrequency,t=>t.woodParams.distortionFreq,t=>t.woodParams.ringNoiseFreq,t=>t.woodParams.rayFrequencyX,t=>t.woodParams.rayFrequencyY,t=>t.woodParams.knotThresholdMin,t=>t.woodParams.knotThresholdMax],NB=Yg(PB,DB),MB=[{id:cB,label:hB,min:.1,max:5,step:.1},{id:dB,label:fB,min:0,max:1,step:.01},{id:pB,label:mB,min:0,max:1,step:.01},{id:gB,label:xB,min:.05,max:.5,step:.01},{id:bB,label:yB,min:0,max:1,step:.01}],LB=[t=>t.woodParams.poreScale,t=>t.woodParams.poreThresholdEarly,t=>t.woodParams.poreThresholdLate,t=>t.woodParams.poreThresholdRange,t=>t.woodParams.poreStrength],OB=Yg(MB,LB),FB=[{id:vB,label:wB,min:1,max:20,step:.5},{id:SB,label:CB,min:.1,max:.5,step:.05},{id:TB,label:IB,min:.5,max:1,step:.05}],UB=[t=>t.woodParams.normalStrength,t=>t.woodParams.roughnessMin,t=>t.woodParams.roughnessMax],BB=Yg(FB,UB),zB=t=>["tileSize","ringScale","ringDistortion","knotIntensity","latewoodBias","rayStrength","poreDensity","fbmOctaves","fbmAmplitude","knotFrequency","distortionFreq","ringNoiseFreq","rayFrequencyX","rayFrequencyY","knotThresholdMin","knotThresholdMax","poreScale","poreThresholdEarly","poreThresholdLate","poreThresholdRange","poreStrength","normalStrength","roughnessMin","roughnessMax"].includes(t),GB=(t,e)=>zB(e.id)&&typeof t[e.id]=="number"?(t[e.id]=e.value,!0):!1,VB=We({__name:"WoodPanelColorSection",setup(t){const{state:e}=is();return(n,s)=>(F(),st(D(yo),{title:"Colors (Gradient)",modelValue:D(e).uiState.woodPanel.showColors,"onUpdate:modelValue":s[1]||(s[1]=r=>D(e).uiState.woodPanel.showColors=r)},{default:hr(()=>[we(D(jd),{modelValue:D(e).woodParams.gradientStops,"onUpdate:modelValue":s[0]||(s[0]=r=>D(e).woodParams.gradientStops=r)},null,8,["modelValue"])]),_:1},8,["modelValue"]))}}),Np=We({__name:"WoodPanelParamsSection",props:{title:{},modelValueKey:{},items:{}},emits:["update-param"],setup(t,{emit:e}){const n=e,{state:s}=is(),r=i=>{i.id in s.woodParams&&n("update-param",i)};return(i,o)=>(F(),st(D(yo),{title:t.title,modelValue:D(s).uiState.woodPanel[t.modelValueKey],"onUpdate:modelValue":o[0]||(o[0]=a=>D(s).uiState.woodPanel[t.modelValueKey]=a)},{default:hr(()=>[(F(!0),V(Xe,null,rt(t.items,a=>(F(),V("div",{key:a.id},[we(D(St),{items:[a],onUpdateValue:r},null,8,["items"])]))),128))]),_:1},8,["title","modelValue"]))}}),WB={class:"grid grid-cols-2 gap-2"},HB=["onClick"],KB=We({__name:"WoodPanelPresetsSection",emits:["update-param","apply-preset"],setup(t,{emit:e}){const{state:n}=is(),s=e,r=i=>{Object.assign(n.woodParams,i),s("apply-preset",i)};return(i,o)=>(F(),st(D(yo),{title:"Presets",modelValue:D(n).uiState.woodPanel.showPresets,"onUpdate:modelValue":o[0]||(o[0]=a=>D(n).uiState.woodPanel.showPresets=a)},{default:hr(()=>[k("div",WB,[(F(!0),V(Xe,null,rt(D(nE),(a,l)=>(F(),V("button",{key:l,onClick:u=>r(a),class:"glass-btn text-xs py-2 px-2 rounded bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 transition-colors"},Le(l),9,HB))),128))])]),_:1},8,["modelValue"]))}}),jB={class:"flex flex-col gap-4"},XB=We({__name:"WoodPanelSections",emits:["update-param","apply-preset"],setup(t,{emit:e}){const{state:n}=is(),s=AB(n),r=NB(n),i=OB(n),o=BB(n),a=e,l=c=>{c.id in n.woodParams&&(GB(n.woodParams,c),a("update-param",c))},u=c=>{a("apply-preset",c)};return(c,h)=>(F(),V("div",jB,[we(VB),we(Np,{title:"Basic Parameters","model-value-key":"showBasicParams",items:D(s),onUpdateParam:l},null,8,["items"]),we(Np,{title:"Pore Parameters","model-value-key":"showPoreParams",items:D(i),onUpdateParam:l},null,8,["items"]),we(Np,{title:"Advanced Parameters","model-value-key":"showAdvancedParams",items:D(r),onUpdateParam:l},null,8,["items"]),we(Np,{title:"Material Properties","model-value-key":"showMaterialParams",items:D(o),onUpdateParam:l},null,8,["items"]),we(KB,{onApplyPreset:u})]))}}),qB=["disabled"],YB={key:0,class:"i-carbon-circle-dash animate-spin text-lg"},ZB={key:1,class:"i-carbon-magic-wand text-lg"},QB=We({__name:"WoodPanelGenerate",props:{isGenerating:{type:Boolean}},emits:["generate"],setup(t,{emit:e}){const n=e,s=()=>{n("generate")};return(r,i)=>(F(),V("button",{onClick:s,disabled:t.isGenerating,class:"glass-btn w-full py-2.5 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 text-white/60 hover:text-white/90 text-sm font-medium transition-all flex items-center justify-center gap-2 disabled:opacity-50"},[t.isGenerating?(F(),V("div",YB)):(F(),V("div",ZB)),Tn(" "+Le(t.isGenerating?"Generating...":"Generate Wood Texture"),1)],8,qB))}}),JB={class:"flex flex-col gap-4"},ez=We({__name:"WoodPanel",props:{isGenerating:{type:Boolean}},emits:["set-image"],setup(t,{emit:e}){const n=e,{state:s}=is(),{generateWood:r}=AU(ye(()=>s.woodParams),n),i=a=>{},o=a=>{};return(a,l)=>(F(),V("div",JB,[we(XB,{onUpdateParam:i,onApplyPreset:o}),we(QB,{"is-generating":t.isGenerating,onGenerate:D(r)},null,8,["is-generating","onGenerate"])]))}}),tz={SET_IMAGE:"set-image"},Zg={IS_GENERATING_BOOLEAN:"isGenerating must be a boolean",INVALID_SLIDER_UPDATE:"Parameter should not be updated via number slider",NO_IMAGE_DATA:"No image data provided for set-image event"},nz={INVALID_IMAGE_DATA_WITH_REASON:t=>`Invalid image data for set-image event: ${t}`},sv={BOOLEAN:"boolean",STRING:"string"},Mp={SHOW_BASIC_PARAMS:"showBasicParams",SHOW_THREAD_PARAMS:"showThreadParams",SHOW_ADVANCED_PARAMS:"showAdvancedParams",SHOW_MATERIAL_PARAMS:"showMaterialParams"},Kn={TILE_SIZE:"tileSize",THREAD_DENSITY:"threadDensity",THREAD_THICKNESS:"threadThickness",WARP_WEFT_RATIO:"warpWeftRatio",THREAD_TWIST:"threadTwist",FIBER_DETAIL:"fiberDetail",FUZZINESS:"fuzziness",WEAVE_TIGHTNESS:"weaveTightness",THREAD_UNEVENNESS:"threadUnevenness",WEAVE_IMPERFECTION:"weaveImperfection",FBM_OCTAVES:"fbmOctaves",FBM_AMPLITUDE:"fbmAmplitude",NOISE_FREQUENCY:"noiseFrequency",COLOR_VARIATION:"colorVariation",THREAD_HEIGHT_SCALE:"threadHeightScale",THREAD_SHADOW_STRENGTH:"threadShadowStrength",WARP_SHEEN:"warpSheen",WEFT_SHEEN:"weftSheen",NORMAL_STRENGTH:"normalStrength",ROUGHNESS_MIN:"roughnessMin",ROUGHNESS_MAX:"roughnessMax"},jn={TILE_SIZE:"Tile Size",THREAD_DENSITY:"Thread Density",THREAD_THICKNESS:"Thread Thickness",WARP_WEFT_RATIO:"Warp/Weft Ratio",THREAD_TWIST:"Thread Twist",FIBER_DETAIL:"Fiber Detail",FUZZINESS:"Fuzziness",WEAVE_TIGHTNESS:"Weave Tightness",THREAD_UNEVENNESS:"Thread Unevenness",WEAVE_IMPERFECTION:"Weave Imperfection",FBM_OCTAVES:"FBM Octaves",FBM_AMPLITUDE:"FBM Amplitude",NOISE_FREQUENCY:"Noise Frequency",COLOR_VARIATION:"Color Variation",THREAD_HEIGHT_SCALE:"Thread Height Scale",THREAD_SHADOW_STRENGTH:"Thread Shadow",WARP_SHEEN:"Warp Sheen",WEFT_SHEEN:"Weft Sheen",NORMAL_STRENGTH:"Normal Strength",ROUGHNESS_MIN:"Min Roughness",ROUGHNESS_MAX:"Max Roughness"},Lp={BASIC_PARAMETERS:"Basic Parameters",THREAD_STRUCTURE:"Thread Structure",ADVANCED_PARAMETERS:"Advanced Parameters",MATERIAL_PROPERTIES:"Material Properties"},sz={AFTER:"after"},rz=50,zS={WIDTH:1024,HEIGHT:1024},Xn=t=>({id:t.id,label:t.label,value:t.value,min:t.min,max:t.max,step:t.step,valuePosition:sz.AFTER,showRuler:!1}),iz=()=>{const{state:t}=is();return ye(()=>[Xn({id:Kn.TILE_SIZE,label:jn.TILE_SIZE,value:t.plainWeaveParams.tileSize,min:.1,max:5,step:.1}),Xn({id:Kn.THREAD_DENSITY,label:jn.THREAD_DENSITY,value:t.plainWeaveParams.threadDensity,min:5,max:50,step:1}),Xn({id:Kn.THREAD_THICKNESS,label:jn.THREAD_THICKNESS,value:t.plainWeaveParams.threadThickness,min:.1,max:1,step:.05}),Xn({id:Kn.WARP_WEFT_RATIO,label:jn.WARP_WEFT_RATIO,value:t.plainWeaveParams.warpWeftRatio,min:.5,max:2,step:.1})])};function oz(t){return[Xn({id:Kn.THREAD_TWIST,label:jn.THREAD_TWIST,value:t.threadTwist,min:0,max:1,step:.05}),Xn({id:Kn.FIBER_DETAIL,label:jn.FIBER_DETAIL,value:t.fiberDetail,min:0,max:1,step:.05}),Xn({id:Kn.FUZZINESS,label:jn.FUZZINESS,value:t.fuzziness,min:0,max:1,step:.05})]}function az(t){return[Xn({id:Kn.WEAVE_TIGHTNESS,label:jn.WEAVE_TIGHTNESS,value:t.weaveTightness,min:0,max:1,step:.05}),Xn({id:Kn.THREAD_UNEVENNESS,label:jn.THREAD_UNEVENNESS,value:t.threadUnevenness,min:0,max:1,step:.05}),Xn({id:Kn.WEAVE_IMPERFECTION,label:jn.WEAVE_IMPERFECTION,value:t.weaveImperfection,min:0,max:1,step:.05})]}const lz=()=>{const{state:t}=is();return ye(()=>[...oz(t.plainWeaveParams),...az(t.plainWeaveParams)])};function uz(t){return[Xn({id:Kn.FBM_OCTAVES,label:jn.FBM_OCTAVES,value:t.fbmOctaves,min:1,max:5,step:1}),Xn({id:Kn.FBM_AMPLITUDE,label:jn.FBM_AMPLITUDE,value:t.fbmAmplitude,min:.1,max:1,step:.05}),Xn({id:Kn.NOISE_FREQUENCY,label:jn.NOISE_FREQUENCY,value:t.noiseFrequency,min:1,max:10,step:.5})]}function cz(t){return[Xn({id:Kn.COLOR_VARIATION,label:jn.COLOR_VARIATION,value:t.colorVariation,min:0,max:.2,step:.01}),Xn({id:Kn.THREAD_HEIGHT_SCALE,label:jn.THREAD_HEIGHT_SCALE,value:t.threadHeightScale,min:.5,max:2,step:.1}),Xn({id:Kn.THREAD_SHADOW_STRENGTH,label:jn.THREAD_SHADOW_STRENGTH,value:t.threadShadowStrength,min:0,max:1,step:.05})]}const hz=()=>{const{state:t}=is();return ye(()=>[...uz(t.plainWeaveParams),...cz(t.plainWeaveParams)])};function dz(t){return[Xn({id:Kn.WARP_SHEEN,label:jn.WARP_SHEEN,value:t.warpSheen,min:0,max:1,step:.05}),Xn({id:Kn.WEFT_SHEEN,label:jn.WEFT_SHEEN,value:t.weftSheen,min:0,max:1,step:.05}),Xn({id:Kn.NORMAL_STRENGTH,label:jn.NORMAL_STRENGTH,value:t.normalStrength,min:1,max:20,step:.5})]}function fz(t){return[Xn({id:Kn.ROUGHNESS_MIN,label:jn.ROUGHNESS_MIN,value:t.roughnessMin,min:.3,max:.7,step:.05}),Xn({id:Kn.ROUGHNESS_MAX,label:jn.ROUGHNESS_MAX,value:t.roughnessMax,min:.7,max:1,step:.05})]}const pz=()=>{const{state:t}=is();return ye(()=>[...dz(t.plainWeaveParams),...fz(t.plainWeaveParams)])},mz=()=>{const t=iz(),e=lz(),n=hz(),s=pz();return ye(()=>[{title:Lp.BASIC_PARAMETERS,modelKey:Mp.SHOW_BASIC_PARAMS,items:t.value},{title:Lp.THREAD_STRUCTURE,modelKey:Mp.SHOW_THREAD_PARAMS,items:e.value},{title:Lp.ADVANCED_PARAMETERS,modelKey:Mp.SHOW_ADVANCED_PARAMS,items:n.value},{title:Lp.MATERIAL_PROPERTIES,modelKey:Mp.SHOW_MATERIAL_PARAMS,items:s.value}])},gz={Cotton:{threadDensity:20,threadThickness:.45,warpWeftRatio:1,threadTwist:.5,fiberDetail:.3,fuzziness:.2,weaveTightness:.7,threadUnevenness:.15,weaveImperfection:.1,gradientStops:[{offset:0,color:"#D4C8B8"},{offset:1,color:"#F0E8DC"}],warpSheen:.3,weftSheen:.25},Linen:{threadDensity:15,threadThickness:.55,warpWeftRatio:1.1,threadTwist:.3,fiberDetail:.5,fuzziness:.1,weaveTightness:.6,threadUnevenness:.25,weaveImperfection:.2,gradientStops:[{offset:0,color:"#B8AE9C"},{offset:1,color:"#E8E0D0"}],warpSheen:.4,weftSheen:.35},Silk:{threadDensity:30,threadThickness:.25,warpWeftRatio:1,threadTwist:.7,fiberDetail:.1,fuzziness:0,weaveTightness:.9,threadUnevenness:.05,weaveImperfection:.05,gradientStops:[{offset:0,color:"#E8D8C8"},{offset:1,color:"#FFF8F0"}],warpSheen:.8,weftSheen:.75},Canvas:{threadDensity:12,threadThickness:.7,warpWeftRatio:1,threadTwist:.4,fiberDetail:.4,fuzziness:.3,weaveTightness:.8,threadUnevenness:.2,weaveImperfection:.15,gradientStops:[{offset:0,color:"#A89880"},{offset:1,color:"#D8D0C0"}],warpSheen:.1,weftSheen:.1}},xz=t=>{const e=t.isGenerating;return typeof e===sv.BOOLEAN?e:(console.warn(Zg.IS_GENERATING_BOOLEAN),!1)},bz=t=>typeof t.isGenerating!==sv.BOOLEAN?Zg.IS_GENERATING_BOOLEAN:!0,yz=t=>typeof t!==sv.STRING?"Image data must be a string":!0,vz=t=>["tileSize","threadDensity","threadThickness","warpWeftRatio","threadTwist","fiberDetail","fuzziness","weaveTightness","threadUnevenness","weaveImperfection","fbmOctaves","fbmAmplitude","noiseFrequency","colorVariation","threadHeightScale","threadShadowStrength","warpSheen","weftSheen","normalStrength","roughnessMin","roughnessMax","gradientStops"].includes(t),wz=t=>["tileSize","threadDensity","threadThickness","warpWeftRatio","threadTwist","fiberDetail","fuzziness","weaveTightness","threadUnevenness","weaveImperfection","fbmOctaves","fbmAmplitude","noiseFrequency","colorVariation","threadHeightScale","threadShadowStrength","warpSheen","weftSheen","normalStrength","roughnessMin","roughnessMax"].includes(t),Sz=t=>t.length===1&&typeof t[0]=="string",Cz=()=>({tileSize:(t,e)=>{t.tileSize=e},threadDensity:(t,e)=>{t.threadDensity=e},threadThickness:(t,e)=>{t.threadThickness=e},warpWeftRatio:(t,e)=>{t.warpWeftRatio=e},threadTwist:(t,e)=>{t.threadTwist=e},fiberDetail:(t,e)=>{t.fiberDetail=e},fuzziness:(t,e)=>{t.fuzziness=e},weaveTightness:(t,e)=>{t.weaveTightness=e},threadUnevenness:(t,e)=>{t.threadUnevenness=e},weaveImperfection:(t,e)=>{t.weaveImperfection=e},fbmOctaves:(t,e)=>{t.fbmOctaves=e},fbmAmplitude:(t,e)=>{t.fbmAmplitude=e},noiseFrequency:(t,e)=>{t.noiseFrequency=e},colorVariation:(t,e)=>{t.colorVariation=e},threadHeightScale:(t,e)=>{t.threadHeightScale=e},threadShadowStrength:(t,e)=>{t.threadShadowStrength=e},warpSheen:(t,e)=>{t.warpSheen=e},weftSheen:(t,e)=>{t.weftSheen=e},normalStrength:(t,e)=>{t.normalStrength=e},roughnessMin:(t,e)=>{t.roughnessMin=e},roughnessMax:(t,e)=>{t.roughnessMax=e}}),Tz=(t,e,n)=>{const r=Cz()[e];return r?(r(t,n),!0):!1},Iz=(t,e)=>{if(!vz(e.id)||!wz(e.id))return;const n={...t.plainWeaveParams};if(!Tz(n,e.id,e.value)){console.warn(Zg.INVALID_SLIDER_UPDATE,e.id);return}Object.assign(t.plainWeaveParams,n)},kz=(t,e)=>{Object.assign(t.plainWeaveParams,e)},Ez=t=>{const e=ce(!1),n=ce(!1);let s=null;return{generate:async()=>{if(n.value){e.value=!0;return}n.value=!0;try{do e.value=!1,await t();while(e.value)}catch(o){console.error("Failed to generate weave texture:",o)}finally{n.value=!1}},debouncedGenerate:()=>{s&&clearTimeout(s),s=setTimeout(()=>{t()},rz)},localIsGenerating:n}},_z=(t,e)=>Ez(async()=>{const s=await FF(t.plainWeaveParams,zS.WIDTH,zS.HEIGHT);e("set-image",s)}),$z=(t,e)=>{const{state:n}=is(),{generate:s,debouncedGenerate:r,localIsGenerating:i}=_z({plainWeaveParams:n.plainWeaveParams},t),o=l=>{Iz({plainWeaveParams:n.plainWeaveParams},l)},a=l=>{kz({plainWeaveParams:n.plainWeaveParams},l)};return _t(n.plainWeaveParams,()=>{r()},{deep:!0}),{state:{plainWeaveParams:n.plainWeaveParams},localIsGenerating:i,weavePresets:e,handleParamUpdate:o,handleApplyPreset:a,generate:s}},Rz={class:"flex flex-col gap-4"},Az=We({__name:"PlainWeavePanel",props:{isGenerating:{type:Boolean}},emits:["set-image"],setup(t,{emit:e}){const n=t,s=e,{state:r}=is(),{localIsGenerating:i,weavePresets:o,handleParamUpdate:a,handleApplyPreset:l,generate:u}=$z(s,gz),c=mz();return(h,d)=>(F(),V("div",Rz,[we(D(yo),{title:"Colors (Gradient)",modelValue:D(r).uiState.plainWeavePanel.showColors,"onUpdate:modelValue":d[1]||(d[1]=f=>D(r).uiState.plainWeavePanel.showColors=f)},{default:hr(()=>[we(D(jd),{modelValue:D(r).plainWeaveParams.gradientStops,"onUpdate:modelValue":d[0]||(d[0]=f=>D(r).plainWeaveParams.gradientStops=f)},null,8,["modelValue"])]),_:1},8,["modelValue"]),(F(!0),V(Xe,null,rt(D(c),f=>(F(),st(D(yo),{key:f.title,title:f.title,"v-model":D(r).uiState.plainWeavePanel[f.modelKey]},{default:hr(()=>[we(D(Lk),{"slider-items":f.items,onUpdateValue:D(a)},null,8,["slider-items","onUpdateValue"])]),_:2},1032,["title","v-model"]))),128)),we(D(yo),{title:"Presets",modelValue:D(r).uiState.plainWeavePanel.showPresets,"onUpdate:modelValue":d[2]||(d[2]=f=>D(r).uiState.plainWeavePanel.showPresets=f)},{default:hr(()=>[we(D(Ok),{presets:D(o),onApplyPreset:D(l)},null,8,["presets","onApplyPreset"])]),_:1},8,["modelValue"]),we(D(Fk),{"is-generating":n.isGenerating||D(i).value,"button-text":"Generate Fabric Texture",onClick:D(u)},null,8,["is-generating","onClick"])]))}}),Pz=(t,e)=>{if(e.length===0)return console.warn(Zg.NO_IMAGE_DATA),!0;const n=e[0],s=yz(n);if(s!==!0){const r=nz.INVALID_IMAGE_DATA_WITH_REASON(s);return console.warn(r),!0}return t(n),!1},Dz=t=>nv(Az,{debug:{enableLogging:!1,enablePerformance:!1,enableTypeChecking:!0},propsInterceptor:{intercept:()=>({isGenerating:xz(t.props)}),validate:e=>bz(e)},emitInterceptor:{intercept:(e,...n)=>{const s=t.emits[e];return s?e===tz.SET_IMAGE?Pz(s,n):(s(...n),!1):!0}}}),Nz={SET_IMAGE:"set-image"},Qg={IS_GENERATING_BOOLEAN:"isGenerating must be a boolean",INVALID_SLIDER_UPDATE:"Parameter should not be updated via number slider",NO_IMAGE_DATA:"No image data provided for set-image event"},Mz={INVALID_IMAGE_DATA_WITH_REASON:t=>`Invalid image data for set-image event: ${t}`},rv={BOOLEAN:"boolean",STRING:"string"},Op={SHOW_BASIC_PARAMS:"showBasicParams",SHOW_THREAD_PARAMS:"showThreadParams",SHOW_ADVANCED_PARAMS:"showAdvancedParams",SHOW_MATERIAL_PARAMS:"showMaterialParams"},Mn={TILE_SIZE:"tileSize",WARP_DENSITY:"warpDensity",WEFT_DENSITY:"weftDensity",BACKGROUND_OPACITY:"backgroundOpacity",THREAD_THICKNESS:"threadThickness",THREAD_TWIST:"threadTwist",FIBER_DETAIL:"fiberDetail",FUZZINESS:"fuzziness",WEAVE_TIGHTNESS:"weaveTightness",THREAD_UNEVENNESS:"threadUnevenness",WEAVE_IMPERFECTION:"weaveImperfection",FBM_OCTAVES:"fbmOctaves",FBM_AMPLITUDE:"fbmAmplitude",NOISE_FREQUENCY:"noiseFrequency",COLOR_VARIATION:"colorVariation",THREAD_HEIGHT_SCALE:"threadHeightScale",THREAD_SHADOW_STRENGTH:"threadShadowStrength",WARP_SHEEN:"warpSheen",WEFT_SHEEN:"weftSheen",NORMAL_STRENGTH:"normalStrength",ROUGHNESS_MIN:"roughnessMin",ROUGHNESS_MAX:"roughnessMax"},Ln={TILE_SIZE:"Tile Size",WARP_DENSITY:"Warp Density",WEFT_DENSITY:"Weft Density",BACKGROUND_OPACITY:"Background Opacity",THREAD_THICKNESS:"Thread Thickness",THREAD_TWIST:"Thread Twist",FIBER_DETAIL:"Fiber Detail",FUZZINESS:"Fuzziness",WEAVE_TIGHTNESS:"Weave Tightness",THREAD_UNEVENNESS:"Thread Unevenness",WEAVE_IMPERFECTION:"Weave Imperfection",FBM_OCTAVES:"FBM Octaves",FBM_AMPLITUDE:"FBM Amplitude",NOISE_FREQUENCY:"Noise Frequency",COLOR_VARIATION:"Color Variation",THREAD_HEIGHT_SCALE:"Thread Height Scale",THREAD_SHADOW_STRENGTH:"Thread Shadow",WARP_SHEEN:"Warp Sheen",WEFT_SHEEN:"Weft Sheen",NORMAL_STRENGTH:"Normal Strength",ROUGHNESS_MIN:"Min Roughness",ROUGHNESS_MAX:"Max Roughness"},Fp={BASIC_PARAMETERS:"Basic Parameters",THREAD_STRUCTURE:"Thread Structure",ADVANCED_PARAMETERS:"Advanced Parameters",MATERIAL_PROPERTIES:"Material Properties"},Lz={AFTER:"after"},Oz=50,GS={WIDTH:1024,HEIGHT:1024},Nt={BACKGROUND_OPACITY:{MIN:0,MAX:1},THREAD_TWIST:{MIN:0,MAX:1},FIBER_DETAIL:{MIN:0,MAX:1},FUZZINESS:{MIN:0,MAX:1},WEAVE_TIGHTNESS:{MIN:0,MAX:1},THREAD_UNEVENNESS:{MIN:0,MAX:1},WEAVE_IMPERFECTION:{MIN:0,MAX:.5},FBM_OCTAVES:{MIN:1,MAX:8},FBM_AMPLITUDE:{MIN:0,MAX:1},NOISE_FREQUENCY:{MIN:1,MAX:20},COLOR_VARIATION:{MIN:0,MAX:.5},THREAD_HEIGHT_SCALE:{MIN:0,MAX:2},THREAD_SHADOW_STRENGTH:{MIN:0,MAX:1},WARP_SHEEN:{MIN:0,MAX:1},WEFT_SHEEN:{MIN:0,MAX:1},NORMAL_STRENGTH:{MIN:0,MAX:20},ROUGHNESS_MIN:{MIN:0,MAX:1},ROUGHNESS_MAX:{MIN:0,MAX:1}},qs={DEFAULT:.01,INTEGER:1},On=t=>({id:t.id,label:t.label,value:t.value,min:t.min,max:t.max,step:t.step,valuePosition:Lz.AFTER,showRuler:!1}),Fz=()=>{const{state:t}=is();return ye(()=>{const e=t.plainWeaveAdvancedParams||Qu;return[On({id:Mn.TILE_SIZE,label:Ln.TILE_SIZE,value:e.tileSize,min:.1,max:5,step:.1}),On({id:Mn.WARP_DENSITY,label:Ln.WARP_DENSITY,value:e.warpDensity,min:5,max:100,step:1}),On({id:Mn.WEFT_DENSITY,label:Ln.WEFT_DENSITY,value:e.weftDensity,min:5,max:100,step:1}),On({id:Mn.BACKGROUND_OPACITY,label:Ln.BACKGROUND_OPACITY,value:e.backgroundOpacity,min:Nt.BACKGROUND_OPACITY.MIN,max:Nt.BACKGROUND_OPACITY.MAX,step:qs.DEFAULT}),On({id:Mn.THREAD_THICKNESS,label:Ln.THREAD_THICKNESS,value:e.threadThickness,min:.1,max:1,step:.05})]})};function Uz(t){return[On({id:Mn.THREAD_TWIST,label:Ln.THREAD_TWIST,value:t.threadTwist,min:Nt.THREAD_TWIST.MIN,max:Nt.THREAD_TWIST.MAX,step:qs.DEFAULT}),On({id:Mn.FIBER_DETAIL,label:Ln.FIBER_DETAIL,value:t.fiberDetail,min:Nt.FIBER_DETAIL.MIN,max:Nt.FIBER_DETAIL.MAX,step:qs.DEFAULT}),On({id:Mn.FUZZINESS,label:Ln.FUZZINESS,value:t.fuzziness,min:Nt.FUZZINESS.MIN,max:Nt.FUZZINESS.MAX,step:qs.DEFAULT})]}function Bz(t){return[On({id:Mn.WEAVE_TIGHTNESS,label:Ln.WEAVE_TIGHTNESS,value:t.weaveTightness,min:Nt.WEAVE_TIGHTNESS.MIN,max:Nt.WEAVE_TIGHTNESS.MAX,step:qs.DEFAULT}),On({id:Mn.THREAD_UNEVENNESS,label:Ln.THREAD_UNEVENNESS,value:t.threadUnevenness,min:Nt.THREAD_UNEVENNESS.MIN,max:Nt.THREAD_UNEVENNESS.MAX,step:qs.DEFAULT}),On({id:Mn.WEAVE_IMPERFECTION,label:Ln.WEAVE_IMPERFECTION,value:t.weaveImperfection,min:Nt.WEAVE_IMPERFECTION.MIN,max:Nt.WEAVE_IMPERFECTION.MAX,step:qs.DEFAULT})]}const zz=()=>{const{state:t}=is();return ye(()=>{const e=t.plainWeaveAdvancedParams||Qu;return[...Uz(e),...Bz(e)]})};function Gz(t){return[On({id:Mn.FBM_OCTAVES,label:Ln.FBM_OCTAVES,value:t.fbmOctaves,min:Nt.FBM_OCTAVES.MIN,max:Nt.FBM_OCTAVES.MAX,step:qs.INTEGER}),On({id:Mn.FBM_AMPLITUDE,label:Ln.FBM_AMPLITUDE,value:t.fbmAmplitude,min:Nt.FBM_AMPLITUDE.MIN,max:Nt.FBM_AMPLITUDE.MAX,step:qs.DEFAULT}),On({id:Mn.NOISE_FREQUENCY,label:Ln.NOISE_FREQUENCY,value:t.noiseFrequency,min:Nt.NOISE_FREQUENCY.MIN,max:Nt.NOISE_FREQUENCY.MAX,step:.5})]}function Vz(t){return[On({id:Mn.COLOR_VARIATION,label:Ln.COLOR_VARIATION,value:t.colorVariation,min:Nt.COLOR_VARIATION.MIN,max:Nt.COLOR_VARIATION.MAX,step:qs.DEFAULT}),On({id:Mn.THREAD_HEIGHT_SCALE,label:Ln.THREAD_HEIGHT_SCALE,value:t.threadHeightScale,min:Nt.THREAD_HEIGHT_SCALE.MIN,max:Nt.THREAD_HEIGHT_SCALE.MAX,step:.1}),On({id:Mn.THREAD_SHADOW_STRENGTH,label:Ln.THREAD_SHADOW_STRENGTH,value:t.threadShadowStrength,min:Nt.THREAD_SHADOW_STRENGTH.MIN,max:Nt.THREAD_SHADOW_STRENGTH.MAX,step:qs.DEFAULT})]}const Wz=()=>{const{state:t}=is();return ye(()=>{const e=t.plainWeaveAdvancedParams||Qu;return[...Gz(e),...Vz(e)]})};function Hz(t){return[On({id:Mn.WARP_SHEEN,label:Ln.WARP_SHEEN,value:t.warpSheen,min:Nt.WARP_SHEEN.MIN,max:Nt.WARP_SHEEN.MAX,step:qs.DEFAULT}),On({id:Mn.WEFT_SHEEN,label:Ln.WEFT_SHEEN,value:t.weftSheen,min:Nt.WEFT_SHEEN.MIN,max:Nt.WEFT_SHEEN.MAX,step:qs.DEFAULT}),On({id:Mn.NORMAL_STRENGTH,label:Ln.NORMAL_STRENGTH,value:t.normalStrength,min:Nt.NORMAL_STRENGTH.MIN,max:Nt.NORMAL_STRENGTH.MAX,step:.5})]}function Kz(t){return[On({id:Mn.ROUGHNESS_MIN,label:Ln.ROUGHNESS_MIN,value:t.roughnessMin,min:Nt.ROUGHNESS_MIN.MIN,max:Nt.ROUGHNESS_MIN.MAX,step:qs.DEFAULT}),On({id:Mn.ROUGHNESS_MAX,label:Ln.ROUGHNESS_MAX,value:t.roughnessMax,min:Nt.ROUGHNESS_MAX.MIN,max:Nt.ROUGHNESS_MAX.MAX,step:qs.DEFAULT})]}const jz=()=>{const{state:t}=is();return ye(()=>{const e=t.plainWeaveAdvancedParams||Qu;return[...Hz(e),...Kz(e)]})},Xz=()=>{const t=Fz(),e=zz(),n=Wz(),s=jz();return ye(()=>[{title:Fp.BASIC_PARAMETERS,modelKey:Op.SHOW_BASIC_PARAMS,items:t.value},{title:Fp.THREAD_STRUCTURE,modelKey:Op.SHOW_THREAD_PARAMS,items:e.value},{title:Fp.ADVANCED_PARAMETERS,modelKey:Op.SHOW_ADVANCED_PARAMS,items:n.value},{title:Fp.MATERIAL_PROPERTIES,modelKey:Op.SHOW_MATERIAL_PARAMS,items:s.value}])},qz={Cotton:{warpDensity:20,weftDensity:20,threadThickness:.45,threadTwist:.5,fiberDetail:.3,fuzziness:.2,weaveTightness:.7,threadUnevenness:.15,weaveImperfection:.1,warpColor:"#D4C8B8",weftColor:"#F0E8DC",warpSheen:.3,weftSheen:.25},Linen:{warpDensity:15,weftDensity:15,threadThickness:.55,threadTwist:.3,fiberDetail:.5,fuzziness:.1,weaveTightness:.6,threadUnevenness:.25,weaveImperfection:.2,warpColor:"#B8AE9C",weftColor:"#E8E0D0",warpSheen:.4,weftSheen:.35},Silk:{warpDensity:30,weftDensity:30,threadThickness:.25,threadTwist:.7,fiberDetail:.1,fuzziness:0,weaveTightness:.9,threadUnevenness:.05,weaveImperfection:.05,warpColor:"#E8D8C8",weftColor:"#FFF8F0",warpSheen:.8,weftSheen:.75},Canvas:{warpDensity:12,weftDensity:12,threadThickness:.7,threadTwist:.4,fiberDetail:.4,fuzziness:.3,weaveTightness:.8,threadUnevenness:.2,weaveImperfection:.15,warpColor:"#A89880",weftColor:"#D8D0C0",warpSheen:.1,weftSheen:.1}},Yz=t=>{const e=t.isGenerating;return typeof e===rv.BOOLEAN?e:(console.warn(Qg.IS_GENERATING_BOOLEAN),!1)},Zz=t=>typeof t.isGenerating!==rv.BOOLEAN?Qg.IS_GENERATING_BOOLEAN:!0,Qz=t=>typeof t!==rv.STRING?"Image data must be a string":!0,Jz=t=>["tileSize","warpDensity","weftDensity","warpColor","weftColor","threadThickness","threadTwist","fiberDetail","fuzziness","weaveTightness","threadUnevenness","weaveImperfection","fbmOctaves","fbmAmplitude","noiseFrequency","colorVariation","threadHeightScale","threadShadowStrength","warpSheen","weftSheen","normalStrength","roughnessMin","roughnessMax"].includes(t),e6=t=>typeof t!="string"?!1:["tileSize","warpDensity","weftDensity","threadThickness","threadTwist","fiberDetail","fuzziness","weaveTightness","threadUnevenness","weaveImperfection","fbmOctaves","fbmAmplitude","noiseFrequency","colorVariation","threadHeightScale","threadShadowStrength","warpSheen","weftSheen","normalStrength","roughnessMin","roughnessMax"].includes(t),t6=()=>({tileSize:(t,e)=>{t.tileSize=e},warpDensity:(t,e)=>{t.warpDensity=e},weftDensity:(t,e)=>{t.weftDensity=e},threadThickness:(t,e)=>{t.threadThickness=e},threadTwist:(t,e)=>{t.threadTwist=e},fiberDetail:(t,e)=>{t.fiberDetail=e},fuzziness:(t,e)=>{t.fuzziness=e},weaveTightness:(t,e)=>{t.weaveTightness=e},threadUnevenness:(t,e)=>{t.threadUnevenness=e},weaveImperfection:(t,e)=>{t.weaveImperfection=e},fbmOctaves:(t,e)=>{t.fbmOctaves=e},fbmAmplitude:(t,e)=>{t.fbmAmplitude=e},noiseFrequency:(t,e)=>{t.noiseFrequency=e},colorVariation:(t,e)=>{t.colorVariation=e},threadHeightScale:(t,e)=>{t.threadHeightScale=e},threadShadowStrength:(t,e)=>{t.threadShadowStrength=e},warpSheen:(t,e)=>{t.warpSheen=e},weftSheen:(t,e)=>{t.weftSheen=e},normalStrength:(t,e)=>{t.normalStrength=e},roughnessMin:(t,e)=>{t.roughnessMin=e},roughnessMax:(t,e)=>{t.roughnessMax=e}}),n6=(t,e,n)=>{const r=t6()[e];return r?(r(t,n),!0):!1},s6=(t,e)=>{if(!Jz(e.id)||!e6(e.id))return;const n={...t};if(!n6(n,e.id,e.value)){console.warn(Qg.INVALID_SLIDER_UPDATE,e.id);return}Object.assign(t,n)},r6=(t,e)=>{Object.assign(t,e)},i6=t=>{const e=ce(!1),n=ce(!1);let s=null;return{state:{localIsGenerating:n},actions:{generate:async()=>{if(n.value){e.value=!0;return}n.value=!0;try{do e.value=!1,await t();while(e.value)}catch(o){console.error("Failed to generate weave texture:",o)}finally{n.value=!1}},debouncedGenerate:()=>{s&&clearTimeout(s),s=setTimeout(()=>{t()},Oz)}}}},o6=(t,e)=>i6(async()=>{const s=await S5(t,GS.WIDTH,GS.HEIGHT);e("set-image",s)}),a6=(t,e)=>{const{state:n}=is(),{state:{localIsGenerating:s},actions:{generate:r,debouncedGenerate:i}}=o6(n.plainWeaveAdvancedParams,t),o=l=>{s6(n.plainWeaveAdvancedParams,l)},a=l=>{r6(n.plainWeaveAdvancedParams,l)};return _t(n.plainWeaveAdvancedParams,()=>{i()},{deep:!0}),{state:{plainWeaveParams:n.plainWeaveAdvancedParams,localIsGenerating:s,weavePresets:e},actions:{handleParamUpdate:o,handleApplyPreset:a,generate:r,debouncedGenerate:i}}},l6={class:"flex flex-col gap-4"},u6={class:"flex flex-col gap-4 p-2 bg-gray-800 rounded"},c6={class:"flex items-center justify-between"},h6={class:"flex items-center gap-2"},d6={class:"text-xs text-gray-400 font-mono"},f6={class:"flex items-center justify-between"},p6={class:"flex items-center gap-2"},m6={class:"text-xs text-gray-400 font-mono"},g6={class:"flex items-center justify-between"},x6={class:"flex items-center gap-2"},b6={class:"text-xs text-gray-400 font-mono"},y6=We({__name:"PlainWeaveAdvancedPanel",props:{isGenerating:{type:Boolean}},emits:["set-image"],setup(t,{emit:e}){const n=t,s=e,{state:r}=is(),{state:{localIsGenerating:i,weavePresets:o},actions:{handleParamUpdate:a,handleApplyPreset:l,generate:u,debouncedGenerate:c}}=a6(s,qz),h=Xz();return(d,f)=>(F(),V("div",l6,[we(D(yo),{title:"Fabrics Colors",modelValue:D(r).uiState.plainWeaveAdvancedPanel.showColors,"onUpdate:modelValue":f[6]||(f[6]=p=>D(r).uiState.plainWeaveAdvancedPanel.showColors=p)},{default:hr(()=>[k("div",u6,[k("div",c6,[f[8]||(f[8]=k("label",{class:"text-gray-300 text-sm font-medium"},"Warp Color (Vertical)",-1)),k("div",h6,[vt(k("input",{type:"color","onUpdate:modelValue":f[0]||(f[0]=p=>D(r).plainWeaveAdvancedParams.warpColor=p),onChange:f[1]||(f[1]=(...p)=>D(c)&&D(c)(...p)),class:"w-8 h-8 cursor-pointer border-none bg-transparent"},null,544),[[Lr,D(r).plainWeaveAdvancedParams.warpColor]]),k("span",d6,Le(D(r).plainWeaveAdvancedParams.warpColor),1)])]),k("div",f6,[f[9]||(f[9]=k("label",{class:"text-gray-300 text-sm font-medium"},"Weft Color (Horizontal)",-1)),k("div",p6,[vt(k("input",{type:"color","onUpdate:modelValue":f[2]||(f[2]=p=>D(r).plainWeaveAdvancedParams.weftColor=p),onChange:f[3]||(f[3]=(...p)=>D(c)&&D(c)(...p)),class:"w-8 h-8 cursor-pointer border-none bg-transparent"},null,544),[[Lr,D(r).plainWeaveAdvancedParams.weftColor]]),k("span",m6,Le(D(r).plainWeaveAdvancedParams.weftColor),1)])]),k("div",g6,[f[10]||(f[10]=k("label",{class:"text-gray-300 text-sm font-medium"},"Background Color",-1)),k("div",x6,[vt(k("input",{type:"color","onUpdate:modelValue":f[4]||(f[4]=p=>D(r).plainWeaveAdvancedParams.backgroundColor=p),onChange:f[5]||(f[5]=(...p)=>D(c)&&D(c)(...p)),class:"w-8 h-8 cursor-pointer border-none bg-transparent"},null,544),[[Lr,D(r).plainWeaveAdvancedParams.backgroundColor]]),k("span",b6,Le(D(r).plainWeaveAdvancedParams.backgroundColor),1)])])])]),_:1},8,["modelValue"]),(F(!0),V(Xe,null,rt(D(h),p=>(F(),st(D(yo),{key:p.title,title:p.title,"v-model":D(r).uiState.plainWeaveAdvancedPanel[p.modelKey]},{default:hr(()=>[we(D(Lk),{"slider-items":p.items,onUpdateValue:D(a)},null,8,["slider-items","onUpdateValue"])]),_:2},1032,["title","v-model"]))),128)),we(D(yo),{title:"Presets",modelValue:D(r).uiState.plainWeaveAdvancedPanel.showPresets,"onUpdate:modelValue":f[7]||(f[7]=p=>D(r).uiState.plainWeaveAdvancedPanel.showPresets=p)},{default:hr(()=>[we(D(Ok),{presets:D(o),onApplyPreset:D(l)},null,8,["presets","onApplyPreset"])]),_:1},8,["modelValue"]),we(D(Fk),{"is-generating":n.isGenerating||D(i),"button-text":"Generate Advanced Weave",onClick:D(u)},null,8,["is-generating","onClick"])]))}}),v6=(t,e)=>{if(e.length===0)return console.warn(Qg.NO_IMAGE_DATA),!0;const n=e[0],s=Qz(n);if(s!==!0){const r=Mz.INVALID_IMAGE_DATA_WITH_REASON(s);return console.warn(r),!0}return t(n),!1},w6=t=>nv(y6,{debug:{enableLogging:!1,enablePerformance:!1,enableTypeChecking:!0},propsInterceptor:{intercept:()=>({isGenerating:Yz(t.props)}),validate:e=>Zz(e)},emitInterceptor:{intercept:(e,...n)=>{const s=t.emits[e];return s?e===Nz.SET_IMAGE?v6(s,n):(s(...n),!1):!0}}}),S6={class:"flex flex-col gap-4"},C6={class:"flex flex-col gap-3"},T6={class:"flex items-center justify-between"},I6={class:"flex flex-col gap-3"},k6={class:"flex flex-col gap-3"},E6={class:"flex items-center justify-between"},_6={class:"flex flex-col gap-3"},$6={class:"flex flex-col gap-3"},R6={class:"flex items-center justify-between"},A6={class:"flex flex-col gap-3"},P6={class:"flex flex-col gap-3"},D6={class:"flex items-center justify-between"},N6={class:"flex flex-col gap-3"},M6={class:"flex flex-col gap-3"},L6={class:"flex items-center justify-between"},O6={class:"flex flex-col gap-3"},F6={class:"flex flex-col gap-3"},U6={class:"flex items-center justify-between"},B6={class:"flex flex-col gap-3"},z6={class:"flex flex-col gap-3"},G6={class:"flex items-center justify-between"},V6={class:"flex flex-col gap-3"},W6={class:"flex flex-col gap-3"},H6={class:"flex items-center justify-between"},K6={class:"grid grid-cols-2 gap-2"},j6=["onClick"],X6=["disabled"],q6={key:0,class:"i-carbon-circle-dash animate-spin text-lg"},Y6={key:1,class:"i-carbon-magic-wand text-lg"},Z6=We({__name:"LeatherPanel",props:{isGenerating:{type:Boolean}},emits:["set-image"],setup(t,{emit:e}){const n=e,s=ce(!0),r=ce(!0),i=ce(!1),o=ce(!1),a=ce(!1),l=ce(!1),u=ce(!1),c=ce(!1),h=pi({...HF}),d=ye(()=>[{id:"tileSize",label:"Tile Size",value:h.tileSize,min:.1,max:5,step:.1,valuePosition:"after",showRuler:!1},{id:"cellScale",label:"Cell Scale",value:h.cellScale,min:5,max:40,step:1,valuePosition:"after",showRuler:!1},{id:"cellRandomness",label:"Randomness",value:h.cellRandomness,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"cellStretch",label:"Stretch",value:h.cellStretch,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"cellStretchAngle",label:"Stretch Angle",value:h.cellStretchAngle,min:0,max:3.14,step:.1,valuePosition:"after",showRuler:!1}]),f=ye(()=>[{id:"grooveWidth",label:"Groove Width",value:h.grooveWidth,min:.01,max:.5,step:.01,valuePosition:"after",showRuler:!1},{id:"grooveDepth",label:"Groove Depth",value:h.grooveDepth,min:.1,max:2,step:.1,valuePosition:"after",showRuler:!1},{id:"grooveProfile",label:"Profile (V-U)",value:h.grooveProfile,min:0,max:1,step:.1,valuePosition:"after",showRuler:!1}]),p=ye(()=>[{id:"wrinkleScale",label:"Wrinkle Scale",value:h.wrinkleScale,min:1,max:20,step:.5,valuePosition:"after",showRuler:!1},{id:"wrinkleIntensity",label:"Wrinkle Strength",value:h.wrinkleIntensity,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"poreDensity",label:"Pore Density",value:h.poreDensity,min:0,max:10,step:.1,valuePosition:"after",showRuler:!1},{id:"poreDepth",label:"Pore Depth",value:h.poreDepth,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"poreVisibility",label:"Pore Visibility",value:h.poreVisibility,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1}]),g=ye(()=>[{id:"fiberScale",label:"Fiber Scale",value:h.fiberScale,min:5,max:50,step:1,valuePosition:"after",showRuler:!1},{id:"fiberStrength",label:"Fiber Strength",value:h.fiberStrength,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"fiberDetail",label:"Fiber Detail",value:h.fiberDetail,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"fiberDirectionality",label:"Directionality",value:h.fiberDirectionality,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"fiberRandomness",label:"Random Direction",value:h.fiberRandomness,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1}]),m=ye(()=>[{id:"creaseIntensity",label:"Creases",value:h.creaseIntensity,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"creaseFrequency",label:"Crease Freq",value:h.creaseFrequency,min:.5,max:5,step:.1,valuePosition:"after",showRuler:!1},{id:"wearLevel",label:"Wear Level",value:h.wearLevel,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"scratchCount",label:"Scratches",value:h.scratchCount,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"scratchIntensity",label:"Scratch Intensity",value:h.scratchIntensity,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1}]),x=ye(()=>[{id:"roughnessMin",label:"Min Roughness",value:h.roughnessMin,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"roughnessMax",label:"Max Roughness",value:h.roughnessMax,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"normalStrength",label:"Normal Strength",value:h.normalStrength,min:1,max:20,step:.5,valuePosition:"after",showRuler:!1},{id:"patinaStrength",label:"Patina / Dirt",value:h.patinaStrength,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"colorVariation",label:"Color Variation",value:h.colorVariation,min:0,max:.5,step:.01,valuePosition:"after",showRuler:!1}]),b={"Cowhide (Full Grain)":{cellScale:15,cellRandomness:.7,grooveWidth:.15,grooveDepth:1,wrinkleScale:8,wrinkleIntensity:.3,poreDensity:2,poreDepth:.3,wearLevel:0,roughnessMin:.3,roughnessMax:.6,gradientStops:[{offset:0,color:"#3E2723"},{offset:1,color:"#8D6E63"}]},"Buffalo (Rough)":{cellScale:8,cellRandomness:.9,grooveWidth:.25,grooveDepth:1.5,wrinkleScale:4,wrinkleIntensity:.6,poreDensity:4,poreVisibility:.8,wearLevel:.2,roughnessMin:.5,roughnessMax:.9,gradientStops:[{offset:0,color:"#1A120B"},{offset:1,color:"#3C2A21"}]},"Aged Saddle":{cellScale:12,cellRandomness:.6,grooveWidth:.2,grooveDepth:.8,creaseIntensity:.6,wearLevel:.8,patinaStrength:.6,roughnessMin:.2,roughnessMax:.7,gradientStops:[{offset:0,color:"#2C1B10"},{offset:1,color:"#A0522D"}]},"Fine Nappa":{cellScale:25,cellRandomness:.4,grooveWidth:.1,grooveDepth:.5,wrinkleIntensity:.1,poreVisibility:.2,roughnessMin:.4,roughnessMax:.6,gradientStops:[{offset:0,color:"#212121"},{offset:1,color:"#424242"}]},"Reptile / Gator":{cellScale:6,cellRandomness:.2,cellStretch:0,grooveWidth:.3,grooveProfile:0,grooveDepth:2,roughnessMin:.1,roughnessMax:.4,gradientStops:[{offset:0,color:"#003300"},{offset:1,color:"#336633"}]}},v=E=>{E.id in h&&(h[E.id]=E.value)},y=E=>{Object.assign(h,E)},C=ce(!1),I=ce(!1),$=async()=>{if(I.value){C.value=!0;return}I.value=!0;try{do{C.value=!1;const E=await jF(h,1024,1024);n("set-image",E)}while(C.value)}catch(E){console.error("Failed to generate leather texture:",E)}finally{I.value=!1}};let T=null;const S=()=>{T&&clearTimeout(T),T=setTimeout(()=>{$()},100)};return _t(h,()=>{S()},{deep:!0}),(E,_)=>(F(),V("div",S6,[k("div",C6,[k("div",T6,[_[9]||(_[9]=k("span",{class:"text-xs font-medium text-white/60"},"Colors (Gradient)",-1)),k("button",{onClick:_[0]||(_[0]=N=>s.value=!s.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":s.value}])},null,2)])]),vt(k("div",I6,[we(jd,{modelValue:h.gradientStops,"onUpdate:modelValue":_[1]||(_[1]=N=>h.gradientStops=N)},null,8,["modelValue"])],512),[[Gt,s.value]])]),k("div",k6,[k("div",E6,[_[10]||(_[10]=k("span",{class:"text-xs font-medium text-white/60"},"Grain Pattern",-1)),k("button",{onClick:_[2]||(_[2]=N=>r.value=!r.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":r.value}])},null,2)])]),vt(k("div",_6,[(F(!0),V(Xe,null,rt(d.value,N=>(F(),V("div",{key:N.id},[we(D(St),{items:[N],onUpdateValue:v},null,8,["items"])]))),128))],512),[[Gt,r.value]])]),k("div",$6,[k("div",R6,[_[11]||(_[11]=k("span",{class:"text-xs font-medium text-white/60"},"Boundaries & Grooves",-1)),k("button",{onClick:_[3]||(_[3]=N=>i.value=!i.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":i.value}])},null,2)])]),vt(k("div",A6,[(F(!0),V(Xe,null,rt(f.value,N=>(F(),V("div",{key:N.id},[we(D(St),{items:[N],onUpdateValue:v},null,8,["items"])]))),128))],512),[[Gt,i.value]])]),k("div",P6,[k("div",D6,[_[12]||(_[12]=k("span",{class:"text-xs font-medium text-white/60"},"Surface Detail (Pores/Wrinkles)",-1)),k("button",{onClick:_[4]||(_[4]=N=>o.value=!o.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":o.value}])},null,2)])]),vt(k("div",N6,[(F(!0),V(Xe,null,rt(p.value,N=>(F(),V("div",{key:N.id},[we(D(St),{items:[N],onUpdateValue:v},null,8,["items"])]))),128))],512),[[Gt,o.value]])]),k("div",M6,[k("div",L6,[_[13]||(_[13]=k("span",{class:"text-xs font-medium text-white/60"},"Fibers & Fine Lines",-1)),k("button",{onClick:_[5]||(_[5]=N=>a.value=!a.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":a.value}])},null,2)])]),vt(k("div",O6,[(F(!0),V(Xe,null,rt(g.value,N=>(F(),V("div",{key:N.id},[we(D(St),{items:[N],onUpdateValue:v},null,8,["items"])]))),128))],512),[[Gt,a.value]])]),k("div",F6,[k("div",U6,[_[14]||(_[14]=k("span",{class:"text-xs font-medium text-white/60"},"Imperfections & Aging",-1)),k("button",{onClick:_[6]||(_[6]=N=>l.value=!l.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":l.value}])},null,2)])]),vt(k("div",B6,[(F(!0),V(Xe,null,rt(m.value,N=>(F(),V("div",{key:N.id},[we(D(St),{items:[N],onUpdateValue:v},null,8,["items"])]))),128))],512),[[Gt,l.value]])]),k("div",z6,[k("div",G6,[_[15]||(_[15]=k("span",{class:"text-xs font-medium text-white/60"},"Material Properties",-1)),k("button",{onClick:_[7]||(_[7]=N=>u.value=!u.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":u.value}])},null,2)])]),vt(k("div",V6,[(F(!0),V(Xe,null,rt(x.value,N=>(F(),V("div",{key:N.id},[we(D(St),{items:[N],onUpdateValue:v},null,8,["items"])]))),128))],512),[[Gt,u.value]])]),k("div",W6,[k("div",H6,[_[16]||(_[16]=k("span",{class:"text-xs font-medium text-white/60"},"Presets",-1)),k("button",{onClick:_[8]||(_[8]=N=>c.value=!c.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":c.value}])},null,2)])]),vt(k("div",K6,[(F(),V(Xe,null,rt(b,(N,P)=>k("button",{key:P,onClick:M=>y(N),class:"glass-btn text-xs py-2 px-2 rounded bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 transition-colors"},Le(P),9,j6)),64))],512),[[Gt,c.value]])]),k("button",{onClick:$,disabled:t.isGenerating,class:"glass-btn w-full py-2.5 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 text-white/60 hover:text-white/90 text-sm font-medium transition-all flex items-center justify-center gap-2 disabled:opacity-50"},[t.isGenerating?(F(),V("div",q6)):(F(),V("div",Y6)),Tn(" "+Le(t.isGenerating?"Generating...":"Generate Leather Texture"),1)],8,X6)]))}}),Q6={class:"flex flex-col gap-4"},J6={class:"flex flex-col gap-3"},eG={class:"flex items-center justify-between"},tG={class:"flex flex-col gap-3"},nG={class:"flex flex-col gap-3"},sG={class:"flex items-center justify-between"},rG={class:"flex flex-col gap-3"},iG={class:"flex flex-col gap-3"},oG={class:"flex items-center justify-between"},aG={class:"flex flex-col gap-3"},lG={class:"flex flex-col gap-3"},uG={class:"flex items-center justify-between"},cG={class:"flex flex-col gap-3"},hG={class:"flex flex-col gap-3"},dG={class:"flex items-center justify-between"},fG={class:"flex flex-col gap-3"},pG={class:"flex flex-col gap-3"},mG={class:"flex items-center justify-between"},gG={class:"flex flex-col gap-3"},xG={class:"flex flex-col gap-3"},bG={class:"flex items-center justify-between"},yG={class:"grid grid-cols-2 gap-2"},vG=["onClick"],wG=["disabled"],SG={key:0,class:"i-carbon-circle-dash animate-spin text-lg"},CG={key:1,class:"i-carbon-magic-wand text-lg"},TG=We({__name:"TwillWeavePanel",props:{isGenerating:{type:Boolean}},emits:["set-image"],setup(t,{emit:e}){const n=e,{state:s}=is(),r=ye(()=>[{id:"tileSize",label:"Tile Size",value:s.twillWeaveParams.tileSize,min:.1,max:5,step:.1,valuePosition:"after",showRuler:!1},{id:"threadDensity",label:"Thread Density",value:s.twillWeaveParams.threadDensity,min:5,max:50,step:1,valuePosition:"after",showRuler:!1},{id:"threadThickness",label:"Thread Thickness",value:s.twillWeaveParams.threadThickness,min:.1,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"warpWeftRatio",label:"Warp/Weft Ratio",value:s.twillWeaveParams.warpWeftRatio,min:.5,max:2,step:.1,valuePosition:"after",showRuler:!1}]),i=ye(()=>[{id:"twillRepeat",label:"Twill Repeat",value:s.twillWeaveParams.twillRepeat,min:2,max:8,step:1,valuePosition:"after",showRuler:!1},{id:"herringboneScale",label:"Herringbone Scale",value:s.twillWeaveParams.herringboneScale,min:0,max:20,step:1,valuePosition:"after",showRuler:!1},{id:"waleDepth",label:"Wale Depth",value:s.twillWeaveParams.waleDepth,min:.1,max:2,step:.1,valuePosition:"after",showRuler:!1}]),o=ye(()=>[{id:"threadTwist",label:"Thread Twist",value:s.twillWeaveParams.threadTwist,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"fiberDetail",label:"Fiber Detail",value:s.twillWeaveParams.fiberDetail,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"fuzziness",label:"Fuzziness",value:s.twillWeaveParams.fuzziness,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"weaveTightness",label:"Weave Tightness",value:s.twillWeaveParams.weaveTightness,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"threadUnevenness",label:"Thread Unevenness",value:s.twillWeaveParams.threadUnevenness,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"weaveImperfection",label:"Weave Imperfection",value:s.twillWeaveParams.weaveImperfection,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1}]),a=ye(()=>[{id:"fbmOctaves",label:"FBM Octaves",value:s.twillWeaveParams.fbmOctaves,min:1,max:5,step:1,valuePosition:"after",showRuler:!1},{id:"fbmAmplitude",label:"FBM Amplitude",value:s.twillWeaveParams.fbmAmplitude,min:.1,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"noiseFrequency",label:"Noise Frequency",value:s.twillWeaveParams.noiseFrequency,min:1,max:10,step:.5,valuePosition:"after",showRuler:!1},{id:"colorVariation",label:"Color Variation",value:s.twillWeaveParams.colorVariation,min:0,max:.2,step:.01,valuePosition:"after",showRuler:!1},{id:"threadHeightScale",label:"Thread Height Scale",value:s.twillWeaveParams.threadHeightScale,min:.5,max:2,step:.1,valuePosition:"after",showRuler:!1},{id:"threadShadowStrength",label:"Thread Shadow",value:s.twillWeaveParams.threadShadowStrength,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1}]),l=ye(()=>[{id:"warpSheen",label:"Warp Sheen",value:s.twillWeaveParams.warpSheen,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"weftSheen",label:"Weft Sheen",value:s.twillWeaveParams.weftSheen,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"normalStrength",label:"Normal Strength",value:s.twillWeaveParams.normalStrength,min:1,max:20,step:.5,valuePosition:"after",showRuler:!1},{id:"roughnessMin",label:"Min Roughness",value:s.twillWeaveParams.roughnessMin,min:.3,max:.7,step:.05,valuePosition:"after",showRuler:!1},{id:"roughnessMax",label:"Max Roughness",value:s.twillWeaveParams.roughnessMax,min:.7,max:1,step:.05,valuePosition:"after",showRuler:!1}]),u={Denim:{threadDensity:40,threadThickness:.8,warpWeftRatio:1,threadTwist:.7,fiberDetail:.4,fuzziness:.3,twillRepeat:4,herringboneScale:0,waleDepth:1.2,weaveTightness:.85,threadUnevenness:.2,weaveImperfection:.15,gradientStops:[{offset:0,color:"#1a1a2e"},{offset:.3,color:"#e0e0d0"},{offset:.6,color:"#2c3e50"},{offset:1,color:"#34495e"}],fbmOctaves:4,fbmAmplitude:.4,noiseFrequency:3,colorVariation:.15,warpSheen:.4,weftSheen:.1,roughnessMin:.5,roughnessMax:.9,normalStrength:8,threadHeightScale:1.2,threadShadowStrength:.6},Herringbone:{threadDensity:35,threadThickness:.7,warpWeftRatio:1,threadTwist:.6,fiberDetail:.3,fuzziness:.2,twillRepeat:4,herringboneScale:10,waleDepth:1,weaveTightness:.8,threadUnevenness:.15,weaveImperfection:.1,gradientStops:[{offset:0,color:"#3a3a4a"},{offset:.3,color:"#d0d0c0"},{offset:.6,color:"#4a5a6a"},{offset:1,color:"#5a6a7a"}],fbmOctaves:3,fbmAmplitude:.3,noiseFrequency:2.5,colorVariation:.1,warpSheen:.3,weftSheen:.2,roughnessMin:.4,roughnessMax:.8,normalStrength:6,threadHeightScale:1,threadShadowStrength:.5},Gabardine:{threadDensity:45,threadThickness:.6,warpWeftRatio:1.2,threadTwist:.8,fiberDetail:.2,fuzziness:.1,twillRepeat:3,herringboneScale:0,waleDepth:.8,weaveTightness:.9,threadUnevenness:.1,weaveImperfection:.05,gradientStops:[{offset:0,color:"#2a2a3a"},{offset:.3,color:"#c0c0b0"},{offset:.6,color:"#3a4a5a"},{offset:1,color:"#4a5a6a"}],fbmOctaves:2,fbmAmplitude:.2,noiseFrequency:2,colorVariation:.08,warpSheen:.5,weftSheen:.3,roughnessMin:.3,roughnessMax:.7,normalStrength:5,threadHeightScale:.8,threadShadowStrength:.4},"Cavalry Twill":{threadDensity:30,threadThickness:.75,warpWeftRatio:1.1,threadTwist:.65,fiberDetail:.35,fuzziness:.25,twillRepeat:6,herringboneScale:0,waleDepth:1.5,weaveTightness:.75,threadUnevenness:.18,weaveImperfection:.12,gradientStops:[{offset:0,color:"#4a4a5a"},{offset:.3,color:"#e8e8d8"},{offset:.6,color:"#5a6a7a"},{offset:1,color:"#6a7a8a"}],fbmOctaves:4,fbmAmplitude:.35,noiseFrequency:2.8,colorVariation:.12,warpSheen:.35,weftSheen:.25,roughnessMin:.45,roughnessMax:.85,normalStrength:7,threadHeightScale:1.1,threadShadowStrength:.55}},c=x=>{x.id in s.twillWeaveParams&&(s.twillWeaveParams[x.id]=x.value)},h=x=>{Object.assign(s.twillWeaveParams,x)},d=ce(!1),f=ce(!1),p=async()=>{if(f.value){d.value=!0;return}f.value=!0;try{do{d.value=!1;const x=await zF(s.twillWeaveParams,1024,1024);n("set-image",x)}while(d.value)}catch(x){console.error("Failed to generate twill weave texture:",x)}finally{f.value=!1}};let g=null;const m=()=>{g&&clearTimeout(g),g=setTimeout(()=>{p()},50)};return _t(s.twillWeaveParams,()=>{m()},{deep:!0}),(x,b)=>(F(),V("div",Q6,[k("div",J6,[k("div",eG,[b[8]||(b[8]=k("span",{class:"text-xs font-medium text-white/60"},"Colors (Gradient)",-1)),k("button",{onClick:b[0]||(b[0]=v=>D(s).uiState.twillWeavePanel.showColors=!D(s).uiState.twillWeavePanel.showColors),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.twillWeavePanel.showColors}])},null,2)])]),vt(k("div",tG,[we(jd,{modelValue:D(s).twillWeaveParams.gradientStops,"onUpdate:modelValue":b[1]||(b[1]=v=>D(s).twillWeaveParams.gradientStops=v)},null,8,["modelValue"])],512),[[Gt,D(s).uiState.twillWeavePanel.showColors]])]),k("div",nG,[k("div",sG,[b[9]||(b[9]=k("span",{class:"text-xs font-medium text-white/60"},"Basic Parameters",-1)),k("button",{onClick:b[2]||(b[2]=v=>D(s).uiState.twillWeavePanel.showBasicParams=!D(s).uiState.twillWeavePanel.showBasicParams),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.twillWeavePanel.showBasicParams}])},null,2)])]),vt(k("div",rG,[(F(!0),V(Xe,null,rt(r.value,v=>(F(),V("div",{key:v.id},[we(D(St),{items:[v],onUpdateValue:c},null,8,["items"])]))),128))],512),[[Gt,D(s).uiState.twillWeavePanel.showBasicParams]])]),k("div",iG,[k("div",oG,[b[10]||(b[10]=k("span",{class:"text-xs font-medium text-white/60"},"Twill Pattern",-1)),k("button",{onClick:b[3]||(b[3]=v=>D(s).uiState.twillWeavePanel.showTwillParams=!D(s).uiState.twillWeavePanel.showTwillParams),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.twillWeavePanel.showTwillParams}])},null,2)])]),vt(k("div",aG,[(F(!0),V(Xe,null,rt(i.value,v=>(F(),V("div",{key:v.id},[we(D(St),{items:[v],onUpdateValue:c},null,8,["items"])]))),128))],512),[[Gt,D(s).uiState.twillWeavePanel.showTwillParams]])]),k("div",lG,[k("div",uG,[b[11]||(b[11]=k("span",{class:"text-xs font-medium text-white/60"},"Thread Structure",-1)),k("button",{onClick:b[4]||(b[4]=v=>D(s).uiState.twillWeavePanel.showThreadParams=!D(s).uiState.twillWeavePanel.showThreadParams),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.twillWeavePanel.showThreadParams}])},null,2)])]),vt(k("div",cG,[(F(!0),V(Xe,null,rt(o.value,v=>(F(),V("div",{key:v.id},[we(D(St),{items:[v],onUpdateValue:c},null,8,["items"])]))),128))],512),[[Gt,D(s).uiState.twillWeavePanel.showThreadParams]])]),k("div",hG,[k("div",dG,[b[12]||(b[12]=k("span",{class:"text-xs font-medium text-white/60"},"Advanced Parameters",-1)),k("button",{onClick:b[5]||(b[5]=v=>D(s).uiState.twillWeavePanel.showAdvancedParams=!D(s).uiState.twillWeavePanel.showAdvancedParams),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.twillWeavePanel.showAdvancedParams}])},null,2)])]),vt(k("div",fG,[(F(!0),V(Xe,null,rt(a.value,v=>(F(),V("div",{key:v.id},[we(D(St),{items:[v],onUpdateValue:c},null,8,["items"])]))),128))],512),[[Gt,D(s).uiState.twillWeavePanel.showAdvancedParams]])]),k("div",pG,[k("div",mG,[b[13]||(b[13]=k("span",{class:"text-xs font-medium text-white/60"},"Material Properties",-1)),k("button",{onClick:b[6]||(b[6]=v=>D(s).uiState.twillWeavePanel.showMaterialParams=!D(s).uiState.twillWeavePanel.showMaterialParams),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.twillWeavePanel.showMaterialParams}])},null,2)])]),vt(k("div",gG,[(F(!0),V(Xe,null,rt(l.value,v=>(F(),V("div",{key:v.id},[we(D(St),{items:[v],onUpdateValue:c},null,8,["items"])]))),128))],512),[[Gt,D(s).uiState.twillWeavePanel.showMaterialParams]])]),k("div",xG,[k("div",bG,[b[14]||(b[14]=k("span",{class:"text-xs font-medium text-white/60"},"Presets",-1)),k("button",{onClick:b[7]||(b[7]=v=>D(s).uiState.twillWeavePanel.showPresets=!D(s).uiState.twillWeavePanel.showPresets),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.twillWeavePanel.showPresets}])},null,2)])]),vt(k("div",yG,[(F(),V(Xe,null,rt(u,(v,y)=>k("button",{key:y,onClick:C=>h(v),class:"glass-btn text-xs py-2 px-2 rounded bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 transition-colors"},Le(y),9,vG)),64))],512),[[Gt,D(s).uiState.twillWeavePanel.showPresets]])]),k("button",{onClick:p,disabled:t.isGenerating,class:"glass-btn w-full py-2.5 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 text-white/60 hover:text-white/90 text-sm font-medium transition-all flex items-center justify-center gap-2 disabled:opacity-50"},[t.isGenerating?(F(),V("div",SG)):(F(),V("div",CG)),Tn(" "+Le(t.isGenerating?"Generating...":"Generate Twill Fabric"),1)],8,wG)]))}}),IG={class:"flex flex-col gap-4"},kG={class:"flex flex-col gap-3"},EG={class:"flex items-center justify-between"},_G={class:"flex flex-col gap-3"},$G={class:"flex flex-col gap-3"},RG={class:"flex items-center justify-between"},AG={class:"flex flex-col gap-3"},PG={class:"flex flex-col gap-3"},DG={class:"flex items-center justify-between"},NG={class:"flex flex-col gap-3"},MG={class:"flex flex-col gap-3"},LG={class:"flex items-center justify-between"},OG={class:"flex flex-col gap-3"},FG={class:"flex flex-col gap-3"},UG={class:"flex items-center justify-between"},BG={class:"flex flex-col gap-3"},zG={class:"flex flex-col gap-3"},GG={class:"flex items-center justify-between"},VG={class:"flex flex-col gap-3"},WG={class:"flex flex-col gap-3"},HG={class:"flex items-center justify-between"},KG={class:"grid grid-cols-2 gap-2"},jG=["onClick"],XG=["disabled"],qG={key:0,class:"i-carbon-circle-dash animate-spin text-lg"},YG={key:1,class:"i-carbon-magic-wand text-lg"},ZG=We({__name:"VelvetPanel",props:{isGenerating:{type:Boolean}},emits:["set-image"],setup(t,{emit:e}){const n=e,{state:s}=is(),r=ye(()=>[{id:"fiberDensity",label:"Fiber Density",value:s.velvetParams.fiberDensity,min:10,max:50,step:1,valuePosition:"after",showRuler:!1},{id:"fiberLength",label:"Fiber Length",value:s.velvetParams.fiberLength,min:.1,max:2,step:.1,valuePosition:"after",showRuler:!1},{id:"fiberThickness",label:"Fiber Thickness",value:s.velvetParams.fiberThickness,min:.05,max:.5,step:.05,valuePosition:"after",showRuler:!1},{id:"fiberStiffness",label:"Fiber Stiffness",value:s.velvetParams.fiberStiffness,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1}]),i=ye(()=>[{id:"pileHeight",label:"Pile Height",value:s.velvetParams.pileHeight,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"pileDirection",label:"Pile Direction",value:s.velvetParams.pileDirection,min:0,max:360,step:5,valuePosition:"after",showRuler:!1}]),o=ye(()=>[{id:"sheenIntensity",label:"Sheen Intensity",value:s.velvetParams.sheenIntensity,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"sheenDirection",label:"Sheen Direction",value:s.velvetParams.sheenDirection,min:0,max:360,step:5,valuePosition:"after",showRuler:!1},{id:"colorVariation",label:"Color Variation",value:s.velvetParams.colorVariation,min:0,max:.3,step:.01,valuePosition:"after",showRuler:!1}]),a=ye(()=>[{id:"roughnessMin",label:"Min Roughness",value:s.velvetParams.roughnessMin,min:.1,max:.5,step:.05,valuePosition:"after",showRuler:!1},{id:"roughnessMax",label:"Max Roughness",value:s.velvetParams.roughnessMax,min:.5,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"normalStrength",label:"Normal Strength",value:s.velvetParams.normalStrength,min:1,max:20,step:.5,valuePosition:"after",showRuler:!1}]),l={"Red Velvet":{baseColor:"#590510",sheenColor:"#ff8c9e",pileHeight:.8,pileDensity:.9,pileSlant:.4,slantDirection:45,crushStrength:.6,crushScale:.5,crushDetail:.7,fiberGrain:.4,stripes:0,stripeFrequency:5,fbmOctaves:4,noiseRoughness:.6,sheenIntensity:.8,sheenFalloff:2.5,ambientOcclusion:.6,colorVariation:.1,lightSourceX:.5,lightSourceY:.5},"Blue Velvet":{baseColor:"#0a0a2e",sheenColor:"#6b8cff",pileHeight:.7,pileDensity:.85,pileSlant:.3,slantDirection:30,crushStrength:.5,crushScale:.6,crushDetail:.6,fiberGrain:.3,stripes:0,stripeFrequency:5,fbmOctaves:3,noiseRoughness:.5,sheenIntensity:.7,sheenFalloff:2,ambientOcclusion:.5,colorVariation:.08,lightSourceX:.3,lightSourceY:.4},"Green Velvet":{baseColor:"#0d2818",sheenColor:"#7dd87d",pileHeight:.75,pileDensity:.8,pileSlant:.35,slantDirection:60,crushStrength:.4,crushScale:.7,crushDetail:.5,fiberGrain:.35,stripes:0,stripeFrequency:5,fbmOctaves:3,noiseRoughness:.55,sheenIntensity:.75,sheenFalloff:2.2,ambientOcclusion:.55,colorVariation:.09,lightSourceX:.4,lightSourceY:.6},"Black Velvet":{baseColor:"#0a0a0a",sheenColor:"#4a4a6a",pileHeight:.9,pileDensity:.95,pileSlant:.25,slantDirection:90,crushStrength:.7,crushScale:.4,crushDetail:.8,fiberGrain:.2,stripes:0,stripeFrequency:5,fbmOctaves:4,noiseRoughness:.4,sheenIntensity:.9,sheenFalloff:3,ambientOcclusion:.7,colorVariation:.05,lightSourceX:.6,lightSourceY:.3},Corduroy:{baseColor:"#8b4513",sheenColor:"#daa520",pileHeight:.6,pileDensity:.7,pileSlant:.5,slantDirection:0,crushStrength:.2,crushScale:.3,crushDetail:.3,fiberGrain:.5,stripes:.8,stripeFrequency:8,fbmOctaves:2,noiseRoughness:.3,sheenIntensity:.4,sheenFalloff:1.5,ambientOcclusion:.4,colorVariation:.12,lightSourceX:.5,lightSourceY:.2},"Crushed Velvet":{baseColor:"#4b0082",sheenColor:"#dda0dd",pileHeight:.85,pileDensity:.9,pileSlant:.6,slantDirection:135,crushStrength:.9,crushScale:.8,crushDetail:.9,fiberGrain:.4,stripes:0,stripeFrequency:5,fbmOctaves:5,noiseRoughness:.7,sheenIntensity:.85,sheenFalloff:2.8,ambientOcclusion:.65,colorVariation:.15,lightSourceX:.7,lightSourceY:.4}},u=m=>{m.id in s.velvetParams&&(s.velvetParams[m.id]=m.value)},c=m=>{Object.assign(s.velvetParams,m)},h=ce(!1),d=ce(!1),f=async()=>{if(d.value){h.value=!0;return}d.value=!0;try{do{h.value=!1;const m=await VF(s.velvetParams,1024,1024);n("set-image",m)}while(h.value)}catch(m){console.error("Failed to generate velvet texture:",m)}finally{d.value=!1}};let p=null;const g=()=>{p&&clearTimeout(p),p=setTimeout(()=>{f()},50)};return _t(s.velvetParams,()=>{g()},{deep:!0}),(m,x)=>(F(),V("div",IG,[k("div",kG,[k("div",EG,[x[8]||(x[8]=k("span",{class:"text-xs font-medium text-white/60"},"Colors",-1)),k("button",{onClick:x[0]||(x[0]=b=>D(s).uiState.velvetPanel.showColors=!D(s).uiState.velvetPanel.showColors),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.velvetPanel.showColors}])},null,2)])]),vt(k("div",_G,[we(jd,{modelValue:D(s).velvetParams.gradientStops,"onUpdate:modelValue":x[1]||(x[1]=b=>D(s).velvetParams.gradientStops=b)},null,8,["modelValue"])],512),[[Gt,D(s).uiState.velvetPanel.showColors]])]),k("div",$G,[k("div",RG,[x[9]||(x[9]=k("span",{class:"text-xs font-medium text-white/60"},"Basic Parameters",-1)),k("button",{onClick:x[2]||(x[2]=b=>D(s).uiState.velvetPanel.showBasicParams=!D(s).uiState.velvetPanel.showBasicParams),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.velvetPanel.showBasicParams}])},null,2)])]),vt(k("div",AG,[(F(!0),V(Xe,null,rt(r.value,b=>(F(),V("div",{key:b.id},[we(D(St),{items:[b],onUpdateValue:u},null,8,["items"])]))),128))],512),[[Gt,D(s).uiState.velvetPanel.showBasicParams]])]),k("div",PG,[k("div",DG,[x[10]||(x[10]=k("span",{class:"text-xs font-medium text-white/60"},"Pile Structure",-1)),k("button",{onClick:x[3]||(x[3]=b=>D(s).uiState.velvetPanel.showPileParams=!D(s).uiState.velvetPanel.showPileParams),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.velvetPanel.showPileParams}])},null,2)])]),vt(k("div",NG,[(F(!0),V(Xe,null,rt(i.value,b=>(F(),V("div",{key:b.id},[we(D(St),{items:[b],onUpdateValue:u},null,8,["items"])]))),128))],512),[[Gt,D(s).uiState.velvetPanel.showPileParams]])]),k("div",MG,[k("div",LG,[x[11]||(x[11]=k("span",{class:"text-xs font-medium text-white/60"},"Crush Effect",-1)),k("button",{onClick:x[4]||(x[4]=b=>D(s).uiState.velvetPanel.showFiberParams=!D(s).uiState.velvetPanel.showFiberParams),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.velvetPanel.showFiberParams}])},null,2)])]),vt(k("div",OG,[(F(!0),V(Xe,null,rt(i.value,b=>(F(),V("div",{key:b.id},[we(D(St),{items:[b],onUpdateValue:u},null,8,["items"])]))),128))],512),[[Gt,D(s).uiState.velvetPanel.showFiberParams]])]),k("div",FG,[k("div",UG,[x[12]||(x[12]=k("span",{class:"text-xs font-medium text-white/60"},"Surface Details",-1)),k("button",{onClick:x[5]||(x[5]=b=>D(s).uiState.velvetPanel.showAdvancedParams=!D(s).uiState.velvetPanel.showAdvancedParams),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.velvetPanel.showAdvancedParams}])},null,2)])]),vt(k("div",BG,[(F(!0),V(Xe,null,rt(o.value,b=>(F(),V("div",{key:b.id},[we(D(St),{items:[b],onUpdateValue:u},null,8,["items"])]))),128))],512),[[Gt,D(s).uiState.velvetPanel.showAdvancedParams]])]),k("div",zG,[k("div",GG,[x[13]||(x[13]=k("span",{class:"text-xs font-medium text-white/60"},"Material Properties",-1)),k("button",{onClick:x[6]||(x[6]=b=>D(s).uiState.velvetPanel.showMaterialParams=!D(s).uiState.velvetPanel.showMaterialParams),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.velvetPanel.showMaterialParams}])},null,2)])]),vt(k("div",VG,[(F(!0),V(Xe,null,rt(a.value,b=>(F(),V("div",{key:b.id},[we(D(St),{items:[b],onUpdateValue:u},null,8,["items"])]))),128))],512),[[Gt,D(s).uiState.velvetPanel.showMaterialParams]])]),k("div",WG,[k("div",HG,[x[14]||(x[14]=k("span",{class:"text-xs font-medium text-white/60"},"Presets",-1)),k("button",{onClick:x[7]||(x[7]=b=>D(s).uiState.velvetPanel.showPresets=!D(s).uiState.velvetPanel.showPresets),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":D(s).uiState.velvetPanel.showPresets}])},null,2)])]),vt(k("div",KG,[(F(),V(Xe,null,rt(l,(b,v)=>k("button",{key:v,onClick:y=>c(b),class:"glass-btn text-xs py-2 px-2 rounded bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 transition-colors"},Le(v),9,jG)),64))],512),[[Gt,D(s).uiState.velvetPanel.showPresets]])]),k("button",{onClick:f,disabled:t.isGenerating,class:"glass-btn w-full py-2.5 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 text-white/60 hover:text-white/90 text-sm font-medium transition-all flex items-center justify-center gap-2 disabled:opacity-50"},[t.isGenerating?(F(),V("div",qG)):(F(),V("div",YG)),Tn(" "+Le(t.isGenerating?"Generating...":"Generate Velvet Texture"),1)],8,XG)]))}}),QG={class:"flex flex-col gap-4"},JG={class:"flex flex-col gap-3"},e8={class:"flex items-center justify-between"},t8={class:"flex flex-col gap-3"},n8={class:"flex flex-col gap-3"},s8={class:"flex items-center justify-between"},r8={class:"flex flex-col gap-3"},i8={class:"flex flex-col gap-3"},o8={class:"flex items-center justify-between"},a8={class:"flex flex-col gap-3"},l8={class:"flex flex-col gap-3"},u8={class:"flex items-center justify-between"},c8={class:"grid grid-cols-2 gap-2"},h8=["onClick"],d8=["disabled"],f8={key:0,class:"i-carbon-circle-dash animate-spin text-lg"},p8={key:1,class:"i-carbon-magic-wand text-lg"},m8=We({__name:"MultiscaleTuringPanel",props:{isGenerating:{type:Boolean}},emits:["set-image"],setup(t,{emit:e}){const n=e,s=ce(!0),r=ce(!1),i=ce(!1),o=ce(!1),a=pi({...h5}),l=ye(()=>[{id:"tileSize",label:"Tile Size",value:a.tileSize,min:.1,max:50,step:.1,valuePosition:"after",showRuler:!1},{id:"simulationSteps",label:"Simulation Steps",value:a.simulationSteps,min:50,max:500,step:10,valuePosition:"after",showRuler:!1},{id:"activatorRadius",label:"Activator Radius",value:a.activatorRadius,min:1,max:10,step:.1,valuePosition:"after",showRuler:!1},{id:"inhibitorRadius",label:"Inhibitor Radius",value:a.inhibitorRadius,min:2,max:20,step:.1,valuePosition:"after",showRuler:!1},{id:"curvature",label:"Curvature (Maze <-> Spot)",value:a.curvature,min:0,max:1,step:.01,valuePosition:"after",showRuler:!1},{id:"diffusionAnisotropy",label:"Diffusion Anisotropy",value:a.diffusionAnisotropy,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1},{id:"flowDirection",label:"Flow Direction",value:a.flowDirection,min:0,max:6.28,step:.1,valuePosition:"after",showRuler:!1}]),u=ye(()=>[{id:"variationScale",label:"Variation Scale",value:a.variationScale,min:.1,max:5,step:.1,valuePosition:"after",showRuler:!1},{id:"variationStrength",label:"Variation Strength",value:a.variationStrength,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1}]),c=ye(()=>[{id:"contrast",label:"Contrast",value:a.contrast,min:0,max:3,step:.1,valuePosition:"after",showRuler:!1},{id:"bias",label:"Bias",value:a.bias,min:-1,max:1,step:.05,valuePosition:"after",showRuler:!1}]),h={Balanced:{activatorRadius:1.5,inhibitorRadius:4,curvature:.55,variationScale:1.5,variationStrength:.5},Maze:{activatorRadius:2,inhibitorRadius:5,curvature:.2,variationScale:1,variationStrength:.3},Spots:{activatorRadius:2.5,inhibitorRadius:6,curvature:.8,variationScale:1.2,variationStrength:.4},Stripes:{activatorRadius:1.5,inhibitorRadius:3.5,curvature:.4,diffusionAnisotropy:.7,flowDirection:1.57,variationScale:.8,variationStrength:.2}},d=v=>{v.id in a&&(a[v.id]=v.value)},f=v=>{Object.assign(a,v)},p=ce(!1),g=ce(!1),m=async()=>{if(g.value){p.value=!0;return}g.value=!0;try{do{p.value=!1;const v=await d5(a,1024,1024);n("set-image",v)}while(p.value)}catch(v){console.error("Failed to generate turing texture:",v)}finally{g.value=!1}};let x=null;const b=()=>{x&&clearTimeout(x),x=setTimeout(()=>{m()},100)};return _t(a,()=>{b()},{deep:!0}),(v,y)=>(F(),V("div",QG,[k("div",JG,[k("div",e8,[y[4]||(y[4]=k("span",{class:"text-xs font-medium text-white/60"},"Reaction Core",-1)),k("button",{onClick:y[0]||(y[0]=C=>s.value=!s.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":s.value}])},null,2)])]),vt(k("div",t8,[(F(!0),V(Xe,null,rt(l.value,C=>(F(),V("div",{key:C.id},[we(D(St),{items:[C],onUpdateValue:d},null,8,["items"])]))),128))],512),[[Gt,s.value]])]),k("div",n8,[k("div",s8,[y[5]||(y[5]=k("span",{class:"text-xs font-medium text-white/60"},"Spatial Variation",-1)),k("button",{onClick:y[1]||(y[1]=C=>r.value=!r.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":r.value}])},null,2)])]),vt(k("div",r8,[(F(!0),V(Xe,null,rt(u.value,C=>(F(),V("div",{key:C.id},[we(D(St),{items:[C],onUpdateValue:d},null,8,["items"])]))),128))],512),[[Gt,r.value]])]),k("div",i8,[k("div",o8,[y[6]||(y[6]=k("span",{class:"text-xs font-medium text-white/60"},"Contrast Adjustment",-1)),k("button",{onClick:y[2]||(y[2]=C=>i.value=!i.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":i.value}])},null,2)])]),vt(k("div",a8,[(F(!0),V(Xe,null,rt(c.value,C=>(F(),V("div",{key:C.id},[we(D(St),{items:[C],onUpdateValue:d},null,8,["items"])]))),128))],512),[[Gt,i.value]])]),k("div",l8,[k("div",u8,[y[7]||(y[7]=k("span",{class:"text-xs font-medium text-white/60"},"Presets",-1)),k("button",{onClick:y[3]||(y[3]=C=>o.value=!o.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":o.value}])},null,2)])]),vt(k("div",c8,[(F(),V(Xe,null,rt(h,(C,I)=>k("button",{key:I,onClick:$=>f(C),class:"glass-btn text-xs py-2 px-2 rounded bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 transition-colors"},Le(I),9,h8)),64))],512),[[Gt,o.value]])]),k("button",{onClick:m,disabled:t.isGenerating,class:"glass-btn w-full py-2.5 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 text-white/60 hover:text-white/90 text-sm font-medium transition-all flex items-center justify-center gap-2 disabled:opacity-50"},[t.isGenerating?(F(),V("div",f8)):(F(),V("div",p8)),Tn(" "+Le(t.isGenerating?"Generating...":"Generate Turing Texture"),1)],8,d8)]))}}),g8=`

// ==========================================
// 1. : 
// ==========================================

fn hash22(p: vec2<f32>) -> vec2<f32> {
    var p3 = fract(vec3<f32>(p.xyx) * vec3<f32>(.1031, .1030, .0973));
    p3 = p3 + dot(p3, p3.yzx + 33.33);
    return fract((p3.xx+p3.yz)*p3.zy);
}

//  ()
fn gradientNoise(p: vec2<f32>, scale: f32) -> f32 {
    let i = floor(p * scale);
    let f = fract(p * scale);
    let u = f * f * (3.0 - 2.0 * f);
    
    // 
    let g00 = hash22(i + vec2<f32>(0.0,0.0)) * 2.0 - 1.0;
    let g10 = hash22(i + vec2<f32>(1.0,0.0)) * 2.0 - 1.0;
    let g01 = hash22(i + vec2<f32>(0.0,1.0)) * 2.0 - 1.0;
    let g11 = hash22(i + vec2<f32>(1.0,1.0)) * 2.0 - 1.0;
    
    let val = mix(
        mix(dot(g00, f - vec2<f32>(0.0,0.0)), dot(g10, f - vec2<f32>(1.0,0.0)), u.x),
        mix(dot(g01, f - vec2<f32>(0.0,1.0)), dot(g11, f - vec2<f32>(1.0,1.0)), u.x),
        u.y);
    return 0.5 + 0.5 * val;
}

// ==========================================
// 2. Compute Shader: Anisotropic Reaction-Diffusion
// ==========================================

struct SimParams {
    feed: f32, kill: f32,
    anisotropy: f32, angle: f32,
    varScale: f32, varStr: f32,
    dt: f32, seed: f32,
    padding1: f32, padding2: f32
};

@group(0) @binding(0) var<uniform> sim : SimParams;
@group(0) @binding(1) var inputTex : texture_2d<f32>;
@group(0) @binding(2) var outputTex : texture_storage_2d<rgba32float, write>;

// 
fn rotate(v: vec2<f32>, a: f32) -> vec2<f32> {
    let s = sin(a);
    let c = cos(a);
    return vec2<f32>(v.x * c - v.y * s, v.x * s + v.y * c);
}

@compute @workgroup_size(8, 8)
fn cs_main(@builtin(global_invocation_id) id : vec3<u32>) {
    let dims = textureDimensions(inputTex);
    let coords = vec2<i32>(id.xy);
    if (coords.x >= i32(dims.x) || coords.y >= i32(dims.y)) { return; }

    let uv = vec2<f32>(coords) / vec2<f32>(dims);

    // 
    let val = textureLoad(inputTex, coords, 0);
    var a = val.r;
    var b = val.g;

    // ---  (Spatial Variation) ---
    //  Feed/Kill
    let noiseVar = gradientNoise(uv, sim.varScale);
    let localFeed = sim.feed + (noiseVar - 0.5) * sim.varStr * 0.02;
    let localKill = sim.kill - (noiseVar - 0.5) * sim.varStr * 0.01;

    // ---  (Authorized Anisotropic Laplacian) ---
    // With normalization fix
    var lapA = 0.0;
    var lapB = 0.0;
    var weightSum = 0.0;
    
    // 
    let rot = -sim.angle;
    let centerA = a;
    let centerB = b;

    for(var i=-1; i<=1; i++) {
        for(var j=-1; j<=1; j++) {
            if (i==0 && j==0) { continue; }

            // Periodic wrap
            var nx = coords.x + i;
            var ny = coords.y + j;
            if(nx < 0) { nx = i32(dims.x)-1; } if(nx >= i32(dims.x)) { nx = 0; }
            if(ny < 0) { ny = i32(dims.y)-1; } if(ny >= i32(dims.y)) { ny = 0; }
            
            let neighbor = textureLoad(inputTex, vec2<i32>(nx, ny), 0);
            
            // 
            let offset = vec2<f32>(f32(i), f32(j));
            var weight = 0.0;
            
            // 
            let localPos = rotate(offset, rot);
            // : 
            let stretch = 1.0 + sim.anisotropy * 3.0;
            let distSq = localPos.x*localPos.x + (localPos.y*localPos.y * stretch);
            
            // 
            weight = exp(-distSq * 2.0); 

            weightSum += weight;
            lapA += neighbor.r * weight;
            lapB += neighbor.g * weight;
        }
    }

    //  Laplacian
    if (weightSum > 0.0) {
        lapA = (lapA / weightSum) - centerA;
        lapB = (lapB / weightSum) - centerB;
    } else {
        lapA = 0.0;
        lapB = 0.0;
    }

    // Gray-Scott Reaction
    // 
    let diffRateA = 1.0;
    let diffRateB = 0.5;

    let reaction = a * b * b;
    let newA = a + (diffRateA * lapA - reaction + localFeed * (1.0 - a)) * sim.dt;
    let newB = b + (diffRateB * lapB + reaction - (localKill + localFeed) * b) * sim.dt;

    textureStore(outputTex, coords, vec4<f32>(clamp(newA, 0.0, 1.0), clamp(newB, 0.0, 1.0), 0.0, 1.0));
}

// ==========================================
// 3. Shader: 
// ==========================================

struct RenderUniforms {
    tileSize : f32,
    padding1: f32,
    padding2: f32, 
    padding3: f32
};

@group(0) @binding(0) var<uniform> u : RenderUniforms;
@group(0) @binding(1) var simTex : texture_2d<f32>;
@group(0) @binding(2) var smp : sampler;

struct VertexOutput {
    @builtin(position) Pos : vec4<f32>,
    @location(0) uv : vec2<f32>,
};

@vertex
fn vs_main(@location(0) pos : vec3<f32>, @location(1) uv : vec2<f32>) -> VertexOutput {
    var out : VertexOutput;
    out.Pos = vec4<f32>(pos, 1.0);
    out.uv = uv;
    return out;
}

@fragment
fn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {
    let dims = vec2<f32>(textureDimensions(simTex));
    let coords = vec2<i32>(in.uv * dims);
    let simData = textureLoad(simTex, coords, 0);
    
    //  B  (G)
    let val = simData.g;
    
    return vec4<f32>(val, val, val, 1.0);
}
`,sE={tileSize:1,simulationSteps:2e3,feedRate:.058,killRate:.062,diffusionAnisotropy:0,flowDirection:.4,variationScale:1.5,variationStrength:.3};async function rE(t,e,n){const s=await Ts();if(!s)throw new Error("WebGPU Unsupported");const r={size:[e,n],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST},i=s.createTexture(r),o=s.createTexture(r),a=new Float32Array(e*n*4);for(let se=0;se<n;se++)for(let fe=0;fe<e;fe++){const he=(se*e+fe)*4;a[he]=1,a[he+1]=Math.random()*.3,a[he+2]=0,a[he+3]=1}s.queue.writeTexture({texture:i},a,{bytesPerRow:e*16},[e,n]);const l=new Float32Array(12);l[0]=t.feedRate,l[1]=t.killRate,l[2]=t.diffusionAnisotropy,l[3]=t.flowDirection,l[4]=t.variationScale,l[5]=t.variationStrength,l[6]=1,l[7]=Math.random()*1e3;const u=s.createBuffer({size:l.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(u,0,l);const c=new Float32Array(4);c[0]=t.tileSize,c[1]=0,c[2]=0,c[3]=0;const h=s.createBuffer({size:c.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(h,0,c);const d=s.createShaderModule({code:g8}),f=s.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float"}}]}),p=s.createPipelineLayout({bindGroupLayouts:[f]}),g=s.createComputePipeline({layout:p,compute:{module:d,entryPoint:"cs_main"}}),m=g.getBindGroupLayout(0),x=s.createBindGroup({layout:m,entries:[{binding:0,resource:{buffer:u}},{binding:1,resource:i.createView()},{binding:2,resource:o.createView()}]}),b=s.createBindGroup({layout:m,entries:[{binding:0,resource:{buffer:u}},{binding:1,resource:o.createView()},{binding:2,resource:i.createView()}]}),v=s.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"non-filtering"}}]}),y=s.createPipelineLayout({bindGroupLayouts:[v]}),C=s.createRenderPipeline({layout:y,vertex:{module:d,entryPoint:"vs_main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}]}]},fragment:{module:d,entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}}),I=s.createCommandEncoder(),$=I.beginComputePass();$.setPipeline(g);const T=Math.ceil(e/8),S=Math.ceil(n/8);for(let se=0;se<t.simulationSteps;se++)se%2===0?$.setBindGroup(0,x):$.setBindGroup(0,b),$.dispatchWorkgroups(T,S);$.end();const E=t.simulationSteps%2===0?i:o,_=s.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"repeat",addressModeV:"repeat"}),N=s.createBindGroup({layout:C.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:h}},{binding:1,resource:E.createView()},{binding:2,resource:_}]}),P=s.createTexture({size:[e,n],format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),M=I.beginRenderPass({colorAttachments:[{view:P.createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]}),z=new Float32Array([-1,-1,0,0,1,1,-1,0,1,1,-1,1,0,0,0,-1,1,0,0,0,1,-1,0,1,1,1,1,0,1,0]),A=s.createBuffer({size:z.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(A.getMappedRange()).set(z),A.unmap(),M.setPipeline(C),M.setBindGroup(0,N),M.setVertexBuffer(0,A),M.draw(6,1,0,0),M.end();const B=Math.ceil(e*4/256)*256,L=s.createBuffer({size:B*n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});I.copyTextureToBuffer({texture:P},{buffer:L,bytesPerRow:B},[e,n]),s.queue.submit([I.finish()]),await L.mapAsync(GPUMapMode.READ);const U=document.createElement("canvas");U.width=e,U.height=n;const j=U.getContext("2d"),Z=j.createImageData(e,n),J=new Uint8Array(L.getMappedRange());for(let se=0;se<n;se++){const fe=se*B,he=se*e*4;for(let ve=0;ve<e;ve++){const Pe=fe+ve*4,Ee=he+ve*4;Z.data[Ee]=J[Pe+2],Z.data[Ee+1]=J[Pe+1],Z.data[Ee+2]=J[Pe],Z.data[Ee+3]=255}}return j.putImageData(Z,0,0),L.unmap(),U.toDataURL("image/png")}const x8={class:"flex flex-col gap-4"},b8={class:"flex flex-col gap-3"},y8={class:"flex items-center justify-between"},v8={class:"flex flex-col gap-3"},w8={class:"flex flex-col gap-3"},S8={class:"flex items-center justify-between"},C8={class:"flex flex-col gap-3"},T8={class:"flex flex-col gap-3"},I8={class:"flex items-center justify-between"},k8={class:"grid grid-cols-2 gap-2"},E8=["onClick"],_8=["disabled"],$8={key:0,class:"i-carbon-circle-dash animate-spin text-lg"},R8={key:1,class:"i-carbon-magic-wand text-lg"},A8=We({__name:"GrayScottTuringPanel",props:{isGenerating:{type:Boolean}},emits:["set-image"],setup(t,{emit:e}){const n=e,s=ce(!0),r=ce(!1),i=ce(!1),o=pi({...sE}),a=ye(()=>[{id:"tileSize",label:"Tile Size",value:o.tileSize,min:.1,max:5,step:.1,valuePosition:"after",showRuler:!1},{id:"simulationSteps",label:"Simulation Steps",value:o.simulationSteps,min:100,max:5e3,step:100,valuePosition:"after",showRuler:!1},{id:"feedRate",label:"Feed Rate (F)",value:o.feedRate,min:.01,max:.1,step:.001,valuePosition:"after",showRuler:!1},{id:"killRate",label:"Kill Rate (K)",value:o.killRate,min:.03,max:.07,step:.001,valuePosition:"after",showRuler:!1},{id:"diffusionAnisotropy",label:"Diffusion Anisotropy",value:o.diffusionAnisotropy,min:0,max:1,step:.001,valuePosition:"after",showRuler:!1},{id:"flowDirection",label:"Flow Direction",value:o.flowDirection,min:0,max:6.28,step:.01,valuePosition:"after",showRuler:!1}]),l=ye(()=>[{id:"variationScale",label:"Variation Scale",value:o.variationScale,min:.1,max:5,step:.1,valuePosition:"after",showRuler:!1},{id:"variationStrength",label:"Variation Strength",value:o.variationStrength,min:0,max:1,step:.05,valuePosition:"after",showRuler:!1}]),u={"Coral / Maze":{feedRate:.055,killRate:.062,simulationSteps:2e3,diffusionAnisotropy:0,variationStrength:.2},"Mitosis / Dots":{feedRate:.0367,killRate:.0649,simulationSteps:3e3,diffusionAnisotropy:0,variationStrength:.1},"Exotic / Ripples":{feedRate:.018,killRate:.051,simulationSteps:3e3,diffusionAnisotropy:.5,flowDirection:.8,variationStrength:.3},"Chaotic / Worms":{feedRate:.05,killRate:.065,simulationSteps:2500,diffusionAnisotropy:0,variationStrength:.4}},c=x=>{x.id in o&&(o[x.id]=x.value)},h=x=>{Object.assign(o,x)},d=ce(!1),f=ce(!1),p=async()=>{if(f.value){d.value=!0;return}f.value=!0;try{do{d.value=!1;const x=await rE(o,1024,1024);n("set-image",x)}while(d.value)}catch(x){console.error("Failed to generate turing texture:",x)}finally{f.value=!1}};let g=null;const m=()=>{g&&clearTimeout(g),g=setTimeout(()=>{p()},100)};return _t(o,()=>{m()},{deep:!0}),(x,b)=>(F(),V("div",x8,[k("div",b8,[k("div",y8,[b[3]||(b[3]=k("span",{class:"text-xs font-medium text-white/60"},"Reaction Core (Gray-Scott)",-1)),k("button",{onClick:b[0]||(b[0]=v=>s.value=!s.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":s.value}])},null,2)])]),vt(k("div",v8,[(F(!0),V(Xe,null,rt(a.value,v=>(F(),V("div",{key:v.id},[we(D(St),{items:[v],onUpdateValue:c},null,8,["items"])]))),128))],512),[[Gt,s.value]])]),k("div",w8,[k("div",S8,[b[4]||(b[4]=k("span",{class:"text-xs font-medium text-white/60"},"Spatial Variation",-1)),k("button",{onClick:b[1]||(b[1]=v=>r.value=!r.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":r.value}])},null,2)])]),vt(k("div",C8,[(F(!0),V(Xe,null,rt(l.value,v=>(F(),V("div",{key:v.id},[we(D(St),{items:[v],onUpdateValue:c},null,8,["items"])]))),128))],512),[[Gt,r.value]])]),k("div",T8,[k("div",I8,[b[5]||(b[5]=k("span",{class:"text-xs font-medium text-white/60"},"Presets",-1)),k("button",{onClick:b[2]||(b[2]=v=>i.value=!i.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":i.value}])},null,2)])]),vt(k("div",k8,[(F(),V(Xe,null,rt(u,(v,y)=>k("button",{key:y,onClick:C=>h(v),class:"glass-btn text-xs py-2 px-2 rounded bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 transition-colors"},Le(y),9,E8)),64))],512),[[Gt,i.value]])]),k("button",{onClick:p,disabled:t.isGenerating,class:"glass-btn w-full py-2.5 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 text-white/60 hover:text-white/90 text-sm font-medium transition-all flex items-center justify-center gap-2 disabled:opacity-50"},[t.isGenerating?(F(),V("div",$8)):(F(),V("div",R8)),Tn(" "+Le(t.isGenerating?"Generating...":"Generate Gray-Scott Texture"),1)],8,_8)]))}}),P8=`

// ==========================================
// ==========================================
// 
// ==========================================

struct HSLRule {
    hue: f32,             // offset 0
    hueTolerance: f32,    // offset 4
    saturation: f32,      // offset 8
    saturationTolerance: f32, // offset 12
    
    lightness: f32,       // offset 16
    lightnessTolerance: f32, // offset 20
    feather: f32,         // offset 24
    invert: f32,          // offset 28
    maskSource: f32,      // offset 32 (0=Self, 1=Base)
    padding: f32,         // offset 36
};

struct LayerParams {
    ruleCount: f32,
    opacity: f32,
    blendMode: f32,      // 0=normal, 1=add, 2=multiply, 3=screen, 4=overlay, 5=max, 6=min
    padding: f32
};

@group(0) @binding(0) var baseTexture: texture_2d<f32>;      // Base (Current Result)
@group(0) @binding(1) var layerTexture: texture_2d<f32>;     // Layer Image
@group(0) @binding(2) var dstTexture: texture_storage_2d<rgba8unorm, write>; // Output
@group(0) @binding(3) var<storage, read> rules: array<HSLRule>; // Mask Rules
@group(0) @binding(4) var<uniform> params: LayerParams;
@group(0) @binding(5) var originalBaseTexture: texture_2d<f32>; // Original Base Image (for Masking)

// ==========================================
// : 
// ==========================================

fn rgbToHsl(c: vec3<f32>) -> vec3<f32> {
    let maxVal = max(max(c.r, c.g), c.b);
    let minVal = min(min(c.r, c.g), c.b);
    let delta = maxVal - minVal;

    var h: f32 = 0.0;
    var s: f32 = 0.0;
    let l = (maxVal + minVal) / 2.0;

    if (delta > 0.00001) {
        if (l < 0.5) {
            s = delta / (maxVal + minVal);
        } else {
            s = delta / (2.0 - maxVal - minVal);
        }

        if (c.r == maxVal) {
            h = (c.g - c.b) / delta;
            if (c.g < c.b) {
                h = h + 6.0;
            }
        } else if (c.g == maxVal) {
            h = (c.b - c.r) / delta + 2.0;
        } else {
            h = (c.r - c.g) / delta + 4.0;
        }
        h = h * 60.0;
    }

    //  S  L  0-100, H  0-360
    return vec3<f32>(h, s * 100.0, l * 100.0);
}

// ==========================================
// 
// ==========================================

fn calculateHueDistance(h1: f32, h2: f32, tolerance: f32) -> f32 {
    let diff = abs(h1 - h2);
    let shortestDiff = min(diff, 360.0 - diff);
    return min(1.0, shortestDiff / max(0.01, tolerance));
}

fn calculateRuleMask(pixelHsl: vec3<f32>, rule: HSLRule) -> f32 {
    let hueDist = calculateHueDistance(pixelHsl.x, rule.hue, rule.hueTolerance);
    let satDist = abs(pixelHsl.y - rule.saturation) / max(0.01, rule.saturationTolerance);
    let lightDist = abs(pixelHsl.z - rule.lightness) / max(0.01, rule.lightnessTolerance);

    let totalDist = sqrt(hueDist * hueDist + satDist * satDist + lightDist * lightDist);
    
    let featherFactor = max(0.01, rule.feather);
    let mask = (1.0 - totalDist) * (1.0 - featherFactor) + featherFactor * exp(-totalDist * 2.0);
    
    var finalVal = clamp(mask, 0.0, 1.0);
    
    if (rule.invert > 0.5) {
        finalVal = 1.0 - finalVal;
    }
    return finalVal;
}

// ==========================================
// 
// ==========================================

fn blendNormal(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32> {
    return blend;
}

fn blendAdd(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32> {
    return min(base + blend, vec3<f32>(1.0));
}

fn blendMultiply(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32> {
    return base * blend;
}

fn blendScreen(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32> {
    return 1.0 - (1.0 - base) * (1.0 - blend);
}

fn blendOverlay(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32> {
    return select(
        2.0 * base * blend,
        1.0 - 2.0 * (1.0 - base) * (1.0 - blend),
        base > vec3<f32>(0.5)
    );
}

fn blendMax(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32> {
    return max(base, blend);
}

fn blendMin(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32> {
    return min(base, blend);
}

// ==========================================
// Compute Shader Main
// ==========================================

@compute @workgroup_size(8, 8)
fn cs_main(@builtin(global_invocation_id) id: vec3<u32>) {
    let dims = textureDimensions(baseTexture);
    if (id.x >= dims.x || id.y >= dims.y) {
        return;
    }
    let coords = vec2<i32>(id.xy);

    // 1.  (Base)  (Layer)
    let baseColor = textureLoad(baseTexture, coords, 0).rgb;
    let layerColor = textureLoad(layerTexture, coords, 0).rgb;
    
    //  (Original Base)
    let originalBaseColor = textureLoad(originalBaseTexture, coords, 0).rgb;
    
    // 2.  Layer Mask
    //  Layer  HSL 
    let layerHsl = rgbToHsl(layerColor);
    let originalBaseHsl = rgbToHsl(originalBaseColor);
    
    var computedAlpha: f32 = 0.0;
    let count = i32(params.ruleCount);
    
    if (count == 0) {
        computedAlpha = 1.0;
    } else {
        //  (Union)
        for (var i = 0; i < count; i = i + 1) {
            let rule = rules[i];
            
            //  maskSource 
            var targetHsl = layerHsl;
            if (rule.maskSource > 0.5) {
                targetHsl = originalBaseHsl;
            }

            let val = calculateRuleMask(targetHsl, rule);
            computedAlpha = max(computedAlpha, val);
        }
    }
    
    // 
    computedAlpha = computedAlpha * params.opacity;

    // 3. 
    var blendedResult = layerColor;
    let mode = i32(params.blendMode);
    
    if (mode == 0) { blendedResult = blendNormal(baseColor, layerColor); }
    else if (mode == 1) { blendedResult = blendAdd(baseColor, layerColor); }
    else if (mode == 2) { blendedResult = blendMultiply(baseColor, layerColor); }
    else if (mode == 3) { blendedResult = blendScreen(baseColor, layerColor); }
    else if (mode == 4) { blendedResult = blendOverlay(baseColor, layerColor); }
    else if (mode == 5) { blendedResult = blendMax(baseColor, layerColor); }
    else if (mode == 6) { blendedResult = blendMin(baseColor, layerColor); }
    
    //  = mix(Base, Blended, Alpha)
    let finalColor = mix(baseColor, blendedResult, computedAlpha);
    
    textureStore(dstTexture, coords, vec4<f32>(finalColor, 1.0));
}
`,iE=48,T1=16,D8={normal:0,add:1,multiply:2,screen:3,overlay:4,max:5,min:6,replace:0};function N8(t){const e=Math.min(t.length,T1),n=iE/4,s=new Float32Array(T1*n);for(let r=0;r<e;r++){const i=t[r],o=r*n;s[o+0]=i.hue,s[o+1]=i.hueTolerance,s[o+2]=i.saturation,s[o+3]=i.saturationTolerance,s[o+4]=i.lightness,s[o+5]=i.lightnessTolerance,s[o+6]=i.feather,s[o+7]=i.invert?1:0,s[o+8]=i.maskSource??0}return s}async function M8(t){const e=t.createShaderModule({code:P8});return t.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"cs_main"}})}function L8(t){const e=T1*iE;return t.createBuffer({size:e,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})}function O8(t,e){const{device:n,baseTexture:s,layerTexture:r,outputTexture:i,rulesBuffer:o,ruleCount:a,layerOpacity:l,layerBlendMode:u,originalBaseTexture:c,width:h,height:d}=t,f=new Float32Array([a,l,u,0]),p=n.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});n.queue.writeBuffer(p,0,f.buffer);const g=n.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:s.createView()},{binding:1,resource:r.createView()},{binding:2,resource:i.createView()},{binding:3,resource:{buffer:o}},{binding:4,resource:{buffer:p}},{binding:5,resource:c.createView()}]}),m=n.createCommandEncoder(),x=m.beginComputePass();x.setPipeline(e),x.setBindGroup(0,g),x.dispatchWorkgroups(Math.ceil(h/8),Math.ceil(d/8)),x.end(),n.queue.submit([m.finish()])}function F8(t,e,n){const s=N8(n);t.queue.writeBuffer(e,0,s.buffer)}function U8(t){return D8[t]??0}const I1={CROSS_ORIGIN:"anonymous",FAILED_TO_LOAD_IMAGE:"Failed to load image",WEBGPU_NOT_SUPPORTED:"WebGPU"},Jh={ELEMENT_TYPE:"canvas",CONTEXT_TYPE:"2d",OUTPUT_FORMAT:"image/png"},iv={TEXTURE_FORMAT:"rgba8unorm"},ru={BUFFER_TYPE_UNIFORM:"uniform",TEXTURE_SAMPLE_TYPE_FLOAT:"float",STORAGE_TEXTURE_ACCESS_WRITE_ONLY:"write-only",SHADER_ENTRY_POINT:"cs_main"},B8={normal:0,multiply:1,screen:2,overlay:3},VS=8,z8=`
// ==========================================
// 
// ==========================================

// RGBsRGB
fn linearToSRGB(linear: vec3<f32>) -> vec3<f32> {
    return select(
        1.055 * pow(linear, vec3<f32>(1.0/2.4)) - 0.055,
        12.92 * linear,
        linear <= vec3<f32>(0.0031308)
    );
}

// sRGBRGB
fn sRGBToLinear(srgb: vec3<f32>) -> vec3<f32> {
    return select(
        pow((srgb + 0.055) / 1.055, vec3<f32>(2.4)),
        srgb / 12.92,
        srgb <= vec3<f32>(0.04045)
    );
}

// Smoothstep
fn smoothstep(edge0: f32, edge1: f32, x: f32) -> f32 {
    let t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
}

// ==========================================
// 
// ==========================================

fn blendNormal(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32> {
    return blend;
}

fn blendMultiply(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32> {
    return base * blend;
}

fn blendScreen(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32> {
    return 1.0 - (1.0 - base) * (1.0 - blend);
}

fn blendOverlay(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32> {
    return select(
        2.0 * base * blend,
        1.0 - 2.0 * (1.0 - base) * (1.0 - blend),
        base > vec3<f32>(0.5)
    );
}

// ==========================================
// Compute Shader: 
// ==========================================

struct CompositorParams {
    threshold: f32,
    softness: f32,
    contrast: f32,
    invertMask: f32,     // 0.0 or 1.0
    
    blendMode: f32,      // 0=normal, 1=multiply, 2=screen, 3=overlay
    opacity: f32,
    maskBias: f32,
    maskGamma: f32,
    
    padding1: f32,
    padding2: f32,
    padding3: f32,
    padding4: f32
};

@group(0) @binding(0) var<uniform> params: CompositorParams;
@group(0) @binding(1) var imageA: texture_2d<f32>;      // A
@group(0) @binding(2) var imageB: texture_2d<f32>;      // B
@group(0) @binding(3) var maskTex: texture_2d<f32>;     // 
@group(0) @binding(4) var outputTex: texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8)
fn cs_main(@builtin(global_invocation_id) id: vec3<u32>) {
    let dims = textureDimensions(imageA);
    let coords = vec2<i32>(id.xy);
    
    if (coords.x >= i32(dims.x) || coords.y >= i32(dims.y)) { return; }
    
    // 
    let colorA = textureLoad(imageA, coords, 0).rgb;
    let colorB = textureLoad(imageB, coords, 0).rgb;
    var maskValue = textureLoad(maskTex, coords, 0).r; // R
    
    // ---  ---
    
    // 1. 
    maskValue = clamp(maskValue + params.maskBias, 0.0, 1.0);
    
    // 2. Gamma
    maskValue = pow(maskValue, params.maskGamma);
    
    // 3. 
    // 0.5
    maskValue = clamp((maskValue - 0.5) * params.contrast + 0.5, 0.0, 1.0);
    
    // 4. 
    let edge0 = clamp(params.threshold - params.softness * 0.5, 0.0, 1.0);
    let edge1 = clamp(params.threshold + params.softness * 0.5, 0.0, 1.0);
    maskValue = smoothstep(edge0, edge1, maskValue);
    
    // 5. 
    if (params.invertMask > 0.5) {
        maskValue = 1.0 - maskValue;
    }
    
    // ---  ---
    
    // 
    let linearA = sRGBToLinear(colorA);
    let linearB = sRGBToLinear(colorB);
    
    // 
    var blendedColor = linearB;
    if (params.blendMode < 0.5) {
        blendedColor = blendNormal(linearA, linearB);
    } else if (params.blendMode < 1.5) {
        blendedColor = blendMultiply(linearA, linearB);
    } else if (params.blendMode < 2.5) {
        blendedColor = blendScreen(linearA, linearB);
    } else {
        blendedColor = blendOverlay(linearA, linearB);
    }
    
    // 
    var finalColor = mix(linearA, blendedColor, maskValue * params.opacity);
    
    // sRGB
    finalColor = linearToSRGB(finalColor);
    
    // 
    textureStore(outputTex, coords, vec4<f32>(finalColor, 1.0));
}

// ==========================================
// 
// ==========================================

struct PreviewUniforms {
    showMask: f32,       // 0=, 1=
    padding1: f32,
    padding2: f32,
    padding3: f32
};

@group(0) @binding(0) var<uniform> preview: PreviewUniforms;
@group(0) @binding(1) var resultTex: texture_2d<f32>;
@group(0) @binding(2) var smp: sampler;

struct VertexOutput {
    @builtin(position) Pos: vec4<f32>,
    @location(0) uv: vec2<f32>,
};

@vertex
fn vs_main(@location(0) pos: vec3<f32>, @location(1) uv: vec2<f32>) -> VertexOutput {
    var out: VertexOutput;
    out.Pos = vec4<f32>(pos, 1.0);
    out.uv = uv;
    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    let color = textureSample(resultTex, smp, in.uv);
    return color;
}
`,Ba={threshold:.5,softness:.2,contrast:1,invert:!1,blendMode:"normal",opacity:1,maskBias:0,maskGamma:1};async function wb(t){return new Promise((e,n)=>{const s=new Image;s.crossOrigin=I1.CROSS_ORIGIN,s.onload=()=>{createImageBitmap(s).then(e).catch(n)},s.onerror=r=>n(new Error(I1.FAILED_TO_LOAD_IMAGE+r.toString())),s.src=t})}async function Sb(t,e,n){if(t.width===e&&t.height===n)return t;const s=document.createElement(Jh.ELEMENT_TYPE);return s.width=e,s.height=n,s.getContext(Jh.CONTEXT_TYPE).drawImage(t,0,0,e,n),createImageBitmap(s)}function Cb(t,e){const n=t.createTexture({size:[e.width,e.height],format:iv.TEXTURE_FORMAT,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return t.queue.copyExternalImageToTexture({source:e},{texture:n},[e.width,e.height]),n}function G8(t){const{device:e,bitmapA:n,bitmapB:s,bitmapMask:r,width:i,height:o}=t,a=Cb(e,n),l=Cb(e,s),u=Cb(e,r),c=e.createTexture({size:[i,o],format:iv.TEXTURE_FORMAT,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC});return{textureA:a,textureB:l,textureMask:u,outputTexture:c}}function V8(t,e){const n=new Float32Array(12);n[0]=e.threshold,n[1]=e.softness,n[2]=e.contrast,n[3]=e.invert?1:0;const s=B8[e.blendMode];n[4]=s,n[5]=e.opacity,n[6]=e.maskBias,n[7]=e.maskGamma,n[8]=0,n[9]=0,n[10]=0,n[11]=0;const r=t.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return t.queue.writeBuffer(r,0,n),r}function W8(t){const{device:e,wgslCode:n}=t,s=e.createShaderModule({code:n}),r=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:ru.BUFFER_TYPE_UNIFORM}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:ru.TEXTURE_SAMPLE_TYPE_FLOAT}},{binding:2,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:ru.TEXTURE_SAMPLE_TYPE_FLOAT}},{binding:3,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:ru.TEXTURE_SAMPLE_TYPE_FLOAT}},{binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:ru.STORAGE_TEXTURE_ACCESS_WRITE_ONLY,format:iv.TEXTURE_FORMAT}}]}),i=e.createPipelineLayout({bindGroupLayouts:[r]});return e.createComputePipeline({layout:i,compute:{module:s,entryPoint:ru.SHADER_ENTRY_POINT}})}function H8(t){const{device:e,pipeline:n,uniformBuffer:s,textureA:r,textureB:i,textureMask:o,outputTexture:a,width:l,height:u}=t,c=e.createBindGroup({layout:n.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:s}},{binding:1,resource:r.createView()},{binding:2,resource:i.createView()},{binding:3,resource:o.createView()},{binding:4,resource:a.createView()}]}),h=e.createCommandEncoder(),d=h.beginComputePass();d.setPipeline(n),d.setBindGroup(0,c);const f=Math.ceil(l/VS),p=Math.ceil(u/VS);d.dispatchWorkgroups(f,p),d.end();const g=Math.ceil(l*4/256)*256,m=e.createBuffer({size:g*u,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});return h.copyTextureToBuffer({texture:a},{buffer:m,bytesPerRow:g},[l,u]),e.queue.submit([h.finish()]),m}async function K8(t){const{readBuffer:e,width:n,height:s,bytesPerRow:r}=t;await e.mapAsync(GPUMapMode.READ);const i=document.createElement(Jh.ELEMENT_TYPE);i.width=n,i.height=s;const o=i.getContext(Jh.CONTEXT_TYPE),a=o.createImageData(n,s),l=new Uint8Array(e.getMappedRange());for(let u=0;u<s;u++){const c=u*r,h=u*n*4;for(let d=0;d<n;d++){const f=c+d*4,p=h+d*4;a.data[p]=l[f],a.data[p+1]=l[f+1],a.data[p+2]=l[f+2],a.data[p+3]=l[f+3]}}return o.putImageData(a,0,0),e.unmap(),i.toDataURL(Jh.OUTPUT_FORMAT)}function j8(t){const{textureA:e,textureB:n,textureMask:s,outputTexture:r,uniformBuffer:i,readBuffer:o}=t;e.destroy(),n.destroy(),s.destroy(),r.destroy(),i.destroy(),o.destroy()}async function X8(t){const{imageASource:e,imageBSource:n,maskSource:s,params:r,outputWidth:i,outputHeight:o}=t,a=await Ts();if(!a)throw new Error(I1.WEBGPU_NOT_SUPPORTED);const[l,u,c]=await Promise.all([wb(e),wb(n),wb(s)]),h=i||c.width,d=o||c.height,[f,p,g]=await Promise.all([Sb(l,h,d),Sb(u,h,d),Sb(c,h,d)]),{textureA:m,textureB:x,textureMask:b,outputTexture:v}=G8({device:a,bitmapA:f,bitmapB:p,bitmapMask:g,width:h,height:d}),y=V8(a,r),C=W8({device:a,wgslCode:z8}),I=Math.ceil(h*4/256)*256,$=H8({device:a,pipeline:C,uniformBuffer:y,textureA:m,textureB:x,textureMask:b,outputTexture:v,width:h,height:d}),T=await K8({readBuffer:$,width:h,height:d,bytesPerRow:I});return j8({textureA:m,textureB:x,textureMask:b,outputTexture:v,uniformBuffer:y,readBuffer:$}),T}const q8={soft:{...Ba,threshold:.5,softness:.5,contrast:.8},hard:{...Ba,threshold:.5,softness:.05,contrast:2},highContrast:{...Ba,threshold:.5,softness:.2,contrast:1.8,maskGamma:.7},inverted:{...Ba,threshold:.5,softness:.2,contrast:1,invert:!0},multiply:{...Ba,threshold:.5,softness:.3,blendMode:"multiply",opacity:.8},screen:{...Ba,threshold:.5,softness:.3,blendMode:"screen",opacity:.8}},Y8={class:"flex flex-col gap-4"},Z8={class:"flex flex-col gap-3"},Q8={class:"flex flex-col gap-2"},J8={class:"glass-btn relative overflow-hidden rounded-xl border border-white/10 bg-white/5 hover:bg-white/10 transition-all cursor-pointer h-20 flex items-center justify-center group"},eV={key:0,class:"flex items-center gap-2 text-white/50"},tV={class:"flex flex-col gap-2"},nV={class:"glass-btn relative overflow-hidden rounded-xl border border-white/10 bg-white/5 hover:bg-white/10 transition-all cursor-pointer h-20 flex items-center justify-center group"},sV={key:0,class:"flex items-center gap-2 text-white/50"},rV={class:"flex flex-col gap-2"},iV={class:"glass-btn relative overflow-hidden rounded-xl border border-white/10 bg-white/5 hover:bg-white/10 transition-all cursor-pointer h-20 flex items-center justify-center group"},oV={key:0,class:"flex items-center gap-2 text-white/50"},aV={class:"flex gap-2"},lV=["disabled"],uV={key:0,class:"i-carbon-circle-dash animate-spin"},cV={key:1,class:"i-carbon-magic-wand"},hV={class:"flex flex-col gap-3"},dV={class:"flex items-center justify-between"},fV={class:"flex flex-col gap-3"},pV={class:"flex flex-col gap-3"},mV={class:"flex items-center justify-between"},gV={class:"flex flex-col gap-3"},xV={class:"flex flex-col gap-2"},bV={class:"grid grid-cols-2 gap-2"},yV=["onClick"],vV={class:"flex items-center justify-between py-2"},wV={class:"flex flex-col gap-3"},SV={class:"flex items-center justify-between"},CV={class:"grid grid-cols-2 gap-2"},TV=["onClick"],IV=["disabled"],kV={key:0,class:"i-carbon-circle-dash animate-spin text-lg"},EV={key:1,class:"i-carbon-checkbox-checked text-lg"},_V={key:0,class:"text-xs text-center text-white/40"},$V=We({__name:"GrayscaleCompositorPanel",props:{isGenerating:{type:Boolean}},emits:["set-image"],setup(t,{emit:e}){const n=e,s=ce(!1),r=ce(!0),i=ce(!1),o=ce(null),a=ce(null),l=ce(null),u=ce(!1),c=pi({...Ba}),h=["normal","multiply","screen","overlay"],d=ye(()=>[{id:"threshold",label:"Threshold",value:c.threshold,min:0,max:1,step:.01,valuePosition:"after",showRuler:!1},{id:"softness",label:"Softness",value:c.softness,min:0,max:1,step:.01,valuePosition:"after",showRuler:!1},{id:"contrast",label:"Contrast",value:c.contrast,min:0,max:2,step:.01,valuePosition:"after",showRuler:!1},{id:"maskBias",label:"Bias",value:c.maskBias,min:-1,max:1,step:.01,valuePosition:"after",showRuler:!1},{id:"maskGamma",label:"Gamma",value:c.maskGamma,min:.01,max:3,step:.01,valuePosition:"after",showRuler:!1}]),f=ye(()=>[{id:"opacity",label:"Opacity",value:c.opacity,min:0,max:1,step:.01,valuePosition:"after",showRuler:!1}]),p=ye(()=>o.value&&a.value&&l.value),g=E=>{E.id in c&&(c[E.id]=E.value)},m=E=>{var N;const _=(N=E.target.files)==null?void 0:N[0];if(_){const P=new FileReader;P.onload=M=>{var z;o.value=(z=M.target)==null?void 0:z.result},P.readAsDataURL(_)}},x=E=>{var N;const _=(N=E.target.files)==null?void 0:N[0];if(_){const P=new FileReader;P.onload=M=>{var z;a.value=(z=M.target)==null?void 0:z.result},P.readAsDataURL(_)}},b=E=>{var N;const _=(N=E.target.files)==null?void 0:N[0];if(_){const P=new FileReader;P.onload=M=>{var z;l.value=(z=M.target)==null?void 0:z.result},P.readAsDataURL(_)}},v=async()=>{u.value=!0;try{const E=await rE(sE,1024,1024);l.value=E}catch(E){console.error("Failed to generate turing mask:",E)}finally{u.value=!1}},y=E=>{Object.assign(c,E)},C=ce(!1),I=ce(!1),$=async()=>{if(p.value){if(C.value){I.value=!0;return}C.value=!0;try{do{I.value=!1;const E=await X8({imageASource:o.value,imageBSource:a.value,maskSource:l.value,params:c});n("set-image",E)}while(I.value)}catch(E){console.error("Failed to composite images:",E)}finally{C.value=!1}}};let T=null;const S=()=>{p.value&&(T&&clearTimeout(T),T=setTimeout(()=>{$()},300))};return _t(c,()=>{S()},{deep:!0}),(E,_)=>(F(),V("div",Y8,[k("div",Z8,[_[10]||(_[10]=k("div",{class:"flex items-center justify-between"},[k("span",{class:"text-xs font-medium text-white/60"},"Input Images")],-1)),k("div",Q8,[_[5]||(_[5]=k("label",{class:"text-xs text-white/40"},"Image A (Base)",-1)),k("label",J8,[o.value?(F(),V("div",{key:1,class:"absolute inset-0 bg-cover bg-center opacity-50 group-hover:opacity-70 transition-opacity",style:bn({backgroundImage:`url(${o.value})`})},null,4)):(F(),V("div",eV,[..._[4]||(_[4]=[k("div",{class:"i-carbon-image text-xl"},null,-1),k("span",{class:"text-xs"},"Select Image A",-1)])])),k("input",{type:"file",accept:"image/*",onChange:m,class:"hidden"},null,32)])]),k("div",tV,[_[7]||(_[7]=k("label",{class:"text-xs text-white/40"},"Image B (Blend)",-1)),k("label",nV,[a.value?(F(),V("div",{key:1,class:"absolute inset-0 bg-cover bg-center opacity-50 group-hover:opacity-70 transition-opacity",style:bn({backgroundImage:`url(${a.value})`})},null,4)):(F(),V("div",sV,[..._[6]||(_[6]=[k("div",{class:"i-carbon-image text-xl"},null,-1),k("span",{class:"text-xs"},"Select Image B",-1)])])),k("input",{type:"file",accept:"image/*",onChange:x,class:"hidden"},null,32)])]),k("div",rV,[_[9]||(_[9]=k("label",{class:"text-xs text-white/40"},"Grayscale Mask",-1)),k("label",iV,[l.value?(F(),V("div",{key:1,class:"absolute inset-0 bg-cover bg-center opacity-50 group-hover:opacity-70 transition-opacity",style:bn({backgroundImage:`url(${l.value})`})},null,4)):(F(),V("div",oV,[..._[8]||(_[8]=[k("div",{class:"i-carbon-image text-xl"},null,-1),k("span",{class:"text-xs"},"Select Mask or Generate Turing",-1)])])),k("input",{type:"file",accept:"image/*",onChange:b,class:"hidden"},null,32)])]),k("div",aV,[k("button",{onClick:v,disabled:u.value,class:"glass-btn flex-1 py-2 px-3 rounded-lg bg-white/5 hover:bg-white/10 border border-white/5 text-white/60 hover:text-white/90 text-xs font-medium transition-all disabled:opacity-50 flex items-center justify-center gap-2"},[u.value?(F(),V("div",uV)):(F(),V("div",cV)),Tn(" "+Le(u.value?"Generating...":"Generate Turing Mask"),1)],8,lV)])]),k("div",hV,[k("div",dV,[_[11]||(_[11]=k("span",{class:"text-xs font-medium text-white/60"},"Mask Control",-1)),k("button",{onClick:_[0]||(_[0]=N=>s.value=!s.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":s.value}])},null,2)])]),vt(k("div",fV,[(F(!0),V(Xe,null,rt(d.value,N=>(F(),V("div",{key:N.id},[we(D(St),{items:[N],onUpdateValue:g},null,8,["items"])]))),128))],512),[[Gt,s.value]])]),k("div",pV,[k("div",mV,[_[12]||(_[12]=k("span",{class:"text-xs font-medium text-white/60"},"Blend Control",-1)),k("button",{onClick:_[1]||(_[1]=N=>r.value=!r.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":r.value}])},null,2)])]),vt(k("div",gV,[k("div",xV,[_[13]||(_[13]=k("span",{class:"text-xs text-white/40"},"Blend Mode",-1)),k("div",bV,[(F(),V(Xe,null,rt(h,N=>k("button",{key:N,onClick:P=>c.blendMode=N,class:Q(["glass-btn text-xs py-1.5 px-2 rounded bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 transition-colors",c.blendMode===N?"bg-white/10 text-white/90":""])},Le(N),11,yV)),64))])]),(F(!0),V(Xe,null,rt(f.value,N=>(F(),V("div",{key:N.id},[we(D(St),{items:[N],onUpdateValue:g},null,8,["items"])]))),128)),k("div",vV,[_[14]||(_[14]=k("span",{class:"text-xs text-white/60"},"Invert Mask",-1)),k("button",{onClick:_[2]||(_[2]=N=>c.invert=!c.invert),class:Q(["glass-btn px-3 py-1.5 rounded-lg text-xs transition-all",c.invert?"bg-white/20 text-white/90":"bg-white/5 text-white/40"])},Le(c.invert?"ON":"OFF"),3)])],512),[[Gt,r.value]])]),k("div",wV,[k("div",SV,[_[15]||(_[15]=k("span",{class:"text-xs font-medium text-white/60"},"Presets",-1)),k("button",{onClick:_[3]||(_[3]=N=>i.value=!i.value),class:"text-white/40 hover:text-white/60 transition-colors"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":i.value}])},null,2)])]),vt(k("div",CV,[(F(!0),V(Xe,null,rt(D(q8),(N,P)=>(F(),V("button",{key:P,onClick:M=>y(N),class:"glass-btn text-xs py-2 px-2 rounded bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 transition-colors"},Le(P),9,TV))),128))],512),[[Gt,i.value]])]),k("button",{onClick:$,disabled:!p.value||t.isGenerating,class:"glass-btn w-full py-2.5 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 text-white/60 hover:text-white/90 text-sm font-medium transition-all flex items-center justify-center gap-2 disabled:opacity-50"},[t.isGenerating?(F(),V("div",kV)):(F(),V("div",EV)),Tn(" "+Le(t.isGenerating?"Compositing...":"Composite Images"),1)],8,IV),p.value?Ue("",!0):(F(),V("div",_V," Please select all three images to continue "))]))}}),RV="modulepreload",AV=function(t){return"/seamless-texture-generator/"+t},WS={},Tb=function(e,n,s){let r=Promise.resolve();if(n&&n.length>0){document.getElementsByTagName("link");const o=document.querySelector("meta[property=csp-nonce]"),a=(o==null?void 0:o.nonce)||(o==null?void 0:o.getAttribute("nonce"));r=Promise.allSettled(n.map(l=>{if(l=AV(l),l in WS)return;WS[l]=!0;const u=l.endsWith(".css"),c=u?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${l}"]${c}`))return;const h=document.createElement("link");if(h.rel=u?"stylesheet":RV,u||(h.as="script"),h.crossOrigin="",h.href=l,a&&h.setAttribute("nonce",a),document.head.appendChild(h),u)return new Promise((d,f)=>{h.addEventListener("load",d),h.addEventListener("error",()=>f(new Error(`Unable to preload CSS for ${l}`)))})}))}function i(o){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=o,window.dispatchEvent(a),!a.defaultPrevented)throw o}return r.then(o=>{for(const a of o||[])a.status==="rejected"&&i(a.reason);return e().catch(i)})};async function PV(t,e,n){const s=e.width,r=e.height;(n.width!==s||n.height!==r)&&(n.width=s,n.height=r);const i=Math.ceil(s*4/256)*256,o=i*r,a=t.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),l=t.createCommandEncoder();l.copyTextureToBuffer({texture:e},{buffer:a,bytesPerRow:i},[s,r]),t.queue.submit([l.finish()]),await a.mapAsync(GPUMapMode.READ);const u=new Uint8Array(a.getMappedRange()),c=n.getContext("2d");if(c){const h=c.createImageData(s,r);for(let d=0;d<r;d++){const f=d*i,p=d*s*4,g=u.subarray(f,f+s*4);h.data.set(g,p)}c.putImageData(h,0,0)}a.unmap(),a.destroy()}const DV={ERRORS:{WEBGPU_INIT_FAILED:"WebGPU Init Failed"}};async function oE(){const t=await Ts(),e=await M8(t),n=L8(t);return{device:t,pipeline:e,rulesBuffer:n}}async function yu(t,e,n){const s=new Image;s.crossOrigin="anonymous",s.src=t,await s.decode();let r=e??s.width,i=n??s.height;try{return{bitmap:await createImageBitmap(s,{resizeWidth:r,resizeHeight:i,resizeQuality:"high"}),width:r,height:i}}catch{const a=document.createElement("canvas");a.width=r,a.height=i;const l=a.getContext("2d");if(!l)throw new Error("Canvas Context Failed");return l.drawImage(s,0,0,r,i),{bitmap:await createImageBitmap(a),width:r,height:i}}}function vu(t,e){const n=t.createTexture({size:[e.width,e.height],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});return t.queue.copyExternalImageToTexture({source:e},{texture:n},[e.width,e.height]),n}async function aE(t,e,n){const{device:s,pipeline:r,rulesBuffer:i}=t,{baseTexture:o,layers:a,width:l,height:u}=e,c={size:[l,u],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC};let h=s.createTexture(c),d=s.createTexture(c),f=s.createTexture(c);const p=s.createCommandEncoder();p.copyTextureToTexture({texture:o},{texture:h},[l,u]),p.copyTextureToTexture({texture:o},{texture:f},[l,u]),s.queue.submit([p.finish()]);for(const g of a){if(!g.visible||!g.imageTexture)continue;F8(s,i,g.maskRules),O8({device:s,baseTexture:h,layerTexture:g.imageTexture,originalBaseTexture:e.baseTexture,outputTexture:d,rulesBuffer:i,ruleCount:g.maskRules.length,layerOpacity:g.opacity,layerBlendMode:U8(g.blendMode),width:l,height:u,originalBaseTexture:f},r);const m=h;h=d,d=m}n&&((n.width!==l||n.height!==u)&&(n.width=l,n.height=u),await PV(s,h,n)),h.destroy(),d.destroy(),f.destroy()}async function NV(t,e,n,s,r){const i={id:Wm(),visible:!0,name:`Layer ${n+1}`,imageSource:e,maskRules:[],blendMode:"normal",opacity:1,imageTexture:void 0},o=await yu(e,s,r);i.imageTexture=vu(t,o.bitmap);try{i.layerPalette=await lE(e)}catch(a){console.warn("Color analysis failed",a),i.layerPalette=[]}return i}function MV(t,e,n){t/=255,e/=255,n/=255;const s=Math.max(t,e,n),r=Math.min(t,e,n);let i=0,o=0,a=(s+r)/2;if(s!==r){const l=s-r;switch(o=a>.5?l/(2-s-r):l/(s+r),s){case t:i=(e-n)/l+(e<n?6:0);break;case e:i=(n-t)/l+2;break;case n:i=(t-e)/l+4;break}i/=6}return{h:i*360,s:o*100,l:a*100}}async function lE(t,e=6){const n=new Image;n.crossOrigin="anonymous",n.src=t,await n.decode();const s=document.createElement("canvas"),r=64,i=64;s.width=r,s.height=i;const o=s.getContext("2d");if(!o)return[];o.drawImage(n,0,0,r,i);const a=o.getImageData(0,0,r,i).data,l=[];for(let d=0;d<a.length;d+=4)a[d+3]<128||l.push([a[d],a[d+1],a[d+2]]);if(l.length===0)return[];let u=[];for(let d=0;d<e;d++)u.push(l[Math.floor(Math.random()*l.length)]);for(let d=0;d<5;d++){const f=Array(e).fill(0).map(()=>[]);for(const p of l){let g=1/0,m=0;for(let x=0;x<e;x++){const b=Math.sqrt(Math.pow(p[0]-u[x][0],2)+Math.pow(p[1]-u[x][1],2)+Math.pow(p[2]-u[x][2],2));b<g&&(g=b,m=x)}f[m].push(p)}for(let p=0;p<e;p++){if(f[p].length===0)continue;let g=0,m=0,x=0;for(const b of f[p])g+=b[0],m+=b[1],x+=b[2];u[p]=[g/f[p].length,m/f[p].length,x/f[p].length]}}const c=u.map(d=>MV(d[0],d[1],d[2])),h=[];for(const d of c)h.some(f=>Math.abs(f.h-d.h)<10&&Math.abs(f.s-d.s)<10&&Math.abs(f.l-d.l)<10)||h.push(d);return h.sort((d,f)=>f.s-d.s)}function Wm(){return Math.random().toString(36).substr(2,9)}async function mu(t,e,n,s){try{t.value=!0,await s()}catch(r){const i=r instanceof Error?r.message:String(r);e.value=`${n}: ${i}`,console.error(r)}finally{t.value=!1}}const Ib=Object.freeze(Object.defineProperty({__proto__:null,analyzeImageColors:lE,createNewLayer:NV,createTextureFromBitmap:vu,executeWithLoading:mu,generateId:Wm,initCompositorResources:oE,loadAndResizeImage:yu,runMultiLayerCompositor:aE},Symbol.toStringTag,{value:"Module"}));function LV(){const t=Ah(null),e=Ah(null),n=Ah(null),s=Ah(null),r=ce(null),i=ce([]),o=ce([]),a=ce(!1),l=ce(null),u=ce({width:1024,height:1024}),c=async()=>{if(!t.value)try{const C=await oE();t.value=C.device,e.value=C.pipeline,n.value=C.rulesBuffer}catch(C){const I=C instanceof Error?C.message:String(C);l.value=`${DV.ERRORS.WEBGPU_INIT_FAILED}: ${I}`,console.error(C)}},h=async C=>{await c(),t.value&&await mu(a,l,"Set Base Image Failed",async()=>{const I=await yu(C);u.value={width:I.width,height:I.height},r.value=C;try{i.value=await Tb(()=>Promise.resolve().then(()=>Ib),void 0).then($=>$.analyzeImageColors(C))}catch($){console.warn("Base color analysis failed",$),i.value=[]}s.value&&s.value.destroy(),s.value=vu(t.value,I.bitmap);for(const $ of o.value)$.imageSource&&await d($)})},d=async C=>{if(!t.value||!C.imageSource)return;const I=await yu(C.imageSource,u.value.width,u.value.height);C.imageTexture&&C.imageTexture.destroy(),C.imageTexture=vu(t.value,I.bitmap)},f=async C=>{await c(),t.value&&await mu(a,l,"Add Layer Failed",async()=>{if(!r.value)throw new Error("Please set Base Image first");const I=await Tb(()=>Promise.resolve().then(()=>Ib),void 0).then($=>$.createNewLayer(t.value,C,o.value.length,u.value.width,u.value.height));o.value.push(I)})},p=C=>{const I=o.value.findIndex($=>$.id===C);if(I>-1){const $=o.value[I];$.imageTexture&&$.imageTexture.destroy(),o.value.splice(I,1)}},g=(C,I)=>{const $=o.value.find(T=>T.id===C);if($){const T=$.maskRules.findIndex(S=>S.id===I.id);T>-1?$.maskRules[T]=I:$.maskRules.push(I)}},m=(C,I)=>{const $=o.value.find(T=>T.id===C);if($){const T=$.maskRules.findIndex(S=>S.id===I);T>-1&&$.maskRules.splice(T,1)}},x=async(C,I)=>{await c(),t.value&&await mu(a,l,"Replace Layer Image Failed",async()=>{const $=o.value.find(S=>S.id===C);if(!$)return;$.imageSource=I;const T=await yu(I,u.value.width,u.value.height);$.imageTexture&&$.imageTexture.destroy(),$.imageTexture=vu(t.value,T.bitmap);try{$.layerPalette=await Tb(()=>Promise.resolve().then(()=>Ib),void 0).then(S=>S.analyzeImageColors(I))}catch(S){console.warn("Color analysis failed during replacement",S)}})},b=(C,I)=>{const $=o.value.findIndex(T=>T.id===C);if($!==-1){if(I==="up"){if($>0){const T=o.value[$];o.value[$]=o.value[$-1],o.value[$-1]=T}}else if($<o.value.length-1){const T=o.value[$];o.value[$]=o.value[$+1],o.value[$+1]=T}}},v=async C=>{t.value&&await mu(a,l,"Duplicate Layer Failed",async()=>{const I=o.value.find(S=>S.id===C);if(!I)return;const $={...I,id:Wm(),imageTexture:null,maskRules:I.maskRules.map(S=>({...S,id:Wm()}))};if(I.imageSource){const S=await yu(I.imageSource,u.value.width,u.value.height);$.imageTexture=vu(t.value,S.bitmap)}const T=o.value.findIndex(S=>S.id===C);o.value.splice(T+1,0,$)})},y=async C=>{!t.value||!e.value||!n.value||!s.value||a.value||await mu(a,l,"Render Failed",async()=>{await aE({device:t.value,pipeline:e.value,rulesBuffer:n.value},{baseTexture:s.value,layers:o.value,width:u.value.width,height:u.value.height},C)})};return fa(()=>{var C,I;(C=s.value)==null||C.destroy(),(I=n.value)==null||I.destroy(),o.value.forEach($=>{var T;return(T=$.imageTexture)==null?void 0:T.destroy()})}),{init:c,baseImage:r,basePalette:i,layers:o,isProcessing:a,error:l,setBaseImage:h,addLayer:f,removeLayer:p,replaceLayerImage:x,duplicateLayer:v,moveLayer:b,updateLayerRule:g,removeLayerRule:m,forceUpdate:y}}const OV={class:"w-8 h-8 rounded bg-black/40 overflow-hidden border border-white/10 flex-shrink-0 relative group/thumb"},FV=["src"],UV={class:"absolute inset-0 bg-black/60 flex items-center justify-center opacity-0 group-hover/thumb:opacity-100 transition-opacity",title:"Replace Image"},BV={class:"flex-1 min-w-0"},zV={class:"text-sm font-medium truncate"},GV={class:"text-[10px] text-white/50 flex gap-2"},VV={class:"flex items-center gap-1"},WV={class:"flex flex-col mr-1"},HV={class:"layer-details p-2 border-t border-white/5 bg-black/20"},KV={class:"grid grid-cols-2 gap-2 mb-3"},jV={key:0,class:"mb-3"},XV={key:0,class:"flex gap-1 flex-wrap mb-2"},qV=["title","onClick"],YV={key:1,class:"flex gap-1 flex-wrap"},ZV=["title","onClick"],QV={class:"mask-rules"},JV={class:"flex items-center justify-between mb-2"},eW={class:"text-[10px] font-bold text-white/50 uppercase"},tW={key:0,class:"text-center py-2 text-[10px] text-white/30 border border-dashed border-white/5 rounded"},nW={class:"space-y-2"},sW=["onClick"],rW={class:"grid grid-cols-2 gap-x-2 gap-y-1"},iW={class:"flex justify-between text-[10px] text-white/40"},oW=["onUpdate:modelValue"],aW={class:"flex justify-between text-[10px] text-white/40"},lW=["onUpdate:modelValue"],uW={class:"flex justify-between text-[10px] text-white/40"},cW=["onUpdate:modelValue"],hW={class:"flex justify-between text-[10px] text-white/40"},dW=["onUpdate:modelValue"],fW={class:"flex justify-between text-[10px] text-white/40"},pW=["onUpdate:modelValue"],mW={class:"flex justify-between text-[10px] text-white/40"},gW=["onUpdate:modelValue"],xW={class:"col-span-2 flex items-center justify-between pt-1 border-t border-white/5 mt-1"},bW={class:"flex-1 mr-2"},yW={class:"flex justify-between text-[10px] text-white/40"},vW=["onUpdate:modelValue"],wW={class:"flex items-center text-[10px] text-white/60 cursor-pointer"},SW=["onUpdate:modelValue"],CW={class:"col-span-2 flex items-center gap-2 pt-1 border-t border-white/5 mt-1"},TW={class:"flex bg-black/20 rounded p-0.5"},IW=["onClick"],kW=["onClick"],EW=We({__name:"AdvancedCompositorLayerItem",props:{layer:{},isActive:{type:Boolean},basePalette:{}},emits:["update","toggle-expand","toggle-visibility","delete","add-rule","remove-rule","add-rule-from-color","replace-image","duplicate","move"],setup(t){return(e,n)=>(F(),V("div",{class:Q(["layer-item bg-white/5 border border-white/5 rounded transition-all hover:bg-white/10 overflow-hidden",{"border-blue-500/50":t.isActive}])},[k("div",{class:"layer-header p-2 flex items-center gap-2 cursor-pointer bg-white/5",onClick:n[6]||(n[6]=s=>e.$emit("toggle-expand"))},[k("div",OV,[t.layer.imageSource?(F(),V("img",{key:0,src:t.layer.imageSource,class:"w-full h-full object-cover"},null,8,FV)):Ue("",!0),k("div",UV,[k("button",{onClick:n[0]||(n[0]=gs(s=>e.$emit("replace-image",t.layer.id),["stop"])),class:"text-white hover:text-blue-300"},[...n[20]||(n[20]=[k("i",{class:"i-carbon-renew"},null,-1)])])])]),k("div",BV,[k("div",zV,Le(t.layer.name),1),k("div",GV,[k("span",null,Le(t.layer.blendMode),1),k("span",null,Le(Math.round(t.layer.opacity*100))+"%",1),k("span",null,Le(t.layer.maskRules.length)+" Rules",1)])]),k("div",VV,[k("div",WV,[k("button",{onClick:n[1]||(n[1]=gs(s=>e.$emit("move",t.layer.id,"up"),["stop"])),class:"text-white/30 hover:text-white leading-none p-0.5",title:"Move Up"},[...n[21]||(n[21]=[k("i",{class:"i-carbon-caret-up text-[10px]"},null,-1)])]),k("button",{onClick:n[2]||(n[2]=gs(s=>e.$emit("move",t.layer.id,"down"),["stop"])),class:"text-white/30 hover:text-white leading-none p-0.5",title:"Move Down"},[...n[22]||(n[22]=[k("i",{class:"i-carbon-caret-down text-[10px]"},null,-1)])])]),k("button",{onClick:n[3]||(n[3]=gs(s=>e.$emit("duplicate",t.layer.id),["stop"])),class:"text-white/30 hover:text-white transition-colors p-1",title:"Duplicate Layer"},[...n[23]||(n[23]=[k("i",{class:"i-carbon-copy"},null,-1)])]),k("button",{onClick:n[4]||(n[4]=gs(s=>e.$emit("toggle-visibility",t.layer),["stop"])),class:Q([t.layer.visible?"text-white/80":"text-white/30","hover:text-white transition-colors p-1"])},[k("i",{class:Q(t.layer.visible?"i-carbon-view":"i-carbon-view-off")},null,2)],2),k("button",{onClick:n[5]||(n[5]=gs(s=>e.$emit("delete",t.layer.id),["stop"])),class:"text-red-400 hover:text-red-300 transition-colors p-1"},[...n[24]||(n[24]=[k("i",{class:"i-carbon-trash-can"},null,-1)])])])]),vt(k("div",HV,[k("div",KV,[k("div",null,[n[26]||(n[26]=k("label",{class:"text-[10px] text-white/50 block mb-1"},"Blend Mode",-1)),vt(k("select",{"onUpdate:modelValue":n[7]||(n[7]=s=>t.layer.blendMode=s),class:"w-full bg-black/40 border border-white/10 rounded text-xs px-2 py-1 text-white/70 outline-none focus:border-blue-500",onChange:n[8]||(n[8]=s=>e.$emit("update"))},[...n[25]||(n[25]=[Ik('<option value="normal" data-v-01fd7521>Normal</option><option value="add" data-v-01fd7521>Add</option><option value="multiply" data-v-01fd7521>Multiply</option><option value="screen" data-v-01fd7521>Screen</option><option value="overlay" data-v-01fd7521>Overlay</option><option value="max" data-v-01fd7521>Max</option><option value="min" data-v-01fd7521>Min</option>',7)])],544),[[jO,t.layer.blendMode]])]),k("div",null,[n[27]||(n[27]=k("label",{class:"text-[10px] text-white/50 block mb-1"},"Opacity",-1)),vt(k("input",{type:"range","onUpdate:modelValue":n[9]||(n[9]=s=>t.layer.opacity=s),min:0,max:1,step:.01,class:"w-full h-1 bg-white/10 rounded-lg appearance-none cursor-pointer accent-blue-500",onInput:n[10]||(n[10]=s=>e.$emit("update"))},null,544),[[Lr,t.layer.opacity,void 0,{number:!0}]])])]),t.layer.layerPalette&&t.layer.layerPalette.length>0||t.basePalette&&t.basePalette.length>0?(F(),V("div",jV,[n[30]||(n[30]=k("label",{class:"text-[10px] text-white/50 block mb-1"},"Suggested Colors",-1)),t.layer.layerPalette&&t.layer.layerPalette.length>0?(F(),V("div",XV,[n[28]||(n[28]=k("div",{class:"text-[9px] text-white/30 w-full mb-0.5"},"Self",-1)),(F(!0),V(Xe,null,rt(t.layer.layerPalette,(s,r)=>(F(),V("button",{key:`l-${r}`,class:"w-6 h-6 rounded-full border border-white/20 hover:border-white transition-all transform hover:scale-110 focus:outline-none focus:ring-1 focus:ring-blue-500",style:bn({backgroundColor:`hsl(${s.h}, ${s.s}%, ${s.l}%)`}),title:`Self - H:${Math.round(s.h)} S:${Math.round(s.s)} L:${Math.round(s.l)}`,onClick:gs(i=>e.$emit("add-rule-from-color",t.layer.id,s,0),["stop"])},null,12,qV))),128))])):Ue("",!0),t.basePalette&&t.basePalette.length>0?(F(),V("div",YV,[n[29]||(n[29]=k("div",{class:"text-[9px] text-white/30 w-full mb-0.5"},"Base",-1)),(F(!0),V(Xe,null,rt(t.basePalette,(s,r)=>(F(),V("button",{key:`b-${r}`,class:"w-6 h-6 rounded-full border border-white/20 hover:border-white transition-all transform hover:scale-110 focus:outline-none focus:ring-1 focus:ring-blue-500",style:bn({backgroundColor:`hsl(${s.h}, ${s.s}%, ${s.l}%)`}),title:`Base - H:${Math.round(s.h)} S:${Math.round(s.s)} L:${Math.round(s.l)}`,onClick:gs(i=>e.$emit("add-rule-from-color",t.layer.id,s,1),["stop"])},null,12,ZV))),128))])):Ue("",!0)])):Ue("",!0),k("div",QV,[k("div",JV,[k("span",eW,"Mask Rules ("+Le(t.layer.maskRules.length)+")",1),k("button",{onClick:n[11]||(n[11]=gs(s=>e.$emit("add-rule",t.layer.id),["stop"])),class:"text-[10px] text-blue-400 hover:text-blue-300 flex items-center gap-1"},[...n[31]||(n[31]=[k("i",{class:"i-carbon-add"},null,-1),Tn(" Add Rule ",-1)])])]),t.layer.maskRules.length===0?(F(),V("div",tW," No rules (Fully Visible) ")):Ue("",!0),k("div",nW,[(F(!0),V(Xe,null,rt(t.layer.maskRules,(s,r)=>(F(),V("div",{key:s.id,class:"rule-item bg-white/5 rounded p-2 text-xs relative group"},[k("button",{onClick:gs(i=>e.$emit("remove-rule",t.layer.id,s.id),["stop"]),class:"absolute top-1 right-1 text-white/20 hover:text-red-400 p-1 opacity-0 group-hover:opacity-100 transition-opacity"},[...n[32]||(n[32]=[k("i",{class:"i-carbon-close"},null,-1)])],8,sW),k("div",{class:"absolute top-1 right-6 w-3 h-3 rounded-full border border-white/20",style:bn({backgroundColor:`hsl(${s.hue}, ${s.saturation}%, ${s.lightness}%)`})},null,4),k("div",rW,[k("div",null,[k("div",iW,[n[33]||(n[33]=k("span",null,"Hue",-1)),k("span",null,Le(Math.round(s.hue)),1)]),vt(k("input",{type:"range","onUpdate:modelValue":i=>s.hue=i,min:0,max:360,class:"w-full h-1 bg-white/5 rounded accent-blue-500/80",onInput:n[12]||(n[12]=i=>e.$emit("update"))},null,40,oW),[[Lr,s.hue,void 0,{number:!0}]])]),k("div",null,[k("div",aW,[n[34]||(n[34]=k("span",null,"H-Tol",-1)),k("span",null,Le(Math.round(s.hueTolerance)),1)]),vt(k("input",{type:"range","onUpdate:modelValue":i=>s.hueTolerance=i,min:1,max:180,class:"w-full h-1 bg-white/5 rounded accent-blue-500/80",onInput:n[13]||(n[13]=i=>e.$emit("update"))},null,40,lW),[[Lr,s.hueTolerance,void 0,{number:!0}]])]),k("div",null,[k("div",uW,[n[35]||(n[35]=k("span",null,"Sat",-1)),k("span",null,Le(Math.round(s.saturation)),1)]),vt(k("input",{type:"range","onUpdate:modelValue":i=>s.saturation=i,min:0,max:100,class:"w-full h-1 bg-white/5 rounded accent-blue-500/80",onInput:n[14]||(n[14]=i=>e.$emit("update"))},null,40,cW),[[Lr,s.saturation,void 0,{number:!0}]])]),k("div",null,[k("div",hW,[n[36]||(n[36]=k("span",null,"S-Tol",-1)),k("span",null,Le(Math.round(s.saturationTolerance)),1)]),vt(k("input",{type:"range","onUpdate:modelValue":i=>s.saturationTolerance=i,min:1,max:100,class:"w-full h-1 bg-white/5 rounded accent-blue-500/80",onInput:n[15]||(n[15]=i=>e.$emit("update"))},null,40,dW),[[Lr,s.saturationTolerance,void 0,{number:!0}]])]),k("div",null,[k("div",fW,[n[37]||(n[37]=k("span",null,"Lum",-1)),k("span",null,Le(Math.round(s.lightness)),1)]),vt(k("input",{type:"range","onUpdate:modelValue":i=>s.lightness=i,min:0,max:100,class:"w-full h-1 bg-white/5 rounded accent-blue-500/80",onInput:n[16]||(n[16]=i=>e.$emit("update"))},null,40,pW),[[Lr,s.lightness,void 0,{number:!0}]])]),k("div",null,[k("div",mW,[n[38]||(n[38]=k("span",null,"L-Tol",-1)),k("span",null,Le(Math.round(s.lightnessTolerance)),1)]),vt(k("input",{type:"range","onUpdate:modelValue":i=>s.lightnessTolerance=i,min:1,max:100,class:"w-full h-1 bg-white/5 rounded accent-blue-500/80",onInput:n[17]||(n[17]=i=>e.$emit("update"))},null,40,gW),[[Lr,s.lightnessTolerance,void 0,{number:!0}]])]),k("div",xW,[k("div",bW,[k("div",yW,[n[39]||(n[39]=k("span",null,"Feather",-1)),k("span",null,Le(s.feather.toFixed(2)),1)]),vt(k("input",{type:"range","onUpdate:modelValue":i=>s.feather=i,min:0,max:1,step:.01,class:"w-full h-1 bg-white/5 rounded accent-green-500/80",onInput:n[18]||(n[18]=i=>e.$emit("update"))},null,40,vW),[[Lr,s.feather,void 0,{number:!0}]])]),k("label",wW,[vt(k("input",{type:"checkbox","onUpdate:modelValue":i=>s.invert=i,class:"mr-1 rounded bg-white/10",onChange:n[19]||(n[19]=i=>e.$emit("update"))},null,40,SW),[[KO,s.invert]]),n[40]||(n[40]=Tn(" Inv ",-1))])]),k("div",CW,[n[41]||(n[41]=k("span",{class:"text-[10px] text-white/40"},"Source:",-1)),k("div",TW,[k("button",{class:Q(["px-2 py-0.5 rounded text-[9px] transition-colors",!s.maskSource||s.maskSource===0?"bg-blue-500 text-white":"text-white/40 hover:text-white"]),onClick:i=>{s.maskSource=0,e.$emit("update")}},"Self",10,IW),k("button",{class:Q(["px-2 py-0.5 rounded text-[9px] transition-colors",s.maskSource===1?"bg-blue-500 text-white":"text-white/40 hover:text-white"]),onClick:i=>{s.maskSource=1,e.$emit("update")}},"Base",10,kW)])])])]))),128))])])],512),[[Gt,t.isActive]])],2))}}),_W=Zi(EW,[["__scopeId","data-v-01fd7521"]]),$W={class:"advanced-compositor-panel flex flex-col h-full bg-[#1e1e1e] text-white p-4 overflow-y-auto"},RW={class:"base-image-section mb-4 p-3 bg-black/20 rounded border border-white/5"},AW={class:"relative group cursor-pointer h-32 bg-white/5 rounded-lg border-2 border-dashed border-white/10 hover:border-blue-500/50 hover:bg-white/10 transition-all flex items-center justify-center overflow-hidden"},PW={key:0,class:"text-center text-white/40 group-hover:text-white/70"},DW=["src"],NW={key:2,class:"absolute top-2 right-2 z-20 opacity-0 group-hover:opacity-100 transition-opacity"},MW={class:"preview-area mb-4 relative flex justify-center bg-black/40 rounded border border-white/10 p-2 min-h-[200px]"},LW={key:0,class:"absolute inset-0 flex items-center justify-center bg-black/50 z-10 backdrop-blur-sm"},OW={key:1,class:"absolute inset-0 flex items-center justify-center text-white/20 pointer-events-none"},FW={key:2,class:"absolute inset-0 flex items-center justify-center bg-red-900/80 p-4 text-center z-20"},UW={class:"text-red-200 text-sm"},BW={class:"layers-section flex-1 flex flex-col min-h-0"},zW={class:"flex items-center justify-between mb-2"},GW={class:"text-xs font-bold text-white/70 uppercase tracking-wide"},VW={class:"flex gap-2"},WW=["disabled"],HW={class:"layers-list flex-1 overflow-y-auto space-y-2 pr-1 custom-scrollbar"},KW={key:0,class:"text-center py-6 text-white/20 text-xs"},jW=We({__name:"AdvancedCompositorPanel",emits:["set-image"],setup(t,{emit:e}){const{init:n,baseImage:s,basePalette:r,setBaseImage:i,addLayer:o,removeLayer:a,updateLayerRule:l,removeLayerRule:u,replaceLayerImage:c,duplicateLayer:h,moveLayer:d,layers:f,isProcessing:p,error:g,forceUpdate:m}=LV(),x=ce(null),b=ce(null),v=ce(null),y=ce(null);let C=null;kr(async()=>{await n()});const I=e,$=()=>{C&&clearTimeout(C),C=setTimeout(async()=>{if(x.value){await m(x.value);try{const A=x.value.toDataURL("image/png");I("set-image",A)}catch(A){console.warn("Failed to export canvas image",A)}}},50)},T=A=>{var L;const B=(L=A.target.files)==null?void 0:L[0];if(B){const U=new FileReader;U.onload=async j=>{var Z;(Z=j.target)!=null&&Z.result&&(await i(j.target.result),$())},U.readAsDataURL(B)}},S=()=>{var A;y.value=null,(A=b.value)==null||A.click()},E=A=>{var B;y.value=A,(B=b.value)==null||B.click()},_=A=>{var L;const B=(L=A.target.files)==null?void 0:L[0];if(B){const U=new FileReader;U.onload=async j=>{var Z;if((Z=j.target)!=null&&Z.result){const J=j.target.result;y.value?(await c(y.value,J),y.value=null):(await o(J),setTimeout(()=>{const se=f.value[f.value.length-1];se&&(v.value=se.id)},100)),$()}},U.readAsDataURL(B)}b.value&&(b.value.value="")},N=A=>{a(A),v.value===A&&(v.value=null),$()},P=(A,B,L=0)=>{const U={id:Math.random().toString(36).substr(2,9),hue:B.h,hueTolerance:20,saturation:B.s,saturationTolerance:15,lightness:B.l,lightnessTolerance:15,feather:.2,invert:!1,maskSource:L};l(A,U),$()},M=A=>{const B={id:Math.random().toString(36).substr(2,9),hue:0,hueTolerance:30,saturation:50,saturationTolerance:20,lightness:50,lightnessTolerance:20,feather:.2,invert:!1,maskSource:0};l(A,B),$()},z=(A,B)=>{u(A,B),$()};return(A,B)=>(F(),V("div",$W,[B[9]||(B[9]=k("div",{class:"header mb-4 border-b border-white/10 pb-2"},[k("h2",{class:"text-lg font-bold flex items-center gap-2"},[k("i",{class:"i-carbon-layers mt-1"}),Tn(" Advanced Compositor ")]),k("p",{class:"text-xs text-white/50 mt-1"}," Multi-Layer Image Compositing with HSL Masking ")],-1)),k("div",RW,[B[4]||(B[4]=k("h3",{class:"text-xs font-bold text-white/70 mb-2 uppercase tracking-wide"},"Base Layer",-1)),k("div",AW,[k("input",{type:"file",accept:"image/*",class:"absolute inset-0 opacity-0 cursor-pointer z-10",onChange:T},null,32),D(s)?(F(),V("img",{key:1,src:D(s),class:"w-full h-full object-contain"},null,8,DW)):(F(),V("div",PW,[...B[2]||(B[2]=[k("i",{class:"i-carbon-image text-2xl mb-1 block"},null,-1),k("span",{class:"text-xs"},"Click or Drop Base Image",-1)])])),D(s)?(F(),V("div",NW,[...B[3]||(B[3]=[k("button",{class:"bg-black/60 text-white p-1 rounded hover:bg-black/80"},[k("i",{class:"i-carbon-edit"})],-1)])])):Ue("",!0)])]),k("div",MW,[k("canvas",{ref_key:"canvasRef",ref:x,class:"max-w-full max-h-[400px] object-contain"},null,512),D(p)?(F(),V("div",LW,[...B[5]||(B[5]=[k("div",{class:"animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"},null,-1)])])):Ue("",!0),D(s)?Ue("",!0):(F(),V("div",OW,[...B[6]||(B[6]=[k("span",null,"Preview Area",-1)])])),D(g)?(F(),V("div",FW,[k("div",UW,[B[7]||(B[7]=k("i",{class:"i-carbon-warning block text-2xl mb-2 mx-auto"},null,-1)),Tn(" "+Le(D(g)),1)])])):Ue("",!0)]),k("div",BW,[k("div",zW,[k("h3",GW,"Overlay Layers ("+Le(D(f).length)+")",1),k("div",VW,[k("button",{onClick:S,disabled:!D(s),class:"px-2 py-1 bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed rounded text-xs flex items-center gap-1 transition-colors"},[...B[8]||(B[8]=[k("i",{class:"i-carbon-add-filled"},null,-1),Tn(" Add Image Layer ",-1)])],8,WW),k("input",{type:"file",ref_key:"layerInputRef",ref:b,accept:"image/*",class:"hidden",onChange:_},null,544)])]),k("div",HW,[(F(!0),V(Xe,null,rt(D(f),L=>(F(),st(_W,{key:L.id,layer:L,"is-active":v.value===L.id,"base-palette":D(r),onToggleExpand:U=>v.value=v.value===L.id?null:L.id,onToggleVisibility:U=>{L.visible=!L.visible,$()},onDelete:N,onUpdate:$,onAddRule:M,onRemoveRule:z,onAddRuleFromColor:P,onReplaceImage:E,onDuplicate:B[0]||(B[0]=U=>{D(h)(U),$()}),onMove:B[1]||(B[1]=(U,j)=>{D(d)(U,j),$()})},null,8,["layer","is-active","base-palette","onToggleExpand","onToggleVisibility"]))),128)),D(f).length===0?(F(),V("div",KW," No overlay layers yet. ")):Ue("",!0)])])]))}}),XW=Zi(jW,[["__scopeId","data-v-848f56e1"]]);class ed extends Error{constructor(n){super(n.message);Wt(this,"status");Wt(this,"code");Wt(this,"response");this.name="FetchError",this.status=n.status,this.code=n.code,this.response=n.response}}const k1="https://api-inference.modelscope.cn",qW="Authorization",uE="Content-Type",YW="X-ModelScope-Async-Mode",HS="X-ModelScope-Task-Type",E1="application/json",KS="image_generation",ZW="Tongyi-MAI/Z-Image-Turbo",QW=1,JW=3e4,e9=3,t9=1e3,n9="TIMEOUT",s9="SERVER_ERROR",r9="NETWORK_ERROR",i9="AbortError",o9="/v1/images/generations",a9="/v1/tasks",l9=t=>` ${t} `,cE="/api/network/forwardProxy",hE="Token ",dE=6e4,ov="POST",fE="GET";function Ju(t,e){const n=encodeURIComponent(t);return`${e}?target=${n}`}const u9=t=>` (${t}ms)`,c9=t=>` ${t}`,h9=t=>`HTTP ${t}`,d9="",f9=t=>`Bearer ${t}`,p9=(t,e)=>`${t}/${e}`,m9=(t,e,n)=>`${t}/${e}/${n}`;function g9(t){return t.json()}function x9(t){return t.text()}async function b9(t,e={}){const{timeout:n=JW,...s}=e,r=new AbortController,i=setTimeout(()=>r.abort(),n);try{return await fetch(t,{...s,signal:r.signal})}catch(o){throw o instanceof DOMException&&o.name===i9?new ed({message:u9(n),status:408,code:n9}):o}finally{clearTimeout(i)}}async function y9(t){const{url:e,options:n,retries:s=e9,retryDelay:r=t9}=t;let i;for(let o=0;o<=s;o++)try{const a=await b9(e,n);if(a.status>=500||a.status===429)throw new ed({message:c9(a.status),status:a.status,code:s9,response:a});return a}catch(a){if(i=a,o<s){const l=r*Math.pow(2,o);await new Promise(u=>setTimeout(u,l));continue}}throw i instanceof ed?i:new ed({message:i instanceof Error?i.message:d9,code:r9})}async function v9(t){const e=t.headers.get(uE);if(!t.ok){const n=await(e!=null&&e.includes(E1)?t.json():t.text());throw new ed({message:n.message||h9(t.status),status:t.status,code:n.code,response:t})}return e!=null&&e.includes(E1)?g9(t):x9(t)}async function Jg(t,e={}){const n=await y9({url:t,options:e});return v9(n)}function _1(t){return{[qW]:f9(t),[uE]:E1}}async function pE(t,e,n,s=3){const r=e.replace(/([^:])\/+/g,"$1/"),o=`${t.url.replace(/\/+$/,"")}${cE}`,a=w9(n.headers),l=Object.entries(a).map(([h,d])=>({[h]:d})),u={url:r,method:n.method||fE,headers:l,timeout:dE,payload:typeof n.body=="string"?JSON.parse(n.body):void 0};let c=null;for(let h=0;h<s;h++){const d=await Jg(o,{method:ov,headers:{Authorization:`${hE}${t.token}`,"Content-Type":"application/json"},body:JSON.stringify(u)});if(d.code!==0)throw new Error(`SiYuan Proxy Error: ${d.msg}`);if(!d.data){c=new Error("SiYuan Proxy Error: No data returned"),console.warn(`[SiYuan Proxy] data is null, retrying (${h+1}/${s})...`),await new Promise(f=>setTimeout(f,1e3*(h+1)));continue}return C9(d.data)}throw c||new Error("SiYuan Proxy Error: Max retries exceeded")}function w9(t){const e={};if(!t)return e;if(Array.isArray(t)||typeof t[Symbol.iterator]=="function"){for(const[n,s]of t)e[n]=s;return e}return Object.assign(e,t)}function S9(t){let e=`HTTP ${t.statusCode}`;if(!t.body)return e;try{e+=`: ${atob(t.body)}`}catch{}return e}function C9(t){const e=t;if(e.statusCode<200||e.statusCode>=300)throw new Error(S9(e));if(!e.body)return{};const s=e.bodyEncoding==="text"?e.body:T9(e.body);try{return JSON.parse(s)}catch{const r=s.substring(0,200);throw new Error(`Failed to parse response body. Preview: ${r}`)}}function T9(t){try{return atob(t)}catch{throw new Error("Failed to decode Base64 response body")}}async function I9(t){const{apiKey:e,prompt:n,params:s={},proxyUrl:r,batchInterval:i=0,siyuanConfig:o}=t,a=!o&&r?Ju(k1,r):k1,l=p9(a,o9),u=s.n??QW,c={model:s.model||ZW,prompt:n,...s.size&&{size:s.size},...s.seed!==void 0&&{seed:s.seed},...s.steps!==void 0&&{steps:s.steps},...s.guidance!==void 0&&{guidance:s.guidance},...s.negative_prompt&&{negative_prompt:s.negative_prompt},...s.image_url&&{image_url:s.image_url},...s.loras&&{loras:s.loras}};if(u===1)return[(await jS({payload:c,apiKey:e,url:l,siyuanConfig:o})).task_id];const h=[];for(let d=0;d<u;d++){i>0&&d>0&&await new Promise(g=>setTimeout(g,i));const f={...c,...c.seed===void 0&&{seed:Math.floor(Math.random()*2147483647)}},p=await jS({payload:f,apiKey:e,url:l,siyuanConfig:o});h.push(p.task_id)}return h}async function jS(t){const{payload:e,apiKey:n,url:s,siyuanConfig:r}=t,i={..._1(n),[YW]:"true"},o=JSON.stringify(e),a={method:ov,headers:i,body:o};return r?pE(r,s,a):Jg(s,a)}async function k9(t){const{apiKey:e,taskId:n,proxyUrl:s,siyuanConfig:r}=t,i=m9(k1,a9,n),o=!r&&s?Ju(i,s):i;return r?pE(r,o,{headers:{..._1(e),[HS]:KS}}):await Jg(o,{headers:{..._1(e),[HS]:KS}})}async function E9(t){const{apiKey:e,taskId:n,interval:s=2e3,maxAttempts:r=60,proxyUrl:i,siyuanConfig:o}=t;for(let a=0;a<r;a++){const l=await k9({apiKey:e,taskId:n,proxyUrl:i,siyuanConfig:o});if(l.task_status==="SUCCEED"||l.task_status==="FAILED")return l;await new Promise(u=>setTimeout(u,s))}throw new Error(l9(n))}async function mE(t){const{imageUrl:e,proxyUrl:n,siyuanConfig:s}=t;if(s){const a=e.replace(/([^:])\/+/g,"$1/"),u=`${s.url.replace(/\/+$/,"")}${cE}`,c=3;let h=null;for(let d=0;d<c;d++){const f=await Jg(u,{method:ov,headers:{Authorization:`${hE}${s.token}`,"Content-Type":"application/json"},body:JSON.stringify({url:a,method:fE,headers:[],timeout:dE,responseEncoding:"base64"})});if(f.code!==0)throw new Error(`SiYuan Proxy Error: ${f.msg}`);if(!f.data){h=new Error("SiYuan Proxy Error: No data returned"),console.warn(`[fetchImageWithProxy] data is null, retrying (${d+1}/${c})...`),await new Promise(v=>setTimeout(v,1e3*(d+1)));continue}if(!f.data.body)throw new Error("SiYuan Proxy Error: Empty image body");const g=f.data.bodyEncoding==="text"?btoa(f.data.body):f.data.body,m=f.data.headers||{};return`data:${(m["Content-Type"]||m["content-type"]||["image/png"])[0]||"image/png"};base64,${g}`}throw h||new Error("SiYuan Proxy Error: Max retries exceeded")}const r=n?Ju(e,n):e,i=await fetch(r);if(!i.ok)throw new Error(`Failed to fetch image: ${i.status}`);const o=await i.blob();return new Promise((a,l)=>{const u=new FileReader;u.onload=()=>a(u.result),u.onerror=l,u.readAsDataURL(o)})}const XS={INVALID_API_KEY:"API ",EMPTY_PROMPT:""},Xo={SUBMITTING:"...",GENERATING:"...",DOWNLOADING:"...",LOADED:""},ko={GENERATION_FAILED:"",TEXT_TO_IMAGE_ERROR:"Text-to-Image error:",NO_IMAGE_URL:" URL",ALL_TASKS_FAILED:"",TASK_SUCCEEDED_NO_IMAGE:" URL",TASK_FAILED:"",UNKNOWN_ERROR:""},En={EMPTY_STRING:"",SIZE:"1024x1024",N:1,NUM_INFERENCE_STEPS:9,MODEL:"Tongyi-MAI/Z-Image-Turbo",SHOW_ADVANCED:!1,PROXY_URL:"/api/common-proxy",PROXY_TYPE:"default",SIYUAN_URL:"http://127.0.0.1:6806",SIYUAN_TOKEN:""},_9={SUCCEED:"SUCCEED"},qS={TASK_SUCCEEDED_NO_IMAGE:t=>` ${t}  URL`,TASK_FAILED:(t,e)=>` ${t} : ${e}`},td={MAX_COUNT:10,ERROR_MESSAGES:{CACHE_FAILED:"Failed to cache image:"}},lr={DB_NAME:"ImageCacheDB",DB_VERSION:1,STORE_NAME:"imageCache",URL_LIST_STORE_NAME:"urlList",URL_LIST_ID:"main",KEY_PATH:{URL:"url",ID:"id"},TRANSACTION_MODE:{READONLY:"readonly",READWRITE:"readwrite"},ERROR_MESSAGES:{FAILED_TO_OPEN:"Failed to open IndexedDB",FAILED_TO_GET_IMAGES:"Failed to get cached images:",FAILED_TO_GET_IMAGE:"Failed to get cached image by URL:",FAILED_TO_GET_URL_LIST:"Failed to get URL list:",FAILED_TO_CLEAR_CACHE:"Failed to clear all cache:"}},$9=t=>`Invalid path format: "${t}". Expected "storeName/key".`,kb=t=>`Directory (Store) not found: ${t}`,R9=(t,e)=>`Directory (Store) not valid: "${t}". Available: ${e.join(", ")}`,zs=(t,e)=>`${t}: ${e}`,A9=t=>`Database ${t} needs upgrade. Connection closed.`,P9=()=>"Transaction aborted",D9=(t,e)=>`[IndexDBFS] : Store "${t}"  keyPath "${e}" data `;function N9(t){return Array.isArray(t)}class gE{constructor(e,n,s=1){Wt(this,"dbName");Wt(this,"storeNames");Wt(this,"db",null);Wt(this,"version");Wt(this,"openPromise",null);this.dbName=e,this.storeNames=new Set(n),this.version=s}async read(e){const{storeName:n,key:s}=this.parsePath(e),r=await this.ensureDB();return new Promise((i,o)=>{try{const u=r.transaction(n,"readonly").objectStore(n).get(s);u.onsuccess=()=>i(u.result||null),u.onerror=()=>o(Gs(zs,"Read",u.error))}catch(a){o(Gs(zs,"Transaction",a))}})}async write(e,n){const{storeName:s,key:r}=this.parsePath(e),i=await this.ensureDB();return new Promise((o,a)=>{try{const u=i.transaction(s,"readwrite").objectStore(s);if(u.keyPath){const h=Array.isArray(u.keyPath)?u.keyPath:[u.keyPath];for(const d of h)if(typeof n!="object"||n===null||!(d in n))throw new Error(D9(s,d))}const c=u.keyPath?u.put(n):u.put(n,r);c.onsuccess=()=>o(),c.onerror=()=>a(Gs(zs,"Write",c.error))}catch(l){a(Gs(zs,"Transaction",l))}})}async delete(e){const{storeName:n,key:s}=this.parsePath(e),r=await this.ensureDB();return new Promise((i,o)=>{try{const u=r.transaction(n,"readwrite").objectStore(n).delete(s);u.onsuccess=()=>i(),u.onerror=()=>o(Gs(zs,"Delete",u.error))}catch(a){o(Gs(zs,"Transaction",a))}})}async list(e){if(!this.storeNames.has(e))throw new Error(kb(e));const n=await this.ensureDB();return new Promise((s,r)=>{try{const a=n.transaction(e,"readonly").objectStore(e).getAllKeys();a.onsuccess=()=>s(a.result),a.onerror=()=>r(Gs(zs,"List",a.error))}catch(i){r(Gs(zs,"Transaction",i))}})}async readdir(e){if(!this.storeNames.has(e))throw new Error(kb(e));const n=await this.ensureDB();return new Promise((s,r)=>{try{const a=n.transaction(e,"readonly").objectStore(e).getAll();a.onsuccess=()=>{const l=a.result;if(!N9(l)){s([]);return}s(l)},a.onerror=()=>r(Gs(zs,"ReadDir",a.error))}catch(i){r(Gs(zs,"Transaction",i))}})}async clear(e){if(!this.storeNames.has(e))throw new Error(kb(e));const n=await this.ensureDB();return new Promise((s,r)=>{try{const a=n.transaction(e,"readwrite").objectStore(e).clear();a.onsuccess=()=>s(),a.onerror=()=>r(Gs(zs,"Clear",a.error))}catch(i){r(Gs(zs,"Transaction",i))}})}async transaction(e,n,s){const r=await this.ensureDB();return new Promise(async(i,o)=>{try{const a=r.transaction(e,n);a.oncomplete=()=>{},a.onerror=()=>o(Gs(zs,"Transaction",a.error)),a.onabort=()=>o(new Error(P9()));try{const l=await s(a);i(l)}catch(l){if(a.error===null)try{a.abort()}catch{}o(l)}}catch(a){o(Gs(zs,"Create transaction",a))}})}async ensureDB(){return this.db?this.db:this.openPromise?this.openPromise:(this.openPromise=new Promise((e,n)=>{const s=indexedDB.open(this.dbName,this.version);s.onerror=()=>{this.openPromise=null,n(Gs(zs,"Open DB",s.error))},s.onsuccess=()=>{this.db=s.result,this.db.onversionchange=()=>{var r;(r=this.db)==null||r.close(),this.db=null,this.openPromise=null,console.warn(A9(this.dbName))},e(this.db)},s.onupgradeneeded=()=>{const r=s.result;for(const i of this.storeNames)r.objectStoreNames.contains(i)||r.createObjectStore(i)}}),this.openPromise)}parsePath(e){const n=e.split("/");if(n.length<2)throw new Error($9(e));const s=n[0],r=n.slice(1).join("/");if(!this.storeNames.has(s))throw new Error(R9(s,Array.from(this.storeNames)));return{storeName:s,key:r}}}function Gs(t,e,n){const s=n instanceof Error?n.message:String(n);return new Error(t(e,s),{cause:n})}const Xd=new gE(lr.DB_NAME,[lr.STORE_NAME,lr.URL_LIST_STORE_NAME],lr.DB_VERSION);async function M9(t,e){if(e)try{const n={url:e,base64:t,timestamp:Date.now()};await Xd.write(`${lr.STORE_NAME}/${e}`,n);const s=await xE();if(!s.includes(e)){const r=[...s,e];await bE(r)}await L9()}catch(n){console.warn(td.ERROR_MESSAGES.CACHE_FAILED,n)}}async function L9(){const t=await xE();if(t.length<=td.MAX_COUNT)return;const e=t.slice(0,t.length-td.MAX_COUNT),n=t.slice(t.length-td.MAX_COUNT);await bE(n);for(const s of e)try{await Xd.delete(`${lr.STORE_NAME}/${s}`)}catch(r){console.warn(`Failed to delete cache ${s}`,r)}}async function O9(t){if(!t)return null;try{const e=await Xd.read(`${lr.STORE_NAME}/${t}`);return(e==null?void 0:e.base64)||null}catch(e){return console.warn(lr.ERROR_MESSAGES.FAILED_TO_GET_IMAGE,e),null}}async function xE(){try{const t=await Xd.read(`${lr.URL_LIST_STORE_NAME}/${lr.URL_LIST_ID}`);return(t==null?void 0:t.urls)||[]}catch(t){return console.warn(lr.ERROR_MESSAGES.FAILED_TO_GET_URL_LIST,t),[]}}async function bE(t){const e={id:lr.URL_LIST_ID,urls:t};await Xd.write(`${lr.URL_LIST_STORE_NAME}/${lr.URL_LIST_ID}`,e)}const yE=async(t,e)=>{if(e)try{await M9(t,e)}catch(n){console.warn(td.ERROR_MESSAGES.CACHE_FAILED,n)}},vE=async t=>{if(!t)return null;try{return await O9(t)}catch(e){return console.warn("Failed to get cached image by URL:",e),null}},F9={class:"flex p-1 bg-white/5 rounded-xl"},U9=["onClick"],B9=We({__name:"TabSelector",props:{activeTab:{},tabs:{}},emits:["tab-change"],setup(t){return(e,n)=>(F(),V("div",F9,[(F(!0),V(Xe,null,rt(t.tabs,s=>(F(),V("button",{key:s,onClick:r=>e.$emit("tab-change",s),class:Q(["glass-btn flex-1 py-1.5 text-xs font-medium rounded-lg transition-all duration-300",t.activeTab===s?"bg-white/10 text-white shadow-sm":"text-white/40 hover:text-white/60"])},Le(s),11,U9))),128))]))}}),z9={class:"flex flex-col gap-4"},G9={class:"flex items-center justify-between"},V9={class:"flex gap-2"},W9=["disabled"],H9={class:"flex flex-col items-center"},K9={key:0,class:"text-xs text-white/40 mt-1"},j9=We({__name:"UploadTabContent",props:{isMobile:{type:Boolean},isProcessing:{type:Boolean},originalImage:{}},emits:["load-sample","image-upload"],setup(t){const e=t,n=ye(()=>e.isMobile?"text-xs font-bold text-gray-400 uppercase tracking-wider":"text-sm font-medium text-gray-400 uppercase tracking-wider"),s=ye(()=>e.isMobile?"glass-btn px-3 py-1.5 rounded-full bg-white/5 hover:bg-white/10 border border-white/5 text-xs font-medium text-white/60 hover:text-white/90 transition-colors disabled:opacity-50":"glass-btn px-4 py-1.5 rounded-full bg-white/5 hover:bg-white/10 border border-white/5 text-xs font-medium text-white/60 hover:text-white/90 transition-all disabled:opacity-50"),r=ye(()=>e.isMobile?"glass-btn relative overflow-hidden rounded-2xl border border-white/10 bg-white/5 h-28 flex items-center justify-center":"glass-btn relative overflow-hidden rounded-2xl border border-white/10 bg-white/5 hover:bg-white/10 transition-all cursor-pointer group h-32 flex items-center justify-center"),i=ye(()=>e.isMobile?"text-xs font-medium text-white/90":"text-sm font-medium text-white/90"),o=ye(()=>e.isMobile?"absolute inset-0 opacity-30 blur-lg bg-cover bg-center":"absolute inset-0 opacity-20 blur-xl bg-cover bg-center");return(a,l)=>(F(),V("div",z9,[k("div",G9,[k("span",{class:Q(n.value)},"Source",2),k("div",V9,[k("button",{onClick:l[0]||(l[0]=u=>a.$emit("load-sample")),disabled:t.isProcessing,class:Q(s.value)}," Sample ",10,W9),k("label",{class:Q(s.value+" cursor-pointer flex items-center")},[k("div",{class:Q(["i-carbon-camera",t.isMobile?"":"mr-2"])},null,2),k("span",{class:Q(t.isMobile?"ml-1.5":"")},"Camera",2),k("input",{type:"file",accept:"image/*",capture:"environment",onChange:l[1]||(l[1]=u=>a.$emit("image-upload",u)),class:"hidden"},null,32)],2)])]),k("label",{class:Q(r.value)},[k("div",{class:Q(["absolute inset-0 flex flex-col items-center justify-center z-10",t.isMobile?"gap-2":"gap-3"])},[k("div",{class:Q(["i-carbon-image text-white/50 group-hover:text-white group-hover:scale-110 transition-all duration-300",t.isMobile?"text-3xl":"text-1xl"])},null,2),k("div",H9,[k("span",{class:Q(i.value)},Le(t.originalImage?"Change Image":"Select Image"),3),t.isMobile?Ue("",!0):(F(),V("span",K9,"Click to upload"))])],2),t.originalImage?(F(),V("div",{key:0,class:Q(o.value),style:bn({backgroundImage:`url(${t.originalImage})`})},null,6)):Ue("",!0),k("input",{type:"file",accept:"image/*",onChange:l[2]||(l[2]=u=>a.$emit("image-upload",u)),class:"hidden"},null,32)],2)]))}}),X9={class:"flex flex-col gap-4"},q9=We({__name:"ProceduralPanelRenderer",props:{proceduralType:{},isGenerating:{type:Boolean}},emits:["set-image"],setup(t,{emit:e}){const n=t,s=e,r=()=>({props:{isGenerating:n.isGenerating},emits:{"set-image":(...a)=>{Sz(a)&&s("set-image",a[0])}}}),i=ye(()=>Dz(r())),o=ye(()=>w6(r()));return(a,l)=>(F(),V("div",X9,[t.proceduralType==="Wood"?(F(),st(D(ez),{key:0,"is-generating":t.isGenerating,onSetImage:l[0]||(l[0]=u=>a.$emit("set-image",u))},null,8,["is-generating"])):Ue("",!0),t.proceduralType==="Plain Weave"?(F(),st(Lm(i.value),{key:1})):Ue("",!0),t.proceduralType==="Plain Weave Advanced"?(F(),st(Lm(o.value),{key:2})):Ue("",!0),t.proceduralType==="Leather"?(F(),st(D(Z6),{key:3,"is-generating":t.isGenerating,onSetImage:l[1]||(l[1]=u=>a.$emit("set-image",u))},null,8,["is-generating"])):Ue("",!0),t.proceduralType==="Twill Weave"?(F(),st(D(TG),{key:4,"is-generating":t.isGenerating,onSetImage:l[2]||(l[2]=u=>a.$emit("set-image",u))},null,8,["is-generating"])):Ue("",!0),t.proceduralType==="Velvet"?(F(),st(D(ZG),{key:5,"is-generating":t.isGenerating,onSetImage:l[3]||(l[3]=u=>a.$emit("set-image",u))},null,8,["is-generating"])):Ue("",!0),t.proceduralType==="Turing"?(F(),st(D(m8),{key:6,"is-generating":t.isGenerating,onSetImage:l[4]||(l[4]=u=>a.$emit("set-image",u))},null,8,["is-generating"])):Ue("",!0),t.proceduralType==="Gray-Scott"?(F(),st(D(A8),{key:7,"is-generating":t.isGenerating,onSetImage:l[5]||(l[5]=u=>a.$emit("set-image",u))},null,8,["is-generating"])):Ue("",!0),t.proceduralType==="Compositor"?(F(),st(D($V),{key:8,"is-generating":t.isGenerating,onSetImage:l[6]||(l[6]=u=>a.$emit("set-image",u))},null,8,["is-generating"])):Ue("",!0),t.proceduralType==="Advanced Compositor"?(F(),st(D(XW),{key:9,onSetImage:l[7]||(l[7]=u=>a.$emit("set-image",u))})):Ue("",!0)]))}}),Y9={class:"flex flex-col gap-4"},Z9={class:"flex items-center justify-between"},Q9=We({__name:"ProceduralTabContent",props:{isMobile:{type:Boolean},proceduralType:{},textureTypes:{},isGenerating:{type:Boolean}},emits:["type-change","set-image"],setup(t){const e=t,n=ye(()=>e.isMobile?"text-xs font-bold text-gray-400 uppercase tracking-wider":"text-sm font-medium text-gray-400 uppercase tracking-wider");return(s,r)=>(F(),V("div",Y9,[k("div",Z9,[k("span",{class:Q(n.value)},"Procedural Texture",2)]),we(D(RU),{"active-type":t.proceduralType,"texture-types":t.textureTypes,onTypeChange:r[0]||(r[0]=i=>s.$emit("type-change",i))},null,8,["active-type","texture-types"]),we(q9,{"procedural-type":t.proceduralType,"is-generating":t.isGenerating,onSetImage:r[1]||(r[1]=i=>s.$emit("set-image",i))},null,8,["procedural-type","is-generating"])]))}}),J9=We({__name:"MaxResolutionSlider",props:{isMobile:{type:Boolean},originalImage:{},inputSliderItems:{}},emits:["slider-update"],setup(t){const e=t,n=ye(()=>(e.isMobile,"bg-white/5 rounded-2xl border border-white/5"));return(s,r)=>t.originalImage?(F(),V("div",{key:0,class:Q(n.value)},[we(D(St),{items:t.inputSliderItems,onUpdateValue:r[0]||(r[0]=i=>s.$emit("slider-update",i))},null,8,["items"])],2)):Ue("",!0)}}),Dh={FILE:"file",TEMP:"temp"},av="ms-",Ou="",e7="",nl={KEY_READY:"key-ready",KEY_CLEARED:"key-cleared",UPDATE_MODEL_VALUE:"update:modelValue"},co={FILE_SELECTION_FAILED:"",INVALID_REF:"Invalid ref type",FILE_SYSTEM_API_NOT_SUPPORTED:"File System Access API ",FILE_HANDLE_ACQUISITION_FAILED:"",USER_CANCELLED_FILE_SELECTION:"",PERMISSION_VERIFICATION_FAILED:"",NO_KEY_FILE_SELECTED:"",FILE_READ_PERMISSION_DENIED:"",EMPTY_KEY_FILE:"",GET_FILE_NAME_FAILED:""},Up={FILE_HANDLE_ACQUIRED:"  ()",KEY_EXECUTION_STARTED:" ...",KEY_MEMORY_CLEARED:" ",KEY_HANDLE_CLEARED:" "},YS={types:[{description:"API Key File",accept:{"text/plain":[".txt",".key",".pem"]}}],multiple:!1},ZS={READ:"read",READWRITE:"readwrite"},QS={GRANTED:"granted"},t7={ABORT_ERROR:"AbortError"},n7="*",JS=".",sl={OBJECT:"object",BOOLEAN:"boolean",STRING:"string"};function s7(t){return t instanceof HTMLInputElement}function r7(t){if(!t||typeof t!==sl.OBJECT)return!1;const e=t;return!(e.multiple!==void 0&&typeof e.multiple!==sl.BOOLEAN||e.types!==void 0&&(!Array.isArray(e.types)||!i7(e.types)))}function i7(t){for(const e of t){if(!e||typeof e!==sl.OBJECT)return!1;const n=e;if(n.description!==void 0&&typeof n.description!==sl.STRING||!n.accept||typeof n.accept!==sl.OBJECT||!o7(n.accept))return!1}return!0}function o7(t){const e=t;for(const n in e){const s=e[n];if(Array.isArray(s)){for(const r of s)if(typeof r!==sl.STRING||!r.startsWith(JS))return!1;continue}if(typeof s!==sl.STRING||!s.startsWith(JS))return!1}return!0}function a7(){return r7(YS)?YS:{types:[{description:"API Key File",accept:{"text/plain":[".txt",".key",".pem"]}}],multiple:!1}}function l7(){return!!(window.showOpenFilePicker&&window.FileSystemFileHandle&&window.FileSystemDirectoryHandle)}async function u7(t,e=!1){const n={mode:e?ZS.READWRITE:ZS.READ};try{if(await t.queryPermission(n)===QS.GRANTED||await t.requestPermission(n)===QS.GRANTED)return!0}catch(s){console.error(co.PERMISSION_VERIFICATION_FAILED,s)}return!1}class c7{constructor(){Wt(this,"_fileHandle",ce(null));Wt(this,"_isSupported");this._isSupported=l7()}get isSupported(){return this._isSupported}async selectKeyFile(){if(!this._isSupported)return console.error(co.FILE_SYSTEM_API_NOT_SUPPORTED),!1;try{const e=a7(),[n]=await window.showOpenFilePicker(e);return this._fileHandle.value=n,console.warn(Up.FILE_HANDLE_ACQUIRED),!0}catch(e){return e instanceof Error&&e.name===t7.ABORT_ERROR?(console.warn(co.USER_CANCELLED_FILE_SELECTION),!1):(console.error(co.FILE_HANDLE_ACQUISITION_FAILED,e),!1)}}async executeWithKey(e){if(!this._fileHandle.value)throw new Error(co.NO_KEY_FILE_SELECTED);if(!await u7(this._fileHandle.value))throw new Error(co.FILE_READ_PERMISSION_DENIED);let s=null;try{if(s=await(await this._fileHandle.value.getFile()).text(),s=s.trim(),!s)throw new Error(co.EMPTY_KEY_FILE);return console.warn(Up.KEY_EXECUTION_STARTED),await e(s)}catch(r){throw r}finally{if(s!==null){const r=s.length;s=n7.repeat(r),s=null}console.warn(Up.KEY_MEMORY_CLEARED)}}hasKeyFile(){return this._fileHandle.value!==null}async getFileName(){if(!this._fileHandle.value)return Ou;try{return this._fileHandle.value.name}catch(e){return console.error(co.GET_FILE_NAME_FAILED,e),Ou}}clearSession(){this._fileHandle.value=null,console.warn(Up.KEY_HANDLE_CLEARED)}}const Bi=new c7;function h7(t){return!!(t&&t.startsWith(av)||Bi.hasKeyFile())}function d7(){const t=ce(Dh.FILE),e=ce(Ou),n=ce(Ou),s=ye(()=>Bi.hasKeyFile()),r=ye(()=>n.value.trim().startsWith(av)),i=ye(()=>s.value||r.value);return{inputMode:t,fileName:e,tempApiKey:n,hasKeyFile:s,hasTempKey:r,hasAnyKey:i}}function f7(t,e){return{selectKeyFile:async()=>{try{await Bi.selectKeyFile()&&(t.value=await Bi.getFileName(),e(nl.KEY_READY,!0))}catch(r){console.error(co.FILE_SELECTION_FAILED,r)}},clearKeyFile:()=>{Bi.clearSession(),t.value=Ou,e(nl.KEY_CLEARED)}}}function p7(t){const{inputMode:e,tempApiKey:n,hasKeyFile:s,hasTempKey:r,emit:i}=t;return{setInputMode:l=>{l===Dh.FILE&&(n.value=Ou),e.value=l,l===Dh.TEMP&&i(nl.KEY_READY,r.value),l===Dh.FILE&&i(nl.KEY_READY,s.value)},handleTempKeyChange:()=>{e.value===Dh.TEMP&&i(nl.KEY_READY,r.value)}}}function m7(t,e){kr(async()=>{Bi.hasKeyFile()&&(t.value=await Bi.getFileName(),e(nl.KEY_READY,!0))})}function g7(t,e){return n=>{t.value=n,e()}}function x7(t,e,n){_t(t,s=>{n(nl.UPDATE_MODEL_VALUE,s)}),_t(()=>e.modelValue,s=>{s!==void 0&&s!==t.value&&(t.value=s)},{immediate:!0})}function b7(t,e){const n=d7(),s=f7(n.fileName,e),r=p7({inputMode:n.inputMode,tempApiKey:n.tempApiKey,hasKeyFile:n.hasKeyFile,hasTempKey:n.hasTempKey,emit:e});x7(n.tempApiKey,t,e),m7(n.fileName,e);const i=g7(n.tempApiKey,r.handleTempKeyChange);return{state:n,actions:{...s,...r,handleTempApiKeyUpdate:i}}}const y7={key:0,class:"flex flex-col gap-2"},v7={key:0,class:"flex flex-col gap-2"},w7={key:1,class:"flex flex-col gap-2"},S7={class:"glass-input px-3 py-2 text-sm rounded-lg bg-green-600/20 border border-green-500/30"},C7={class:"flex gap-2"},T7=We({__name:"FileModeSection",props:{inputMode:{},hasKeyFile:{type:Boolean},fileName:{},isMobile:{type:Boolean}},emits:["selectKeyFile","clearKeyFile"],setup(t){return(e,n)=>t.inputMode==="file"?(F(),V("div",y7,[t.hasKeyFile?(F(),V("div",w7,[k("div",S7,"  : "+Le(t.fileName||""),1),k("div",C7,[k("button",{onClick:n[1]||(n[1]=s=>e.$emit("selectKeyFile")),class:Q(["glass-input px-3 py-2 text-sm rounded-lg bg-blue-600/20 hover:bg-blue-600/30 text-blue-300 border border-blue-500/30 transition-colors",t.isMobile?"h-10":"h-9"])},"   ",2),k("button",{onClick:n[2]||(n[2]=s=>e.$emit("clearKeyFile")),class:Q(["glass-input px-3 py-2 text-sm rounded-lg bg-red-600/20 hover:bg-red-600/30 text-red-300 border border-red-500/30 transition-colors",t.isMobile?"h-10":"h-9"])},"   ",2)]),n[4]||(n[4]=k("p",{class:"text-xs text-green-400"},"   ",-1))])):(F(),V("div",v7,[k("button",{onClick:n[0]||(n[0]=s=>e.$emit("selectKeyFile")),class:Q(["glass-input px-3 py-2 text-sm rounded-lg bg-blue-600/20 hover:bg-blue-600/30 text-blue-300 border border-blue-500/30 transition-colors",t.isMobile?"h-10":"h-9"])},"   ",2),n[3]||(n[3]=k("p",{class:"text-xs text-white/40"},[Tn("  API Key  "),k("a",{href:"https://modelscope.cn/settings/token",target:"_blank",class:"text-blue-400 hover:text-blue-300 underline"}," API Key")],-1))]))])):Ue("",!0)}}),I7={key:0,class:"flex flex-col gap-2"},k7=["value"],E7=We({__name:"TempModeSection",props:{inputMode:{},tempApiKey:{},isMobile:{type:Boolean}},emits:["update:tempApiKey"],setup(t,{emit:e}){const n=e,s=r=>{s7(r.target)&&n("update:tempApiKey",r.target.value)};return(r,i)=>t.inputMode==="temp"?(F(),V("div",I7,[k("input",{value:t.tempApiKey,onInput:s,type:"password",placeholder:" API Key ( 'ms-' )",class:Q(["glass-input px-3 py-2 text-sm rounded-lg",t.isMobile?"h-10":"h-9"])},null,42,k7),i[0]||(i[0]=k("p",{class:"text-xs text-white/40"},[Tn("  API Key  "),k("a",{href:"https://modelscope.cn/settings/token",target:"_blank",class:"text-blue-400 hover:text-blue-300 underline"}," API Key")],-1))])):Ue("",!0)}}),_7=We({__name:"FileModeContent",props:{inputMode:{},hasKeyFile:{type:Boolean},fileName:{},tempApiKey:{},isMobile:{type:Boolean}},emits:["selectKeyFile","clearKeyFile","update:tempApiKey"],setup(t){return(e,n)=>(F(),V(Xe,null,[we(T7,{"input-mode":t.inputMode,"has-key-file":t.hasKeyFile,"file-name":t.fileName,"is-mobile":t.isMobile,onSelectKeyFile:n[0]||(n[0]=s=>e.$emit("selectKeyFile")),onClearKeyFile:n[1]||(n[1]=s=>e.$emit("clearKeyFile"))},null,8,["input-mode","has-key-file","file-name","is-mobile"]),we(E7,{"input-mode":t.inputMode,"temp-api-key":t.tempApiKey,"is-mobile":t.isMobile,"onUpdate:tempApiKey":n[2]||(n[2]=s=>e.$emit("update:tempApiKey",s))},null,8,["input-mode","temp-api-key","is-mobile"])],64))}}),$7={class:"flex flex-col gap-2"},R7={key:0,class:"glass-input px-3 py-2 text-sm rounded-lg text-red-400"},A7={key:1,class:"flex flex-col gap-2"},P7={class:"flex gap-2"},D7=We({__name:"SecureApiKeyInput",props:{modelValue:{},isMobile:{type:Boolean}},emits:["update:modelValue","key-ready","key-cleared"],setup(t,{emit:e}){const n=t,s=e,{state:r,actions:i}=b7(n,s),{inputMode:o,fileName:a,tempApiKey:l,hasKeyFile:u}=r,{selectKeyFile:c,clearKeyFile:h,setInputMode:d,handleTempApiKeyUpdate:f}=i;return(p,g)=>(F(),V("div",$7,[g[2]||(g[2]=k("label",{class:"text-xs font-medium text-white/70"},"ModelScope API Key",-1)),D(Bi).isSupported?(F(),V("div",A7,[k("div",P7,[k("button",{onClick:g[0]||(g[0]=m=>D(d)("file")),class:Q(["px-3 py-1 text-xs rounded transition-colors",D(o)==="file"?"bg-blue-600/30 text-blue-300 border border-blue-500/30":"bg-white/10 text-white/60 border border-white/20 hover:bg-white/20"])},"   ",2),k("button",{onClick:g[1]||(g[1]=m=>D(d)("temp")),class:Q(["px-3 py-1 text-xs rounded transition-colors",D(o)==="temp"?"bg-blue-600/30 text-blue-300 border border-blue-500/30":"bg-white/10 text-white/60 border border-white/20 hover:bg-white/20"])},"   ",2)]),we(_7,{"input-mode":D(o),"has-key-file":D(u),"file-name":D(a),"temp-api-key":D(l),"is-mobile":t.isMobile,onSelectKeyFile:D(c),onClearKeyFile:D(h),"onUpdate:tempApiKey":D(f)},null,8,["input-mode","has-key-file","file-name","temp-api-key","is-mobile","onSelectKeyFile","onClearKeyFile","onUpdate:tempApiKey"])])):(F(),V("div",R7,"   File System Access API Chrome 86+  Edge 86+ "))]))}}),N7={class:"flex flex-col gap-2"},M7=["value"],L7=We({__name:"PromptInput",props:{modelValue:{}},emits:["update:modelValue"],setup(t){return(e,n)=>(F(),V("div",N7,[n[1]||(n[1]=k("label",{class:"text-xs font-medium text-white/70"}," (Prompt)",-1)),k("textarea",{value:t.modelValue,placeholder:"Cyberpunk city, neon lights, 8k resolution",rows:"3",class:"glass-input px-3 py-2 text-sm rounded-lg resize-none",onInput:n[0]||(n[0]=s=>e.$emit("update:modelValue",s.target.value))},null,40,M7)]))}}),O7={class:"grid grid-cols-2 gap-3"},F7={class:"flex flex-col gap-1"},U7=["value"],B7={class:"flex flex-col gap-1"},z7=["value"],G7={key:0,class:"col-span-2 flex flex-col gap-2 p-2 bg-yellow-500/10 border border-yellow-500/20 rounded-lg"},V7={class:"flex flex-col gap-1"},W7=["value"],H7=We({__name:"ParameterGrid",props:{size:{},n:{},batchInterval:{}},emits:["update:size","update:n","update:batchInterval"],setup(t){return(e,n)=>(F(),V("div",O7,[k("div",F7,[n[4]||(n[4]=k("label",{class:"text-xs font-medium text-white/70"},"",-1)),k("select",{value:t.size,class:"glass-input px-2 py-1.5 text-sm rounded-lg",onChange:n[0]||(n[0]=s=>e.$emit("update:size",s.target.value))},[...n[3]||(n[3]=[k("option",{value:"1024x1024"},"10241024 (1:1)",-1),k("option",{value:"1280x720"},"1280720 (16:9)",-1),k("option",{value:"720x1280"},"7201280 (9:16)",-1)])],40,U7)]),k("div",B7,[n[5]||(n[5]=k("label",{class:"text-xs font-medium text-white/70"},"",-1)),k("input",{value:t.n,type:"number",min:"1",step:"1",class:"glass-input px-2 py-1.5 text-sm rounded-lg",onInput:n[1]||(n[1]=s=>e.$emit("update:n",Number(s.target.value)))},null,40,z7)]),t.n>4?(F(),V("div",G7,[n[8]||(n[8]=k("div",{class:"flex items-center gap-2 text-yellow-500/90"},[k("span",{class:"text-xs"}," ")],-1)),k("div",V7,[n[6]||(n[6]=k("label",{class:"text-xs font-medium text-white/70"}," ()",-1)),k("input",{value:t.batchInterval,type:"number",min:"0",step:"100",placeholder:": 1000",class:"glass-input px-2 py-1.5 text-sm rounded-lg",onInput:n[2]||(n[2]=s=>e.$emit("update:batchInterval",Number(s.target.value)))},null,40,W7),n[7]||(n[7]=k("p",{class:"text-[10px] text-white/40"}," 1000ms ",-1))])])):Ue("",!0)]))}}),K7={key:0,class:"p-3 bg-red-900/30 border border-red-700/50 rounded-lg"},j7={class:"text-xs text-red-300"},X7={key:1,class:"p-3 bg-blue-900/30 border border-blue-700/50 rounded-lg"},q7={class:"text-xs text-blue-300"},Y7=We({__name:"StatusDisplay",props:{error:{},status:{}},setup(t){return(e,n)=>(F(),V(Xe,null,[t.error?(F(),V("div",K7,[k("p",j7,Le(t.error),1)])):Ue("",!0),t.status?(F(),V("div",X7,[k("p",q7,Le(t.status),1)])):Ue("",!0)],64))}});function Z7(){const t=ce(""),e=ce(""),n=ce(En.SIZE),s=ce(En.N),r=ce(En.NUM_INFERENCE_STEPS),i=ce(En.MODEL),o=ce(En.PROXY_URL),a=ce(0),l=ce(En.PROXY_TYPE),u=ce(En.SIYUAN_URL),c=ce(En.SIYUAN_TOKEN),h=ce(En.SHOW_ADVANCED),d=ce(!1),f=ce(""),p=ce(""),g=ce([]),m=ce(!1);let x=null;const b=ye(()=>h7(t.value));function v(){return new Promise(C=>{x=C,m.value=!0})}function y(C){m.value=!1,x&&(x(C),x=null)}return{apiKey:t,prompt:e,size:n,n:s,numInferenceSteps:r,model:i,proxyUrl:o,batchInterval:a,proxyType:l,siyuanUrl:u,siyuanToken:c,showAdvanced:h,isGenerating:d,error:f,status:p,generatedImages:g,apiKeyValid:b,showProxyWarning:m,showProxyWarningAndWait:v,handleProxyWarningResponse:y}}function Q7(t){var o,a;const{result:e,taskId:n,imageUrls:s,errors:r}=t;if(e.task_status!==_9.SUCCEED){r.push(qS.TASK_FAILED(n,((o=e.error)==null?void 0:o.message)||ko.UNKNOWN_ERROR));return}const i=(a=e.output_images)==null?void 0:a[0];i&&s.push(i)||r.push(qS.TASK_SUCCEEDED_NO_IMAGE(n))}async function J7(t){const e=t.proxyType==="siyuan"?{url:t.siyuanUrl||"",token:t.siyuanToken||""}:void 0;return await I9({apiKey:t.apiKey,prompt:t.prompt,params:{size:t.size,n:t.n,steps:t.numInferenceSteps,model:t.model},proxyUrl:t.proxyUrl,batchInterval:t.batchInterval,proxyType:t.proxyType,siyuanConfig:e})}async function eH(t,e){const n=e.map(s=>E9({apiKey:t.apiKey,taskId:s,interval:2e3,maxAttempts:60,proxyUrl:t.proxyUrl,proxyType:t.proxyType,siyuanConfig:t.proxyType==="siyuan"?{url:t.siyuanUrl||"",token:t.siyuanToken||""}:void 0}));return await Promise.all(n)}function tH(t,e){const n=[],s=[];for(const[r,i]of t.entries())Q7({result:i,taskId:e[r],imageUrls:n,errors:s});return{imageUrls:n,errors:s}}async function wE(t){try{const e=await J7(t),n=await eH(t,e),{imageUrls:s,errors:r}=tH(n,e);return s.length===0?{success:!1,error:r.join("; ")||ko.ALL_TASKS_FAILED}:{success:!0,imageUrls:s}}catch(e){return{success:!1,error:e instanceof Error?e.message:ko.GENERATION_FAILED}}}function nH(t,e,n){return ye(()=>t.value.map(s=>n.value==="siyuan"?s:e.value?Ju(s,e.value):s))}const ao={TITLE:" ",DESCRIPTION:" CORS ModelScope API ",REQUIREMENTS_TITLE:"",REQUIREMENTS:[" ?target=encodedUrl ","CORS"," Vite dev server"],SOLUTIONS_TITLE:"",SOLUTIONS:[" npm run dev "," URL",""],BUTTONS:{CONTINUE:"",CANCEL:""},CONTINUE_WARNING:" CORS "},$1={TIMEOUT:5e3,TEST_TARGET:"https://httpstat.us/200",STATUS:{CHECKING:"..."},ERRORS:{UNAVAILABLE:"",TIMEOUT:""}};async function sH(t){try{const e=`${t}?target=${encodeURIComponent($1.TEST_TARGET)}`,n=new AbortController,s=setTimeout(()=>n.abort(),$1.TIMEOUT),r=await fetch(e,{method:"HEAD",signal:n.signal});return clearTimeout(s),r.ok}catch{return!1}}function rH(t){return Bi.hasKeyFile()&&!t.startsWith(av)}async function iH(t,e){const n={apiKey:e7,prompt:t.prompt.value,size:t.size.value,n:t.n.value,numInferenceSteps:t.numInferenceSteps.value,model:t.model.value,proxyUrl:t.proxyUrl.value||void 0,batchInterval:t.batchInterval.value,proxyType:t.proxyType.value,siyuanUrl:t.siyuanUrl.value,siyuanToken:t.siyuanToken.value};t.status.value=Xo.GENERATING;const s=await Bi.executeWithKey(async h=>{const d={...n,apiKey:h};return await wE(d)});if(!s.success)throw new Error(s.error||ko.GENERATION_FAILED);t.status.value=Xo.DOWNLOADING,t.status.value=Xo.DOWNLOADING;const r=s.imageUrls||[],i=n.proxyUrl,o=n.proxyType==="siyuan",a=o?{url:n.siyuanUrl||"",token:n.siyuanToken||""}:void 0,l=r.map(async h=>{const d=o?h:i?Ju(h,i):h;try{const f=await mE({imageUrl:h,proxyUrl:o?void 0:i,siyuanConfig:a});return await yE(f,d),{url:h,base64:f}}catch(f){return console.warn(`Failed to download and cache image: ${h}`,f),null}}),c=(await Promise.all(l)).filter(h=>h!==null);if(c.length>0){const h=c[0];e&&e(h.base64)}else if(r.length>0)throw new Error(ko.NO_IMAGE_URL);s.imageUrls&&s.imageUrls.length>0&&(t.generatedImages.value=s.imageUrls),t.status.value=Xo.LOADED}async function oH(t,e){const n={apiKey:t.apiKey.value,prompt:t.prompt.value,size:t.size.value,n:t.n.value,numInferenceSteps:t.numInferenceSteps.value,model:t.model.value,proxyUrl:t.proxyUrl.value||void 0,batchInterval:t.batchInterval.value,proxyType:t.proxyType.value,siyuanUrl:t.siyuanUrl.value,siyuanToken:t.siyuanToken.value};t.status.value=Xo.GENERATING;const s=await wE(n);if(!s.success)throw new Error(s.error||ko.GENERATION_FAILED);t.status.value=Xo.DOWNLOADING;const r=s.imageUrls||[],i=n.proxyUrl,o=n.proxyType==="siyuan",a=o?{url:n.siyuanUrl||"",token:n.siyuanToken||""}:void 0,l=r.map(async h=>{const d=o?h:i?Ju(h,i):h;try{const f=await mE({imageUrl:h,proxyUrl:o?void 0:i,siyuanConfig:a});return await yE(f,d),{url:h,base64:f}}catch(f){return console.warn(`Failed to download and cache image: ${h}`,f),null}}),c=(await Promise.all(l)).filter(h=>h!==null);if(c.length>0){const h=c[0];e&&e(h.base64)}else if(r.length>0)throw new Error(ko.NO_IMAGE_URL);s.imageUrls&&s.imageUrls.length>0&&(t.generatedImages.value=s.imageUrls),t.status.value=Xo.LOADED}function aH(t,e){return async()=>{if(!t.apiKeyValid.value||!t.prompt.value.trim()){t.error.value=t.apiKeyValid.value?XS.EMPTY_PROMPT:XS.INVALID_API_KEY;return}if(t.n.value>4&&(!t.batchInterval.value||t.batchInterval.value<=0)){t.error.value="4 ( > 1000ms)";return}const n=t.proxyType.value==="siyuan",s=t.proxyUrl.value||En.PROXY_URL,r=s===En.PROXY_URL;if(!n&&r&&(t.status.value=$1.STATUS.CHECKING,!await sH(s)&&!await t.showProxyWarningAndWait())){t.status.value=En.EMPTY_STRING;return}t.isGenerating.value=!0,t.error.value=En.EMPTY_STRING,t.status.value=Xo.SUBMITTING;try{await(rH(t.apiKey.value)?iH(t,e):oH(t,e))}catch(o){const a=o instanceof Error?o.message:ko.GENERATION_FAILED;t.error.value=a,console.error(ko.TEXT_TO_IMAGE_ERROR,o)}finally{t.isGenerating.value=!1}}}function lH(t){return()=>{t.apiKey.value=En.EMPTY_STRING,t.prompt.value=En.EMPTY_STRING,t.size.value=En.SIZE,t.n.value=En.N,t.numInferenceSteps.value=En.NUM_INFERENCE_STEPS,t.model.value=En.MODEL,t.proxyUrl.value=En.PROXY_URL,t.batchInterval.value=0,t.proxyType.value="default",t.siyuanUrl.value="http://127.0.0.1:6806",t.siyuanToken.value="",t.showAdvanced.value=En.SHOW_ADVANCED,t.error.value=En.EMPTY_STRING,t.status.value=En.EMPTY_STRING}}function uH(t){const e=Z7(),n=aH(e,t),s=lH(e);return{apiKey:e.apiKey,prompt:e.prompt,size:e.size,n:e.n,numInferenceSteps:e.numInferenceSteps,model:e.model,proxyUrl:e.proxyUrl,batchInterval:e.batchInterval,proxyType:e.proxyType,siyuanUrl:e.siyuanUrl,siyuanToken:e.siyuanToken,showAdvanced:e.showAdvanced,isGenerating:e.isGenerating,error:e.error,status:e.status,generatedImages:e.generatedImages,apiKeyValid:e.apiKeyValid,showProxyWarning:e.showProxyWarning,handleProxyWarningResponse:e.handleProxyWarningResponse,generate:n,reset:s}}const cH={class:"flex flex-col gap-3 p-3 bg-white/5 rounded-lg"},hH={class:"flex flex-col gap-1"},dH=["value"],fH={class:"text-center text-xs text-white/70"},pH={class:"flex flex-col gap-1"},mH=["value"],gH={class:"flex flex-col gap-2 border-t border-white/10 pt-2"},xH={class:"flex gap-2"},bH={class:"flex items-center gap-1 text-xs text-white/80 cursor-pointer"},yH=["checked"],vH={class:"flex items-center gap-1 text-xs text-white/80 cursor-pointer"},wH=["checked"],SH={class:"flex items-center gap-1 text-xs text-white/80 cursor-pointer"},CH=["checked"],TH={key:0,class:"flex flex-col gap-1"},IH=["value"],kH={key:1,class:"flex flex-col gap-2"},EH={class:"flex flex-col gap-1"},_H=["value"],$H={class:"flex flex-col gap-1"},RH=["value"],AH=We({__name:"AdvancedParametersContent",props:{numInferenceSteps:{},model:{},proxyUrl:{},proxyType:{},siyuanUrl:{},siyuanToken:{}},emits:["update:numInferenceSteps","update:model","update:proxyUrl","update:proxyType","update:siyuanUrl","update:siyuanToken"],setup(t){return(e,n)=>(F(),V("div",cH,[k("div",hH,[n[8]||(n[8]=k("label",{class:"text-xs font-medium text-white/70"}," (num_inference_steps)",-1)),k("input",{value:t.numInferenceSteps,type:"range",min:"4",max:"20",step:"1",class:"w-full",onInput:n[0]||(n[0]=s=>e.$emit("update:numInferenceSteps",Number(s.target.value)))},null,40,dH),n[9]||(n[9]=k("div",{class:"flex justify-between text-xs text-white/50"},[k("span",null," (4)"),k("span",null," (9)"),k("span",null," (20)")],-1)),k("div",fH,Le(t.numInferenceSteps)+" ",1)]),k("div",pH,[n[11]||(n[11]=k("label",{class:"text-xs font-medium text-white/70"},"",-1)),k("select",{value:t.model,class:"glass-input px-2 py-1.5 text-sm rounded-lg",onChange:n[1]||(n[1]=s=>e.$emit("update:model",s.target.value))},[...n[10]||(n[10]=[k("option",{value:"Tongyi-MAI/Z-Image-Turbo"},"Z-Image-Turbo ()",-1),k("option",{value:"Tongyi-MAI/Z-Image"},"Z-Image",-1),k("option",{value:"Qwen/Qwen-Image"},"Qwen-Image",-1)])],40,mH)]),k("div",gH,[n[15]||(n[15]=k("label",{class:"text-xs font-medium text-white/70"},"",-1)),k("div",xH,[k("label",bH,[k("input",{type:"radio",checked:t.proxyType==="default",onChange:n[2]||(n[2]=s=>e.$emit("update:proxyType","default"))},null,40,yH),n[12]||(n[12]=Tn("  ",-1))]),k("label",vH,[k("input",{type:"radio",checked:t.proxyType==="custom",onChange:n[3]||(n[3]=s=>e.$emit("update:proxyType","custom"))},null,40,wH),n[13]||(n[13]=Tn("  ",-1))]),k("label",SH,[k("input",{type:"radio",checked:t.proxyType==="siyuan",onChange:n[4]||(n[4]=s=>e.$emit("update:proxyType","siyuan"))},null,40,CH),n[14]||(n[14]=Tn("  ",-1))])])]),t.proxyType==="custom"?(F(),V("div",TH,[n[16]||(n[16]=k("label",{class:"text-xs font-medium text-white/70"}," URL",-1)),k("input",{value:t.proxyUrl,type:"text",placeholder:"/api/common-proxy",class:"glass-input px-2 py-1.5 text-sm rounded-lg",onInput:n[5]||(n[5]=s=>e.$emit("update:proxyUrl",s.target.value))},null,40,IH),n[17]||(n[17]=k("p",{class:"text-xs text-white/40"}," ?target=url ",-1))])):Ue("",!0),t.proxyType==="siyuan"?(F(),V("div",kH,[k("div",EH,[n[18]||(n[18]=k("label",{class:"text-xs font-medium text-white/70"},"SiYuan ",-1)),k("input",{value:t.siyuanUrl,type:"text",placeholder:"http://127.0.0.1:6806",class:"glass-input px-2 py-1.5 text-sm rounded-lg",onInput:n[6]||(n[6]=s=>e.$emit("update:siyuanUrl",s.target.value))},null,40,_H)]),k("div",$H,[n[19]||(n[19]=k("label",{class:"text-xs font-medium text-white/70"},"API Token",-1)),k("input",{value:t.siyuanToken,type:"password",placeholder:"SiYuan API Token",class:"glass-input px-2 py-1.5 text-sm rounded-lg",onInput:n[7]||(n[7]=s=>e.$emit("update:siyuanToken",s.target.value))},null,40,RH)])])):Ue("",!0)]))}}),PH={class:"flex flex-col gap-2"},DH=We({__name:"AdvancedParameters",props:{showAdvanced:{type:Boolean},numInferenceSteps:{},model:{},proxyUrl:{},proxyType:{},siyuanUrl:{},siyuanToken:{}},emits:["toggle","update:numInferenceSteps","update:model","update:proxyUrl","update:proxyType","update:siyuanUrl","update:siyuanToken"],setup(t){return(e,n)=>(F(),V("div",PH,[k("button",{onClick:n[0]||(n[0]=s=>e.$emit("toggle")),class:"glass-btn flex items-center justify-between px-3 py-2 text-xs font-medium rounded-lg text-white/80 hover:text-white transition-all"},[n[7]||(n[7]=k("span",null,"",-1)),k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform duration-200",t.showAdvanced?"rotate-180":""])},null,2)]),t.showAdvanced?(F(),st(AH,{key:0,"num-inference-steps":t.numInferenceSteps,model:t.model,"proxy-url":t.proxyUrl,"proxy-type":t.proxyType,"siyuan-url":t.siyuanUrl,"siyuan-token":t.siyuanToken,"onUpdate:numInferenceSteps":n[1]||(n[1]=s=>e.$emit("update:numInferenceSteps",s)),"onUpdate:model":n[2]||(n[2]=s=>e.$emit("update:model",s)),"onUpdate:proxyUrl":n[3]||(n[3]=s=>e.$emit("update:proxyUrl",s)),"onUpdate:proxyType":n[4]||(n[4]=s=>e.$emit("update:proxyType",s)),"onUpdate:siyuanUrl":n[5]||(n[5]=s=>e.$emit("update:siyuanUrl",s)),"onUpdate:siyuanToken":n[6]||(n[6]=s=>e.$emit("update:siyuanToken",s))},null,8,["num-inference-steps","model","proxy-url","proxy-type","siyuan-url","siyuan-token"])):Ue("",!0)]))}}),NH=["disabled"],MH=We({__name:"GenerateButton",props:{isGenerating:{type:Boolean},disabled:{type:Boolean},apiKeyValid:{type:Boolean},promptValid:{type:Boolean}},setup(t){const e=t,n=ye(()=>e.apiKeyValid&&e.promptValid&&!e.isGenerating?"bg-blue-600/80 text-white hover:bg-blue-500/80":"bg-gray-700/50 text-white/40 cursor-not-allowed");return(s,r)=>(F(),V("button",{onClick:r[0]||(r[0]=i=>s.$emit("generate")),disabled:t.disabled,class:Q(["glass-btn py-2.5 text-sm font-medium rounded-lg transition-all duration-300",n.value])},Le(t.isGenerating?"...":""),11,NH))}});function LH(){return ce([])}async function OH(t,e){const n=await Promise.all(t.map(async s=>{try{return await vE(s)||""}catch(r){return console.warn("Failed to load cached image:",r),""}}));e.value=n}function FH(t,e){_t(t,n=>OH(n,e),{immediate:!0})}async function UH(t,e){try{const n=await vE(t);if(n){e==null||e(n);return}throw new Error("")}catch(n){console.error("Failed to load image:",n)}}const BH={key:0,class:"mt-4"},zH={class:"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2"},GH=["onClick"],VH=["src","alt"],WH={class:"absolute bottom-2 left-2 text-xs text-white bg-black bg-opacity-60 px-2 py-1 rounded"},HH=We({__name:"ImageGallery",props:{imageUrls:{},onImageClick:{type:Function}},setup(t){const e=t,n=LH();FH(()=>e.imageUrls,n);const s=async r=>{await UH(r,e.onImageClick)};return(r,i)=>t.imageUrls.length>0?(F(),V("div",BH,[i[1]||(i[1]=k("h3",{class:"text-sm font-medium text-white/70 mb-2"},"",-1)),k("div",zH,[(F(!0),V(Xe,null,rt(t.imageUrls,(o,a)=>(F(),V("div",{key:a,class:"relative group cursor-pointer",onClick:l=>s(o)},[k("img",{src:D(n)[a],alt:` ${a+1}`,class:"w-full h-32 object-cover rounded-lg border border-gray-600 group-hover:border-blue-400 transition-colors",loading:"lazy"},null,8,VH),i[0]||(i[0]=k("div",{class:"absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-20 transition-opacity rounded-lg"},null,-1)),k("div",WH,"  "+Le(a+1),1)],8,GH))),128))])])):Ue("",!0)}}),KH={key:0,class:"fixed inset-0 z-50 flex items-center justify-center"},jH={class:"relative bg-gray-900/95 border border-orange-500/50 rounded-xl shadow-2xl max-w-md w-full mx-4 overflow-hidden"},XH={class:"px-5 py-4 bg-orange-900/30 border-b border-orange-500/30"},qH={class:"text-lg font-semibold text-orange-300"},YH={class:"px-5 py-4 space-y-4 max-h-96 overflow-y-auto"},ZH={class:"text-sm text-white/80 leading-relaxed"},QH={class:"bg-white/5 rounded-lg p-3"},JH={class:"text-sm font-medium text-orange-300 mb-2"},eK={class:"space-y-1.5"},tK={class:"bg-blue-900/20 rounded-lg p-3"},nK={class:"text-sm font-medium text-blue-300 mb-2"},sK={class:"space-y-1.5"},rK={class:"text-blue-400 shrink-0"},iK={class:"text-xs text-orange-400/70 italic"},oK={class:"px-5 py-4 bg-white/5 border-t border-white/10 flex justify-end gap-3"},aK=We({__name:"ProxyWarningModal",props:{show:{type:Boolean}},emits:["continue","cancel"],setup(t,{emit:e}){const n=e;function s(){n("continue")}function r(){n("cancel")}return(i,o)=>(F(),st(Fg,{to:"body"},[we(kO,{name:"modal"},{default:hr(()=>[t.show?(F(),V("div",KH,[k("div",{class:"absolute inset-0 bg-black/60 backdrop-blur-sm",onClick:r}),k("div",jH,[k("div",XH,[k("h3",qH,Le(D(ao).TITLE),1)]),k("div",YH,[k("p",ZH,Le(D(ao).DESCRIPTION),1),k("div",QH,[k("h4",JH,Le(D(ao).REQUIREMENTS_TITLE),1),k("ul",eK,[(F(!0),V(Xe,null,rt(D(ao).REQUIREMENTS,(a,l)=>(F(),V("li",{key:l,class:"text-xs text-white/60 flex items-start gap-2"},[o[0]||(o[0]=k("span",{class:"text-orange-400 shrink-0"},"",-1)),k("span",null,Le(a),1)]))),128))])]),k("div",tK,[k("h4",nK,Le(D(ao).SOLUTIONS_TITLE),1),k("ul",sK,[(F(!0),V(Xe,null,rt(D(ao).SOLUTIONS,(a,l)=>(F(),V("li",{key:l,class:"text-xs text-white/60 flex items-start gap-2"},[k("span",rK,Le(l+1)+".",1),k("span",null,Le(a),1)]))),128))])]),k("p",iK,Le(D(ao).CONTINUE_WARNING),1)]),k("div",oK,[k("button",{onClick:r,class:"px-4 py-2 text-sm font-medium text-white/70 bg-white/10 hover:bg-white/20 rounded-lg transition-colors"},Le(D(ao).BUTTONS.CANCEL),1),k("button",{onClick:s,class:"px-4 py-2 text-sm font-medium text-white bg-orange-600/80 hover:bg-orange-500/80 rounded-lg transition-colors"},Le(D(ao).BUTTONS.CONTINUE),1)])])])):Ue("",!0)]),_:1})]))}}),lK=Zi(aK,[["__scopeId","data-v-cb371b7e"]]),uK={class:"flex flex-col gap-4"},cK=We({__name:"TextToImageTabContent",props:{isMobile:{type:Boolean}},emits:["set-image"],setup(t,{emit:e}){const n=e,{apiKey:s,prompt:r,size:i,n:o,batchInterval:a,numInferenceSteps:l,model:u,proxyUrl:c,proxyType:h,siyuanUrl:d,siyuanToken:f,showAdvanced:p,isGenerating:g,error:m,status:x,apiKeyValid:b,generate:v,generatedImages:y,showProxyWarning:C,handleProxyWarningResponse:I}=uH(S=>{n("set-image",S)}),$=nH(y,c,h),T=S=>{n("set-image",S)};return(S,E)=>(F(),V("div",uK,[we(D(D7),{modelValue:D(s),"onUpdate:modelValue":E[0]||(E[0]=_=>Yt(s)?s.value=_:null),"is-mobile":t.isMobile},null,8,["modelValue","is-mobile"]),we(D(L7),{modelValue:D(r),"onUpdate:modelValue":E[1]||(E[1]=_=>Yt(r)?r.value=_:null)},null,8,["modelValue"]),we(D(H7),{size:D(i),"onUpdate:size":E[2]||(E[2]=_=>Yt(i)?i.value=_:null),n:D(o),"onUpdate:n":E[3]||(E[3]=_=>Yt(o)?o.value=_:null),"batch-interval":D(a),"onUpdate:batchInterval":E[4]||(E[4]=_=>Yt(a)?a.value=_:null)},null,8,["size","n","batch-interval"]),we(DH,{"num-inference-steps":D(l),"onUpdate:numInferenceSteps":E[5]||(E[5]=_=>Yt(l)?l.value=_:null),model:D(u),"onUpdate:model":E[6]||(E[6]=_=>Yt(u)?u.value=_:null),"proxy-url":D(c),"onUpdate:proxyUrl":E[7]||(E[7]=_=>Yt(c)?c.value=_:null),"proxy-type":D(h),"onUpdate:proxyType":E[8]||(E[8]=_=>Yt(h)?h.value=_:null),"siyuan-url":D(d),"onUpdate:siyuanUrl":E[9]||(E[9]=_=>Yt(d)?d.value=_:null),"siyuan-token":D(f),"onUpdate:siyuanToken":E[10]||(E[10]=_=>Yt(f)?f.value=_:null),"show-advanced":D(p),onToggle:E[11]||(E[11]=_=>p.value=!D(p))},null,8,["num-inference-steps","model","proxy-url","proxy-type","siyuan-url","siyuan-token","show-advanced"]),we(MH,{"is-generating":D(g),disabled:D(g)||!D(b)||!D(r).trim(),"api-key-valid":D(b),"prompt-valid":!!D(r).trim(),onGenerate:D(v)},null,8,["is-generating","disabled","api-key-valid","prompt-valid","onGenerate"]),we(D(Y7),{error:D(m),status:D(x)},null,8,["error","status"]),we(HH,{"image-urls":D($),"on-image-click":T},null,8,["image-urls"]),we(lK,{show:D(C),onContinue:E[12]||(E[12]=_=>D(I)(!0)),onCancel:E[13]||(E[13]=_=>D(I)(!1))},null,8,["show"])]))}}),iu={UPLOAD:"Upload",PROCEDURAL:"Procedural",TEXT_TO_IMAGE:"Text-to-Image"},Eb={IS_PROCESSING_BOOLEAN:"isProcessing must be a boolean",ORIGINAL_IMAGE_STRING_OR_NULL:"originalImage must be a string or null",INPUT_SLIDER_ITEMS_ARRAY:"inputSliderItems must be an array"},hK={IS_MOBILE:!1},eC={BOOLEAN:"boolean",STRING:"string"},SE=We({__name:"InputsPanel",props:{isMobile:{type:Boolean},isProcessing:{type:Boolean},originalImage:{},inputSliderItems:{}},emits:["load-sample","image-upload","slider-update","set-image"],setup(t,{emit:e}){const{state:n}=is(),s=["Wood","Plain Weave","Plain Weave Advanced","Leather","Twill Weave","Velvet","Turing","Gray-Scott","Compositor","Advanced Compositor"],r=[iu.UPLOAD,iu.PROCEDURAL,iu.TEXT_TO_IMAGE],i=ce(!1),o=l=>{n.activeTab=l},a=l=>{n.proceduralType=l};return(l,u)=>(F(),V("div",{class:Q(["flex flex-col",(t.isMobile,"gap-6")])},[we(B9,{"active-tab":D(n).activeTab,tabs:r,onTabChange:o},null,8,["active-tab"]),D(n).activeTab===D(iu).UPLOAD?(F(),st(j9,{key:0,"is-mobile":t.isMobile,"is-processing":t.isProcessing,"original-image":t.originalImage,onLoadSample:u[0]||(u[0]=c=>l.$emit("load-sample")),onImageUpload:u[1]||(u[1]=c=>l.$emit("image-upload",c))},null,8,["is-mobile","is-processing","original-image"])):D(n).activeTab===D(iu).PROCEDURAL?(F(),st(Q9,{key:1,"is-mobile":t.isMobile,"procedural-type":D(n).proceduralType,"texture-types":s,"is-generating":i.value,onTypeChange:a,onSetImage:u[2]||(u[2]=c=>l.$emit("set-image",c))},null,8,["is-mobile","procedural-type","is-generating"])):D(n).activeTab===D(iu).TEXT_TO_IMAGE?(F(),st(cK,{key:2,"is-mobile":t.isMobile,onSetImage:u[3]||(u[3]=c=>l.$emit("set-image",c))},null,8,["is-mobile"])):Ue("",!0),we(J9,{"is-mobile":t.isMobile,"original-image":t.originalImage,"input-slider-items":t.inputSliderItems,onSliderUpdate:u[4]||(u[4]=c=>l.$emit("slider-update",c))},null,8,["is-mobile","original-image","input-slider-items"])],2))}}),dK={class:"flex flex-col gap-4"},fK={key:1,class:"flex flex-col gap-4"},CE=We({__name:"CropPanel",props:{isMobile:{type:Boolean},originalImage:{}},emits:["open-sampling-editor"],setup(t){const e=t,n=ye(()=>e.isMobile?"text-center text-white/30 py-8 text-sm":"flex flex-col items-center justify-center py-12 text-white/30 gap-4"),s=ye(()=>e.isMobile?"bg-white/5 rounded-2xl p-5 border border-white/5":"bg-white/5 rounded-2xl p-6 border border-white/5"),r=ye(()=>e.isMobile?"text-sm text-gray-300 mb-4":"text-sm text-gray-300 mb-6 leading-relaxed"),i=ye(()=>e.isMobile?"w-full py-3.5 rounded-xl bg-indigo-500 text-white font-medium shadow-lg shadow-indigo-500/20 flex items-center justify-center gap-2":"w-full py-4 rounded-xl bg-indigo-500 hover:bg-indigo-400 text-white font-medium shadow-lg shadow-indigo-500/20 transition-all flex items-center justify-center gap-3 group"),o=ye(()=>e.isMobile?"i-carbon-crop text-lg":"i-carbon-crop text-xl group-hover:rotate-90 transition-transform");return(a,l)=>(F(),V("div",dK,[t.originalImage?(F(),V("div",fK,[k("div",{class:Q(s.value)},[k("p",{class:Q(r.value)},Le(t.isMobile?"Select area for texture generation.":`Define a quadrilateral area on your image to
                    be transformed into a seamless texture.`),3),k("button",{onClick:l[0]||(l[0]=u=>a.$emit("open-sampling-editor")),class:Q(i.value)},[k("div",{class:Q(o.value)},null,2),l[2]||(l[2]=k("span",null,"Open Crop Editor",-1))],2)],2)])):(F(),V("div",{key:0,class:Q(n.value)},[...l[1]||(l[1]=[k("div",{class:"i-carbon-image text-1xl"},null,-1),k("span",{class:"text-sm"},"Please select an image first",-1)])],2))]))}}),pK={key:0,class:"layers-section mt-4 pt-4 border-t border-white/5"},mK={class:"text-sm text-white/70 mb-2"},gK={class:"layers-list flex flex-col gap-1 max-h-[150px] overflow-y-auto scrollbar-thin scrollbar-track-white/5 scrollbar-thumb-white/20 hover:scrollbar-thumb-white/30"},xK=["onClick"],bK={class:"layer-info flex items-center gap-2 flex-1 overflow-hidden"},yK=["checked","onChange"],vK={class:"layer-name text-xs font-medium truncate"},wK={class:"layer-type text-[10px] px-1 py-0.5 bg-white/10 rounded text-white/60"},SK=["onClick"],CK=We({__name:"LayersList",props:{layers:{},activeLayerId:{}},emits:["select-layer","remove-layer","update-layer"],setup(t,{emit:e}){const n=e,s=(r,i)=>{Xk(i.target)&&n("update-layer",r.id,{visible:i.target.checked})};return(r,i)=>t.layers.length>0?(F(),V("div",pK,[k("h4",mK," ("+Le(t.layers.length)+")",1),k("div",gK,[(F(!0),V(Xe,null,rt(t.layers,o=>(F(),V("div",{key:o.id,class:Q(["layer-item flex items-center justify-between p-2 bg-white/5 border border-white/5 rounded cursor-pointer transition-all",{"border-blue-500 bg-blue-500/10":t.activeLayerId===o.id}]),onClick:a=>n("select-layer",o.id)},[k("div",bK,[k("input",{type:"checkbox",checked:o.visible,onChange:gs(a=>s(o,a),["stop"]),class:"layer-visibility cursor-pointer"},null,40,yK),k("span",vK,Le(o.name),1),k("span",wK,Le(o.type==="hsl"?"HSL":"Color"),1)]),k("button",{class:"remove-layer-btn text-sm px-1 text-white/50 hover:text-red-500 transition-colors",onClick:gs(a=>n("remove-layer",o.id),["stop"])},"",8,SK)],10,xK))),128))])])):Ue("",!0)}}),TK={key:0,class:"layer-adjustment-panel mt-3 p-3 bg-white/5 rounded border border-white/5"},IK={class:"text-xs text-white/80 mb-2 pb-2 border-b border-white/5"},kK={class:"control-row flex items-center justify-between mb-2 text-xs mt-2"},EK=["value"],_K={key:0,class:"hsl-controls mt-2"},$K={key:1,class:"quantized-controls"},RK=We({__name:"LayerAdjustmentPanel",props:{activeLayer:{}},emits:["update-layer"],setup(t,{emit:e}){const n=t,s=e,r=ye(()=>n.activeLayer?[{id:"layer-intensity",label:"",value:n.activeLayer.intensity,min:0,max:1,step:.01,format:u=>`${Math.round(u*100)}%`}]:[]),i=ye(()=>{if(!n.activeLayer||!n.activeLayer.hslRange)return[];const u=n.activeLayer.hslRange;return[{id:"hsl-hue",label:"",value:u.hue,min:0,max:360,step:1,format:c=>`${Math.round(c)}`,group:" (Hue)"},{id:"hsl-hueTolerance",label:"",value:u.hueTolerance,min:0,max:180,step:1,group:" (Hue)"},{id:"hsl-saturation",label:"",value:u.saturation,min:0,max:100,step:1,format:c=>`${Math.round(c)}%`,group:" (Saturation)"},{id:"hsl-saturationTolerance",label:"",value:u.saturationTolerance,min:0,max:100,step:1,group:" (Saturation)"},{id:"hsl-lightness",label:"",value:u.lightness,min:0,max:100,step:1,format:c=>`${Math.round(c)}%`,group:" (Lightness)"},{id:"hsl-lightnessTolerance",label:"",value:u.lightnessTolerance,min:0,max:100,step:1,group:" (Lightness)"},{id:"hsl-feather",label:"",value:u.feather,min:0,max:1,step:.05,format:c=>c.toFixed(2)}]}),o=ye(()=>!n.activeLayer||n.activeLayer.type!=="quantized"?[]:[{id:"quantized-tolerance",label:"",value:n.activeLayer.tolerance||0,min:0,max:100,step:1}]),a=u=>{if(!n.activeLayer)return;const c=u.target;s("update-layer",n.activeLayer.id,{blendMode:c.value})},l=u=>{if(n.activeLayer){if(u.id==="layer-intensity"){s("update-layer",n.activeLayer.id,{intensity:u.value});return}if(u.id.startsWith("hsl-")&&n.activeLayer.hslRange){const c=u.id.replace("hsl-",""),h={...n.activeLayer.hslRange,[c]:u.value};s("update-layer",n.activeLayer.id,{hslRange:h});return}if(u.id.startsWith("quantized-")){const c=u.id.replace("quantized-","");s("update-layer",n.activeLayer.id,{[c]:u.value})}}};return(u,c)=>t.activeLayer?(F(),V("div",TK,[k("h4",IK,": "+Le(t.activeLayer.name),1),we(D(St),{items:r.value,onUpdateValue:l},null,8,["items"]),k("div",kK,[c[1]||(c[1]=k("label",null,":",-1)),k("select",{value:t.activeLayer.blendMode,onChange:a,class:"w-3/5 px-1 py-0.5 bg-white/5 border border-white/10 text-white rounded text-xs"},[...c[0]||(c[0]=[k("option",{value:"max"}," (Max)",-1),k("option",{value:"add"}," (Add)",-1),k("option",{value:"multiply"}," (Multiply)",-1),k("option",{value:"min"}," (Min)",-1)])],40,EK)]),t.activeLayer.type==="hsl"&&t.activeLayer.hslRange?(F(),V("div",_K,[we(D(St),{items:i.value,onUpdateValue:l},null,8,["items"])])):Ue("",!0),t.activeLayer.type==="quantized"?(F(),V("div",$K,[we(D(St),{items:o.value,onUpdateValue:l},null,8,["items"])])):Ue("",!0)])):Ue("",!0)}}),AK=["onClick","title"],PK={class:"drop-shadow-md"},DK=We({__name:"QuantizedColorBlocks",props:{quantizedColorBlocks:{},isMobile:{type:Boolean,default:!1}},emits:["add-color-layer"],setup(t,{emit:e}){const n=e;return(s,r)=>t.quantizedColorBlocks.length>0?(F(),V("div",{key:0,class:Q(["color-block-section",t.isMobile?"flex-shrink-0":""])},[r[0]||(r[0]=k("h4",{class:"text-xs text-white/60 font-bold mb-2 whitespace-nowrap"},"",-1)),k("div",{class:Q(["color-blocks flex gap-2",t.isMobile?"flex-nowrap":"flex-wrap"])},[(F(!0),V(Xe,null,rt(t.quantizedColorBlocks,(i,o)=>(F(),V("div",{key:`quantized-${o}`,class:Q(["color-block rounded cursor-pointer relative transition-all duration-200 flex items-center justify-center font-bold text-white shadow-sm border-2 border-white/10 hover:scale-110 hover:shadow-md hover:z-10",t.isMobile?"w-16 h-16 text-xs":"w-10 h-10 text-[9px]","flex-shrink-0"]),style:bn({backgroundColor:`rgb(${i.r}, ${i.g}, ${i.b})`}),onClick:a=>n("add-color-layer",i),title:`RGB(${i.r}, ${i.g}, ${i.b}) - ${i.count}`},[k("span",PK,Le(i.count),1)],14,AK))),128))],2)],2)):Ue("",!0)}}),NK=["onClick","title"],MK={class:"drop-shadow-md"},LK=We({__name:"CommonHslBlocks",props:{commonHslBlocks:{},isMobile:{type:Boolean}},emits:["add-hsl-layer"],setup(t,{emit:e}){const n=e;return(s,r)=>(F(),V("div",{class:Q(["color-block-section",t.isMobile?"flex-shrink-0":""])},[r[0]||(r[0]=k("h4",{class:"text-xs text-white/60 font-bold mb-2 whitespace-nowrap"},"HSL",-1)),k("div",{class:Q(["color-blocks flex gap-2",t.isMobile?"flex-nowrap":"flex-wrap"])},[(F(!0),V(Xe,null,rt(t.commonHslBlocks,(i,o)=>(F(),V("div",{key:`hsl-${o}`,class:Q(["color-block hsl-block rounded cursor-pointer relative transition-all duration-200 flex items-center justify-center font-bold text-white shadow-sm border border-white/10 hover:scale-110 hover:shadow-md hover:z-10 text-center leading-tight",t.isMobile?"w-16 h-16 text-xs":"w-10 h-10 text-[9px]","flex-shrink-0"]),style:bn({backgroundColor:D(jk)(i)}),onClick:a=>n("add-hsl-layer",i),title:i.name},[k("span",MK,Le(i.name),1)],14,NK))),128))],2)],2))}}),OK={class:"input-group"},FK={key:0,class:"text-white/80 text-sm font-medium mb-2 block"},R1=We({__name:"ColorBlockSelector",props:{processing:{type:Boolean},quantizedColorBlocks:{},commonHslBlocks:{},layers:{},activeLayerId:{},mode:{default:"full"},isMobile:{type:Boolean}},emits:["add-color-layer","add-hsl-layer","remove-layer","select-layer","update-layer"],setup(t,{emit:e}){const n=t,s=e,r=ye(()=>n.mode==="full"||n.mode==="add-only"),i=ye(()=>n.mode==="full"||n.mode==="list-only"),o=ye(()=>n.mode==="full"||n.mode==="settings-only"),a=ye(()=>n.layers.find(l=>l.id===n.activeLayerId));return(l,u)=>(F(),V("div",OK,[t.isMobile?Ue("",!0):(F(),V("label",FK,":")),k("div",{class:Q(["color-blocks-container flex gap-4",t.isMobile?"flex-row overflow-x-auto scrollbar-thin scrollbar-track-white/5 scrollbar-thumb-white/20 hover:scrollbar-thumb-white/30 scrollbar-rounded pb-2":"flex-col"])},[r.value?(F(),st(DK,{key:0,quantizedColorBlocks:t.quantizedColorBlocks,isMobile:t.isMobile,onAddColorLayer:u[0]||(u[0]=c=>s("add-color-layer",c))},null,8,["quantizedColorBlocks","isMobile"])):Ue("",!0),r.value?(F(),st(LK,{key:1,commonHslBlocks:t.commonHslBlocks,isMobile:t.isMobile,onAddHslLayer:u[1]||(u[1]=c=>s("add-hsl-layer",c))},null,8,["commonHslBlocks","isMobile"])):Ue("",!0)],2),i.value?(F(),st(CK,{key:1,layers:t.layers,activeLayerId:t.activeLayerId,onSelectLayer:u[2]||(u[2]=c=>s("select-layer",c)),onRemoveLayer:u[3]||(u[3]=c=>s("remove-layer",c)),onUpdateLayer:u[4]||(u[4]=(c,h)=>s("update-layer",c,h))},null,8,["layers","activeLayerId"])):Ue("",!0),o.value&&a.value?(F(),st(RK,{key:2,activeLayer:a.value,onUpdateLayer:u[5]||(u[5]=(c,h)=>s("update-layer",c,h))},null,8,["activeLayer"])):Ue("",!0)]))}}),UK={class:"mask-preview-container w-full h-full flex flex-col bg-darkglass-100 rounded-xl overflow-hidden"},BK={class:"preview-header p-4 border-b border-white/5 bg-black/20"},zK={class:"layer-info flex gap-4 text-sm text-white/60"},GK=We({__name:"MaskPreview",props:{maskPreviewImage:{},maskData:{},originalImage:{},activeLayerName:{},visibleLayerCount:{},layers:{}},setup(t){const e=t,n=ce(),s=ce(),r=async()=>{if(!n.value||!e.originalImage)return;await tl();const i=n.value,o=i.getContext("2d");if(!o)return;const a=new Image;a.crossOrigin="anonymous",await new Promise((m,x)=>{a.onload=()=>m(),a.onerror=()=>x(new Error("")),a.src=e.originalImage});const l=s.value;if(!l)return;const u=l.getBoundingClientRect(),c=u.width-32,h=u.height-32,d=a.width/a.height,f=c/h;let p,g;if(d>f?(p=c,g=c/d):(g=h,p=h*d),p=Math.max(1,Math.floor(p)),g=Math.max(1,Math.floor(g)),i.style.width=`${p}px`,i.style.height=`${g}px`,i.width=p,i.height=g,o.clearRect(0,0,p,g),o.drawImage(a,0,0,p,g),e.maskData)try{const m=C1(e.maskData,a,p,g);Kk(m,i,"source-over")}catch(m){console.error(":",m)}else if(e.maskPreviewImage){const m=new Image;m.onload=()=>{o.drawImage(m,0,0,p,g)},m.src=e.maskPreviewImage}};return _t([()=>e.maskData,()=>e.originalImage],r,{deep:!0}),kr(r),(i,o)=>(F(),V("div",UK,[k("div",BK,[o[0]||(o[0]=k("h3",{class:"text-lg font-semibold text-white/90 mb-1"},"",-1)),k("div",zK,[k("span",null,": "+Le(t.activeLayerName||""),1),k("span",null,": "+Le(t.visibleLayerCount),1)])]),k("div",{ref_key:"previewContent",ref:s,class:"preview-content flex-1 flex items-center justify-center p-4"},[k("canvas",{ref_key:"maskCanvas",ref:n,class:"rounded border-2 border-red-500/30"},null,512)],512),o[1]||(o[1]=Ik('<div class="preview-legend p-4 border-t border-white/5 bg-black/20" data-v-4bba43f6><div class="legend-item flex items-center gap-2 mb-2" data-v-4bba43f6><div class="color-box w-4 h-4 rounded bg-red-500/80 border border-red-300" data-v-4bba43f6></div><span class="text-sm text-white/80" data-v-4bba43f6>LUT</span></div><div class="legend-item flex items-center gap-2" data-v-4bba43f6><div class="color-box w-4 h-4 rounded bg-transparent border border-white/40" data-v-4bba43f6></div><span class="text-sm text-white/80" data-v-4bba43f6>LUT</span></div></div>',1))]))}}),VK=Zi(GK,[["__scopeId","data-v-4bba43f6"]]),WK={class:"mask-preview-panel"},HK={class:"mask-options flex flex-col gap-2 mb-3 p-2 bg-black/20 rounded border border-white/5"},KK={class:"checkbox-label flex items-center cursor-pointer text-xs text-white/80"},jK=["checked","disabled"],XK={class:"checkbox-label flex items-center cursor-pointer text-xs text-white/80"},qK=["checked","disabled"],YK={key:0,class:"mask-preview border-t border-white/5 pt-3"},ZK={class:"canvas-container flex justify-center items-center bg-black/20 rounded border border-white/10 p-2"},QK={class:"mt-3 flex justify-center"},JK=We({__name:"MaskPreviewPanel",props:{processing:{type:Boolean},originalImage:{},layers:{},maskOptions:{},updateMaskPreview:{type:Function},generateMaskPreviewImageDataUrl:{type:Function},generateColorBlockMask:{type:Function},isMobile:{type:Boolean}},emits:["update:maskOptions","set-preview-overlay"],setup(t,{expose:e,emit:n}){const s=t,r=n,i=ce(),o=ce(!1),a=pi({maskData:null,originalImage:null,activeLayerName:void 0,visibleLayerCount:0,layers:[]}),l=async()=>{if(!s.originalImage)return;const d=await s.generateColorBlockMask(s.originalImage);if(!d)return;const f=s.layers.find(p=>p.visible);a.maskData=d,a.originalImage=s.originalImage,a.activeLayerName=f==null?void 0:f.name,a.visibleLayerCount=s.layers.filter(p=>p.visible).length,a.layers=s.layers};_t([()=>s.layers,()=>s.maskOptions],async()=>{s.layers.length>0&&s.originalImage&&(s.updateMaskPreview(s.originalImage,i.value),o.value&&await l())},{deep:!0}),_t(()=>s.originalImage,async d=>{d&&s.layers.length>0&&(s.updateMaskPreview(d,i.value),o.value&&await l())});const u=d=>{const f=d.target;r("update:maskOptions",{...s.maskOptions,smooth:f.checked})},c=d=>{const f=d.target;r("update:maskOptions",{...s.maskOptions,invert:!f.checked})},h=async()=>{if(o.value)r("set-preview-overlay",null,null),o.value=!1;else{if(!s.originalImage)return;await l(),r("set-preview-overlay",a,VK),o.value=!0}};return e({toggleMaskPreview:h}),(d,f)=>(F(),V("div",WK,[k("div",HK,[k("label",KK,[k("input",{type:"checkbox",checked:t.maskOptions.smooth,onChange:u,disabled:t.processing,class:"mr-2 rounded bg-white/10 border-white/20 text-blue-500 focus:ring-blue-500 focus:ring-offset-0"},null,40,jK),f[0]||(f[0]=Tn("  ",-1))]),k("label",XK,[k("input",{type:"checkbox",checked:!t.maskOptions.invert,onChange:c,disabled:t.processing,class:"mr-2 rounded bg-white/10 border-white/20 text-blue-500 focus:ring-blue-500 focus:ring-offset-0"},null,40,qK),f[1]||(f[1]=Tn("  ",-1))])]),t.layers.length>0&&!t.isMobile?(F(),V("div",YK,[f[2]||(f[2]=k("h4",{class:"text-xs text-white/70 mb-2"},"",-1)),k("div",ZK,[k("canvas",{ref_key:"maskPreviewCanvasRef",ref:i,class:"max-w-full rounded border-2 border-red-500/30"},null,512)]),f[3]||(f[3]=k("div",{class:"text-[10px] text-white/50 text-center mt-1"}," = LUT",-1)),k("div",QK,[k("button",{onClick:h,class:"preview-btn flex items-center gap-2 px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded transition-colors"},[k("div",{class:Q([o.value?"i-carbon-view-off":"i-carbon-view","w-4 h-4"])},null,2),Tn(" "+Le(o.value?"":""),1)])])])):Ue("",!0)]))}}),ej=Zi(JK,[["__scopeId","data-v-b50bbebd"]]),tj={class:"flex items-center gap-2 px-4 py-2 overflow-x-auto scrollbar-hide w-full bg-black border-t border-white/5"},nj=["onClick"],sj={class:"relative z-10 text-xs font-bold text-white shadow-black drop-shadow-md"},rj={key:0,class:"absolute inset-0 flex items-center justify-center bg-black/60 z-20"},ij=We({__name:"LUTMobileNav",props:{isMobile:{type:Boolean},layers:{},activeMobileTab:{}},emits:["switch-tab"],setup(t){return(e,n)=>t.isMobile?(F(),st(Fg,{key:0,to:"#secondary-nav-container"},[k("div",tj,[k("button",{onClick:n[0]||(n[0]=s=>e.$emit("switch-tab","lut")),class:Q(["flex flex-col items-center justify-center min-w-[3rem] h-12 rounded-lg border transition-all duration-200",t.activeMobileTab==="lut"?"bg-white/20 border-white/40 text-white":"bg-black/40 border-white/10 text-white/50"])},[...n[2]||(n[2]=[k("div",{class:"i-carbon-color-palette text-lg mb-0.5"},null,-1),k("span",{class:"text-[9px] font-medium"},"LUT",-1)])],2),(F(!0),V(Xe,null,rt(t.layers,s=>(F(),V("button",{key:s.id,onClick:r=>e.$emit("switch-tab",s.id),class:Q(["relative flex flex-col items-center justify-center min-w-[3rem] h-12 rounded-lg border transition-all duration-200 overflow-hidden",t.activeMobileTab===s.id?"border-white/60 shadow-[0_0_8px_rgba(255,255,255,0.3)]":"border-white/10 opacity-80"])},[k("div",{class:"absolute inset-0 opacity-50",style:bn({backgroundColor:s.type==="quantized"&&s.color?`rgb(${s.color.r},${s.color.g},${s.color.b})`:s.type==="hsl"&&s.hslRange?D(jk)(s.hslRange):"#333"})},null,4),k("div",sj,Le(s.type==="hsl"?"HSL":"RGB"),1),s.visible?Ue("",!0):(F(),V("div",rj,[...n[3]||(n[3]=[k("div",{class:"i-carbon-view-off text-white/80 text-lg"},null,-1)])]))],10,nj))),128)),k("button",{onClick:n[1]||(n[1]=s=>e.$emit("switch-tab","add")),class:Q(["flex flex-col items-center justify-center min-w-[3rem] h-12 rounded-lg border border-dashed transition-all duration-200",t.activeMobileTab==="add"?"bg-white/10 border-white/40 text-white":"bg-transparent border-white/20 text-white/50"])},[...n[4]||(n[4]=[k("div",{class:"i-carbon-add text-xl"},null,-1)])],2)])])):Ue("",!0)}}),oj=["onClick"],aj=["src","onError"],lj={key:1,class:"w-full h-full bg-gray-800 flex items-center justify-center"},uj={class:"text-xs text-white/30 text-center px-1 break-all"},cj={class:"absolute inset-x-0 bottom-0 bg-black/60 p-1 transform translate-y-full group-hover:translate-y-0 transition-transform flex items-center justify-between gap-1"},hj={class:"text-[10px] text-white truncate flex-1 text-center"},dj=["onClick"],fj=["onClick"],pj=We({__name:"LUTGallery",props:{luts:{},selectedId:{}},emits:["trigger-upload","select","delete","update-thumbnail"],setup(t){const e=ce({}),n=ye(()=>Qy()),s=r=>{e.value[r]=!0};return(r,i)=>(F(),V("div",{class:Q([n.value?"flex gap-2 overflow-x-auto p-1 custom-scrollbar":"grid grid-cols-3 gap-2 max-h-60 overflow-y-auto p-1 custom-scrollbar"])},[k("div",{class:Q(["aspect-square bg-white/5 hover:bg-white/10 border border-white/10 rounded-lg flex flex-col items-center justify-center cursor-pointer transition-colors group",[n.value?"w-24 h-24":""]]),onClick:i[0]||(i[0]=o=>r.$emit("trigger-upload"))},[...i[1]||(i[1]=[k("div",{class:"i-carbon-add text-2xl text-white/50 group-hover:text-white/80 transition-colors"},null,-1),k("span",{class:"text-xs text-white/40 mt-1 group-hover:text-white/70"},"Add LUT",-1)])],2),(F(!0),V(Xe,null,rt(t.luts,o=>(F(),V("div",{key:o.id,class:Q(["relative aspect-square rounded-lg overflow-hidden cursor-pointer border transition-all group",[t.selectedId===o.id?"border-primary-500 ring-1 ring-primary-500":"border-white/10 hover:border-white/30",n.value?"w-24 h-24":""]]),onClick:a=>r.$emit("select",o)},[o.thumbnail&&!e.value[o.id]?(F(),V("img",{key:0,src:o.thumbnail,class:"w-full h-full object-cover",alt:"LUT Thumbnail",onError:a=>s(o.id)},null,40,aj)):(F(),V("div",lj,[k("span",uj,Le(o.name),1)])),k("div",cj,[k("p",hj,Le(o.name),1),k("button",{class:"glass-btn p-1 hover:bg-white/20 rounded text-white/70 hover:text-white transition-colors",title:"Update Thumbnail",onClick:gs(a=>r.$emit("update-thumbnail",o.id),["stop"])},[...i[2]||(i[2]=[k("div",{class:"i-carbon-image-copy text-[10px]"},null,-1)])],8,dj)]),k("button",{class:"glass-btn absolute top-1 right-1 p-1 bg-black/50 hover:bg-red-500/80 rounded-full opacity-0 group-hover:opacity-100 transition-all",onClick:gs(a=>r.$emit("delete",o.id),["stop"])},[...i[3]||(i[3]=[k("div",{class:"i-carbon-trash-can text-white text-xs"},null,-1)])],8,fj)],10,oj))),128))],2))}}),mj=Zi(pj,[["__scopeId","data-v-084730f8"]]),gj={class:"flex items-center justify-between mb-2"},xj=["disabled"],bj={key:0,class:"mt-4 border-t border-white/5 pt-4"},yj={class:"flex items-center justify-between mb-3"},vj={class:"text-xs text-white/60"},wj={class:"flex gap-2"},Sj={key:1,class:"mt-4 border-t border-white/5 pt-4"},Cj=We({__name:"LUTLibraryView",props:{isMobile:{type:Boolean},luts:{},selectedLutId:{},selectedLutName:{},originalImage:{},processedImage:{},isUpdatingThumbnails:{type:Boolean},lutSliderItems:{},quantizedColorBlocks:{},commonHslBlocks:{},layers:{},activeLayerId:{}},emits:["update-all-thumbnails","files-selected","select-lut","delete-lut","update-thumbnail","update-current-thumbnail","clear-selection","slider-update","add-color-layer","add-hsl-layer","remove-layer","select-layer","update-layer"],setup(t,{emit:e}){const n=e,s=ce(),r=()=>{var o;(o=s.value)==null||o.click()},i=o=>{const a=o.target;a.files&&a.files.length>0&&n("files-selected",a.files),a.value=""};return(o,a)=>(F(),V("div",{class:Q(["pb-3 pt-3",{"px-4":!t.isMobile}])},[k("div",gj,[a[13]||(a[13]=k("label",{class:"block text-sm font-medium text-white/80"}," LUT Library ",-1)),k("button",{onClick:a[0]||(a[0]=l=>o.$emit("update-all-thumbnails")),disabled:t.isUpdatingThumbnails||!t.originalImage,class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"},[k("div",{class:Q(t.isUpdatingThumbnails?"i-carbon-circle-dash animate-spin":"i-carbon-renew")},null,2),a[12]||(a[12]=k("span",null,"Update All",-1))],8,xj)]),we(mj,{luts:t.luts,"selected-id":t.selectedLutId,onTriggerUpload:r,onSelect:a[1]||(a[1]=l=>o.$emit("select-lut",l)),onDelete:a[2]||(a[2]=l=>o.$emit("delete-lut",l)),onUpdateThumbnail:a[3]||(a[3]=l=>o.$emit("update-thumbnail",l))},null,8,["luts","selected-id"]),k("input",{ref_key:"lutInputRef",ref:s,type:"file",accept:".cube",multiple:"",onChange:i,class:"hidden"},null,544),t.selectedLutId?(F(),V("div",bj,[k("div",yj,[k("span",vj,Le(t.selectedLutName),1),k("div",wj,[t.processedImage?(F(),V("button",{key:0,onClick:a[4]||(a[4]=l=>o.$emit("update-current-thumbnail")),class:"glass-btn p-1.5 rounded bg-white/5 hover:bg-white/10 text-white/70 transition-colors",title:"Update thumbnail from current result"},[...a[14]||(a[14]=[k("div",{class:"i-carbon-image-copy text-sm"},null,-1)])])):Ue("",!0),k("button",{onClick:a[5]||(a[5]=l=>o.$emit("clear-selection")),class:"glass-btn p-1.5 rounded bg-white/5 hover:bg-white/10 text-white/70 transition-colors",title:"Clear selection"},[...a[15]||(a[15]=[k("div",{class:"i-carbon-close text-sm"},null,-1)])])])]),we(D(St),{items:t.lutSliderItems,onUpdateValue:a[6]||(a[6]=l=>o.$emit("slider-update",l))},null,8,["items"])])):Ue("",!0),!t.isMobile&&t.selectedLutId?(F(),V("div",Sj,[we(R1,{processing:!1,"quantized-color-blocks":t.quantizedColorBlocks,"common-hsl-blocks":t.commonHslBlocks,layers:t.layers,"active-layer-id":t.activeLayerId,"is-mobile":!1,onAddColorLayer:a[7]||(a[7]=l=>o.$emit("add-color-layer",l)),onAddHslLayer:a[8]||(a[8]=l=>o.$emit("add-hsl-layer",l)),onRemoveLayer:a[9]||(a[9]=l=>o.$emit("remove-layer",l)),onSelectLayer:a[10]||(a[10]=l=>o.$emit("select-layer",l)),onUpdateLayer:a[11]||(a[11]=(l,u)=>o.$emit("update-layer",l,u))},null,8,["quantized-color-blocks","common-hsl-blocks","layers","active-layer-id"])])):Ue("",!0)],2))}}),Tj=()=>`
struct HSLParams {
    // HSL
    targetHue: f32,        //  (0-1)
    targetSaturation: f32, //  (0-1)
    
    // 
    hueOffset: f32,        //  (-0.5 to 0.5, -180180)
    saturationOffset: f32, //  (-1 to 1)
    lightnessOffset: f32,  //  (-1 to 1)
    
    // 
    tolerance: f32,        //  (0-100), 
    range: f32,            //  (0-100), 
    
    // 
    enableMask: f32,       //  (0.0 = , 1.0 = )
    maskMode: f32,         //  (0 = , 1 = , 2 = )
    
    // 
    overlayColor: vec3<f32>, //  (RGB)
    overlayAlpha: f32,       //  (0-1)
}
`,Ij=()=>`
@group(0) @binding(0) var inputTexture: texture_2d<f32>;                    // 
@group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>; // 
@group(0) @binding(2) var<uniform> params: HSLParams;                        // Uniform
`,TE=()=>`
// RGBHSL
fn rgbToHsl(rgb: vec3<f32>) -> vec3<f32> {
    let r = rgb.r;
    let g = rgb.g;
    let b = rgb.b;
    
    let maxVal = max(max(r, g), b);
    let minVal = min(min(r, g), b);
    let l = (maxVal + minVal) * 0.5;
    
    var h = 0.0;
    var s = 0.0;
    
    if (maxVal != minVal) {
        let d = maxVal - minVal;
        s = select(d / (2.0 - maxVal - minVal), d / (maxVal + minVal), l > 0.5);
        
        if (maxVal == r) {
            h = (g - b) / d + select(6.0, 0.0, g >= b);
        } else if (maxVal == g) {
            h = (b - r) / d + 2.0;
        } else {
            h = (r - g) / d + 4.0;
        }
        h = h / 6.0;
    }
    
    return vec3<f32>(h, s, l);
}
`,IE=()=>`
// HSLRGB
fn hslToRgb(hsl: vec3<f32>) -> vec3<f32> {
    let h = hsl.x;
    let s = hsl.y;
    let l = hsl.z;
    
    var r = 0.0;
    var g = 0.0;
    var b = 0.0;
    
    if (s == 0.0) {
        // 
        r = l;
        g = l;
        b = l;
    } else {
        let q = select(l * (1.0 + s), l + s - l * s, l < 0.5);
        let p = 2.0 * l - q;
        
        r = hue2rgb(p, q, h + 1.0 / 3.0);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1.0 / 3.0);
    }
    
    return vec3<f32>(r, g, b);
}
`,kE=()=>`
// HSL
fn hue2rgb(p: f32, q: f32, t: f32) -> f32 {
    var tAdjusted = t;
    if (tAdjusted < 0.0) { tAdjusted = tAdjusted + 1.0; }
    if (tAdjusted > 1.0) { tAdjusted = tAdjusted - 1.0; }
    
    if (tAdjusted < 1.0 / 6.0) {
        return p + (q - p) * 6.0 * tAdjusted;
    } else if (tAdjusted < 1.0 / 2.0) {
        return q;
    } else if (tAdjusted < 2.0 / 3.0) {
        return p + (q - p) * (2.0 / 3.0 - tAdjusted) * 6.0;
    } else {
        return p;
    }
}
`,kj=()=>`
// 
fn hueDifference(h1: f32, h2: f32) -> f32 {
    let diff = abs(h1 - h2);
    return min(diff, 1.0 - diff);
}

// 
fn applyFeathering(weight: f32, featherFactor: f32) -> f32 {
    if (featherFactor == 0.0) {
        //  - smoothstep
        return weight * weight * (3.0 - 2.0 * weight);
    } else if (featherFactor == 1.0) {
        //  - 
        return weight;
    } else {
        // 
        let hardEdge = weight * weight * (3.0 - 2.0 * weight);
        let softEdge = weight;
        return hardEdge * (1.0 - featherFactor) + softEdge * featherFactor;
    }
}

// 
fn calculateMaskWeight(pixelH: f32, pixelS: f32, targetH: f32, targetS: f32, tolerance: f32, range: f32) -> f32 {
    // 
    // tolerance 100 -> tolerance 0.05, tolerance 0 -> tolerance 0.5
    let hueTolerance = 0.5 - (tolerance / 100.0) * 0.45;
    let satTolerance = 1.0 - (tolerance / 100.0) * 0.9;

    let hueDiff = hueDifference(pixelH, targetH);
    let satDiff = abs(pixelS - targetS);

    var hueWeight = 0.0;
    if (hueTolerance > 0.0) {
        hueWeight = max(0.0, 1.0 - (hueDiff / hueTolerance));
    } else {
        hueWeight = select(0.0, 1.0, hueDiff < 0.01);
    }

    var satWeight = 0.0;
    if (satTolerance > 0.0) {
        satWeight = max(0.0, 1.0 - (satDiff / satTolerance));
    } else {
        satWeight = select(0.0, 1.0, satDiff < 0.01);
    }

    let weight = min(hueWeight, satWeight);
    
    // 
    let featherFactor = range / 100.0;
    let featheredWeight = applyFeathering(weight, featherFactor);
    
    return featheredWeight;
}
`,Ej=(t,e)=>`
@compute @workgroup_size(${t}, ${e})
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let dims = textureDimensions(inputTexture);
    let coords = vec2<u32>(global_id.xy);

    // 
    if (coords.x >= dims.x || coords.y >= dims.y) {
        return;
    }

    // 
    let originalColor = textureLoad(inputTexture, vec2<i32>(i32(coords.x), i32(coords.y)), 0);
    
    // HSL
    let hsl = rgbToHsl(originalColor.rgb);
    
    // 
    let maskWeight = calculateMaskWeight(
        hsl.x, hsl.y,
        params.targetHue, params.targetSaturation,
        params.tolerance, params.range
    );

    var finalColor = originalColor;
    
    if (params.maskMode == 0.0) {
        // 0: 
        if (maskWeight > 0.0) {
            var newH = hsl.x + (params.hueOffset * maskWeight);
            newH = fract(newH); // 0-1

            let newS = clamp(hsl.y + (params.saturationOffset * maskWeight), 0.0, 1.0);
            let newL = clamp(hsl.z + (params.lightnessOffset * maskWeight), 0.0, 1.0);

            let adjustedRgb = hslToRgb(vec3<f32>(newH, newS, newL));
            
            // 
            finalColor = vec4<f32>(
                mix(originalColor.rgb, adjustedRgb, maskWeight),
                originalColor.a
            );
        }
    } else if (params.maskMode == 1.0) {
        // 1: 
        let maskValue = maskWeight;
        finalColor = vec4<f32>(maskValue, maskValue, maskValue, originalColor.a);
    } else if (params.maskMode == 2.0) {
        // 2: 
        let alpha = maskWeight * params.overlayAlpha;
        finalColor = vec4<f32>(
            mix(originalColor.rgb, params.overlayColor, alpha),
            originalColor.a
        );
    }

    // 
    textureStore(outputTexture, coords, finalColor);
}
`,EE=(t,e)=>[Tj(),Ij(),TE(),IE(),kE(),kj(),Ej(t,e)].join(`
`),_j=()=>`
struct GlobalHSLParams {
    // HSL
    hueOffset: f32,        //  (-0.5 to 0.5, -180180)
    saturationOffset: f32, //  (-1 to 1)
    lightnessOffset: f32,  //  (-1 to 1)
}
`,$j=()=>`
@group(0) @binding(0) var inputTexture: texture_2d<f32>;                    // 
@group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>; // 
@group(0) @binding(2) var<uniform> params: GlobalHSLParams;                   // Uniform
`,Rj=(t,e)=>`
@compute @workgroup_size(${t}, ${e})
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let dims = textureDimensions(inputTexture);
    let coords = vec2<u32>(global_id.xy);

    // 
    if (coords.x >= dims.x || coords.y >= dims.y) {
        return;
    }

    // 
    let originalColor = textureLoad(inputTexture, vec2<i32>(i32(coords.x), i32(coords.y)), 0);
    
    // HSL
    let hsl = rgbToHsl(originalColor.rgb);
    
    // HSL
    var newH = hsl.x + params.hueOffset;
    newH = fract(newH); // 0-1

    let newS = clamp(hsl.y + params.saturationOffset, 0.0, 1.0);
    let newL = clamp(hsl.z + params.lightnessOffset, 0.0, 1.0);

    let adjustedRgb = hslToRgb(vec3<f32>(newH, newS, newL));
    
    // 
    let finalColor = vec4<f32>(adjustedRgb, originalColor.a);

    // 
    textureStore(outputTexture, coords, finalColor);
}
`,_E=(t,e)=>[_j(),$j(),TE(),IE(),kE(),Rj(t,e)].join(`
`);function Aj(t){const e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);if(!e)return[0,0,0];const n=parseInt(e[1]??"0",16)/255,s=parseInt(e[2]??"0",16)/255,r=parseInt(e[3]??"0",16)/255,i=Math.max(n,s,r),o=Math.min(n,s,r);let a=0,l=0;const u=(i+o)/2;if(i!==o){const c=i-o;l=u>.5?c/(2-i-o):c/(i+o);const h={[n]:()=>((s-r)/c+(s<r?6:0))/6,[s]:()=>((r-n)/c+2)/6,[r]:()=>((n-s)/c+4)/6};for(const[d,f]of Object.entries(h))if(parseFloat(d)===i){a=f();break}}return[a,l,u]}function Pj(t){const[e,n]=Aj(t.targetColor),s=t.maskMode==="adjust"?0:t.maskMode==="mask"?1:2,r=t.overlayColor||[1,0,0],i=t.overlayAlpha??.6,o=new Float32Array(16);return o[0]=e,o[1]=n,o[2]=t.hueOffset/360,o[3]=t.saturationOffset/100,o[4]=t.lightnessOffset/100,o[5]=t.precision,o[6]=t.range,o[7]=t.maskMode==="none"?0:1,o[8]=s,o[9]=0,o[10]=0,o[11]=0,o[12]=r[0],o[13]=r[1],o[14]=r[2],o[15]=i,o}function Dj(t){const e=new Float32Array(4);return e[0]=t.hueOffset/360,e[1]=t.saturationOffset/100,e[2]=t.lightnessOffset/100,e[3]=0,e}const Nj=EE(16,16),Mj=EE(32,32),Lj=_E(16,16),Oj=_E(32,32);function Fj(t,e=!1){const n=e?Mj:Nj;return t.createShaderModule({code:n,label:e?"HSL Compute Shader (High Performance)":"HSL Compute Shader (Optimized)"})}function Uj(t,e=!1){const n=e?Oj:Lj;return t.createShaderModule({code:n,label:e?"Global HSL Compute Shader (High Performance)":"Global HSL Compute Shader (Optimized)"})}class $E{constructor(e,n=!1){Wt(this,"device");Wt(this,"shaderModule");Wt(this,"pipeline");Wt(this,"uniformBuffer");Wt(this,"uniformData");this.device=e,this.shaderModule=Fj(e,n),this.uniformData=new Float32Array(16),this.uniformBuffer=e.createBuffer({size:this.uniformData.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"HSL Uniform Buffer"}),this.pipeline=e.createComputePipeline({layout:"auto",label:"HSL Compute Pipeline",compute:{module:this.shaderModule,entryPoint:"main"}})}processImage(e,n,s,r){const i=r??this.device.createCommandEncoder({label:"HSL Process Encoder"}),o=Pj(s);this.device.queue.writeBuffer(this.uniformBuffer,0,o.buffer);const a=this.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:e.createView({label:"Input Texture View"})},{binding:1,resource:n.createView({label:"Output Texture View"})},{binding:2,resource:{buffer:this.uniformBuffer}}],label:"HSL Bind Group"}),l=i.beginComputePass({label:"HSL Compute Pass"});l.setPipeline(this.pipeline),l.setBindGroup(0,a);const u=this.calculateWorkgroupCount(e.width,e.height);return l.dispatchWorkgroups(u.x,u.y),l.end(),i}generateMaskVisualization(e,n,s,r,i=50,o){const a={targetColor:s,hueOffset:0,saturationOffset:0,lightnessOffset:0,precision:r,range:i,maskMode:"mask"};return this.processImage(e,n,a,o)}generateMaskOverlay(e,n,s,r,i=50,o=[1,0,0],a=.6,l){const u={targetColor:s,hueOffset:0,saturationOffset:0,lightnessOffset:0,precision:r,range:i,maskMode:"overlay",overlayColor:o,overlayAlpha:a};return this.processImage(e,n,u,l)}processGlobalHSL(e,n,s,r){const i=r??this.device.createCommandEncoder({label:"Global HSL Process Encoder"}),o=Uj(this.device,!1),a=Dj(s),l=this.device.createBuffer({size:a.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"Global HSL Uniform Buffer"});this.device.queue.writeBuffer(l,0,a.buffer);const u=this.device.createComputePipeline({layout:"auto",label:"Global HSL Compute Pipeline",compute:{module:o,entryPoint:"main"}}),c=this.device.createBindGroup({layout:u.getBindGroupLayout(0),entries:[{binding:0,resource:e.createView({label:"Input Texture View"})},{binding:1,resource:n.createView({label:"Output Texture View"})},{binding:2,resource:{buffer:l}}],label:"Global HSL Bind Group"}),h=i.beginComputePass({label:"Global HSL Compute Pass"});h.setPipeline(u),h.setBindGroup(0,c);const d=this.calculateWorkgroupCount(e.width,e.height);return h.dispatchWorkgroups(d.x,d.y),h.end(),{encoder:i,cleanup:()=>{l.destroy()}}}calculateWorkgroupCount(e,n){return{x:Math.ceil(e/16),y:Math.ceil(n/16)}}destroy(){this.uniformBuffer.destroy()}getDevice(){return this.device}}function Bj(t,e=!1){return new $E(t,e)}async function zj(t,e,n,s,r=!1){const i=Bj(t,r);try{const o=i.processGlobalHSL(e,n,s),a=o.encoder.finish();t.queue.submit([a]),await t.queue.onSubmittedWorkDone(),o.cleanup()}finally{i.destroy()}}async function Gj(t,e,n){if(!e||e.length===0)return t;const s=e.filter(E=>E.hue!==0||E.saturation!==0||E.lightness!==0);if(s.length===0)return t;let r;if(t.buffer instanceof GPUBuffer)r=t.buffer;else throw new Error("HSLGPUBufferGPUTexture");const i=s.filter(E=>E.type==="global"),o=s.filter(E=>E.type==="selective"),a={size:{width:t.width,height:t.height},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING,label:"HSL Input Texture"},l=n.createTexture(a),u=n.createCommandEncoder({label:"HSL Copy Input"}),c=256,h=t.width*4,d=Math.ceil(h/c)*c,f=d*t.height,p=n.createBuffer({size:f,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!1}),g=t.width*4;for(let E=0;E<t.height;E++){const _=E*g,N=E*d;u.copyBufferToBuffer(r,_,p,N,g)}u.copyBufferToTexture({buffer:p,offset:0,bytesPerRow:d},{texture:l},{width:t.width,height:t.height}),n.queue.submit([u.finish()]);let m=l,x=null;const b=[];if(i.length>0){const E={hueOffset:i.reduce((_,N)=>_+N.hue,0),saturationOffset:i.reduce((_,N)=>_+N.saturation,0),lightnessOffset:i.reduce((_,N)=>_+N.lightness,0)};x=n.createTexture({...a,label:"Global HSL Output Texture"}),await zj(n,m,x,E,!1),await n.queue.onSubmittedWorkDone(),m!==l&&b.push(m),m=x}if(o.length>0){const E=new $E(n,!1);try{const _=n.createTexture({...a,label:"HSL Temp Texture 1"}),N=n.createTexture({...a,label:"HSL Temp Texture 2"});let P=!0;for(const M of o){const z={targetColor:M.targetColor||"#000000",hueOffset:M.hue,saturationOffset:M.saturation,lightnessOffset:M.lightness,precision:M.precision??30,range:M.range??50,maskMode:"adjust"},A=n.createCommandEncoder({label:`HSL Process Layer ${M.id}`}),B=P?_:N;E.processImage(m,B,z,A);const L=A.finish();n.queue.submit([L]),m!==l&&m!==_&&m!==N&&b.push(m),m=B,P=!P}await n.queue.onSubmittedWorkDone(),m!==_&&_.destroy(),m!==N&&N.destroy()}finally{E.destroy()}}const v=n.createBuffer({size:t.width*t.height*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,label:"HSL Output Buffer"}),C=n.createShaderModule({code:`
        @group(0) @binding(0) var inputTexture: texture_2d<f32>;
        @group(0) @binding(1) var<storage, read_write> outputBuffer: array<u32>;

        @compute @workgroup_size(16, 16)
        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
            let x = global_id.x;
            let y = global_id.y;
            let dims = textureDimensions(inputTexture);
            
            if (x >= dims.x || y >= dims.y) {
                return;
            }
            
            let color = textureLoad(inputTexture, vec2<i32>(i32(x), i32(y)), 0);
            
            // Convert to RGBA8Unorm and pack into u32 (little endian: R G B A)
            let r = u32(color.r * 255.0 + 0.5);
            let g = u32(color.g * 255.0 + 0.5);
            let b = u32(color.b * 255.0 + 0.5);
            let a = u32(color.a * 255.0 + 0.5);
            
            let packed = r | (g << 8) | (b << 16) | (a << 24);
            
            let index = y * dims.x + x;
            outputBuffer[index] = packed;
        }
    `,label:"HSL Pack Shader"}),I=await n.createComputePipelineAsync({layout:"auto",compute:{module:C,entryPoint:"main"},label:"HSL Pack Pipeline"}),$=n.createBindGroup({layout:I.getBindGroupLayout(0),entries:[{binding:0,resource:m.createView()},{binding:1,resource:{buffer:v}}],label:"HSL Pack BindGroup"}),T=n.createCommandEncoder({label:"HSL Pack Encoder"}),S=T.beginComputePass({label:"HSL Pack Pass"});return S.setPipeline(I),S.setBindGroup(0,$),S.dispatchWorkgroups(Math.ceil(t.width/16),Math.ceil(t.height/16)),S.end(),n.queue.submit([T.finish()]),await n.queue.onSubmittedWorkDone(),l.destroy(),p.destroy(),b.forEach(E=>{E!==m&&E.destroy()}),m!==l&&!b.includes(m)&&m.destroy(),r.destroy(),{buffer:v,width:t.width,height:t.height}}const Vj="",Wj="2D",Hj="",Kj=": {src}",RE=(t,e)=>{if(e<=0)throw new Error(Vj);const n=document.createElement("canvas"),s=n.getContext("2d");if(!s)throw new Error(Wj);const r=Math.max(t.width,t.height);if(r<=e)return n.width=t.width,n.height=t.height,s.drawImage(t,0,0),n;const i=e/r,o=Math.round(t.width*i),a=Math.round(t.height*i);return n.width=o,n.height=a,s.imageSmoothingEnabled=!0,s.imageSmoothingQuality="high",s.drawImage(t,0,0,o,a),n},jj=t=>new Promise((e,n)=>{if(!t||typeof t!="string"){n(new Error(Hj));return}const s=new Image;s.crossOrigin="anonymous",s.onload=()=>e(s),s.onerror=()=>n(new Error(Kj.replace("{src}",t))),s.src=t});async function El(t,e,n,s){const r=e*n*4,i=s.createBuffer({size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),o=s.createCommandEncoder();if(t instanceof GPUBuffer)o.copyBufferToBuffer(t,0,i,0,r);else{const c=e*4,h=Math.ceil(c/256)*256,d=h*n,f=s.createBuffer({size:d,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});o.copyTextureToBuffer({texture:t},{buffer:f,bytesPerRow:h},{width:e,height:n}),o.copyBufferToBuffer(f,0,i,0,r),f.destroy()}s.queue.submit([o.finish()]),await i.mapAsync(GPUMapMode.READ);const a=i.getMappedRange(),l=new Uint8ClampedArray(a.slice(0));return i.unmap(),i.destroy(),new ImageData(l,e,n)}let Bp=null,bh=null;async function Xj(){if(Bp)return Bp;if(bh)return bh;bh=qj();try{return Bp=await bh,Bp}catch(t){throw bh=null,t}}async function qj(){if(!navigator.gpu)throw new Error("WebGPU ");const t=await navigator.gpu.requestAdapter();if(!t)throw new Error(" WebGPU ");const e={maxComputeInvocationsPerWorkgroup:1024,maxComputeWorkgroupSizeX:32,maxComputeWorkgroupSizeY:32,maxComputeWorkgroupSizeZ:64},n=await t.requestDevice({requiredLimits:e});if(!n)throw new Error(" WebGPU ");const s=document.createElement("canvas"),r=s.getContext("webgpu");if(!r)throw new Error(" WebGPU ");return{device:n,context:r,canvas:s}}function Yj(t,e,n=64,s){const r=t.createTexture({size:{width:e.width,height:e.height,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),i=t.createTexture({size:{width:e.width,height:e.height,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC}),o=t.createTexture({size:{width:n,height:n,depthOrArrayLayers:n},dimension:"3d",format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),a=r.createView(),l=i.createView(),u=o.createView({dimension:"3d"}),c={inputTexture:r,outputTexture:i,lutTexture:o,inputTextureView:a,outputTextureView:l,lutTextureView:u};if(s){const h=t.createTexture({size:{width:s.width,height:s.height,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),d=h.createView();c.maskTexture=h,c.maskTextureView=d}return c}function Zj(t){t.inputTexture.destroy(),t.outputTexture.destroy(),t.lutTexture.destroy(),t.maskTexture&&t.maskTexture.destroy()}function Qj(t,e){const n=t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return t.queue.writeBuffer(n,0,e),n}function tC(t){return t.createSampler({addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"})}const AE=(t,e)=>`
struct Params {
    intensity: f32,      // LUT 
    lutSize: f32,        // LUT 
    maskIntensity: f32,  // 
    enableMask: f32,     //  (0.0 = , 1.0 = )
    maskOffsetX: f32,    // X
    maskOffsetY: f32,    // Y
    maskWidth: f32,      // 
    maskHeight: f32      // 
}

@group(0) @binding(0) var inputTexture: texture_2d<f32>;           // 
@group(0) @binding(1) var lutTexture: texture_3d<f32>;             // 3D LUT 
@group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>; // 
@group(0) @binding(3) var lutSampler: sampler;                   // LUT 
@group(0) @binding(4) var maskTexture: texture_2d<f32>;          // 
@group(0) @binding(5) var maskSampler: sampler;                  // 
@group(0) @binding(6) var<uniform> params: Params;               // Uniform 

// 
@compute @workgroup_size(${t}, ${e})
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let dims = textureDimensions(inputTexture);
    let coords = vec2<u32>(global_id.xy);

    // 
    if (coords.x >= dims.x || coords.y >= dims.y) {
        return;
    }

    // 
    let originalColor = textureLoad(inputTexture, vec2<i32>(coords), 0);
    
    // LUT
    let lutSizeMinusOne = params.lutSize - 1.0;
    let lutSizeRecip = 1.0 / params.lutSize;
    let halfLutSizeRecip = 0.5 * lutSizeRecip;
    
    let lutCoord = originalColor.rgb * (lutSizeMinusOne * lutSizeRecip) + halfLutSizeRecip;

    // LUT
    let lutColor = textureSampleLevel(lutTexture, lutSampler, lutCoord, 0.0);

    // 
    var finalIntensity = params.intensity;
    
    // 
    if (params.enableMask > 0.5) {
        //  + 
        let globalX = params.maskOffsetX + f32(coords.x);
        let globalY = params.maskOffsetY + f32(coords.y);
        
        // 
        // 
        let maskCoordX = globalX / f32(textureDimensions(maskTexture).x);
        let maskCoordY = globalY / f32(textureDimensions(maskTexture).y);
        
        // 
        if (maskCoordX >= 0.0 && maskCoordX <= 1.0 && maskCoordY >= 0.0 && maskCoordY <= 1.0) {
            let maskColor = textureSampleLevel(maskTexture, maskSampler, vec2<f32>(maskCoordX, maskCoordY), 0.0);
            // R
            let maskValue = maskColor.r;
            // 
            finalIntensity = params.intensity * (1.0 - maskValue) * params.maskIntensity;
        }
    }

    // LUT
    let newColor = vec4<f32>(
        mix(originalColor.rgb, lutColor.rgb, finalIntensity),
        originalColor.a
    );

    // 
    textureStore(outputTexture, coords, newColor);
}
`,Jj=AE(16,16),eX=AE(32,32);function tX(t,e=!1){const n=e?eX:Jj;return t.createShaderModule({code:n,label:e?"LUT Compute Shader (High Performance)":"LUT Compute Shader (Optimized)"})}function nX(t,e=!1){const n=tX(t,e);return t.createComputePipeline({layout:"auto",compute:{module:n,entryPoint:"main"}})}function sX(t,e,n=!1){const s=n?32:16;return[Math.ceil(t/s),Math.ceil(e/s)]}function rX(t,e,n,s){const r=tC(t),i=tC(t),o=[{binding:0,resource:n.inputTextureView},{binding:1,resource:n.lutTextureView},{binding:2,resource:n.outputTextureView},{binding:3,resource:r}];return n.maskTextureView?o.push({binding:4,resource:n.maskTextureView},{binding:5,resource:i},{binding:6,resource:{buffer:s}}):o.push({binding:4,resource:n.inputTextureView},{binding:5,resource:r},{binding:6,resource:{buffer:s}}),t.createBindGroup({layout:e.getBindGroupLayout(0),entries:o})}function iX(t,e,n){t.queue.writeTexture({texture:e},n.data,{bytesPerRow:n.width*4,rowsPerImage:n.height},{width:n.width,height:n.height,depthOrArrayLayers:1})}function oX(t,e,n,s=64){const r=s*s*s*4;if(n.length!==r)throw new Error(`LUT: ${r}${n.length}`);t.queue.writeTexture({texture:e},n,{bytesPerRow:s*4,rowsPerImage:s},{width:s,height:s,depthOrArrayLayers:s})}async function aX(t,e,n,s){const r=Math.ceil(n*4/256)*256,i=r*s,o=t.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),a=t.createCommandEncoder();a.copyTextureToBuffer({texture:e},{buffer:o,bytesPerRow:r,rowsPerImage:s},{width:n,height:s,depthOrArrayLayers:1}),t.queue.submit([a.finish()]),await o.mapAsync(GPUMapMode.READ);const l=new Uint8Array(o.getMappedRange()),u=new Uint8Array(n*s*4);if(r===n*4)u.set(l);else for(let c=0;c<s;c++){const h=c*r,d=c*n*4;u.set(l.slice(h,h+n*4),d)}return o.unmap(),o.destroy(),u}function lX(t,e,n){t.queue.writeTexture({texture:e},n.data,{bytesPerRow:n.width*4,rowsPerImage:n.height},{width:n.width,height:n.height,depthOrArrayLayers:1})}function uX(t,e,n,s,r,i){iX(t,e.inputTexture,n),oX(t,e.lutTexture,s,r),e.maskTexture&&i&&lX(t,e.maskTexture,i)}const cX={"text/plain":"cube","application/octet-stream":"cube","text/cube":"cube"};function hX(t){const e=t.type.toLowerCase(),n=cX[e];return{format:e,supported:!!n,extension:n||"unknown"}}function dX(t){var d;const e=t.split(`
`),n=[];for(let f=0;f<e.length;f++){const p=(d=e[f])==null?void 0:d.trim();p&&!p.startsWith("#")&&n.push(p)}let s=64,r,i;const o=s*s*s*3,a=new Array(o);let l=0;for(let f=0;f<n.length;f++){const p=n[f];if(p.startsWith("LUT_3D_SIZE")){const g=p.split(" ")[1];if(g){const m=parseInt(g);if(m>0){s=m;const x=s*s*s*3;l===0&&(a.length=x)}}}else if(p.startsWith("TITLE"))r=p.split(" ").slice(1).join(" ").replace(/"/g,"");else if(p.startsWith("DOMAIN_MIN")){const g=p.split(" ").slice(1).map(Number);i=i||{min:[0,0,0],max:[1,1,1]},g[0]!==void 0&&g[1]!==void 0&&g[2]!==void 0&&(i.min=[g[0],g[1],g[2]])}else if(p.startsWith("DOMAIN_MAX")){const g=p.split(" ").slice(1).map(Number);i=i||{min:[0,0,0],max:[1,1,1]},g[0]!==void 0&&g[1]!==void 0&&g[2]!==void 0&&(i.max=[g[0],g[1],g[2]])}else{const g=p.split(/\s+/);let m=0;for(let x=0;x<g.length&&m<3;x++){const b=parseFloat(g[x]);isNaN(b)||(a[l+m]=b,m++)}m>=3&&(l+=3)}}const u=s*s*s*3;if(l!==u)throw new Error(`LUT: ${u}${l}`);const c=new Uint8Array(s*s*s*4);for(let f=0;f<l;f+=3){const p=Math.floor(f*4/3),g=a[f],m=a[f+1],x=a[f+2];g!==void 0&&m!==void 0&&x!==void 0&&(c[p]=Math.floor(g*255),c[p+1]=Math.floor(m*255),c[p+2]=Math.floor(x*255),c[p+3]=255)}const h={data:c,size:s};return r!==void 0&&(h.title=r),i!==void 0&&(h.domain=i),h}async function fX(t,e){try{let n,s,r;if(typeof t=="string"){const o=await fetch(t);if(!o.ok)throw new Error(`LUT: ${o.statusText}`);s=await o.blob(),n=await s.text()}else if(t instanceof Blob)s=t,n=await s.text();else if(t instanceof ArrayBuffer)s=new Blob([t],{type:"text/plain"}),n=new TextDecoder().decode(t);else throw new Error("LUT");if(r=hX(s),!r.supported)throw new Error(`LUT: ${r.format}`);return{data:dX(n).data,blob:s,blobURL:URL.createObjectURL(s),fileName:e||`lut.${r.extension}`,fileSize:s.size}}catch(n){throw new Error(`LUT: ${n instanceof Error?n.message:""}`)}}async function pX(t,e,n={}){const{intensity:s=1,debug:r=!1,highPerformance:i=!1,maskData:o,maskIntensity:a=1,enableMask:l=!1,maskOffsetX:u=0,maskOffsetY:c=0,maskWidth:h,maskHeight:d}=n;let f=null,p=null;try{if(!t||!e)throw new Error("LUT");const g=Math.cbrt(e.length/4);if(!Number.isInteger(g)||g<=0)throw new Error(`LUT: ${e.length}`);r&&console.log("LUT:",{imageSize:`${t.width}x${t.height}`,lutDataSize:e.length,lutSize:g,intensity:s,highPerformance:i,enableMask:l,maskIntensity:a,maskData:o?`${o.width}x${o.height}`:""});const{device:m}=await Xj(),x=Yj(m,t,g,l&&o?o:void 0);f=x;const b=new Float32Array([s,g,a,l?1:0,u||0,c||0,h||0,d||0]);p=Qj(m,b);const v=nX(m,i),y=rX(m,v,x,p);uX(m,x,t,e,g,l&&o?o:void 0);const[C,I]=sX(t.width,t.height,i);r&&console.log(":",{workgroupsX:C,workgroupsY:I,workgroupSize:i?"32x32":"16x16",totalWorkgroups:C*I});const $=m.createCommandEncoder(),T=$.beginComputePass();T.setPipeline(v),T.setBindGroup(0,y),T.dispatchWorkgroups(C,I),T.end(),m.queue.submit([$.finish()]);const S=await aX(m,x.outputTexture,t.width,t.height);return r&&console.log("LUT"),{success:!0,result:S}}catch(g){const m=g instanceof Error?g.message:"";return console.error("LUT:",m),{success:!1,error:m}}finally{f&&Zj(f),p&&p.destroy()}}const nC=t=>({data:Array.from(t.data),width:t.width,height:t.height});function mX(t,e){const n=[],s=t*e;for(let r=0;r<s;r++)n.push(0),n.push(0),n.push(0),n.push(255);return{data:n,width:t,height:e}}const gX=new Map;function qo(t){return function(...e){const n=performance.now();let s=t(...e);const r=()=>{const o=(performance.now()-n).toFixed(2);gX.set(t,o),console.log(`Function ${t.name||"anonymous"} took ${o} milliseconds.n/${new Error().stack}`)};return s instanceof Promise?s.then(i=>(r(),i)).catch(i=>{throw r(),i}):(r(),s)}}const xX=`struct Uniforms {\r
  width: u32,\r
  height: u32,\r
};\r
\r
@group(0) @binding(0) var<storage, read> dataRGBA: array<f32>;\r
@group(0) @binding(1) var<storage, read> eigenVectors: array<f32>;\r
@group(0) @binding(2) var<storage, read_write> outputValues: array<f32>;  // RGB\r
@group(0) @binding(3) var<storage, read_write> outputOffsets: array<u32>; // \r
@group(0) @binding(4) var<uniform> uniforms: Uniforms;\r
\r
// \r
fn dotProduct(px: f32, py: f32, pz: f32, ev0: f32, ev1: f32, ev2: f32) -> f32 {\r
  return px * ev0 + py * ev1 + pz * ev2;\r
}\r
\r
@compute @workgroup_size(16, 16)\r
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r
  let width = uniforms.width;\r
  let height = uniforms.height;\r
  \r
  let i = global_id.x;\r
  let j = global_id.y;\r
  \r
  // \r
  if (i >= width || j >= height) {\r
    return;\r
  }\r
  \r
  let pixelIndex = j * width + i;\r
  let rgbaIndex = pixelIndex * 4u; // 4(RGBA)\r
  \r
  // RGBARGB\r
  let pixelR = dataRGBA[rgbaIndex];\r
  let pixelG = dataRGBA[rgbaIndex + 1u];\r
  let pixelB = dataRGBA[rgbaIndex + 2u];\r
  \r
  // \r
  let valueR = dotProduct(pixelR, pixelG, pixelB, eigenVectors[0], eigenVectors[1], eigenVectors[2]);\r
  let valueG = dotProduct(pixelR, pixelG, pixelB, eigenVectors[3], eigenVectors[4], eigenVectors[5]);\r
  let valueB = dotProduct(pixelR, pixelG, pixelB, eigenVectors[6], eigenVectors[7], eigenVectors[8]);\r
  \r
  // \r
  let pixelOffset = pixelIndex;\r
  outputValues[pixelIndex * 3u] = valueR;\r
  outputValues[pixelIndex * 3u + 1u] = valueG;\r
  outputValues[pixelIndex * 3u + 2u] = valueB;\r
  outputOffsets[pixelIndex * 3u] = pixelOffset;\r
  outputOffsets[pixelIndex * 3u + 1u] = pixelOffset;\r
  outputOffsets[pixelIndex * 3u + 2u] = pixelOffset;\r
}`,_b=Symbol.for("webgpu_cache"),e0=async()=>{const t=window;t[_b]||(t[_b]={:null,:null});const e=t[_b];if(e.)return e.;if(!navigator.gpu)throw new Error("WebGPU ");if(e.=await navigator.gpu.requestAdapter(),!e.)throw new Error(" WebGPU ");const n=e..limits,s=Math.min(n.maxStorageBufferBindingSize||134217728,2147483644);if(e.=await e..requestDevice({requiredLimits:{maxStorageBufferBindingSize:s}}),!e.)throw new Error(" WebGPU ");return e.},sC=(t,e,n,s)=>{if(!e||e.length===0)throw new Error(": 0");const r=t.createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:s});return new Float32Array(r.getMappedRange()).set(e),r.unmap(),r},bX=`@group(0) @binding(0) var<storage, read_write> channelValues: array<f32>;\r
@group(0) @binding(1) var<storage, read_write> channelPixelOffsets: array<u32>;\r
@group(0) @binding(2) var<uniform> params: Params;\r
\r
struct Params {\r
    k: u32,\r
    j: u32,\r
    element_count: u32,\r
    total_invocations: u32,\r
    channel_count: u32,\r
};\r
\r
@compute @workgroup_size(256)\r
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r
    let thread_index = global_id.x;\r
    let element_count = params.element_count;\r
    let k = params.k;\r
    let j = params.j;\r
    let total_invocations = params.total_invocations;\r
    let channel_count = params.channel_count;\r
\r
    for (var i = thread_index; i < element_count; i = i + total_invocations) {\r
        let ix = i;\r
        let jx = ix ^ j;\r
        \r
        if (jx >= element_count || jx < ix) {\r
            continue;\r
        }\r
        \r
        let direction = ((ix & k) == 0u);\r
        \r
        // \r
        for (var channel = 0u; channel < channel_count; channel = channel + 1u) {\r
            let val_i = channelValues[ix * channel_count + channel];\r
            let val_j = channelValues[jx * channel_count + channel];\r
            \r
            if (direction == (val_i > val_j)) {\r
                // \r
                let temp_val = channelValues[ix * channel_count + channel];\r
                channelValues[ix * channel_count + channel] = channelValues[jx * channel_count + channel];\r
                channelValues[jx * channel_count + channel] = temp_val;\r
\r
                // \r
                let temp_offset = channelPixelOffsets[ix * channel_count + channel];\r
                channelPixelOffsets[ix * channel_count + channel] = channelPixelOffsets[jx * channel_count + channel];\r
                channelPixelOffsets[jx * channel_count + channel] = temp_offset;\r
            }\r
        }\r
    }\r
}`,yX=t=>(t&t-1)===0&&t!==0,vX=t=>{if(t<=0)return 1;let e=1;for(;e<t;)e<<=1;return e},rC=(t,e,n,s,r)=>{for(let i=e;i<n;i++)for(let o=0;o<r;o++)t[i*r+o]=s},wX=async(t,e,n)=>{const s=await e0(),r=t.length/n;let i=r;yX(r)||(i=vX(r));const o=i!==r,a=new Float32Array(i*n),l=new Uint32Array(i*n);a.set(t),l.set(e),o&&(rC(a,r,i,1/0,n),rC(l,r,i,0,n));const u=s.createShaderModule({code:bX}),c=s.createComputePipeline({layout:s.createPipelineLayout({bindGroupLayouts:[s.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]})]}),compute:{module:u,entryPoint:"main"}}),h=s.createBuffer({size:a.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),d=s.createBuffer({size:l.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(h,0,a),s.queue.writeBuffer(d,0,l),await s.queue.onSubmittedWorkDone();const f=s.createCommandEncoder(),p=Math.ceil(i/256)*256;for(let b=2;b<=i;b<<=1)for(let v=b>>1;v>0;v=v>>1){const y=s.createBuffer({size:20,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:`params_k${b}_j${v}`});s.queue.writeBuffer(y,0,new Uint32Array([b,v,i,p,n]));const C=s.createBindGroup({layout:c.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:h}},{binding:1,resource:{buffer:d}},{binding:2,resource:{buffer:y}}],label:`bindGroup_k${b}_j${v}`}),I=f.beginComputePass();I.setPipeline(c),I.setBindGroup(0,C),I.dispatchWorkgroups(Math.ceil(i/256)),I.end()}s.queue.submit([f.finish()]),await s.queue.onSubmittedWorkDone();const g=s.createBuffer({size:l.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),m=s.createCommandEncoder();m.copyBufferToBuffer(d,0,g,0,l.byteLength),s.queue.submit([m.finish()]),await g.mapAsync(GPUMapMode.READ);const x=new Uint32Array(g.getMappedRange().slice(0));return g.unmap(),x},iC=16,SX=async(t,e,n)=>{const{width:s,height:r}=e,i=s*r,o=new Float32Array(e.data),a=new Float32Array(n.flat()),l=t.createShaderModule({code:xX,label:""}),u=new Uint32Array([s,r]),c=t.createBuffer({size:u.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0,label:"Uniform"});new Uint32Array(c.getMappedRange()).set(u),c.unmap();const h=sC(t,o,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,"RGBA"),d=sC(t,a,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,""),f=t.createBuffer({size:i*3*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,label:""}),p=t.createBuffer({size:i*3*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,label:""}),g=t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}],label:""}),m=t.createBindGroup({layout:g,entries:[{binding:0,resource:{buffer:h}},{binding:1,resource:{buffer:d}},{binding:2,resource:{buffer:f}},{binding:3,resource:{buffer:p}},{binding:4,resource:{buffer:c}}],label:""}),x=t.createComputePipeline({layout:t.createPipelineLayout({bindGroupLayouts:[g],label:""}),compute:{module:l,entryPoint:"main"},label:""}),b=t.createCommandEncoder({label:""}),v=b.beginComputePass({label:""});v.setPipeline(x),v.setBindGroup(0,m);const y=Math.ceil(s/iC),C=Math.ceil(r/iC);v.dispatchWorkgroups(y,C),v.end(),t.queue.submit([b.finish()]),await t.queue.onSubmittedWorkDone();const I=t.createBuffer({size:i*3*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:""}),$=t.createBuffer({size:i*3*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:""}),T=t.createCommandEncoder({label:""});T.copyBufferToBuffer(f,0,I,0,i*3*4),T.copyBufferToBuffer(p,0,$,0,i*3*4),t.queue.submit([T.finish()]),await t.queue.onSubmittedWorkDone(),await Promise.all([I.mapAsync(GPUMapMode.READ),$.mapAsync(GPUMapMode.READ)]);const S=I.getMappedRange(),E=$.getMappedRange(),_=new Float32Array(S.slice(0)),N=new Uint32Array(E.slice(0));return I.unmap(),$.unmap(),await wX(_,N,3)},CX=async(t,e)=>{const n=await e0();return SX(n,t,e)};function zp(t){throw new Error('Could not dynamically require "'+t+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var PE={exports:{}};/**
 * gpu.js
 * http://gpu.rocks/
 *
 * GPU Accelerated JavaScript
 *
 * @version 2.16.0
 * @date Wed Nov 16 2022 15:48:37 GMT-0500 (Eastern Standard Time)
 *
 * @license MIT
 * The MIT License
 *
 * Copyright (c) 2022 gpu.js Team
 */(function(t,e){(function(n){t.exports=n()})(function(){return function(){function n(s,r,i){function o(u,c){if(!r[u]){if(!s[u]){var h=typeof zp=="function"&&zp;if(!c&&h)return h(u,!0);if(a)return a(u,!0);var d=new Error("Cannot find module '"+u+"'");throw d.code="MODULE_NOT_FOUND",d}var f=r[u]={exports:{}};s[u][0].call(f.exports,function(p){var g=s[u][1][p];return o(g||p)},f,f.exports,n,s,r,i)}return r[u].exports}for(var a=typeof zp=="function"&&zp,l=0;l<i.length;l++)o(i[l]);return o}return n}()({1:[function(n,s,r){(function(i,o){typeof r=="object"&&typeof s<"u"?o(r):(i=i||self,o(i.acorn={}))})(this,function(i){var o={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"},a="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",l={5:a,"5module":a+" export import",6:a+" const class extends export import super"},u=/^in(stanceof)?$/,c="---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",h="--------------------------------------------------------------------------------------------------------------------------------------------------",d=new RegExp("["+c+"]"),f=new RegExp("["+c+h+"]");c=h=null;var p=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541],g=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];function m(w,R){for(var O=65536,W=0;W<R.length;W+=2){if(O+=R[W],O>w)return!1;if(O+=R[W+1],O>=w)return!0}}function x(w,R){return w<65?w===36:w<91?!0:w<97?w===95:w<123?!0:w<=65535?w>=170&&d.test(String.fromCharCode(w)):R===!1?!1:m(w,p)}function b(w,R){return w<48?w===36:w<58?!0:w<65?!1:w<91?!0:w<97?w===95:w<123?!0:w<=65535?w>=170&&f.test(String.fromCharCode(w)):R===!1?!1:m(w,p)||m(w,g)}var v=function(R,O){O===void 0&&(O={}),this.label=R,this.keyword=O.keyword,this.beforeExpr=!!O.beforeExpr,this.startsExpr=!!O.startsExpr,this.isLoop=!!O.isLoop,this.isAssign=!!O.isAssign,this.prefix=!!O.prefix,this.postfix=!!O.postfix,this.binop=O.binop||null,this.updateContext=null};function y(w,R){return new v(w,{beforeExpr:!0,binop:R})}var C={beforeExpr:!0},I={startsExpr:!0},$={};function T(w,R){return R===void 0&&(R={}),R.keyword=w,$[w]=new v(w,R)}var S={num:new v("num",I),regexp:new v("regexp",I),string:new v("string",I),name:new v("name",I),eof:new v("eof"),bracketL:new v("[",{beforeExpr:!0,startsExpr:!0}),bracketR:new v("]"),braceL:new v("{",{beforeExpr:!0,startsExpr:!0}),braceR:new v("}"),parenL:new v("(",{beforeExpr:!0,startsExpr:!0}),parenR:new v(")"),comma:new v(",",C),semi:new v(";",C),colon:new v(":",C),dot:new v("."),question:new v("?",C),arrow:new v("=>",C),template:new v("template"),invalidTemplate:new v("invalidTemplate"),ellipsis:new v("...",C),backQuote:new v("`",I),dollarBraceL:new v("${",{beforeExpr:!0,startsExpr:!0}),eq:new v("=",{beforeExpr:!0,isAssign:!0}),assign:new v("_=",{beforeExpr:!0,isAssign:!0}),incDec:new v("++/--",{prefix:!0,postfix:!0,startsExpr:!0}),prefix:new v("!/~",{beforeExpr:!0,prefix:!0,startsExpr:!0}),logicalOR:y("||",1),logicalAND:y("&&",2),bitwiseOR:y("|",3),bitwiseXOR:y("^",4),bitwiseAND:y("&",5),equality:y("==/!=/===/!==",6),relational:y("</>/<=/>=",7),bitShift:y("<</>>/>>>",8),plusMin:new v("+/-",{beforeExpr:!0,binop:9,prefix:!0,startsExpr:!0}),modulo:y("%",10),star:y("*",10),slash:y("/",10),starstar:new v("**",{beforeExpr:!0}),_break:T("break"),_case:T("case",C),_catch:T("catch"),_continue:T("continue"),_debugger:T("debugger"),_default:T("default",C),_do:T("do",{isLoop:!0,beforeExpr:!0}),_else:T("else",C),_finally:T("finally"),_for:T("for",{isLoop:!0}),_function:T("function",I),_if:T("if"),_return:T("return",C),_switch:T("switch"),_throw:T("throw",C),_try:T("try"),_var:T("var"),_const:T("const"),_while:T("while",{isLoop:!0}),_with:T("with"),_new:T("new",{beforeExpr:!0,startsExpr:!0}),_this:T("this",I),_super:T("super",I),_class:T("class",I),_extends:T("extends",C),_export:T("export"),_import:T("import",I),_null:T("null",I),_true:T("true",I),_false:T("false",I),_in:T("in",{beforeExpr:!0,binop:7}),_instanceof:T("instanceof",{beforeExpr:!0,binop:7}),_typeof:T("typeof",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_void:T("void",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_delete:T("delete",{beforeExpr:!0,prefix:!0,startsExpr:!0})},E=/\r\n?|\n|\u2028|\u2029/,_=new RegExp(E.source,"g");function N(w,R){return w===10||w===13||!R&&(w===8232||w===8233)}var P=/[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,M=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,z=Object.prototype,A=z.hasOwnProperty,B=z.toString;function L(w,R){return A.call(w,R)}var U=Array.isArray||function(w){return B.call(w)==="[object Array]"};function j(w){return new RegExp("^(?:"+w.replace(/ /g,"|")+")$")}var Z=function(R,O){this.line=R,this.column=O};Z.prototype.offset=function(R){return new Z(this.line,this.column+R)};var J=function(R,O,W){this.start=O,this.end=W,R.sourceFile!==null&&(this.source=R.sourceFile)};function se(w,R){for(var O=1,W=0;;){_.lastIndex=W;var Y=_.exec(w);if(Y&&Y.index<R)++O,W=Y.index+Y[0].length;else return new Z(O,R-W)}}var fe={ecmaVersion:10,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowAwaitOutsideFunction:!1,allowHashBang:!1,locations:!1,onToken:null,onComment:null,ranges:!1,program:null,sourceFile:null,directSourceFile:null,preserveParens:!1};function he(w){var R={};for(var O in fe)R[O]=w&&L(w,O)?w[O]:fe[O];if(R.ecmaVersion>=2015&&(R.ecmaVersion-=2009),R.allowReserved==null&&(R.allowReserved=R.ecmaVersion<5),U(R.onToken)){var W=R.onToken;R.onToken=function(Y){return W.push(Y)}}return U(R.onComment)&&(R.onComment=ve(R,R.onComment)),R}function ve(w,R){return function(O,W,Y,ge,Ce,et){var gt={type:O?"Block":"Line",value:W,start:Y,end:ge};w.locations&&(gt.loc=new J(this,Ce,et)),w.ranges&&(gt.range=[Y,ge]),R.push(gt)}}var Pe=1,Ee=2,Se=Pe|Ee,ze=4,ke=8,H=16,K=32,re=64,pe=128;function me(w,R){return Ee|(w?ze:0)|(R?ke:0)}var xe=0,Te=1,De=2,Re=3,_e=4,nt=5,Ae=function(R,O,W){this.options=R=he(R),this.sourceFile=R.sourceFile,this.keywords=j(l[R.ecmaVersion>=6?6:R.sourceType==="module"?"5module":5]);var Y="";if(R.allowReserved!==!0){for(var ge=R.ecmaVersion;!(Y=o[ge]);ge--);R.sourceType==="module"&&(Y+=" await")}this.reservedWords=j(Y);var Ce=(Y?Y+" ":"")+o.strict;this.reservedWordsStrict=j(Ce),this.reservedWordsStrictBind=j(Ce+" "+o.strictBind),this.input=String(O),this.containsEsc=!1,W?(this.pos=W,this.lineStart=this.input.lastIndexOf(`
`,W-1)+1,this.curLine=this.input.slice(0,this.lineStart).split(E).length):(this.pos=this.lineStart=0,this.curLine=1),this.type=S.eof,this.value=null,this.start=this.end=this.pos,this.startLoc=this.endLoc=this.curPosition(),this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,this.context=this.initialContext(),this.exprAllowed=!0,this.inModule=R.sourceType==="module",this.strict=this.inModule||this.strictDirective(this.pos),this.potentialArrowAt=-1,this.yieldPos=this.awaitPos=this.awaitIdentPos=0,this.labels=[],this.undefinedExports={},this.pos===0&&R.allowHashBang&&this.input.slice(0,2)==="#!"&&this.skipLineComment(2),this.scopeStack=[],this.enterScope(Pe),this.regexpState=null},Je={inFunction:{configurable:!0},inGenerator:{configurable:!0},inAsync:{configurable:!0},allowSuper:{configurable:!0},allowDirectSuper:{configurable:!0},treatFunctionsAsVar:{configurable:!0}};Ae.prototype.parse=function(){var R=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel(R)},Je.inFunction.get=function(){return(this.currentVarScope().flags&Ee)>0},Je.inGenerator.get=function(){return(this.currentVarScope().flags&ke)>0},Je.inAsync.get=function(){return(this.currentVarScope().flags&ze)>0},Je.allowSuper.get=function(){return(this.currentThisScope().flags&re)>0},Je.allowDirectSuper.get=function(){return(this.currentThisScope().flags&pe)>0},Je.treatFunctionsAsVar.get=function(){return this.treatFunctionsAsVarInScope(this.currentScope())},Ae.prototype.inNonArrowFunction=function(){return(this.currentThisScope().flags&Ee)>0},Ae.extend=function(){for(var R=[],O=arguments.length;O--;)R[O]=arguments[O];for(var W=this,Y=0;Y<R.length;Y++)W=R[Y](W);return W},Ae.parse=function(R,O){return new this(O,R).parse()},Ae.parseExpressionAt=function(R,O,W){var Y=new this(W,R,O);return Y.nextToken(),Y.parseExpression()},Ae.tokenizer=function(R,O){return new this(O,R)},Object.defineProperties(Ae.prototype,Je);var tt=Ae.prototype,Tt=/^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;tt.strictDirective=function(w){for(;;){M.lastIndex=w,w+=M.exec(this.input)[0].length;var R=Tt.exec(this.input.slice(w));if(!R)return!1;if((R[1]||R[2])==="use strict")return!0;w+=R[0].length,M.lastIndex=w,w+=M.exec(this.input)[0].length,this.input[w]===";"&&w++}},tt.eat=function(w){return this.type===w?(this.next(),!0):!1},tt.isContextual=function(w){return this.type===S.name&&this.value===w&&!this.containsEsc},tt.eatContextual=function(w){return this.isContextual(w)?(this.next(),!0):!1},tt.expectContextual=function(w){this.eatContextual(w)||this.unexpected()},tt.canInsertSemicolon=function(){return this.type===S.eof||this.type===S.braceR||E.test(this.input.slice(this.lastTokEnd,this.start))},tt.insertSemicolon=function(){if(this.canInsertSemicolon())return this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),!0},tt.semicolon=function(){!this.eat(S.semi)&&!this.insertSemicolon()&&this.unexpected()},tt.afterTrailingComma=function(w,R){if(this.type===w)return this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),R||this.next(),!0},tt.expect=function(w){this.eat(w)||this.unexpected()},tt.unexpected=function(w){this.raise(w??this.start,"Unexpected token")};function $t(){this.shorthandAssign=this.trailingComma=this.parenthesizedAssign=this.parenthesizedBind=this.doubleProto=-1}tt.checkPatternErrors=function(w,R){if(w){w.trailingComma>-1&&this.raiseRecoverable(w.trailingComma,"Comma is not permitted after the rest element");var O=R?w.parenthesizedAssign:w.parenthesizedBind;O>-1&&this.raiseRecoverable(O,"Parenthesized pattern")}},tt.checkExpressionErrors=function(w,R){if(!w)return!1;var O=w.shorthandAssign,W=w.doubleProto;if(!R)return O>=0||W>=0;O>=0&&this.raise(O,"Shorthand property assignments are valid only in destructuring patterns"),W>=0&&this.raiseRecoverable(W,"Redefinition of __proto__ property")},tt.checkYieldAwaitInDefaultParams=function(){this.yieldPos&&(!this.awaitPos||this.yieldPos<this.awaitPos)&&this.raise(this.yieldPos,"Yield expression cannot be a default value"),this.awaitPos&&this.raise(this.awaitPos,"Await expression cannot be a default value")},tt.isSimpleAssignTarget=function(w){return w.type==="ParenthesizedExpression"?this.isSimpleAssignTarget(w.expression):w.type==="Identifier"||w.type==="MemberExpression"};var Ke=Ae.prototype;Ke.parseTopLevel=function(w){var R={};for(w.body||(w.body=[]);this.type!==S.eof;){var O=this.parseStatement(null,!0,R);w.body.push(O)}if(this.inModule)for(var W=0,Y=Object.keys(this.undefinedExports);W<Y.length;W+=1){var ge=Y[W];this.raiseRecoverable(this.undefinedExports[ge].start,"Export '"+ge+"' is not defined")}return this.adaptDirectivePrologue(w.body),this.next(),w.sourceType=this.options.sourceType,this.finishNode(w,"Program")};var Sn={kind:"loop"},Zn={kind:"switch"};Ke.isLet=function(w){if(this.options.ecmaVersion<6||!this.isContextual("let"))return!1;M.lastIndex=this.pos;var R=M.exec(this.input),O=this.pos+R[0].length,W=this.input.charCodeAt(O);if(W===91)return!0;if(w)return!1;if(W===123)return!0;if(x(W,!0)){for(var Y=O+1;b(this.input.charCodeAt(Y),!0);)++Y;var ge=this.input.slice(O,Y);if(!u.test(ge))return!0}return!1},Ke.isAsyncFunction=function(){if(this.options.ecmaVersion<8||!this.isContextual("async"))return!1;M.lastIndex=this.pos;var w=M.exec(this.input),R=this.pos+w[0].length;return!E.test(this.input.slice(this.pos,R))&&this.input.slice(R,R+8)==="function"&&(R+8===this.input.length||!b(this.input.charAt(R+8)))},Ke.parseStatement=function(w,R,O){var W=this.type,Y=this.startNode(),ge;switch(this.isLet(w)&&(W=S._var,ge="let"),W){case S._break:case S._continue:return this.parseBreakContinueStatement(Y,W.keyword);case S._debugger:return this.parseDebuggerStatement(Y);case S._do:return this.parseDoStatement(Y);case S._for:return this.parseForStatement(Y);case S._function:return w&&(this.strict||w!=="if"&&w!=="label")&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(Y,!1,!w);case S._class:return w&&this.unexpected(),this.parseClass(Y,!0);case S._if:return this.parseIfStatement(Y);case S._return:return this.parseReturnStatement(Y);case S._switch:return this.parseSwitchStatement(Y);case S._throw:return this.parseThrowStatement(Y);case S._try:return this.parseTryStatement(Y);case S._const:case S._var:return ge=ge||this.value,w&&ge!=="var"&&this.unexpected(),this.parseVarStatement(Y,ge);case S._while:return this.parseWhileStatement(Y);case S._with:return this.parseWithStatement(Y);case S.braceL:return this.parseBlock(!0,Y);case S.semi:return this.parseEmptyStatement(Y);case S._export:case S._import:if(this.options.ecmaVersion>10&&W===S._import){M.lastIndex=this.pos;var Ce=M.exec(this.input),et=this.pos+Ce[0].length,gt=this.input.charCodeAt(et);if(gt===40)return this.parseExpressionStatement(Y,this.parseExpression())}return this.options.allowImportExportEverywhere||(R||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),W===S._import?this.parseImport(Y):this.parseExport(Y,O);default:if(this.isAsyncFunction())return w&&this.unexpected(),this.next(),this.parseFunctionStatement(Y,!0,!w);var jt=this.value,sr=this.parseExpression();return W===S.name&&sr.type==="Identifier"&&this.eat(S.colon)?this.parseLabeledStatement(Y,jt,sr,w):this.parseExpressionStatement(Y,sr)}},Ke.parseBreakContinueStatement=function(w,R){var O=R==="break";this.next(),this.eat(S.semi)||this.insertSemicolon()?w.label=null:this.type!==S.name?this.unexpected():(w.label=this.parseIdent(),this.semicolon());for(var W=0;W<this.labels.length;++W){var Y=this.labels[W];if((w.label==null||Y.name===w.label.name)&&(Y.kind!=null&&(O||Y.kind==="loop")||w.label&&O))break}return W===this.labels.length&&this.raise(w.start,"Unsyntactic "+R),this.finishNode(w,O?"BreakStatement":"ContinueStatement")},Ke.parseDebuggerStatement=function(w){return this.next(),this.semicolon(),this.finishNode(w,"DebuggerStatement")},Ke.parseDoStatement=function(w){return this.next(),this.labels.push(Sn),w.body=this.parseStatement("do"),this.labels.pop(),this.expect(S._while),w.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(S.semi):this.semicolon(),this.finishNode(w,"DoWhileStatement")},Ke.parseForStatement=function(w){this.next();var R=this.options.ecmaVersion>=9&&(this.inAsync||!this.inFunction&&this.options.allowAwaitOutsideFunction)&&this.eatContextual("await")?this.lastTokStart:-1;if(this.labels.push(Sn),this.enterScope(0),this.expect(S.parenL),this.type===S.semi)return R>-1&&this.unexpected(R),this.parseFor(w,null);var O=this.isLet();if(this.type===S._var||this.type===S._const||O){var W=this.startNode(),Y=O?"let":this.value;return this.next(),this.parseVar(W,!0,Y),this.finishNode(W,"VariableDeclaration"),(this.type===S._in||this.options.ecmaVersion>=6&&this.isContextual("of"))&&W.declarations.length===1?(this.options.ecmaVersion>=9&&(this.type===S._in?R>-1&&this.unexpected(R):w.await=R>-1),this.parseForIn(w,W)):(R>-1&&this.unexpected(R),this.parseFor(w,W))}var ge=new $t,Ce=this.parseExpression(!0,ge);return this.type===S._in||this.options.ecmaVersion>=6&&this.isContextual("of")?(this.options.ecmaVersion>=9&&(this.type===S._in?R>-1&&this.unexpected(R):w.await=R>-1),this.toAssignable(Ce,!1,ge),this.checkLVal(Ce),this.parseForIn(w,Ce)):(this.checkExpressionErrors(ge,!0),R>-1&&this.unexpected(R),this.parseFor(w,Ce))},Ke.parseFunctionStatement=function(w,R,O){return this.next(),this.parseFunction(w,ms|(O?0:nr),!1,R)},Ke.parseIfStatement=function(w){return this.next(),w.test=this.parseParenExpression(),w.consequent=this.parseStatement("if"),w.alternate=this.eat(S._else)?this.parseStatement("if"):null,this.finishNode(w,"IfStatement")},Ke.parseReturnStatement=function(w){return!this.inFunction&&!this.options.allowReturnOutsideFunction&&this.raise(this.start,"'return' outside of function"),this.next(),this.eat(S.semi)||this.insertSemicolon()?w.argument=null:(w.argument=this.parseExpression(),this.semicolon()),this.finishNode(w,"ReturnStatement")},Ke.parseSwitchStatement=function(w){this.next(),w.discriminant=this.parseParenExpression(),w.cases=[],this.expect(S.braceL),this.labels.push(Zn),this.enterScope(0);for(var R,O=!1;this.type!==S.braceR;)if(this.type===S._case||this.type===S._default){var W=this.type===S._case;R&&this.finishNode(R,"SwitchCase"),w.cases.push(R=this.startNode()),R.consequent=[],this.next(),W?R.test=this.parseExpression():(O&&this.raiseRecoverable(this.lastTokStart,"Multiple default clauses"),O=!0,R.test=null),this.expect(S.colon)}else R||this.unexpected(),R.consequent.push(this.parseStatement(null));return this.exitScope(),R&&this.finishNode(R,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(w,"SwitchStatement")},Ke.parseThrowStatement=function(w){return this.next(),E.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),w.argument=this.parseExpression(),this.semicolon(),this.finishNode(w,"ThrowStatement")};var $s=[];Ke.parseTryStatement=function(w){if(this.next(),w.block=this.parseBlock(),w.handler=null,this.type===S._catch){var R=this.startNode();if(this.next(),this.eat(S.parenL)){R.param=this.parseBindingAtom();var O=R.param.type==="Identifier";this.enterScope(O?K:0),this.checkLVal(R.param,O?_e:De),this.expect(S.parenR)}else this.options.ecmaVersion<10&&this.unexpected(),R.param=null,this.enterScope(0);R.body=this.parseBlock(!1),this.exitScope(),w.handler=this.finishNode(R,"CatchClause")}return w.finalizer=this.eat(S._finally)?this.parseBlock():null,!w.handler&&!w.finalizer&&this.raise(w.start,"Missing catch or finally clause"),this.finishNode(w,"TryStatement")},Ke.parseVarStatement=function(w,R){return this.next(),this.parseVar(w,!1,R),this.semicolon(),this.finishNode(w,"VariableDeclaration")},Ke.parseWhileStatement=function(w){return this.next(),w.test=this.parseParenExpression(),this.labels.push(Sn),w.body=this.parseStatement("while"),this.labels.pop(),this.finishNode(w,"WhileStatement")},Ke.parseWithStatement=function(w){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),w.object=this.parseParenExpression(),w.body=this.parseStatement("with"),this.finishNode(w,"WithStatement")},Ke.parseEmptyStatement=function(w){return this.next(),this.finishNode(w,"EmptyStatement")},Ke.parseLabeledStatement=function(w,R,O,W){for(var Y=0,ge=this.labels;Y<ge.length;Y+=1){var Ce=ge[Y];Ce.name===R&&this.raise(O.start,"Label '"+R+"' is already declared")}for(var et=this.type.isLoop?"loop":this.type===S._switch?"switch":null,gt=this.labels.length-1;gt>=0;gt--){var jt=this.labels[gt];if(jt.statementStart===w.start)jt.statementStart=this.start,jt.kind=et;else break}return this.labels.push({name:R,kind:et,statementStart:this.start}),w.body=this.parseStatement(W?W.indexOf("label")===-1?W+"label":W:"label"),this.labels.pop(),w.label=O,this.finishNode(w,"LabeledStatement")},Ke.parseExpressionStatement=function(w,R){return w.expression=R,this.semicolon(),this.finishNode(w,"ExpressionStatement")},Ke.parseBlock=function(w,R){for(w===void 0&&(w=!0),R===void 0&&(R=this.startNode()),R.body=[],this.expect(S.braceL),w&&this.enterScope(0);!this.eat(S.braceR);){var O=this.parseStatement(null);R.body.push(O)}return w&&this.exitScope(),this.finishNode(R,"BlockStatement")},Ke.parseFor=function(w,R){return w.init=R,this.expect(S.semi),w.test=this.type===S.semi?null:this.parseExpression(),this.expect(S.semi),w.update=this.type===S.parenR?null:this.parseExpression(),this.expect(S.parenR),w.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(w,"ForStatement")},Ke.parseForIn=function(w,R){var O=this.type===S._in;return this.next(),R.type==="VariableDeclaration"&&R.declarations[0].init!=null&&(!O||this.options.ecmaVersion<8||this.strict||R.kind!=="var"||R.declarations[0].id.type!=="Identifier")?this.raise(R.start,(O?"for-in":"for-of")+" loop variable declaration may not have an initializer"):R.type==="AssignmentPattern"&&this.raise(R.start,"Invalid left-hand side in for-loop"),w.left=R,w.right=O?this.parseExpression():this.parseMaybeAssign(),this.expect(S.parenR),w.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(w,O?"ForInStatement":"ForOfStatement")},Ke.parseVar=function(w,R,O){for(w.declarations=[],w.kind=O;;){var W=this.startNode();if(this.parseVarId(W,O),this.eat(S.eq)?W.init=this.parseMaybeAssign(R):O==="const"&&!(this.type===S._in||this.options.ecmaVersion>=6&&this.isContextual("of"))?this.unexpected():W.id.type!=="Identifier"&&!(R&&(this.type===S._in||this.isContextual("of")))?this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value"):W.init=null,w.declarations.push(this.finishNode(W,"VariableDeclarator")),!this.eat(S.comma))break}return w},Ke.parseVarId=function(w,R){w.id=this.parseBindingAtom(),this.checkLVal(w.id,R==="var"?Te:De,!1)};var ms=1,nr=2,$a=4;Ke.parseFunction=function(w,R,O,W){this.initFunction(w),(this.options.ecmaVersion>=9||this.options.ecmaVersion>=6&&!W)&&(this.type===S.star&&R&nr&&this.unexpected(),w.generator=this.eat(S.star)),this.options.ecmaVersion>=8&&(w.async=!!W),R&ms&&(w.id=R&$a&&this.type!==S.name?null:this.parseIdent(),w.id&&!(R&nr)&&this.checkLVal(w.id,this.strict||w.generator||w.async?this.treatFunctionsAsVar?Te:De:Re));var Y=this.yieldPos,ge=this.awaitPos,Ce=this.awaitIdentPos;return this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(me(w.async,w.generator)),R&ms||(w.id=this.type===S.name?this.parseIdent():null),this.parseFunctionParams(w),this.parseFunctionBody(w,O,!1),this.yieldPos=Y,this.awaitPos=ge,this.awaitIdentPos=Ce,this.finishNode(w,R&ms?"FunctionDeclaration":"FunctionExpression")},Ke.parseFunctionParams=function(w){this.expect(S.parenL),w.params=this.parseBindingList(S.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams()},Ke.parseClass=function(w,R){this.next();var O=this.strict;this.strict=!0,this.parseClassId(w,R),this.parseClassSuper(w);var W=this.startNode(),Y=!1;for(W.body=[],this.expect(S.braceL);!this.eat(S.braceR);){var ge=this.parseClassElement(w.superClass!==null);ge&&(W.body.push(ge),ge.type==="MethodDefinition"&&ge.kind==="constructor"&&(Y&&this.raise(ge.start,"Duplicate constructor in the same class"),Y=!0))}return w.body=this.finishNode(W,"ClassBody"),this.strict=O,this.finishNode(w,R?"ClassDeclaration":"ClassExpression")},Ke.parseClassElement=function(w){var R=this;if(this.eat(S.semi))return null;var O=this.startNode(),W=function(gt,jt){jt===void 0&&(jt=!1);var sr=R.start,so=R.startLoc;return R.eatContextual(gt)?R.type!==S.parenL&&(!jt||!R.canInsertSemicolon())?!0:(O.key&&R.unexpected(),O.computed=!1,O.key=R.startNodeAt(sr,so),O.key.name=gt,R.finishNode(O.key,"Identifier"),!1):!1};O.kind="method",O.static=W("static");var Y=this.eat(S.star),ge=!1;Y||(this.options.ecmaVersion>=8&&W("async",!0)?(ge=!0,Y=this.options.ecmaVersion>=9&&this.eat(S.star)):W("get")?O.kind="get":W("set")&&(O.kind="set")),O.key||this.parsePropertyName(O);var Ce=O.key,et=!1;return!O.computed&&!O.static&&(Ce.type==="Identifier"&&Ce.name==="constructor"||Ce.type==="Literal"&&Ce.value==="constructor")?(O.kind!=="method"&&this.raise(Ce.start,"Constructor can't have get/set modifier"),Y&&this.raise(Ce.start,"Constructor can't be a generator"),ge&&this.raise(Ce.start,"Constructor can't be an async method"),O.kind="constructor",et=w):O.static&&Ce.type==="Identifier"&&Ce.name==="prototype"&&this.raise(Ce.start,"Classes may not have a static property named prototype"),this.parseClassMethod(O,Y,ge,et),O.kind==="get"&&O.value.params.length!==0&&this.raiseRecoverable(O.value.start,"getter should have no params"),O.kind==="set"&&O.value.params.length!==1&&this.raiseRecoverable(O.value.start,"setter should have exactly one param"),O.kind==="set"&&O.value.params[0].type==="RestElement"&&this.raiseRecoverable(O.value.params[0].start,"Setter cannot use rest params"),O},Ke.parseClassMethod=function(w,R,O,W){return w.value=this.parseMethod(R,O,W),this.finishNode(w,"MethodDefinition")},Ke.parseClassId=function(w,R){this.type===S.name?(w.id=this.parseIdent(),R&&this.checkLVal(w.id,De,!1)):(R===!0&&this.unexpected(),w.id=null)},Ke.parseClassSuper=function(w){w.superClass=this.eat(S._extends)?this.parseExprSubscripts():null},Ke.parseExport=function(w,R){if(this.next(),this.eat(S.star))return this.expectContextual("from"),this.type!==S.string&&this.unexpected(),w.source=this.parseExprAtom(),this.semicolon(),this.finishNode(w,"ExportAllDeclaration");if(this.eat(S._default)){this.checkExport(R,"default",this.lastTokStart);var O;if(this.type===S._function||(O=this.isAsyncFunction())){var W=this.startNode();this.next(),O&&this.next(),w.declaration=this.parseFunction(W,ms|$a,!1,O)}else if(this.type===S._class){var Y=this.startNode();w.declaration=this.parseClass(Y,"nullableID")}else w.declaration=this.parseMaybeAssign(),this.semicolon();return this.finishNode(w,"ExportDefaultDeclaration")}if(this.shouldParseExportStatement())w.declaration=this.parseStatement(null),w.declaration.type==="VariableDeclaration"?this.checkVariableExport(R,w.declaration.declarations):this.checkExport(R,w.declaration.id.name,w.declaration.id.start),w.specifiers=[],w.source=null;else{if(w.declaration=null,w.specifiers=this.parseExportSpecifiers(R),this.eatContextual("from"))this.type!==S.string&&this.unexpected(),w.source=this.parseExprAtom();else{for(var ge=0,Ce=w.specifiers;ge<Ce.length;ge+=1){var et=Ce[ge];this.checkUnreserved(et.local),this.checkLocalExport(et.local)}w.source=null}this.semicolon()}return this.finishNode(w,"ExportNamedDeclaration")},Ke.checkExport=function(w,R,O){w&&(L(w,R)&&this.raiseRecoverable(O,"Duplicate export '"+R+"'"),w[R]=!0)},Ke.checkPatternExport=function(w,R){var O=R.type;if(O==="Identifier")this.checkExport(w,R.name,R.start);else if(O==="ObjectPattern")for(var W=0,Y=R.properties;W<Y.length;W+=1){var ge=Y[W];this.checkPatternExport(w,ge)}else if(O==="ArrayPattern")for(var Ce=0,et=R.elements;Ce<et.length;Ce+=1){var gt=et[Ce];gt&&this.checkPatternExport(w,gt)}else O==="Property"?this.checkPatternExport(w,R.value):O==="AssignmentPattern"?this.checkPatternExport(w,R.left):O==="RestElement"?this.checkPatternExport(w,R.argument):O==="ParenthesizedExpression"&&this.checkPatternExport(w,R.expression)},Ke.checkVariableExport=function(w,R){if(w)for(var O=0,W=R;O<W.length;O+=1){var Y=W[O];this.checkPatternExport(w,Y.id)}},Ke.shouldParseExportStatement=function(){return this.type.keyword==="var"||this.type.keyword==="const"||this.type.keyword==="class"||this.type.keyword==="function"||this.isLet()||this.isAsyncFunction()},Ke.parseExportSpecifiers=function(w){var R=[],O=!0;for(this.expect(S.braceL);!this.eat(S.braceR);){if(O)O=!1;else if(this.expect(S.comma),this.afterTrailingComma(S.braceR))break;var W=this.startNode();W.local=this.parseIdent(!0),W.exported=this.eatContextual("as")?this.parseIdent(!0):W.local,this.checkExport(w,W.exported.name,W.exported.start),R.push(this.finishNode(W,"ExportSpecifier"))}return R},Ke.parseImport=function(w){return this.next(),this.type===S.string?(w.specifiers=$s,w.source=this.parseExprAtom()):(w.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),w.source=this.type===S.string?this.parseExprAtom():this.unexpected()),this.semicolon(),this.finishNode(w,"ImportDeclaration")},Ke.parseImportSpecifiers=function(){var w=[],R=!0;if(this.type===S.name){var O=this.startNode();if(O.local=this.parseIdent(),this.checkLVal(O.local,De),w.push(this.finishNode(O,"ImportDefaultSpecifier")),!this.eat(S.comma))return w}if(this.type===S.star){var W=this.startNode();return this.next(),this.expectContextual("as"),W.local=this.parseIdent(),this.checkLVal(W.local,De),w.push(this.finishNode(W,"ImportNamespaceSpecifier")),w}for(this.expect(S.braceL);!this.eat(S.braceR);){if(R)R=!1;else if(this.expect(S.comma),this.afterTrailingComma(S.braceR))break;var Y=this.startNode();Y.imported=this.parseIdent(!0),this.eatContextual("as")?Y.local=this.parseIdent():(this.checkUnreserved(Y.imported),Y.local=Y.imported),this.checkLVal(Y.local,De),w.push(this.finishNode(Y,"ImportSpecifier"))}return w},Ke.adaptDirectivePrologue=function(w){for(var R=0;R<w.length&&this.isDirectiveCandidate(w[R]);++R)w[R].directive=w[R].expression.raw.slice(1,-1)},Ke.isDirectiveCandidate=function(w){return w.type==="ExpressionStatement"&&w.expression.type==="Literal"&&typeof w.expression.value=="string"&&(this.input[w.start]==='"'||this.input[w.start]==="'")};var xn=Ae.prototype;xn.toAssignable=function(w,R,O){if(this.options.ecmaVersion>=6&&w)switch(w.type){case"Identifier":this.inAsync&&w.name==="await"&&this.raise(w.start,"Cannot use 'await' as identifier inside an async function");break;case"ObjectPattern":case"ArrayPattern":case"RestElement":break;case"ObjectExpression":w.type="ObjectPattern",O&&this.checkPatternErrors(O,!0);for(var W=0,Y=w.properties;W<Y.length;W+=1){var ge=Y[W];this.toAssignable(ge,R),ge.type==="RestElement"&&(ge.argument.type==="ArrayPattern"||ge.argument.type==="ObjectPattern")&&this.raise(ge.argument.start,"Unexpected token")}break;case"Property":w.kind!=="init"&&this.raise(w.key.start,"Object pattern can't contain getter or setter"),this.toAssignable(w.value,R);break;case"ArrayExpression":w.type="ArrayPattern",O&&this.checkPatternErrors(O,!0),this.toAssignableList(w.elements,R);break;case"SpreadElement":w.type="RestElement",this.toAssignable(w.argument,R),w.argument.type==="AssignmentPattern"&&this.raise(w.argument.start,"Rest elements cannot have a default value");break;case"AssignmentExpression":w.operator!=="="&&this.raise(w.left.end,"Only '=' operator can be used for specifying default value."),w.type="AssignmentPattern",delete w.operator,this.toAssignable(w.left,R);case"AssignmentPattern":break;case"ParenthesizedExpression":this.toAssignable(w.expression,R,O);break;case"MemberExpression":if(!R)break;default:this.raise(w.start,"Assigning to rvalue")}else O&&this.checkPatternErrors(O,!0);return w},xn.toAssignableList=function(w,R){for(var O=w.length,W=0;W<O;W++){var Y=w[W];Y&&this.toAssignable(Y,R)}if(O){var ge=w[O-1];this.options.ecmaVersion===6&&R&&ge&&ge.type==="RestElement"&&ge.argument.type!=="Identifier"&&this.unexpected(ge.argument.start)}return w},xn.parseSpread=function(w){var R=this.startNode();return this.next(),R.argument=this.parseMaybeAssign(!1,w),this.finishNode(R,"SpreadElement")},xn.parseRestBinding=function(){var w=this.startNode();return this.next(),this.options.ecmaVersion===6&&this.type!==S.name&&this.unexpected(),w.argument=this.parseBindingAtom(),this.finishNode(w,"RestElement")},xn.parseBindingAtom=function(){if(this.options.ecmaVersion>=6)switch(this.type){case S.bracketL:var w=this.startNode();return this.next(),w.elements=this.parseBindingList(S.bracketR,!0,!0),this.finishNode(w,"ArrayPattern");case S.braceL:return this.parseObj(!0)}return this.parseIdent()},xn.parseBindingList=function(w,R,O){for(var W=[],Y=!0;!this.eat(w);)if(Y?Y=!1:this.expect(S.comma),R&&this.type===S.comma)W.push(null);else{if(O&&this.afterTrailingComma(w))break;if(this.type===S.ellipsis){var ge=this.parseRestBinding();this.parseBindingListItem(ge),W.push(ge),this.type===S.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.expect(w);break}else{var Ce=this.parseMaybeDefault(this.start,this.startLoc);this.parseBindingListItem(Ce),W.push(Ce)}}return W},xn.parseBindingListItem=function(w){return w},xn.parseMaybeDefault=function(w,R,O){if(O=O||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(S.eq))return O;var W=this.startNodeAt(w,R);return W.left=O,W.right=this.parseMaybeAssign(),this.finishNode(W,"AssignmentPattern")},xn.checkLVal=function(w,R,O){switch(R===void 0&&(R=xe),w.type){case"Identifier":R===De&&w.name==="let"&&this.raiseRecoverable(w.start,"let is disallowed as a lexically bound name"),this.strict&&this.reservedWordsStrictBind.test(w.name)&&this.raiseRecoverable(w.start,(R?"Binding ":"Assigning to ")+w.name+" in strict mode"),O&&(L(O,w.name)&&this.raiseRecoverable(w.start,"Argument name clash"),O[w.name]=!0),R!==xe&&R!==nt&&this.declareName(w.name,R,w.start);break;case"MemberExpression":R&&this.raiseRecoverable(w.start,"Binding member expression");break;case"ObjectPattern":for(var W=0,Y=w.properties;W<Y.length;W+=1){var ge=Y[W];this.checkLVal(ge,R,O)}break;case"Property":this.checkLVal(w.value,R,O);break;case"ArrayPattern":for(var Ce=0,et=w.elements;Ce<et.length;Ce+=1){var gt=et[Ce];gt&&this.checkLVal(gt,R,O)}break;case"AssignmentPattern":this.checkLVal(w.left,R,O);break;case"RestElement":this.checkLVal(w.argument,R,O);break;case"ParenthesizedExpression":this.checkLVal(w.expression,R,O);break;default:this.raise(w.start,(R?"Binding":"Assigning to")+" rvalue")}};var yt=Ae.prototype;yt.checkPropClash=function(w,R,O){if(!(this.options.ecmaVersion>=9&&w.type==="SpreadElement")&&!(this.options.ecmaVersion>=6&&(w.computed||w.method||w.shorthand))){var W=w.key,Y;switch(W.type){case"Identifier":Y=W.name;break;case"Literal":Y=String(W.value);break;default:return}var ge=w.kind;if(this.options.ecmaVersion>=6){Y==="__proto__"&&ge==="init"&&(R.proto&&(O?O.doubleProto<0&&(O.doubleProto=W.start):this.raiseRecoverable(W.start,"Redefinition of __proto__ property")),R.proto=!0);return}Y="$"+Y;var Ce=R[Y];if(Ce){var et;ge==="init"?et=this.strict&&Ce.init||Ce.get||Ce.set:et=Ce.init||Ce[ge],et&&this.raiseRecoverable(W.start,"Redefinition of property")}else Ce=R[Y]={init:!1,get:!1,set:!1};Ce[ge]=!0}},yt.parseExpression=function(w,R){var O=this.start,W=this.startLoc,Y=this.parseMaybeAssign(w,R);if(this.type===S.comma){var ge=this.startNodeAt(O,W);for(ge.expressions=[Y];this.eat(S.comma);)ge.expressions.push(this.parseMaybeAssign(w,R));return this.finishNode(ge,"SequenceExpression")}return Y},yt.parseMaybeAssign=function(w,R,O){if(this.isContextual("yield")){if(this.inGenerator)return this.parseYield(w);this.exprAllowed=!1}var W=!1,Y=-1,ge=-1;R?(Y=R.parenthesizedAssign,ge=R.trailingComma,R.parenthesizedAssign=R.trailingComma=-1):(R=new $t,W=!0);var Ce=this.start,et=this.startLoc;(this.type===S.parenL||this.type===S.name)&&(this.potentialArrowAt=this.start);var gt=this.parseMaybeConditional(w,R);if(O&&(gt=O.call(this,gt,Ce,et)),this.type.isAssign){var jt=this.startNodeAt(Ce,et);return jt.operator=this.value,jt.left=this.type===S.eq?this.toAssignable(gt,!1,R):gt,W||(R.parenthesizedAssign=R.trailingComma=R.doubleProto=-1),R.shorthandAssign>=jt.left.start&&(R.shorthandAssign=-1),this.checkLVal(gt),this.next(),jt.right=this.parseMaybeAssign(w),this.finishNode(jt,"AssignmentExpression")}else W&&this.checkExpressionErrors(R,!0);return Y>-1&&(R.parenthesizedAssign=Y),ge>-1&&(R.trailingComma=ge),gt},yt.parseMaybeConditional=function(w,R){var O=this.start,W=this.startLoc,Y=this.parseExprOps(w,R);if(this.checkExpressionErrors(R))return Y;if(this.eat(S.question)){var ge=this.startNodeAt(O,W);return ge.test=Y,ge.consequent=this.parseMaybeAssign(),this.expect(S.colon),ge.alternate=this.parseMaybeAssign(w),this.finishNode(ge,"ConditionalExpression")}return Y},yt.parseExprOps=function(w,R){var O=this.start,W=this.startLoc,Y=this.parseMaybeUnary(R,!1);return this.checkExpressionErrors(R)||Y.start===O&&Y.type==="ArrowFunctionExpression"?Y:this.parseExprOp(Y,O,W,-1,w)},yt.parseExprOp=function(w,R,O,W,Y){var ge=this.type.binop;if(ge!=null&&(!Y||this.type!==S._in)&&ge>W){var Ce=this.type===S.logicalOR||this.type===S.logicalAND,et=this.value;this.next();var gt=this.start,jt=this.startLoc,sr=this.parseExprOp(this.parseMaybeUnary(null,!1),gt,jt,ge,Y),so=this.buildBinary(R,O,w,sr,et,Ce);return this.parseExprOp(so,R,O,W,Y)}return w},yt.buildBinary=function(w,R,O,W,Y,ge){var Ce=this.startNodeAt(w,R);return Ce.left=O,Ce.operator=Y,Ce.right=W,this.finishNode(Ce,ge?"LogicalExpression":"BinaryExpression")},yt.parseMaybeUnary=function(w,R){var O=this.start,W=this.startLoc,Y;if(this.isContextual("await")&&(this.inAsync||!this.inFunction&&this.options.allowAwaitOutsideFunction))Y=this.parseAwait(),R=!0;else if(this.type.prefix){var ge=this.startNode(),Ce=this.type===S.incDec;ge.operator=this.value,ge.prefix=!0,this.next(),ge.argument=this.parseMaybeUnary(null,!0),this.checkExpressionErrors(w,!0),Ce?this.checkLVal(ge.argument):this.strict&&ge.operator==="delete"&&ge.argument.type==="Identifier"?this.raiseRecoverable(ge.start,"Deleting local variable in strict mode"):R=!0,Y=this.finishNode(ge,Ce?"UpdateExpression":"UnaryExpression")}else{if(Y=this.parseExprSubscripts(w),this.checkExpressionErrors(w))return Y;for(;this.type.postfix&&!this.canInsertSemicolon();){var et=this.startNodeAt(O,W);et.operator=this.value,et.prefix=!1,et.argument=Y,this.checkLVal(Y),this.next(),Y=this.finishNode(et,"UpdateExpression")}}return!R&&this.eat(S.starstar)?this.buildBinary(O,W,Y,this.parseMaybeUnary(null,!1),"**",!1):Y},yt.parseExprSubscripts=function(w){var R=this.start,O=this.startLoc,W=this.parseExprAtom(w);if(W.type==="ArrowFunctionExpression"&&this.input.slice(this.lastTokStart,this.lastTokEnd)!==")")return W;var Y=this.parseSubscripts(W,R,O);return w&&Y.type==="MemberExpression"&&(w.parenthesizedAssign>=Y.start&&(w.parenthesizedAssign=-1),w.parenthesizedBind>=Y.start&&(w.parenthesizedBind=-1)),Y},yt.parseSubscripts=function(w,R,O,W){for(var Y=this.options.ecmaVersion>=8&&w.type==="Identifier"&&w.name==="async"&&this.lastTokEnd===w.end&&!this.canInsertSemicolon()&&this.input.slice(w.start,w.end)==="async";;){var ge=this.parseSubscript(w,R,O,W,Y);if(ge===w||ge.type==="ArrowFunctionExpression")return ge;w=ge}},yt.parseSubscript=function(w,R,O,W,Y){var ge=this.eat(S.bracketL);if(ge||this.eat(S.dot)){var Ce=this.startNodeAt(R,O);Ce.object=w,Ce.property=ge?this.parseExpression():this.parseIdent(this.options.allowReserved!=="never"),Ce.computed=!!ge,ge&&this.expect(S.bracketR),w=this.finishNode(Ce,"MemberExpression")}else if(!W&&this.eat(S.parenL)){var et=new $t,gt=this.yieldPos,jt=this.awaitPos,sr=this.awaitIdentPos;this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0;var so=this.parseExprList(S.parenR,this.options.ecmaVersion>=8,!1,et);if(Y&&!this.canInsertSemicolon()&&this.eat(S.arrow))return this.checkPatternErrors(et,!1),this.checkYieldAwaitInDefaultParams(),this.awaitIdentPos>0&&this.raise(this.awaitIdentPos,"Cannot use 'await' as identifier inside an async function"),this.yieldPos=gt,this.awaitPos=jt,this.awaitIdentPos=sr,this.parseArrowExpression(this.startNodeAt(R,O),so,!0);this.checkExpressionErrors(et,!0),this.yieldPos=gt||this.yieldPos,this.awaitPos=jt||this.awaitPos,this.awaitIdentPos=sr||this.awaitIdentPos;var tu=this.startNodeAt(R,O);tu.callee=w,tu.arguments=so,w=this.finishNode(tu,"CallExpression")}else if(this.type===S.backQuote){var Aa=this.startNodeAt(R,O);Aa.tag=w,Aa.quasi=this.parseTemplate({isTagged:!0}),w=this.finishNode(Aa,"TaggedTemplateExpression")}return w},yt.parseExprAtom=function(w){this.type===S.slash&&this.readRegexp();var R,O=this.potentialArrowAt===this.start;switch(this.type){case S._super:return this.allowSuper||this.raise(this.start,"'super' keyword outside a method"),R=this.startNode(),this.next(),this.type===S.parenL&&!this.allowDirectSuper&&this.raise(R.start,"super() call outside constructor of a subclass"),this.type!==S.dot&&this.type!==S.bracketL&&this.type!==S.parenL&&this.unexpected(),this.finishNode(R,"Super");case S._this:return R=this.startNode(),this.next(),this.finishNode(R,"ThisExpression");case S.name:var W=this.start,Y=this.startLoc,ge=this.containsEsc,Ce=this.parseIdent(!1);if(this.options.ecmaVersion>=8&&!ge&&Ce.name==="async"&&!this.canInsertSemicolon()&&this.eat(S._function))return this.parseFunction(this.startNodeAt(W,Y),0,!1,!0);if(O&&!this.canInsertSemicolon()){if(this.eat(S.arrow))return this.parseArrowExpression(this.startNodeAt(W,Y),[Ce],!1);if(this.options.ecmaVersion>=8&&Ce.name==="async"&&this.type===S.name&&!ge)return Ce=this.parseIdent(!1),(this.canInsertSemicolon()||!this.eat(S.arrow))&&this.unexpected(),this.parseArrowExpression(this.startNodeAt(W,Y),[Ce],!0)}return Ce;case S.regexp:var et=this.value;return R=this.parseLiteral(et.value),R.regex={pattern:et.pattern,flags:et.flags},R;case S.num:case S.string:return this.parseLiteral(this.value);case S._null:case S._true:case S._false:return R=this.startNode(),R.value=this.type===S._null?null:this.type===S._true,R.raw=this.type.keyword,this.next(),this.finishNode(R,"Literal");case S.parenL:var gt=this.start,jt=this.parseParenAndDistinguishExpression(O);return w&&(w.parenthesizedAssign<0&&!this.isSimpleAssignTarget(jt)&&(w.parenthesizedAssign=gt),w.parenthesizedBind<0&&(w.parenthesizedBind=gt)),jt;case S.bracketL:return R=this.startNode(),this.next(),R.elements=this.parseExprList(S.bracketR,!0,!0,w),this.finishNode(R,"ArrayExpression");case S.braceL:return this.parseObj(!1,w);case S._function:return R=this.startNode(),this.next(),this.parseFunction(R,0);case S._class:return this.parseClass(this.startNode(),!1);case S._new:return this.parseNew();case S.backQuote:return this.parseTemplate();case S._import:return this.options.ecmaVersion>=11?this.parseExprImport():this.unexpected();default:this.unexpected()}},yt.parseExprImport=function(){var w=this.startNode();switch(this.next(),this.type){case S.parenL:return this.parseDynamicImport(w);default:this.unexpected()}},yt.parseDynamicImport=function(w){if(this.next(),w.source=this.parseMaybeAssign(),!this.eat(S.parenR)){var R=this.start;this.eat(S.comma)&&this.eat(S.parenR)?this.raiseRecoverable(R,"Trailing comma is not allowed in import()"):this.unexpected(R)}return this.finishNode(w,"ImportExpression")},yt.parseLiteral=function(w){var R=this.startNode();return R.value=w,R.raw=this.input.slice(this.start,this.end),R.raw.charCodeAt(R.raw.length-1)===110&&(R.bigint=R.raw.slice(0,-1)),this.next(),this.finishNode(R,"Literal")},yt.parseParenExpression=function(){this.expect(S.parenL);var w=this.parseExpression();return this.expect(S.parenR),w},yt.parseParenAndDistinguishExpression=function(w){var R=this.start,O=this.startLoc,W,Y=this.options.ecmaVersion>=8;if(this.options.ecmaVersion>=6){this.next();var ge=this.start,Ce=this.startLoc,et=[],gt=!0,jt=!1,sr=new $t,so=this.yieldPos,tu=this.awaitPos,Aa;for(this.yieldPos=0,this.awaitPos=0;this.type!==S.parenR;)if(gt?gt=!1:this.expect(S.comma),Y&&this.afterTrailingComma(S.parenR,!0)){jt=!0;break}else if(this.type===S.ellipsis){Aa=this.start,et.push(this.parseParenItem(this.parseRestBinding())),this.type===S.comma&&this.raise(this.start,"Comma is not permitted after the rest element");break}else et.push(this.parseMaybeAssign(!1,sr,this.parseParenItem));var TM=this.start,IM=this.startLoc;if(this.expect(S.parenR),w&&!this.canInsertSemicolon()&&this.eat(S.arrow))return this.checkPatternErrors(sr,!1),this.checkYieldAwaitInDefaultParams(),this.yieldPos=so,this.awaitPos=tu,this.parseParenArrowList(R,O,et);(!et.length||jt)&&this.unexpected(this.lastTokStart),Aa&&this.unexpected(Aa),this.checkExpressionErrors(sr,!0),this.yieldPos=so||this.yieldPos,this.awaitPos=tu||this.awaitPos,et.length>1?(W=this.startNodeAt(ge,Ce),W.expressions=et,this.finishNodeAt(W,"SequenceExpression",TM,IM)):W=et[0]}else W=this.parseParenExpression();if(this.options.preserveParens){var jw=this.startNodeAt(R,O);return jw.expression=W,this.finishNode(jw,"ParenthesizedExpression")}else return W},yt.parseParenItem=function(w){return w},yt.parseParenArrowList=function(w,R,O){return this.parseArrowExpression(this.startNodeAt(w,R),O)};var vp=[];yt.parseNew=function(){this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword new");var w=this.startNode(),R=this.parseIdent(!0);if(this.options.ecmaVersion>=6&&this.eat(S.dot)){w.meta=R;var O=this.containsEsc;return w.property=this.parseIdent(!0),(w.property.name!=="target"||O)&&this.raiseRecoverable(w.property.start,"The only valid meta property for new is new.target"),this.inNonArrowFunction()||this.raiseRecoverable(w.start,"new.target can only be used in functions"),this.finishNode(w,"MetaProperty")}var W=this.start,Y=this.startLoc,ge=this.type===S._import;return w.callee=this.parseSubscripts(this.parseExprAtom(),W,Y,!0),ge&&w.callee.type==="ImportExpression"&&this.raise(W,"Cannot use new with import()"),this.eat(S.parenL)?w.arguments=this.parseExprList(S.parenR,this.options.ecmaVersion>=8,!1):w.arguments=vp,this.finishNode(w,"NewExpression")},yt.parseTemplateElement=function(w){var R=w.isTagged,O=this.startNode();return this.type===S.invalidTemplate?(R||this.raiseRecoverable(this.start,"Bad escape sequence in untagged template literal"),O.value={raw:this.value,cooked:null}):O.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,`
`),cooked:this.value},this.next(),O.tail=this.type===S.backQuote,this.finishNode(O,"TemplateElement")},yt.parseTemplate=function(w){w===void 0&&(w={});var R=w.isTagged;R===void 0&&(R=!1);var O=this.startNode();this.next(),O.expressions=[];var W=this.parseTemplateElement({isTagged:R});for(O.quasis=[W];!W.tail;)this.type===S.eof&&this.raise(this.pos,"Unterminated template literal"),this.expect(S.dollarBraceL),O.expressions.push(this.parseExpression()),this.expect(S.braceR),O.quasis.push(W=this.parseTemplateElement({isTagged:R}));return this.next(),this.finishNode(O,"TemplateLiteral")},yt.isAsyncProp=function(w){return!w.computed&&w.key.type==="Identifier"&&w.key.name==="async"&&(this.type===S.name||this.type===S.num||this.type===S.string||this.type===S.bracketL||this.type.keyword||this.options.ecmaVersion>=9&&this.type===S.star)&&!E.test(this.input.slice(this.lastTokEnd,this.start))},yt.parseObj=function(w,R){var O=this.startNode(),W=!0,Y={};for(O.properties=[],this.next();!this.eat(S.braceR);){if(W)W=!1;else if(this.expect(S.comma),this.options.ecmaVersion>=5&&this.afterTrailingComma(S.braceR))break;var ge=this.parseProperty(w,R);w||this.checkPropClash(ge,Y,R),O.properties.push(ge)}return this.finishNode(O,w?"ObjectPattern":"ObjectExpression")},yt.parseProperty=function(w,R){var O=this.startNode(),W,Y,ge,Ce;if(this.options.ecmaVersion>=9&&this.eat(S.ellipsis))return w?(O.argument=this.parseIdent(!1),this.type===S.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.finishNode(O,"RestElement")):(this.type===S.parenL&&R&&(R.parenthesizedAssign<0&&(R.parenthesizedAssign=this.start),R.parenthesizedBind<0&&(R.parenthesizedBind=this.start)),O.argument=this.parseMaybeAssign(!1,R),this.type===S.comma&&R&&R.trailingComma<0&&(R.trailingComma=this.start),this.finishNode(O,"SpreadElement"));this.options.ecmaVersion>=6&&(O.method=!1,O.shorthand=!1,(w||R)&&(ge=this.start,Ce=this.startLoc),w||(W=this.eat(S.star)));var et=this.containsEsc;return this.parsePropertyName(O),!w&&!et&&this.options.ecmaVersion>=8&&!W&&this.isAsyncProp(O)?(Y=!0,W=this.options.ecmaVersion>=9&&this.eat(S.star),this.parsePropertyName(O,R)):Y=!1,this.parsePropertyValue(O,w,W,Y,ge,Ce,R,et),this.finishNode(O,"Property")},yt.parsePropertyValue=function(w,R,O,W,Y,ge,Ce,et){if((O||W)&&this.type===S.colon&&this.unexpected(),this.eat(S.colon))w.value=R?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(!1,Ce),w.kind="init";else if(this.options.ecmaVersion>=6&&this.type===S.parenL)R&&this.unexpected(),w.kind="init",w.method=!0,w.value=this.parseMethod(O,W);else if(!R&&!et&&this.options.ecmaVersion>=5&&!w.computed&&w.key.type==="Identifier"&&(w.key.name==="get"||w.key.name==="set")&&this.type!==S.comma&&this.type!==S.braceR){(O||W)&&this.unexpected(),w.kind=w.key.name,this.parsePropertyName(w),w.value=this.parseMethod(!1);var gt=w.kind==="get"?0:1;if(w.value.params.length!==gt){var jt=w.value.start;w.kind==="get"?this.raiseRecoverable(jt,"getter should have no params"):this.raiseRecoverable(jt,"setter should have exactly one param")}else w.kind==="set"&&w.value.params[0].type==="RestElement"&&this.raiseRecoverable(w.value.params[0].start,"Setter cannot use rest params")}else this.options.ecmaVersion>=6&&!w.computed&&w.key.type==="Identifier"?((O||W)&&this.unexpected(),this.checkUnreserved(w.key),w.key.name==="await"&&!this.awaitIdentPos&&(this.awaitIdentPos=Y),w.kind="init",R?w.value=this.parseMaybeDefault(Y,ge,w.key):this.type===S.eq&&Ce?(Ce.shorthandAssign<0&&(Ce.shorthandAssign=this.start),w.value=this.parseMaybeDefault(Y,ge,w.key)):w.value=w.key,w.shorthand=!0):this.unexpected()},yt.parsePropertyName=function(w){if(this.options.ecmaVersion>=6){if(this.eat(S.bracketL))return w.computed=!0,w.key=this.parseMaybeAssign(),this.expect(S.bracketR),w.key;w.computed=!1}return w.key=this.type===S.num||this.type===S.string?this.parseExprAtom():this.parseIdent(this.options.allowReserved!=="never")},yt.initFunction=function(w){w.id=null,this.options.ecmaVersion>=6&&(w.generator=w.expression=!1),this.options.ecmaVersion>=8&&(w.async=!1)},yt.parseMethod=function(w,R,O){var W=this.startNode(),Y=this.yieldPos,ge=this.awaitPos,Ce=this.awaitIdentPos;return this.initFunction(W),this.options.ecmaVersion>=6&&(W.generator=w),this.options.ecmaVersion>=8&&(W.async=!!R),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(me(R,W.generator)|re|(O?pe:0)),this.expect(S.parenL),W.params=this.parseBindingList(S.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams(),this.parseFunctionBody(W,!1,!0),this.yieldPos=Y,this.awaitPos=ge,this.awaitIdentPos=Ce,this.finishNode(W,"FunctionExpression")},yt.parseArrowExpression=function(w,R,O){var W=this.yieldPos,Y=this.awaitPos,ge=this.awaitIdentPos;return this.enterScope(me(O,!1)|H),this.initFunction(w),this.options.ecmaVersion>=8&&(w.async=!!O),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,w.params=this.toAssignableList(R,!0),this.parseFunctionBody(w,!0,!1),this.yieldPos=W,this.awaitPos=Y,this.awaitIdentPos=ge,this.finishNode(w,"ArrowFunctionExpression")},yt.parseFunctionBody=function(w,R,O){var W=R&&this.type!==S.braceL,Y=this.strict,ge=!1;if(W)w.body=this.parseMaybeAssign(),w.expression=!0,this.checkParams(w,!1);else{var Ce=this.options.ecmaVersion>=7&&!this.isSimpleParamList(w.params);(!Y||Ce)&&(ge=this.strictDirective(this.end),ge&&Ce&&this.raiseRecoverable(w.start,"Illegal 'use strict' directive in function with non-simple parameter list"));var et=this.labels;this.labels=[],ge&&(this.strict=!0),this.checkParams(w,!Y&&!ge&&!R&&!O&&this.isSimpleParamList(w.params)),w.body=this.parseBlock(!1),w.expression=!1,this.adaptDirectivePrologue(w.body.body),this.labels=et}this.exitScope(),this.strict&&w.id&&this.checkLVal(w.id,nt),this.strict=Y},yt.isSimpleParamList=function(w){for(var R=0,O=w;R<O.length;R+=1){var W=O[R];if(W.type!=="Identifier")return!1}return!0},yt.checkParams=function(w,R){for(var O={},W=0,Y=w.params;W<Y.length;W+=1){var ge=Y[W];this.checkLVal(ge,Te,R?null:O)}},yt.parseExprList=function(w,R,O,W){for(var Y=[],ge=!0;!this.eat(w);){if(ge)ge=!1;else if(this.expect(S.comma),R&&this.afterTrailingComma(w))break;var Ce=void 0;O&&this.type===S.comma?Ce=null:this.type===S.ellipsis?(Ce=this.parseSpread(W),W&&this.type===S.comma&&W.trailingComma<0&&(W.trailingComma=this.start)):Ce=this.parseMaybeAssign(!1,W),Y.push(Ce)}return Y},yt.checkUnreserved=function(w){var R=w.start,O=w.end,W=w.name;if(this.inGenerator&&W==="yield"&&this.raiseRecoverable(R,"Cannot use 'yield' as identifier inside a generator"),this.inAsync&&W==="await"&&this.raiseRecoverable(R,"Cannot use 'await' as identifier inside an async function"),this.keywords.test(W)&&this.raise(R,"Unexpected keyword '"+W+"'"),!(this.options.ecmaVersion<6&&this.input.slice(R,O).indexOf("\\")!==-1)){var Y=this.strict?this.reservedWordsStrict:this.reservedWords;Y.test(W)&&(!this.inAsync&&W==="await"&&this.raiseRecoverable(R,"Cannot use keyword 'await' outside an async function"),this.raiseRecoverable(R,"The keyword '"+W+"' is reserved"))}},yt.parseIdent=function(w,R){var O=this.startNode();return this.type===S.name?O.name=this.value:this.type.keyword?(O.name=this.type.keyword,(O.name==="class"||O.name==="function")&&(this.lastTokEnd!==this.lastTokStart+1||this.input.charCodeAt(this.lastTokStart)!==46)&&this.context.pop()):this.unexpected(),this.next(!!w),this.finishNode(O,"Identifier"),w||(this.checkUnreserved(O),O.name==="await"&&!this.awaitIdentPos&&(this.awaitIdentPos=O.start)),O},yt.parseYield=function(w){this.yieldPos||(this.yieldPos=this.start);var R=this.startNode();return this.next(),this.type===S.semi||this.canInsertSemicolon()||this.type!==S.star&&!this.type.startsExpr?(R.delegate=!1,R.argument=null):(R.delegate=this.eat(S.star),R.argument=this.parseMaybeAssign(w)),this.finishNode(R,"YieldExpression")},yt.parseAwait=function(){this.awaitPos||(this.awaitPos=this.start);var w=this.startNode();return this.next(),w.argument=this.parseMaybeUnary(null,!1),this.finishNode(w,"AwaitExpression")};var Ra=Ae.prototype;Ra.raise=function(w,R){var O=se(this.input,w);R+=" ("+O.line+":"+O.column+")";var W=new SyntaxError(R);throw W.pos=w,W.loc=O,W.raisedAt=this.pos,W},Ra.raiseRecoverable=Ra.raise,Ra.curPosition=function(){if(this.options.locations)return new Z(this.curLine,this.pos-this.lineStart)};var Oo=Ae.prototype,hM=function(R){this.flags=R,this.var=[],this.lexical=[],this.functions=[]};Oo.enterScope=function(w){this.scopeStack.push(new hM(w))},Oo.exitScope=function(){this.scopeStack.pop()},Oo.treatFunctionsAsVarInScope=function(w){return w.flags&Ee||!this.inModule&&w.flags&Pe},Oo.declareName=function(w,R,O){var W=!1;if(R===De){var Y=this.currentScope();W=Y.lexical.indexOf(w)>-1||Y.functions.indexOf(w)>-1||Y.var.indexOf(w)>-1,Y.lexical.push(w),this.inModule&&Y.flags&Pe&&delete this.undefinedExports[w]}else if(R===_e){var ge=this.currentScope();ge.lexical.push(w)}else if(R===Re){var Ce=this.currentScope();this.treatFunctionsAsVar?W=Ce.lexical.indexOf(w)>-1:W=Ce.lexical.indexOf(w)>-1||Ce.var.indexOf(w)>-1,Ce.functions.push(w)}else for(var et=this.scopeStack.length-1;et>=0;--et){var gt=this.scopeStack[et];if(gt.lexical.indexOf(w)>-1&&!(gt.flags&K&&gt.lexical[0]===w)||!this.treatFunctionsAsVarInScope(gt)&&gt.functions.indexOf(w)>-1){W=!0;break}if(gt.var.push(w),this.inModule&&gt.flags&Pe&&delete this.undefinedExports[w],gt.flags&Se)break}W&&this.raiseRecoverable(O,"Identifier '"+w+"' has already been declared")},Oo.checkLocalExport=function(w){this.scopeStack[0].lexical.indexOf(w.name)===-1&&this.scopeStack[0].var.indexOf(w.name)===-1&&(this.undefinedExports[w.name]=w)},Oo.currentScope=function(){return this.scopeStack[this.scopeStack.length-1]},Oo.currentVarScope=function(){for(var w=this.scopeStack.length-1;;w--){var R=this.scopeStack[w];if(R.flags&Se)return R}},Oo.currentThisScope=function(){for(var w=this.scopeStack.length-1;;w--){var R=this.scopeStack[w];if(R.flags&Se&&!(R.flags&H))return R}};var wp=function(R,O,W){this.type="",this.start=O,this.end=0,R.options.locations&&(this.loc=new J(R,W)),R.options.directSourceFile&&(this.sourceFile=R.options.directSourceFile),R.options.ranges&&(this.range=[O,0])},Sp=Ae.prototype;Sp.startNode=function(){return new wp(this,this.start,this.startLoc)},Sp.startNodeAt=function(w,R){return new wp(this,w,R)};function Pw(w,R,O,W){return w.type=R,w.end=O,this.options.locations&&(w.loc.end=W),this.options.ranges&&(w.range[1]=O),w}Sp.finishNode=function(w,R){return Pw.call(this,w,R,this.lastTokEnd,this.lastTokEndLoc)},Sp.finishNodeAt=function(w,R,O,W){return Pw.call(this,w,R,O,W)};var Ar=function(R,O,W,Y,ge){this.token=R,this.isExpr=!!O,this.preserveSpace=!!W,this.override=Y,this.generator=!!ge},An={b_stat:new Ar("{",!1),b_expr:new Ar("{",!0),b_tmpl:new Ar("${",!1),p_stat:new Ar("(",!1),p_expr:new Ar("(",!0),q_tmpl:new Ar("`",!0,!0,function(w){return w.tryReadTemplateToken()}),f_stat:new Ar("function",!1),f_expr:new Ar("function",!0),f_expr_gen:new Ar("function",!0,!1,null,!0),f_gen:new Ar("function",!1,!1,null,!0)},Cp=Ae.prototype;Cp.initialContext=function(){return[An.b_stat]},Cp.braceIsBlock=function(w){var R=this.curContext();return R===An.f_expr||R===An.f_stat?!0:w===S.colon&&(R===An.b_stat||R===An.b_expr)?!R.isExpr:w===S._return||w===S.name&&this.exprAllowed?E.test(this.input.slice(this.lastTokEnd,this.start)):w===S._else||w===S.semi||w===S.eof||w===S.parenR||w===S.arrow?!0:w===S.braceL?R===An.b_stat:w===S._var||w===S._const||w===S.name?!1:!this.exprAllowed},Cp.inGeneratorContext=function(){for(var w=this.context.length-1;w>=1;w--){var R=this.context[w];if(R.token==="function")return R.generator}return!1},Cp.updateContext=function(w){var R,O=this.type;O.keyword&&w===S.dot?this.exprAllowed=!1:(R=O.updateContext)?R.call(this,w):this.exprAllowed=O.beforeExpr},S.parenR.updateContext=S.braceR.updateContext=function(){if(this.context.length===1){this.exprAllowed=!0;return}var w=this.context.pop();w===An.b_stat&&this.curContext().token==="function"&&(w=this.context.pop()),this.exprAllowed=!w.isExpr},S.braceL.updateContext=function(w){this.context.push(this.braceIsBlock(w)?An.b_stat:An.b_expr),this.exprAllowed=!0},S.dollarBraceL.updateContext=function(){this.context.push(An.b_tmpl),this.exprAllowed=!0},S.parenL.updateContext=function(w){var R=w===S._if||w===S._for||w===S._with||w===S._while;this.context.push(R?An.p_stat:An.p_expr),this.exprAllowed=!0},S.incDec.updateContext=function(){},S._function.updateContext=S._class.updateContext=function(w){w.beforeExpr&&w!==S.semi&&w!==S._else&&!(w===S._return&&E.test(this.input.slice(this.lastTokEnd,this.start)))&&!((w===S.colon||w===S.braceL)&&this.curContext()===An.b_stat)?this.context.push(An.f_expr):this.context.push(An.f_stat),this.exprAllowed=!1},S.backQuote.updateContext=function(){this.curContext()===An.q_tmpl?this.context.pop():this.context.push(An.q_tmpl),this.exprAllowed=!1},S.star.updateContext=function(w){if(w===S._function){var R=this.context.length-1;this.context[R]===An.f_expr?this.context[R]=An.f_expr_gen:this.context[R]=An.f_gen}this.exprAllowed=!0},S.name.updateContext=function(w){var R=!1;this.options.ecmaVersion>=6&&w!==S.dot&&(this.value==="of"&&!this.exprAllowed||this.value==="yield"&&this.inGeneratorContext())&&(R=!0),this.exprAllowed=R};var Dw="ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",Nw=Dw+" Extended_Pictographic",dM=Nw,fM={9:Dw,10:Nw,11:dM},Mw="Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",Lw="Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",Ow=Lw+" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",pM=Ow+" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",mM={9:Lw,10:Ow,11:pM},Fw={};function nb(w){var R=Fw[w]={binary:j(fM[w]+" "+Mw),nonBinary:{General_Category:j(Mw),Script:j(mM[w])}};R.nonBinary.Script_Extensions=R.nonBinary.Script,R.nonBinary.gc=R.nonBinary.General_Category,R.nonBinary.sc=R.nonBinary.Script,R.nonBinary.scx=R.nonBinary.Script_Extensions}nb(9),nb(10),nb(11);var dt=Ae.prototype,no=function(R){this.parser=R,this.validFlags="gim"+(R.options.ecmaVersion>=6?"uy":"")+(R.options.ecmaVersion>=9?"s":""),this.unicodeProperties=Fw[R.options.ecmaVersion>=11?11:R.options.ecmaVersion],this.source="",this.flags="",this.start=0,this.switchU=!1,this.switchN=!1,this.pos=0,this.lastIntValue=0,this.lastStringValue="",this.lastAssertionIsQuantifiable=!1,this.numCapturingParens=0,this.maxBackReference=0,this.groupNames=[],this.backReferenceNames=[]};no.prototype.reset=function(R,O,W){var Y=W.indexOf("u")!==-1;this.start=R|0,this.source=O+"",this.flags=W,this.switchU=Y&&this.parser.options.ecmaVersion>=6,this.switchN=Y&&this.parser.options.ecmaVersion>=9},no.prototype.raise=function(R){this.parser.raiseRecoverable(this.start,"Invalid regular expression: /"+this.source+"/: "+R)},no.prototype.at=function(R){var O=this.source,W=O.length;if(R>=W)return-1;var Y=O.charCodeAt(R);if(!this.switchU||Y<=55295||Y>=57344||R+1>=W)return Y;var ge=O.charCodeAt(R+1);return ge>=56320&&ge<=57343?(Y<<10)+ge-56613888:Y},no.prototype.nextIndex=function(R){var O=this.source,W=O.length;if(R>=W)return W;var Y=O.charCodeAt(R),ge;return!this.switchU||Y<=55295||Y>=57344||R+1>=W||(ge=O.charCodeAt(R+1))<56320||ge>57343?R+1:R+2},no.prototype.current=function(){return this.at(this.pos)},no.prototype.lookahead=function(){return this.at(this.nextIndex(this.pos))},no.prototype.advance=function(){this.pos=this.nextIndex(this.pos)},no.prototype.eat=function(R){return this.current()===R?(this.advance(),!0):!1};function Tp(w){return w<=65535?String.fromCharCode(w):(w-=65536,String.fromCharCode((w>>10)+55296,(w&1023)+56320))}dt.validateRegExpFlags=function(w){for(var R=w.validFlags,O=w.flags,W=0;W<O.length;W++){var Y=O.charAt(W);R.indexOf(Y)===-1&&this.raise(w.start,"Invalid regular expression flag"),O.indexOf(Y,W+1)>-1&&this.raise(w.start,"Duplicate regular expression flag")}},dt.validateRegExpPattern=function(w){this.regexp_pattern(w),!w.switchN&&this.options.ecmaVersion>=9&&w.groupNames.length>0&&(w.switchN=!0,this.regexp_pattern(w))},dt.regexp_pattern=function(w){w.pos=0,w.lastIntValue=0,w.lastStringValue="",w.lastAssertionIsQuantifiable=!1,w.numCapturingParens=0,w.maxBackReference=0,w.groupNames.length=0,w.backReferenceNames.length=0,this.regexp_disjunction(w),w.pos!==w.source.length&&(w.eat(41)&&w.raise("Unmatched ')'"),(w.eat(93)||w.eat(125))&&w.raise("Lone quantifier brackets")),w.maxBackReference>w.numCapturingParens&&w.raise("Invalid escape");for(var R=0,O=w.backReferenceNames;R<O.length;R+=1){var W=O[R];w.groupNames.indexOf(W)===-1&&w.raise("Invalid named capture referenced")}},dt.regexp_disjunction=function(w){for(this.regexp_alternative(w);w.eat(124);)this.regexp_alternative(w);this.regexp_eatQuantifier(w,!0)&&w.raise("Nothing to repeat"),w.eat(123)&&w.raise("Lone quantifier brackets")},dt.regexp_alternative=function(w){for(;w.pos<w.source.length&&this.regexp_eatTerm(w););},dt.regexp_eatTerm=function(w){return this.regexp_eatAssertion(w)?(w.lastAssertionIsQuantifiable&&this.regexp_eatQuantifier(w)&&w.switchU&&w.raise("Invalid quantifier"),!0):(w.switchU?this.regexp_eatAtom(w):this.regexp_eatExtendedAtom(w))?(this.regexp_eatQuantifier(w),!0):!1},dt.regexp_eatAssertion=function(w){var R=w.pos;if(w.lastAssertionIsQuantifiable=!1,w.eat(94)||w.eat(36))return!0;if(w.eat(92)){if(w.eat(66)||w.eat(98))return!0;w.pos=R}if(w.eat(40)&&w.eat(63)){var O=!1;if(this.options.ecmaVersion>=9&&(O=w.eat(60)),w.eat(61)||w.eat(33))return this.regexp_disjunction(w),w.eat(41)||w.raise("Unterminated group"),w.lastAssertionIsQuantifiable=!O,!0}return w.pos=R,!1},dt.regexp_eatQuantifier=function(w,R){return R===void 0&&(R=!1),this.regexp_eatQuantifierPrefix(w,R)?(w.eat(63),!0):!1},dt.regexp_eatQuantifierPrefix=function(w,R){return w.eat(42)||w.eat(43)||w.eat(63)||this.regexp_eatBracedQuantifier(w,R)},dt.regexp_eatBracedQuantifier=function(w,R){var O=w.pos;if(w.eat(123)){var W=0,Y=-1;if(this.regexp_eatDecimalDigits(w)&&(W=w.lastIntValue,w.eat(44)&&this.regexp_eatDecimalDigits(w)&&(Y=w.lastIntValue),w.eat(125)))return Y!==-1&&Y<W&&!R&&w.raise("numbers out of order in {} quantifier"),!0;w.switchU&&!R&&w.raise("Incomplete quantifier"),w.pos=O}return!1},dt.regexp_eatAtom=function(w){return this.regexp_eatPatternCharacters(w)||w.eat(46)||this.regexp_eatReverseSolidusAtomEscape(w)||this.regexp_eatCharacterClass(w)||this.regexp_eatUncapturingGroup(w)||this.regexp_eatCapturingGroup(w)},dt.regexp_eatReverseSolidusAtomEscape=function(w){var R=w.pos;if(w.eat(92)){if(this.regexp_eatAtomEscape(w))return!0;w.pos=R}return!1},dt.regexp_eatUncapturingGroup=function(w){var R=w.pos;if(w.eat(40)){if(w.eat(63)&&w.eat(58)){if(this.regexp_disjunction(w),w.eat(41))return!0;w.raise("Unterminated group")}w.pos=R}return!1},dt.regexp_eatCapturingGroup=function(w){if(w.eat(40)){if(this.options.ecmaVersion>=9?this.regexp_groupSpecifier(w):w.current()===63&&w.raise("Invalid group"),this.regexp_disjunction(w),w.eat(41))return w.numCapturingParens+=1,!0;w.raise("Unterminated group")}return!1},dt.regexp_eatExtendedAtom=function(w){return w.eat(46)||this.regexp_eatReverseSolidusAtomEscape(w)||this.regexp_eatCharacterClass(w)||this.regexp_eatUncapturingGroup(w)||this.regexp_eatCapturingGroup(w)||this.regexp_eatInvalidBracedQuantifier(w)||this.regexp_eatExtendedPatternCharacter(w)},dt.regexp_eatInvalidBracedQuantifier=function(w){return this.regexp_eatBracedQuantifier(w,!0)&&w.raise("Nothing to repeat"),!1},dt.regexp_eatSyntaxCharacter=function(w){var R=w.current();return Uw(R)?(w.lastIntValue=R,w.advance(),!0):!1};function Uw(w){return w===36||w>=40&&w<=43||w===46||w===63||w>=91&&w<=94||w>=123&&w<=125}dt.regexp_eatPatternCharacters=function(w){for(var R=w.pos,O=0;(O=w.current())!==-1&&!Uw(O);)w.advance();return w.pos!==R},dt.regexp_eatExtendedPatternCharacter=function(w){var R=w.current();return R!==-1&&R!==36&&!(R>=40&&R<=43)&&R!==46&&R!==63&&R!==91&&R!==94&&R!==124?(w.advance(),!0):!1},dt.regexp_groupSpecifier=function(w){if(w.eat(63)){if(this.regexp_eatGroupName(w)){w.groupNames.indexOf(w.lastStringValue)!==-1&&w.raise("Duplicate capture group name"),w.groupNames.push(w.lastStringValue);return}w.raise("Invalid group")}},dt.regexp_eatGroupName=function(w){if(w.lastStringValue="",w.eat(60)){if(this.regexp_eatRegExpIdentifierName(w)&&w.eat(62))return!0;w.raise("Invalid capture group name")}return!1},dt.regexp_eatRegExpIdentifierName=function(w){if(w.lastStringValue="",this.regexp_eatRegExpIdentifierStart(w)){for(w.lastStringValue+=Tp(w.lastIntValue);this.regexp_eatRegExpIdentifierPart(w);)w.lastStringValue+=Tp(w.lastIntValue);return!0}return!1},dt.regexp_eatRegExpIdentifierStart=function(w){var R=w.pos,O=w.current();return w.advance(),O===92&&this.regexp_eatRegExpUnicodeEscapeSequence(w)&&(O=w.lastIntValue),gM(O)?(w.lastIntValue=O,!0):(w.pos=R,!1)};function gM(w){return x(w,!0)||w===36||w===95}dt.regexp_eatRegExpIdentifierPart=function(w){var R=w.pos,O=w.current();return w.advance(),O===92&&this.regexp_eatRegExpUnicodeEscapeSequence(w)&&(O=w.lastIntValue),xM(O)?(w.lastIntValue=O,!0):(w.pos=R,!1)};function xM(w){return b(w,!0)||w===36||w===95||w===8204||w===8205}dt.regexp_eatAtomEscape=function(w){return this.regexp_eatBackReference(w)||this.regexp_eatCharacterClassEscape(w)||this.regexp_eatCharacterEscape(w)||w.switchN&&this.regexp_eatKGroupName(w)?!0:(w.switchU&&(w.current()===99&&w.raise("Invalid unicode escape"),w.raise("Invalid escape")),!1)},dt.regexp_eatBackReference=function(w){var R=w.pos;if(this.regexp_eatDecimalEscape(w)){var O=w.lastIntValue;if(w.switchU)return O>w.maxBackReference&&(w.maxBackReference=O),!0;if(O<=w.numCapturingParens)return!0;w.pos=R}return!1},dt.regexp_eatKGroupName=function(w){if(w.eat(107)){if(this.regexp_eatGroupName(w))return w.backReferenceNames.push(w.lastStringValue),!0;w.raise("Invalid named reference")}return!1},dt.regexp_eatCharacterEscape=function(w){return this.regexp_eatControlEscape(w)||this.regexp_eatCControlLetter(w)||this.regexp_eatZero(w)||this.regexp_eatHexEscapeSequence(w)||this.regexp_eatRegExpUnicodeEscapeSequence(w)||!w.switchU&&this.regexp_eatLegacyOctalEscapeSequence(w)||this.regexp_eatIdentityEscape(w)},dt.regexp_eatCControlLetter=function(w){var R=w.pos;if(w.eat(99)){if(this.regexp_eatControlLetter(w))return!0;w.pos=R}return!1},dt.regexp_eatZero=function(w){return w.current()===48&&!Ip(w.lookahead())?(w.lastIntValue=0,w.advance(),!0):!1},dt.regexp_eatControlEscape=function(w){var R=w.current();return R===116?(w.lastIntValue=9,w.advance(),!0):R===110?(w.lastIntValue=10,w.advance(),!0):R===118?(w.lastIntValue=11,w.advance(),!0):R===102?(w.lastIntValue=12,w.advance(),!0):R===114?(w.lastIntValue=13,w.advance(),!0):!1},dt.regexp_eatControlLetter=function(w){var R=w.current();return Bw(R)?(w.lastIntValue=R%32,w.advance(),!0):!1};function Bw(w){return w>=65&&w<=90||w>=97&&w<=122}dt.regexp_eatRegExpUnicodeEscapeSequence=function(w){var R=w.pos;if(w.eat(117)){if(this.regexp_eatFixedHexDigits(w,4)){var O=w.lastIntValue;if(w.switchU&&O>=55296&&O<=56319){var W=w.pos;if(w.eat(92)&&w.eat(117)&&this.regexp_eatFixedHexDigits(w,4)){var Y=w.lastIntValue;if(Y>=56320&&Y<=57343)return w.lastIntValue=(O-55296)*1024+(Y-56320)+65536,!0}w.pos=W,w.lastIntValue=O}return!0}if(w.switchU&&w.eat(123)&&this.regexp_eatHexDigits(w)&&w.eat(125)&&bM(w.lastIntValue))return!0;w.switchU&&w.raise("Invalid unicode escape"),w.pos=R}return!1};function bM(w){return w>=0&&w<=1114111}dt.regexp_eatIdentityEscape=function(w){if(w.switchU)return this.regexp_eatSyntaxCharacter(w)?!0:w.eat(47)?(w.lastIntValue=47,!0):!1;var R=w.current();return R!==99&&(!w.switchN||R!==107)?(w.lastIntValue=R,w.advance(),!0):!1},dt.regexp_eatDecimalEscape=function(w){w.lastIntValue=0;var R=w.current();if(R>=49&&R<=57){do w.lastIntValue=10*w.lastIntValue+(R-48),w.advance();while((R=w.current())>=48&&R<=57);return!0}return!1},dt.regexp_eatCharacterClassEscape=function(w){var R=w.current();if(yM(R))return w.lastIntValue=-1,w.advance(),!0;if(w.switchU&&this.options.ecmaVersion>=9&&(R===80||R===112)){if(w.lastIntValue=-1,w.advance(),w.eat(123)&&this.regexp_eatUnicodePropertyValueExpression(w)&&w.eat(125))return!0;w.raise("Invalid property name")}return!1};function yM(w){return w===100||w===68||w===115||w===83||w===119||w===87}dt.regexp_eatUnicodePropertyValueExpression=function(w){var R=w.pos;if(this.regexp_eatUnicodePropertyName(w)&&w.eat(61)){var O=w.lastStringValue;if(this.regexp_eatUnicodePropertyValue(w)){var W=w.lastStringValue;return this.regexp_validateUnicodePropertyNameAndValue(w,O,W),!0}}if(w.pos=R,this.regexp_eatLoneUnicodePropertyNameOrValue(w)){var Y=w.lastStringValue;return this.regexp_validateUnicodePropertyNameOrValue(w,Y),!0}return!1},dt.regexp_validateUnicodePropertyNameAndValue=function(w,R,O){L(w.unicodeProperties.nonBinary,R)||w.raise("Invalid property name"),w.unicodeProperties.nonBinary[R].test(O)||w.raise("Invalid property value")},dt.regexp_validateUnicodePropertyNameOrValue=function(w,R){w.unicodeProperties.binary.test(R)||w.raise("Invalid property name")},dt.regexp_eatUnicodePropertyName=function(w){var R=0;for(w.lastStringValue="";zw(R=w.current());)w.lastStringValue+=Tp(R),w.advance();return w.lastStringValue!==""};function zw(w){return Bw(w)||w===95}dt.regexp_eatUnicodePropertyValue=function(w){var R=0;for(w.lastStringValue="";vM(R=w.current());)w.lastStringValue+=Tp(R),w.advance();return w.lastStringValue!==""};function vM(w){return zw(w)||Ip(w)}dt.regexp_eatLoneUnicodePropertyNameOrValue=function(w){return this.regexp_eatUnicodePropertyValue(w)},dt.regexp_eatCharacterClass=function(w){if(w.eat(91)){if(w.eat(94),this.regexp_classRanges(w),w.eat(93))return!0;w.raise("Unterminated character class")}return!1},dt.regexp_classRanges=function(w){for(;this.regexp_eatClassAtom(w);){var R=w.lastIntValue;if(w.eat(45)&&this.regexp_eatClassAtom(w)){var O=w.lastIntValue;w.switchU&&(R===-1||O===-1)&&w.raise("Invalid character class"),R!==-1&&O!==-1&&R>O&&w.raise("Range out of order in character class")}}},dt.regexp_eatClassAtom=function(w){var R=w.pos;if(w.eat(92)){if(this.regexp_eatClassEscape(w))return!0;if(w.switchU){var O=w.current();(O===99||Ww(O))&&w.raise("Invalid class escape"),w.raise("Invalid escape")}w.pos=R}var W=w.current();return W!==93?(w.lastIntValue=W,w.advance(),!0):!1},dt.regexp_eatClassEscape=function(w){var R=w.pos;if(w.eat(98))return w.lastIntValue=8,!0;if(w.switchU&&w.eat(45))return w.lastIntValue=45,!0;if(!w.switchU&&w.eat(99)){if(this.regexp_eatClassControlLetter(w))return!0;w.pos=R}return this.regexp_eatCharacterClassEscape(w)||this.regexp_eatCharacterEscape(w)},dt.regexp_eatClassControlLetter=function(w){var R=w.current();return Ip(R)||R===95?(w.lastIntValue=R%32,w.advance(),!0):!1},dt.regexp_eatHexEscapeSequence=function(w){var R=w.pos;if(w.eat(120)){if(this.regexp_eatFixedHexDigits(w,2))return!0;w.switchU&&w.raise("Invalid escape"),w.pos=R}return!1},dt.regexp_eatDecimalDigits=function(w){var R=w.pos,O=0;for(w.lastIntValue=0;Ip(O=w.current());)w.lastIntValue=10*w.lastIntValue+(O-48),w.advance();return w.pos!==R};function Ip(w){return w>=48&&w<=57}dt.regexp_eatHexDigits=function(w){var R=w.pos,O=0;for(w.lastIntValue=0;Gw(O=w.current());)w.lastIntValue=16*w.lastIntValue+Vw(O),w.advance();return w.pos!==R};function Gw(w){return w>=48&&w<=57||w>=65&&w<=70||w>=97&&w<=102}function Vw(w){return w>=65&&w<=70?10+(w-65):w>=97&&w<=102?10+(w-97):w-48}dt.regexp_eatLegacyOctalEscapeSequence=function(w){if(this.regexp_eatOctalDigit(w)){var R=w.lastIntValue;if(this.regexp_eatOctalDigit(w)){var O=w.lastIntValue;R<=3&&this.regexp_eatOctalDigit(w)?w.lastIntValue=R*64+O*8+w.lastIntValue:w.lastIntValue=R*8+O}else w.lastIntValue=R;return!0}return!1},dt.regexp_eatOctalDigit=function(w){var R=w.current();return Ww(R)?(w.lastIntValue=R-48,w.advance(),!0):(w.lastIntValue=0,!1)};function Ww(w){return w>=48&&w<=55}dt.regexp_eatFixedHexDigits=function(w,R){var O=w.pos;w.lastIntValue=0;for(var W=0;W<R;++W){var Y=w.current();if(!Gw(Y))return w.pos=O,!1;w.lastIntValue=16*w.lastIntValue+Vw(Y),w.advance()}return!0};var kp=function(R){this.type=R.type,this.value=R.value,this.start=R.start,this.end=R.end,R.options.locations&&(this.loc=new J(R,R.startLoc,R.endLoc)),R.options.ranges&&(this.range=[R.start,R.end])},Mt=Ae.prototype;Mt.next=function(w){!w&&this.type.keyword&&this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword "+this.type.keyword),this.options.onToken&&this.options.onToken(new kp(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken()},Mt.getToken=function(){return this.next(),new kp(this)},typeof Symbol<"u"&&(Mt[Symbol.iterator]=function(){var w=this;return{next:function(){var R=w.getToken();return{done:R.type===S.eof,value:R}}}}),Mt.curContext=function(){return this.context[this.context.length-1]},Mt.nextToken=function(){var w=this.curContext();if((!w||!w.preserveSpace)&&this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length)return this.finishToken(S.eof);if(w.override)return w.override(this);this.readToken(this.fullCharCodeAtPos())},Mt.readToken=function(w){return x(w,this.options.ecmaVersion>=6)||w===92?this.readWord():this.getTokenFromCode(w)},Mt.fullCharCodeAtPos=function(){var w=this.input.charCodeAt(this.pos);if(w<=55295||w>=57344)return w;var R=this.input.charCodeAt(this.pos+1);return(w<<10)+R-56613888},Mt.skipBlockComment=function(){var w=this.options.onComment&&this.curPosition(),R=this.pos,O=this.input.indexOf("*/",this.pos+=2);if(O===-1&&this.raise(this.pos-2,"Unterminated comment"),this.pos=O+2,this.options.locations){_.lastIndex=R;for(var W;(W=_.exec(this.input))&&W.index<this.pos;)++this.curLine,this.lineStart=W.index+W[0].length}this.options.onComment&&this.options.onComment(!0,this.input.slice(R+2,O),R,this.pos,w,this.curPosition())},Mt.skipLineComment=function(w){for(var R=this.pos,O=this.options.onComment&&this.curPosition(),W=this.input.charCodeAt(this.pos+=w);this.pos<this.input.length&&!N(W);)W=this.input.charCodeAt(++this.pos);this.options.onComment&&this.options.onComment(!1,this.input.slice(R+w,this.pos),R,this.pos,O,this.curPosition())},Mt.skipSpace=function(){e:for(;this.pos<this.input.length;){var w=this.input.charCodeAt(this.pos);switch(w){case 32:case 160:++this.pos;break;case 13:this.input.charCodeAt(this.pos+1)===10&&++this.pos;case 10:case 8232:case 8233:++this.pos,this.options.locations&&(++this.curLine,this.lineStart=this.pos);break;case 47:switch(this.input.charCodeAt(this.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break e}break;default:if(w>8&&w<14||w>=5760&&P.test(String.fromCharCode(w)))++this.pos;else break e}}},Mt.finishToken=function(w,R){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var O=this.type;this.type=w,this.value=R,this.updateContext(O)},Mt.readToken_dot=function(){var w=this.input.charCodeAt(this.pos+1);if(w>=48&&w<=57)return this.readNumber(!0);var R=this.input.charCodeAt(this.pos+2);return this.options.ecmaVersion>=6&&w===46&&R===46?(this.pos+=3,this.finishToken(S.ellipsis)):(++this.pos,this.finishToken(S.dot))},Mt.readToken_slash=function(){var w=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):w===61?this.finishOp(S.assign,2):this.finishOp(S.slash,1)},Mt.readToken_mult_modulo_exp=function(w){var R=this.input.charCodeAt(this.pos+1),O=1,W=w===42?S.star:S.modulo;return this.options.ecmaVersion>=7&&w===42&&R===42&&(++O,W=S.starstar,R=this.input.charCodeAt(this.pos+2)),R===61?this.finishOp(S.assign,O+1):this.finishOp(W,O)},Mt.readToken_pipe_amp=function(w){var R=this.input.charCodeAt(this.pos+1);return R===w?this.finishOp(w===124?S.logicalOR:S.logicalAND,2):R===61?this.finishOp(S.assign,2):this.finishOp(w===124?S.bitwiseOR:S.bitwiseAND,1)},Mt.readToken_caret=function(){var w=this.input.charCodeAt(this.pos+1);return w===61?this.finishOp(S.assign,2):this.finishOp(S.bitwiseXOR,1)},Mt.readToken_plus_min=function(w){var R=this.input.charCodeAt(this.pos+1);return R===w?R===45&&!this.inModule&&this.input.charCodeAt(this.pos+2)===62&&(this.lastTokEnd===0||E.test(this.input.slice(this.lastTokEnd,this.pos)))?(this.skipLineComment(3),this.skipSpace(),this.nextToken()):this.finishOp(S.incDec,2):R===61?this.finishOp(S.assign,2):this.finishOp(S.plusMin,1)},Mt.readToken_lt_gt=function(w){var R=this.input.charCodeAt(this.pos+1),O=1;return R===w?(O=w===62&&this.input.charCodeAt(this.pos+2)===62?3:2,this.input.charCodeAt(this.pos+O)===61?this.finishOp(S.assign,O+1):this.finishOp(S.bitShift,O)):R===33&&w===60&&!this.inModule&&this.input.charCodeAt(this.pos+2)===45&&this.input.charCodeAt(this.pos+3)===45?(this.skipLineComment(4),this.skipSpace(),this.nextToken()):(R===61&&(O=2),this.finishOp(S.relational,O))},Mt.readToken_eq_excl=function(w){var R=this.input.charCodeAt(this.pos+1);return R===61?this.finishOp(S.equality,this.input.charCodeAt(this.pos+2)===61?3:2):w===61&&R===62&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(S.arrow)):this.finishOp(w===61?S.eq:S.prefix,1)},Mt.getTokenFromCode=function(w){switch(w){case 46:return this.readToken_dot();case 40:return++this.pos,this.finishToken(S.parenL);case 41:return++this.pos,this.finishToken(S.parenR);case 59:return++this.pos,this.finishToken(S.semi);case 44:return++this.pos,this.finishToken(S.comma);case 91:return++this.pos,this.finishToken(S.bracketL);case 93:return++this.pos,this.finishToken(S.bracketR);case 123:return++this.pos,this.finishToken(S.braceL);case 125:return++this.pos,this.finishToken(S.braceR);case 58:return++this.pos,this.finishToken(S.colon);case 63:return++this.pos,this.finishToken(S.question);case 96:if(this.options.ecmaVersion<6)break;return++this.pos,this.finishToken(S.backQuote);case 48:var R=this.input.charCodeAt(this.pos+1);if(R===120||R===88)return this.readRadixNumber(16);if(this.options.ecmaVersion>=6){if(R===111||R===79)return this.readRadixNumber(8);if(R===98||R===66)return this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(!1);case 34:case 39:return this.readString(w);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo_exp(w);case 124:case 38:return this.readToken_pipe_amp(w);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(w);case 60:case 62:return this.readToken_lt_gt(w);case 61:case 33:return this.readToken_eq_excl(w);case 126:return this.finishOp(S.prefix,1)}this.raise(this.pos,"Unexpected character '"+sb(w)+"'")},Mt.finishOp=function(w,R){var O=this.input.slice(this.pos,this.pos+R);return this.pos+=R,this.finishToken(w,O)},Mt.readRegexp=function(){for(var w,R,O=this.pos;;){this.pos>=this.input.length&&this.raise(O,"Unterminated regular expression");var W=this.input.charAt(this.pos);if(E.test(W)&&this.raise(O,"Unterminated regular expression"),w)w=!1;else{if(W==="[")R=!0;else if(W==="]"&&R)R=!1;else if(W==="/"&&!R)break;w=W==="\\"}++this.pos}var Y=this.input.slice(O,this.pos);++this.pos;var ge=this.pos,Ce=this.readWord1();this.containsEsc&&this.unexpected(ge);var et=this.regexpState||(this.regexpState=new no(this));et.reset(O,Y,Ce),this.validateRegExpFlags(et),this.validateRegExpPattern(et);var gt=null;try{gt=new RegExp(Y,Ce)}catch{}return this.finishToken(S.regexp,{pattern:Y,flags:Ce,value:gt})},Mt.readInt=function(w,R){for(var O=this.pos,W=0,Y=0,ge=R??1/0;Y<ge;++Y){var Ce=this.input.charCodeAt(this.pos),et=void 0;if(Ce>=97?et=Ce-97+10:Ce>=65?et=Ce-65+10:Ce>=48&&Ce<=57?et=Ce-48:et=1/0,et>=w)break;++this.pos,W=W*w+et}return this.pos===O||R!=null&&this.pos-O!==R?null:W},Mt.readRadixNumber=function(w){var R=this.pos;this.pos+=2;var O=this.readInt(w);return O==null&&this.raise(this.start+2,"Expected number in radix "+w),this.options.ecmaVersion>=11&&this.input.charCodeAt(this.pos)===110?(O=typeof BigInt<"u"?BigInt(this.input.slice(R,this.pos)):null,++this.pos):x(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(S.num,O)},Mt.readNumber=function(w){var R=this.pos;!w&&this.readInt(10)===null&&this.raise(R,"Invalid number");var O=this.pos-R>=2&&this.input.charCodeAt(R)===48;O&&this.strict&&this.raise(R,"Invalid number");var W=this.input.charCodeAt(this.pos);if(!O&&!w&&this.options.ecmaVersion>=11&&W===110){var Y=this.input.slice(R,this.pos),ge=typeof BigInt<"u"?BigInt(Y):null;return++this.pos,x(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(S.num,ge)}O&&/[89]/.test(this.input.slice(R,this.pos))&&(O=!1),W===46&&!O&&(++this.pos,this.readInt(10),W=this.input.charCodeAt(this.pos)),(W===69||W===101)&&!O&&(W=this.input.charCodeAt(++this.pos),(W===43||W===45)&&++this.pos,this.readInt(10)===null&&this.raise(R,"Invalid number")),x(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var Ce=this.input.slice(R,this.pos),et=O?parseInt(Ce,8):parseFloat(Ce);return this.finishToken(S.num,et)},Mt.readCodePoint=function(){var w=this.input.charCodeAt(this.pos),R;if(w===123){this.options.ecmaVersion<6&&this.unexpected();var O=++this.pos;R=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,R>1114111&&this.invalidStringToken(O,"Code point out of bounds")}else R=this.readHexChar(4);return R};function sb(w){return w<=65535?String.fromCharCode(w):(w-=65536,String.fromCharCode((w>>10)+55296,(w&1023)+56320))}Mt.readString=function(w){for(var R="",O=++this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated string constant");var W=this.input.charCodeAt(this.pos);if(W===w)break;W===92?(R+=this.input.slice(O,this.pos),R+=this.readEscapedChar(!1),O=this.pos):(N(W,this.options.ecmaVersion>=10)&&this.raise(this.start,"Unterminated string constant"),++this.pos)}return R+=this.input.slice(O,this.pos++),this.finishToken(S.string,R)};var Hw={};Mt.tryReadTemplateToken=function(){this.inTemplateElement=!0;try{this.readTmplToken()}catch(w){if(w===Hw)this.readInvalidTemplateToken();else throw w}this.inTemplateElement=!1},Mt.invalidStringToken=function(w,R){if(this.inTemplateElement&&this.options.ecmaVersion>=9)throw Hw;this.raise(w,R)},Mt.readTmplToken=function(){for(var w="",R=this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated template");var O=this.input.charCodeAt(this.pos);if(O===96||O===36&&this.input.charCodeAt(this.pos+1)===123)return this.pos===this.start&&(this.type===S.template||this.type===S.invalidTemplate)?O===36?(this.pos+=2,this.finishToken(S.dollarBraceL)):(++this.pos,this.finishToken(S.backQuote)):(w+=this.input.slice(R,this.pos),this.finishToken(S.template,w));if(O===92)w+=this.input.slice(R,this.pos),w+=this.readEscapedChar(!0),R=this.pos;else if(N(O)){switch(w+=this.input.slice(R,this.pos),++this.pos,O){case 13:this.input.charCodeAt(this.pos)===10&&++this.pos;case 10:w+=`
`;break;default:w+=String.fromCharCode(O);break}this.options.locations&&(++this.curLine,this.lineStart=this.pos),R=this.pos}else++this.pos}},Mt.readInvalidTemplateToken=function(){for(;this.pos<this.input.length;this.pos++)switch(this.input[this.pos]){case"\\":++this.pos;break;case"$":if(this.input[this.pos+1]!=="{")break;case"`":return this.finishToken(S.invalidTemplate,this.input.slice(this.start,this.pos))}this.raise(this.start,"Unterminated template")},Mt.readEscapedChar=function(w){var R=this.input.charCodeAt(++this.pos);switch(++this.pos,R){case 110:return`
`;case 114:return"\r";case 120:return String.fromCharCode(this.readHexChar(2));case 117:return sb(this.readCodePoint());case 116:return"	";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 13:this.input.charCodeAt(this.pos)===10&&++this.pos;case 10:return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";case 56:case 57:if(w){var O=this.pos-1;return this.invalidStringToken(O,"Invalid escape sequence in template string"),null}default:if(R>=48&&R<=55){var W=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],Y=parseInt(W,8);return Y>255&&(W=W.slice(0,-1),Y=parseInt(W,8)),this.pos+=W.length-1,R=this.input.charCodeAt(this.pos),(W!=="0"||R===56||R===57)&&(this.strict||w)&&this.invalidStringToken(this.pos-1-W.length,w?"Octal literal in template string":"Octal literal in strict mode"),String.fromCharCode(Y)}return N(R)?"":String.fromCharCode(R)}},Mt.readHexChar=function(w){var R=this.pos,O=this.readInt(16,w);return O===null&&this.invalidStringToken(R,"Bad character escape sequence"),O},Mt.readWord1=function(){this.containsEsc=!1;for(var w="",R=!0,O=this.pos,W=this.options.ecmaVersion>=6;this.pos<this.input.length;){var Y=this.fullCharCodeAtPos();if(b(Y,W))this.pos+=Y<=65535?1:2;else if(Y===92){this.containsEsc=!0,w+=this.input.slice(O,this.pos);var ge=this.pos;this.input.charCodeAt(++this.pos)!==117&&this.invalidStringToken(this.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.pos;var Ce=this.readCodePoint();(R?x:b)(Ce,W)||this.invalidStringToken(ge,"Invalid Unicode escape"),w+=sb(Ce),O=this.pos}else break;R=!1}return w+this.input.slice(O,this.pos)},Mt.readWord=function(){var w=this.readWord1(),R=S.name;return this.keywords.test(w)&&(R=$[w]),this.finishToken(R,w)};var Kw="7.1.0";Ae.acorn={Parser:Ae,version:Kw,defaultOptions:fe,Position:Z,SourceLocation:J,getLineInfo:se,Node:wp,TokenType:v,tokTypes:S,keywordTypes:$,TokContext:Ar,tokContexts:An,isIdentifierChar:b,isIdentifierStart:x,Token:kp,isNewLine:N,lineBreak:E,lineBreakG:_,nonASCIIwhitespace:P};function wM(w,R){return Ae.parse(w,R)}function SM(w,R,O){return Ae.parseExpressionAt(w,R,O)}function CM(w,R){return Ae.tokenizer(w,R)}i.Node=wp,i.Parser=Ae,i.Position=Z,i.SourceLocation=J,i.TokContext=Ar,i.Token=kp,i.TokenType=v,i.defaultOptions=fe,i.getLineInfo=se,i.isIdentifierChar=b,i.isIdentifierStart=x,i.isNewLine=N,i.keywordTypes=$,i.lineBreak=E,i.lineBreakG=_,i.nonASCIIwhitespace=P,i.parse=wM,i.parseExpressionAt=SM,i.tokContexts=An,i.tokTypes=S,i.tokenizer=CM,i.version=Kw,Object.defineProperty(i,"__esModule",{value:!0})})},{}],2:[function(n,s,r){},{}],3:[function(n,s,r){function i(c,h={}){const{contextName:d="gl",throwGetError:f,useTrackablePrimitives:p,readPixelsFile:g,recording:m=[],variables:x={},onReadPixels:b,onUnrecognizedArgumentLookup:v}=h,y=new Proxy(c,{get:E}),C=[],I={};let $=0,T="",S;return y;function E(se,fe){switch(fe){case"addComment":return L;case"checkThrowError":return U;case"getReadPixelsVariableName":return S;case"insertVariable":return P;case"reset":return N;case"setIndent":return z;case"toString":return _;case"getContextVariableName":return J}return typeof c[fe]=="function"?function(){switch(fe){case"getError":return f?m.push(`${T}if (${d}.getError() !== ${d}.NONE) throw new Error('error');`):m.push(`${T}${d}.getError();`),c.getError();case"getExtension":{const Se=`${d}Variables${C.length}`;m.push(`${T}const ${Se} = ${d}.getExtension('${arguments[0]}');`);const ze=c.getExtension(arguments[0]);if(ze&&typeof ze=="object"){const ke=o(ze,{getEntity:M,useTrackablePrimitives:p,recording:m,contextName:Se,contextVariables:C,variables:x,indent:T,onUnrecognizedArgumentLookup:v});return C.push(ke),ke}else C.push(null);return ze}case"readPixels":const ve=C.indexOf(arguments[6]);let Pe;if(ve===-1){const Se=Z(arguments[6]);Se?(Pe=Se,m.push(`${T}${Se}`)):(Pe=`${d}Variable${C.length}`,C.push(arguments[6]),m.push(`${T}const ${Pe} = new ${arguments[6].constructor.name}(${arguments[6].length});`))}else Pe=`${d}Variable${ve}`;S=Pe;const Ee=[arguments[0],arguments[1],arguments[2],arguments[3],M(arguments[4]),M(arguments[5]),Pe];return m.push(`${T}${d}.readPixels(${Ee.join(", ")});`),g&&B(arguments[2],arguments[3]),b&&b(Pe,Ee),c.readPixels.apply(c,arguments);case"drawBuffers":return m.push(`${T}${d}.drawBuffers([${a(arguments[0],{contextName:d,contextVariables:C,getEntity:M,addVariable:A,variables:x,onUnrecognizedArgumentLookup:v})}]);`),c.drawBuffers(arguments[0])}let he=c[fe].apply(c,arguments);switch(typeof he){case"undefined":m.push(`${T}${j(fe,arguments)};`);return;case"number":case"boolean":if(p&&C.indexOf(u(he))===-1){m.push(`${T}const ${d}Variable${C.length} = ${j(fe,arguments)};`),C.push(he=u(he));break}default:he===null?m.push(`${j(fe,arguments)};`):m.push(`${T}const ${d}Variable${C.length} = ${j(fe,arguments)};`),C.push(he)}return he}:(I[c[fe]]=fe,c[fe])}function _(){return m.join(`
`)}function N(){for(;m.length>0;)m.pop()}function P(se,fe){x[se]=fe}function M(se){const fe=I[se];return fe?d+"."+fe:se}function z(se){T=" ".repeat(se)}function A(se,fe){const he=`${d}Variable${C.length}`;return m.push(`${T}const ${he} = ${fe};`),C.push(se),he}function B(se,fe){const he=`${d}Variable${C.length}`,ve=`imageDatum${$}`;m.push(`${T}let ${ve} = ["P3\\n# ${g}.ppm\\n", ${se}, ' ', ${fe}, "\\n255\\n"].join("");`),m.push(`${T}for (let i = 0; i < ${ve}.length; i += 4) {`),m.push(`${T}  ${ve} += ${he}[i] + ' ' + ${he}[i + 1] + ' ' + ${he}[i + 2] + ' ';`),m.push(`${T}}`),m.push(`${T}if (typeof require !== "undefined") {`),m.push(`${T}  require('fs').writeFileSync('./${g}.ppm', ${ve});`),m.push(`${T}}`),$++}function L(se){m.push(`${T}// ${se}`)}function U(){m.push(`${T}(() => {
${T}const error = ${d}.getError();
${T}if (error !== ${d}.NONE) {
${T}  const names = Object.getOwnPropertyNames(gl);
${T}  for (let i = 0; i < names.length; i++) {
${T}    const name = names[i];
${T}    if (${d}[name] === error) {
${T}      throw new Error('${d} threw ' + name);
${T}    }
${T}  }
${T}}
${T}})();`)}function j(se,fe){return`${d}.${se}(${a(fe,{contextName:d,contextVariables:C,getEntity:M,addVariable:A,variables:x,onUnrecognizedArgumentLookup:v})})`}function Z(se){if(x){for(const fe in x)if(x[fe]===se)return fe}return null}function J(se){const fe=C.indexOf(se);return fe!==-1?`${d}Variable${fe}`:null}}function o(c,h){const d=new Proxy(c,{get:I}),f={},{contextName:p,contextVariables:g,getEntity:m,useTrackablePrimitives:x,recording:b,variables:v,indent:y,onUnrecognizedArgumentLookup:C}=h;return d;function I(E,_){return typeof E[_]=="function"?function(){switch(_){case"drawBuffersWEBGL":return b.push(`${y}${p}.drawBuffersWEBGL([${a(arguments[0],{contextName:p,contextVariables:g,getEntity:$,addVariable:S,variables:v,onUnrecognizedArgumentLookup:C})}]);`),c.drawBuffersWEBGL(arguments[0])}let N=c[_].apply(c,arguments);switch(typeof N){case"undefined":b.push(`${y}${T(_,arguments)};`);return;case"number":case"boolean":x&&g.indexOf(u(N))===-1?(b.push(`${y}const ${p}Variable${g.length} = ${T(_,arguments)};`),g.push(N=u(N))):(b.push(`${y}const ${p}Variable${g.length} = ${T(_,arguments)};`),g.push(N));break;default:N===null?b.push(`${T(_,arguments)};`):b.push(`${y}const ${p}Variable${g.length} = ${T(_,arguments)};`),g.push(N)}return N}:(f[c[_]]=_,c[_])}function $(E){return f.hasOwnProperty(E)?`${p}.${f[E]}`:m(E)}function T(E,_){return`${p}.${E}(${a(_,{contextName:p,contextVariables:g,getEntity:$,addVariable:S,variables:v,onUnrecognizedArgumentLookup:C})})`}function S(E,_){const N=`${p}Variable${g.length}`;return g.push(E),b.push(`${y}const ${N} = ${_};`),N}}function a(c,h){const{variables:d,onUnrecognizedArgumentLookup:f}=h;return Array.from(c).map(g=>{const m=p(g);return m||l(g,h)}).join(", ");function p(g){if(d){for(const m in d)if(d.hasOwnProperty(m)&&d[m]===g)return m}return f?f(g):null}}function l(c,h){const{contextName:d,contextVariables:f,getEntity:p,addVariable:g,onUnrecognizedArgumentLookup:m}=h;if(typeof c>"u")return"undefined";if(c===null)return"null";const x=f.indexOf(c);if(x>-1)return`${d}Variable${x}`;switch(c.constructor.name){case"String":const b=/\n/.test(c),v=/'/.test(c),y=/"/.test(c);return b?"`"+c+"`":v&&!y?'"'+c+'"':"'"+c+"'";case"Number":return p(c);case"Boolean":return p(c);case"Array":return g(c,`new ${c.constructor.name}([${Array.from(c).join(",")}])`);case"Float32Array":case"Uint8Array":case"Uint16Array":case"Int32Array":return g(c,`new ${c.constructor.name}(${JSON.stringify(Array.from(c))})`);default:if(m){const C=m(c);if(C)return C}throw new Error(`unrecognized argument type ${c.constructor.name}`)}}function u(c){return new c.constructor(c)}typeof s<"u"&&(s.exports={glWiretap:i,glExtensionWiretap:o}),typeof window<"u"&&(i.glExtensionWiretap=o,window.glWiretap=i)},{}],4:[function(n,s,r){function i(g){const m=new Array(g.length);for(let x=0;x<g.length;x++){const b=g[x];b.toArray?m[x]=b.toArray():m[x]=b}return m}function o(){const g=i(arguments),m=new Float32Array(this.output.x);for(let x=0;x<this.output.x;x++)this.thread.x=x,this.thread.y=0,this.thread.z=0,m[x]=this._fn.apply(this,g);return m}function a(){const g=i(arguments),m=new Array(this.output.y);for(let x=0;x<this.output.y;x++){const b=new Float32Array(this.output.x);for(let v=0;v<this.output.x;v++)this.thread.x=v,this.thread.y=x,this.thread.z=0,b[v]=this._fn.apply(this,g);m[x]=b}return m}function l(){const g=i(arguments);for(let m=0;m<this.output.y;m++)for(let x=0;x<this.output.x;x++)this.thread.x=x,this.thread.y=m,this.thread.z=0,this._fn.apply(this,g)}function u(){const g=i(arguments),m=new Array(this.output.z);for(let x=0;x<this.output.z;x++){const b=new Array(this.output.y);for(let v=0;v<this.output.y;v++){const y=new Float32Array(this.output.x);for(let C=0;C<this.output.x;C++)this.thread.x=C,this.thread.y=v,this.thread.z=x,y[C]=this._fn.apply(this,g);b[v]=y}m[x]=b}return m}function c(g){g.setOutput=b=>{g.output=d(b),g.graphical&&h(g)},g.toJSON=()=>{throw new Error("Not usable with gpuMock")},g.setConstants=b=>(g.constants=b,g),g.setGraphical=b=>(g.graphical=b,g),g.setCanvas=b=>(g.canvas=b,g),g.setContext=b=>(g.context=b,g),g.destroy=()=>{},g.validateSettings=()=>{},g.graphical&&g.output&&h(g),g.exec=function(){return new Promise((b,v)=>{try{b(g.apply(g,arguments))}catch(y){v(y)}})},g.getPixels=b=>{const{x:v,y}=g.output;return b?p(g._imageData.data,v,y):g._imageData.data.slice(0)},g.color=function(b,v,y,C){typeof C>"u"&&(C=1),b=Math.floor(b*255),v=Math.floor(v*255),y=Math.floor(y*255),C=Math.floor(C*255);const I=g.output.x,$=g.output.y,T=g.thread.x,S=$-g.thread.y-1,E=T+S*I;g._colorData[E*4+0]=b,g._colorData[E*4+1]=v,g._colorData[E*4+2]=y,g._colorData[E*4+3]=C};const m=()=>g,x=["setWarnVarUsage","setArgumentTypes","setTactic","setOptimizeFloatMemory","setDebug","setLoopMaxIterations","setConstantTypes","setFunctions","setNativeFunctions","setInjectedNative","setPipeline","setPrecision","setOutputToTexture","setImmutable","setStrictIntegers","setDynamicOutput","setHardcodeConstants","setDynamicArguments","setUseLegacyEncoder","setWarnVarUsage","addSubKernel"];for(let b=0;b<x.length;b++)g[x[b]]=m;return g}function h(g){const{x:m,y:x}=g.output;if(g.context&&g.context.createImageData){const b=new Uint8ClampedArray(m*x*4);g._imageData=g.context.createImageData(m,x),g._colorData=b}else{const b=new Uint8ClampedArray(m*x*4);g._imageData={data:b},g._colorData=b}}function d(g){let m=null;if(g.length)if(g.length===3){const[x,b,v]=g;m={x,y:b,z:v}}else if(g.length===2){const[x,b]=g;m={x,y:b}}else{const[x]=g;m={x}}else m=g;return m}function f(g,m={}){const x=m.output?d(m.output):null;function b(){return b.output.z?u.apply(b,arguments):b.output.y?b.graphical?l.apply(b,arguments):a.apply(b,arguments):o.apply(b,arguments)}return b._fn=g,b.constants=m.constants||null,b.context=m.context||null,b.canvas=m.canvas||null,b.graphical=m.graphical||!1,b._imageData=null,b._colorData=null,b.output=x,b.thread={x:0,y:0,z:0},c(b)}function p(g,m,x){const b=x/2|0,v=m*4,y=new Uint8ClampedArray(m*4),C=g.slice(0);for(let I=0;I<b;++I){const $=I*v,T=(x-I-1)*v;y.set(C.subarray($,$+v)),C.copyWithin($,T,T+v),C.set(y,T)}return C}s.exports={gpuMock:f}},{}],5:[function(n,s,r){const{utils:i}=n("./utils");function o(a,l){const u=l.toString();return new Function(`return function ${a} (${i.getArgumentNamesFromString(u).join(", ")}) {
  ${i.getFunctionBodyFromString(u)}
}`)()}s.exports={alias:o}},{"./utils":114}],6:[function(n,s,r){const{FunctionNode:i}=n("../function-node");class o extends i{astFunction(l,u){if(!this.isRootKernel){u.push("function"),u.push(" "),u.push(this.name),u.push("(");for(let c=0;c<this.argumentNames.length;++c){const h=this.argumentNames[c];c>0&&u.push(", "),u.push("user_"),u.push(h)}u.push(`) {
`)}for(let c=0;c<l.body.body.length;++c)this.astGeneric(l.body.body[c],u),u.push(`
`);return this.isRootKernel||u.push(`}
`),u}astReturnStatement(l,u){const c=this.returnType||this.getType(l.argument);return this.returnType||(this.returnType=c),this.isRootKernel?(u.push(this.leadingReturnStatement),this.astGeneric(l.argument,u),u.push(`;
`),u.push(this.followingReturnStatement),u.push(`continue;
`)):this.isSubKernel?(u.push(`subKernelResult_${this.name} = `),this.astGeneric(l.argument,u),u.push(";"),u.push(`return subKernelResult_${this.name};`)):(u.push("return "),this.astGeneric(l.argument,u),u.push(";")),u}astLiteral(l,u){if(isNaN(l.value))throw this.astErrorOutput("Non-numeric literal not supported : "+l.value,l);return u.push(l.value),u}astBinaryExpression(l,u){return u.push("("),this.astGeneric(l.left,u),u.push(l.operator),this.astGeneric(l.right,u),u.push(")"),u}astIdentifierExpression(l,u){if(l.type!=="Identifier")throw this.astErrorOutput("IdentifierExpression - not an Identifier",l);switch(l.name){case"Infinity":u.push("Infinity");break;default:this.constants&&this.constants.hasOwnProperty(l.name)?u.push("constants_"+l.name):u.push("user_"+l.name)}return u}astForStatement(l,u){if(l.type!=="ForStatement")throw this.astErrorOutput("Invalid for statement",l);const c=[],h=[],d=[],f=[];let p=null;if(l.init){this.pushState("in-for-loop-init"),this.astGeneric(l.init,c);for(let g=0;g<c.length;g++)c[g].includes&&c[g].includes(",")&&(p=!1);this.popState("in-for-loop-init")}else p=!1;if(l.test?this.astGeneric(l.test,h):p=!1,l.update?this.astGeneric(l.update,d):p=!1,l.body&&(this.pushState("loop-body"),this.astGeneric(l.body,f),this.popState("loop-body")),p===null&&(p=this.isSafe(l.init)&&this.isSafe(l.test)),p)u.push(`for (${c.join("")};${h.join("")};${d.join("")}){
`),u.push(f.join("")),u.push(`}
`);else{const g=this.getInternalVariableName("safeI");c.length>0&&u.push(c.join(""),`;
`),u.push(`for (let ${g}=0;${g}<LOOP_MAX;${g}++){
`),h.length>0&&u.push(`if (!${h.join("")}) break;
`),u.push(f.join("")),u.push(`
${d.join("")};`),u.push(`}
`)}return u}astWhileStatement(l,u){if(l.type!=="WhileStatement")throw this.astErrorOutput("Invalid while statement",l);return u.push("for (let i = 0; i < LOOP_MAX; i++) {"),u.push("if ("),this.astGeneric(l.test,u),u.push(`) {
`),this.astGeneric(l.body,u),u.push(`} else {
`),u.push(`break;
`),u.push(`}
`),u.push(`}
`),u}astDoWhileStatement(l,u){if(l.type!=="DoWhileStatement")throw this.astErrorOutput("Invalid while statement",l);return u.push("for (let i = 0; i < LOOP_MAX; i++) {"),this.astGeneric(l.body,u),u.push("if (!"),this.astGeneric(l.test,u),u.push(`) {
`),u.push(`break;
`),u.push(`}
`),u.push(`}
`),u}astAssignmentExpression(l,u){const c=this.getDeclaration(l.left);if(c&&!c.assignable)throw this.astErrorOutput(`Variable ${l.left.name} is not assignable here`,l);return this.astGeneric(l.left,u),u.push(l.operator),this.astGeneric(l.right,u),u}astBlockStatement(l,u){if(this.isState("loop-body")){this.pushState("block-body");for(let c=0;c<l.body.length;c++)this.astGeneric(l.body[c],u);this.popState("block-body")}else{u.push(`{
`);for(let c=0;c<l.body.length;c++)this.astGeneric(l.body[c],u);u.push(`}
`)}return u}astVariableDeclaration(l,u){u.push(`${l.kind} `);const{declarations:c}=l;for(let h=0;h<c.length;h++){h>0&&u.push(",");const d=c[h],f=this.getDeclaration(d.id);f.valueType||(f.valueType=this.getType(d.init)),this.astGeneric(d,u)}return this.isState("in-for-loop-init")||u.push(";"),u}astIfStatement(l,u){return u.push("if ("),this.astGeneric(l.test,u),u.push(")"),l.consequent.type==="BlockStatement"?this.astGeneric(l.consequent,u):(u.push(` {
`),this.astGeneric(l.consequent,u),u.push(`
}
`)),l.alternate&&(u.push("else "),l.alternate.type==="BlockStatement"||l.alternate.type==="IfStatement"?this.astGeneric(l.alternate,u):(u.push(` {
`),this.astGeneric(l.alternate,u),u.push(`
}
`))),u}astSwitchStatement(l,u){const{discriminant:c,cases:h}=l;u.push("switch ("),this.astGeneric(c,u),u.push(`) {
`);for(let d=0;d<h.length;d++){if(h[d].test===null){u.push(`default:
`),this.astGeneric(h[d].consequent,u),h[d].consequent&&h[d].consequent.length>0&&u.push(`break;
`);continue}u.push("case "),this.astGeneric(h[d].test,u),u.push(`:
`),h[d].consequent&&h[d].consequent.length>0&&(this.astGeneric(h[d].consequent,u),u.push(`break;
`))}u.push(`
}`)}astThisExpression(l,u){return u.push("_this"),u}astMemberExpression(l,u){const{signature:c,type:h,property:d,xProperty:f,yProperty:p,zProperty:g,name:m,origin:x}=this.getMemberExpressionDetails(l);switch(c){case"this.thread.value":return u.push(`_this.thread.${m}`),u;case"this.output.value":switch(m){case"x":u.push("outputX");break;case"y":u.push("outputY");break;case"z":u.push("outputZ");break;default:throw this.astErrorOutput("Unexpected expression",l)}return u;case"value":throw this.astErrorOutput("Unexpected expression",l);case"value[]":case"value[][]":case"value[][][]":case"value.value":if(x==="Math")return u.push(Math[m]),u;switch(d){case"r":return u.push(`user_${m}[0]`),u;case"g":return u.push(`user_${m}[1]`),u;case"b":return u.push(`user_${m}[2]`),u;case"a":return u.push(`user_${m}[3]`),u}break;case"this.constants.value":case"this.constants.value[]":case"this.constants.value[][]":case"this.constants.value[][][]":break;case"fn()[]":return this.astGeneric(l.object,u),u.push("["),this.astGeneric(l.property,u),u.push("]"),u;case"fn()[][]":return this.astGeneric(l.object.object,u),u.push("["),this.astGeneric(l.object.property,u),u.push("]"),u.push("["),this.astGeneric(l.property,u),u.push("]"),u;default:throw this.astErrorOutput("Unexpected expression",l)}if(!l.computed)switch(h){case"Number":case"Integer":case"Float":case"Boolean":return u.push(`${x}_${m}`),u}const b=`${x}_${m}`;switch(h){case"Array(2)":case"Array(3)":case"Array(4)":case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":case"HTMLImageArray":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":case"HTMLImage":default:let v,y;if(x==="constants"){const C=this.constants[m];y=this.constantTypes[m]==="Input",v=y?C.size:null}else y=this.isInput(m),v=y?this.argumentSizes[this.argumentNames.indexOf(m)]:null;u.push(`${b}`),g&&p?y?(u.push("[("),this.astGeneric(g,u),u.push(`*${this.dynamicArguments?"(outputY * outputX)":v[1]*v[0]})+(`),this.astGeneric(p,u),u.push(`*${this.dynamicArguments?"outputX":v[0]})+`),this.astGeneric(f,u),u.push("]")):(u.push("["),this.astGeneric(g,u),u.push("]"),u.push("["),this.astGeneric(p,u),u.push("]"),u.push("["),this.astGeneric(f,u),u.push("]")):p?y?(u.push("[("),this.astGeneric(p,u),u.push(`*${this.dynamicArguments?"outputX":v[0]})+`),this.astGeneric(f,u),u.push("]")):(u.push("["),this.astGeneric(p,u),u.push("]"),u.push("["),this.astGeneric(f,u),u.push("]")):typeof f<"u"&&(u.push("["),this.astGeneric(f,u),u.push("]"))}return u}astCallExpression(l,u){if(l.type!=="CallExpression")throw this.astErrorOutput("Unknown CallExpression",l);let c=this.astMemberExpressionUnroll(l.callee);this.calledFunctions.indexOf(c)<0&&this.calledFunctions.push(c),this.isAstMathFunction(l),this.onFunctionCall&&this.onFunctionCall(this.name,c,l.arguments),u.push(c),u.push("(");const h=this.lookupFunctionArgumentTypes(c)||[];for(let d=0;d<l.arguments.length;++d){const f=l.arguments[d];let p=this.getType(f);h[d]||this.triggerImplyArgumentType(c,d,p,this),d>0&&u.push(", "),this.astGeneric(f,u)}return u.push(")"),u}astArrayExpression(l,u){const c=this.getType(l),h=l.elements.length,d=[];for(let f=0;f<h;++f){const p=[];this.astGeneric(l.elements[f],p),d.push(p.join(""))}switch(c){case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":u.push(`[${d.join(", ")}]`);break;default:u.push(`new Float32Array([${d.join(", ")}])`)}return u}astDebuggerStatement(l,u){return u.push("debugger;"),u}}s.exports={CPUFunctionNode:o}},{"../function-node":10}],7:[function(n,s,r){const{utils:i}=n("../../utils");function o(l,u){const c=[];for(const h in u){if(!u.hasOwnProperty(h))continue;const d=u[h],f=l[h];switch(d){case"Number":case"Integer":case"Float":case"Boolean":c.push(`${h}:${f}`);break;case"Array(2)":case"Array(3)":case"Array(4)":case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":c.push(`${h}:new ${f.constructor.name}(${JSON.stringify(Array.from(f))})`);break}}return`{ ${c.join()} }`}function a(l,u){const c=[],h=[],d=[],f=!/^function/.test(l.color.toString());if(c.push("  const { context, canvas, constants: incomingConstants } = settings;",`  const output = new Int32Array(${JSON.stringify(Array.from(l.output))});`,`  const _constantTypes = ${JSON.stringify(l.constantTypes)};`,`  const _constants = ${o(l.constants,l.constantTypes)};`),h.push("    constants: _constants,","    context,","    output,","    thread: {x: 0, y: 0, z: 0},"),l.graphical){c.push(`  const _imageData = context.createImageData(${l.output[0]}, ${l.output[1]});`),c.push(`  const _colorData = new Uint8ClampedArray(${l.output[0]} * ${l.output[1]} * 4);`);const m=i.flattenFunctionToString((f?"function ":"")+l.color.toString(),{thisLookup:b=>{switch(b){case"_colorData":return"_colorData";case"_imageData":return"_imageData";case"output":return"output";case"thread":return"this.thread"}return JSON.stringify(l[b])},findDependency:(b,v)=>null}),x=i.flattenFunctionToString((f?"function ":"")+l.getPixels.toString(),{thisLookup:b=>{switch(b){case"_colorData":return"_colorData";case"_imageData":return"_imageData";case"output":return"output";case"thread":return"this.thread"}return JSON.stringify(l[b])},findDependency:()=>null});h.push("    _imageData,","    _colorData,",`    color: ${m},`),d.push(`  kernel.getPixels = ${x};`)}const p=[],g=Object.keys(l.constantTypes);for(let m=0;m<g.length;m++)p.push(l.constantTypes[g]);if(l.argumentTypes.indexOf("HTMLImageArray")!==-1||p.indexOf("HTMLImageArray")!==-1){const m=i.flattenFunctionToString((f?"function ":"")+l._imageTo3DArray.toString(),{doNotDefine:["canvas"],findDependency:(x,b)=>x==="this"?(f?"function ":"")+l[b].toString():null,thisLookup:x=>{switch(x){case"canvas":return;case"context":return"context"}}});d.push(m),h.push("    _mediaTo2DArray,"),h.push("    _imageTo3DArray,")}else if(l.argumentTypes.indexOf("HTMLImage")!==-1||p.indexOf("HTMLImage")!==-1){const m=i.flattenFunctionToString((f?"function ":"")+l._mediaTo2DArray.toString(),{findDependency:(x,b)=>null,thisLookup:x=>{switch(x){case"canvas":return"settings.canvas";case"context":return"settings.context"}throw new Error("unhandled thisLookup")}});d.push(m),h.push("    _mediaTo2DArray,")}return`function(settings) {
${c.join(`
`)}
  for (const p in _constantTypes) {
    if (!_constantTypes.hasOwnProperty(p)) continue;
    const type = _constantTypes[p];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        if (incomingConstants.hasOwnProperty(p)) {
          console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');
        }
        continue;
    }
    if (!incomingConstants.hasOwnProperty(p)) {
      throw new Error('constant ' + p + ' not found');
    }
    _constants[p] = incomingConstants[p];
  }
  const kernel = (function() {
${l._kernelString}
  })
    .apply({ ${h.join(`
`)} });
  ${d.join(`
`)}
  return kernel;
}`}s.exports={cpuKernelString:a}},{"../../utils":114}],8:[function(n,s,r){const{Kernel:i}=n("../kernel"),{FunctionBuilder:o}=n("../function-builder"),{CPUFunctionNode:a}=n("./function-node"),{utils:l}=n("../../utils"),{cpuKernelString:u}=n("./kernel-string");class c extends i{static getFeatures(){return this.features}static get features(){return Object.freeze({kernelMap:!0,isIntegerDivisionAccurate:!0})}static get isSupported(){return!0}static isContextMatch(d){return!1}static get mode(){return"cpu"}static nativeFunctionArguments(){return null}static nativeFunctionReturnType(){throw new Error(`Looking up native function return type not supported on ${this.name}`)}static combineKernels(d){return d}static getSignature(d,f){return"cpu"+(f.length>0?":"+f.join(","):"")}constructor(d,f){super(d,f),this.mergeSettings(d.settings||f),this._imageData=null,this._colorData=null,this._kernelString=null,this._prependedString=[],this.thread={x:0,y:0,z:0},this.translatedSources=null}initCanvas(){if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(0,0)}initContext(){return this.canvas?this.canvas.getContext("2d"):null}initPlugins(d){return[]}validateSettings(d){if(!this.output||this.output.length===0){if(d.length!==1)throw new Error("Auto output only supported for kernels with only one input");const f=l.getVariableType(d[0],this.strictIntegers);if(f==="Array")this.output=l.getDimensions(f);else if(f==="NumberTexture"||f==="ArrayTexture(4)")this.output=d[0].output;else throw new Error("Auto output not supported for input type: "+f)}if(this.graphical&&this.output.length!==2)throw new Error("Output must have 2 dimensions on graphical mode");this.checkOutput()}translateSource(){if(this.leadingReturnStatement=this.output.length>1?"resultX[x] = ":"result[x] = ",this.subKernels){const f=[];for(let p=0;p<this.subKernels.length;p++){const{name:g}=this.subKernels[p];f.push(this.output.length>1?`resultX_${g}[x] = subKernelResult_${g};
`:`result_${g}[x] = subKernelResult_${g};
`)}this.followingReturnStatement=f.join("")}const d=o.fromKernel(this,a);this.translatedSources=d.getPrototypes("kernel"),!this.graphical&&!this.returnType&&(this.returnType=d.getKernelResultType())}build(){if(this.built)return;if(this.setupConstants(),this.setupArguments(arguments),this.validateSettings(arguments),this.translateSource(),this.graphical){const{canvas:f,output:p}=this;if(!f)throw new Error("no canvas available for using graphical output");const g=p[0],m=p[1]||1;f.width=g,f.height=m,this._imageData=this.context.createImageData(g,m),this._colorData=new Uint8ClampedArray(g*m*4)}const d=this.getKernelString();this.kernelString=d,this.debug&&(console.log("Function output:"),console.log(d));try{this.run=new Function([],d).bind(this)()}catch(f){console.error("An error occurred compiling the javascript: ",f)}this.buildSignature(arguments),this.built=!0}color(d,f,p,g){typeof g>"u"&&(g=1),d=Math.floor(d*255),f=Math.floor(f*255),p=Math.floor(p*255),g=Math.floor(g*255);const m=this.output[0],x=this.output[1],b=this.thread.x,v=x-this.thread.y-1,y=b+v*m;this._colorData[y*4+0]=d,this._colorData[y*4+1]=f,this._colorData[y*4+2]=p,this._colorData[y*4+3]=g}getKernelString(){if(this._kernelString!==null)return this._kernelString;let d=null,{translatedSources:f}=this;return f.length>1?f=f.filter(p=>/^function/.test(p)?p:(d=p,!1)):d=f.shift(),this._kernelString=`  const LOOP_MAX = ${this._getLoopMaxString()};
  ${this.injectedNative||""}
  const _this = this;
  ${this._resultKernelHeader()}
  ${this._processConstants()}
  return (${this.argumentNames.map(p=>"user_"+p).join(", ")}) => {
    ${this._prependedString.join("")}
    ${this._earlyThrows()}
    ${this._processArguments()}
    ${this.graphical?this._graphicalKernelBody(d):this._resultKernelBody(d)}
    ${f.length>0?f.join(`
`):""}
  };`}toString(){return u(this)}_getLoopMaxString(){return this.loopMaxIterations?` ${parseInt(this.loopMaxIterations)};`:" 1000;"}_processConstants(){if(!this.constants)return"";const d=[];for(let f in this.constants)switch(this.constantTypes[f]){case"HTMLCanvas":case"OffscreenCanvas":case"HTMLImage":case"ImageBitmap":case"ImageData":case"HTMLVideo":d.push(`    const constants_${f} = this._mediaTo2DArray(this.constants.${f});
`);break;case"HTMLImageArray":d.push(`    const constants_${f} = this._imageTo3DArray(this.constants.${f});
`);break;case"Input":d.push(`    const constants_${f} = this.constants.${f}.value;
`);break;default:d.push(`    const constants_${f} = this.constants.${f};
`)}return d.join("")}_earlyThrows(){if(this.graphical||this.immutable||!this.pipeline)return"";const d=[];for(let p=0;p<this.argumentTypes.length;p++)this.argumentTypes[p]==="Array"&&d.push(this.argumentNames[p]);if(d.length===0)return"";const f=[];for(let p=0;p<d.length;p++){const g=d[p],m=this._mapSubKernels(x=>`user_${g} === result_${x.name}`).join(" || ");f.push(`user_${g} === result${m?` || ${m}`:""}`)}return`if (${f.join(" || ")}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`}_processArguments(){const d=[];for(let f=0;f<this.argumentTypes.length;f++){const p=`user_${this.argumentNames[f]}`;switch(this.argumentTypes[f]){case"HTMLCanvas":case"OffscreenCanvas":case"HTMLImage":case"ImageBitmap":case"ImageData":case"HTMLVideo":d.push(`    ${p} = this._mediaTo2DArray(${p});
`);break;case"HTMLImageArray":d.push(`    ${p} = this._imageTo3DArray(${p});
`);break;case"Input":d.push(`    ${p} = ${p}.value;
`);break;case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":case"NumberTexture":case"MemoryOptimizedNumberTexture":d.push(`
    if (${p}.toArray) {
      if (!_this.textureCache) {
        _this.textureCache = [];
        _this.arrayCache = [];
      }
      const textureIndex = _this.textureCache.indexOf(${p});
      if (textureIndex !== -1) {
        ${p} = _this.arrayCache[textureIndex];
      } else {
        _this.textureCache.push(${p});
        ${p} = ${p}.toArray();
        _this.arrayCache.push(${p});
      }
    }`);break}}return d.join("")}_mediaTo2DArray(d){const f=this.canvas,p=d.width>0?d.width:d.videoWidth,g=d.height>0?d.height:d.videoHeight;f.width<p&&(f.width=p),f.height<g&&(f.height=g);const m=this.context;let x;d.constructor===ImageData?x=d.data:(m.drawImage(d,0,0,p,g),x=m.getImageData(0,0,p,g).data);const b=new Array(g);let v=0;for(let y=g-1;y>=0;y--){const C=b[y]=new Array(p);for(let I=0;I<p;I++){const $=new Float32Array(4);$[0]=x[v++]/255,$[1]=x[v++]/255,$[2]=x[v++]/255,$[3]=x[v++]/255,C[I]=$}}return b}getPixels(d){const[f,p]=this.output;return d?l.flipPixels(this._imageData.data,f,p):this._imageData.data.slice(0)}_imageTo3DArray(d){const f=new Array(d.length);for(let p=0;p<d.length;p++)f[p]=this._mediaTo2DArray(d[p]);return f}_resultKernelHeader(){if(this.graphical||this.immutable||!this.pipeline)return"";switch(this.output.length){case 1:return this._mutableKernel1DResults();case 2:return this._mutableKernel2DResults();case 3:return this._mutableKernel3DResults()}}_resultKernelBody(d){switch(this.output.length){case 1:return(!this.immutable&&this.pipeline?this._resultMutableKernel1DLoop(d):this._resultImmutableKernel1DLoop(d))+this._kernelOutput();case 2:return(!this.immutable&&this.pipeline?this._resultMutableKernel2DLoop(d):this._resultImmutableKernel2DLoop(d))+this._kernelOutput();case 3:return(!this.immutable&&this.pipeline?this._resultMutableKernel3DLoop(d):this._resultImmutableKernel3DLoop(d))+this._kernelOutput();default:throw new Error("unsupported size kernel")}}_graphicalKernelBody(d){switch(this.output.length){case 2:return this._graphicalKernel2DLoop(d)+this._graphicalOutput();default:throw new Error("unsupported size kernel")}}_graphicalOutput(){return`
    this._imageData.data.set(this._colorData);
    this.context.putImageData(this._imageData, 0, 0);
    return;`}_getKernelResultTypeConstructorString(){switch(this.returnType){case"LiteralInteger":case"Number":case"Integer":case"Float":return"Float32Array";case"Array(2)":case"Array(3)":case"Array(4)":return"Array";default:if(this.graphical)return"Float32Array";throw new Error(`unhandled returnType ${this.returnType}`)}}_resultImmutableKernel1DLoop(d){const f=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const result = new ${f}(outputX);
    ${this._mapSubKernels(p=>`const result_${p.name} = new ${f}(outputX);
`).join("    ")}
    ${this._mapSubKernels(p=>`let subKernelResult_${p.name};
`).join("    ")}
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${d}
    }`}_mutableKernel1DResults(){const d=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const result = new ${d}(outputX);
    ${this._mapSubKernels(f=>`const result_${f.name} = new ${d}(outputX);
`).join("    ")}
    ${this._mapSubKernels(f=>`let subKernelResult_${f.name};
`).join("    ")}`}_resultMutableKernel1DLoop(d){return`  const outputX = _this.output[0];
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${d}
    }`}_resultImmutableKernel2DLoop(d){const f=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${this._mapSubKernels(p=>`const result_${p.name} = new Array(outputY);
`).join("    ")}
    ${this._mapSubKernels(p=>`let subKernelResult_${p.name};
`).join("    ")}
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y] = new ${f}(outputX);
      ${this._mapSubKernels(p=>`const resultX_${p.name} = result_${p.name}[y] = new ${f}(outputX);
`).join("")}
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${d}
      }
    }`}_mutableKernel2DResults(){const d=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${this._mapSubKernels(f=>`const result_${f.name} = new Array(outputY);
`).join("    ")}
    ${this._mapSubKernels(f=>`let subKernelResult_${f.name};
`).join("    ")}
    for (let y = 0; y < outputY; y++) {
      const resultX = result[y] = new ${d}(outputX);
      ${this._mapSubKernels(f=>`const resultX_${f.name} = result_${f.name}[y] = new ${d}(outputX);
`).join("")}
    }`}_resultMutableKernel2DLoop(d){const f=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y];
      ${this._mapSubKernels(p=>`const resultX_${p.name} = result_${p.name}[y] = new ${f}(outputX);
`).join("")}
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${d}
      }
    }`}_graphicalKernel2DLoop(d){return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${d}
      }
    }`}_resultImmutableKernel3DLoop(d){const f=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${this._mapSubKernels(p=>`const result_${p.name} = new Array(outputZ);
`).join("    ")}
    ${this._mapSubKernels(p=>`let subKernelResult_${p.name};
`).join("    ")}
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z] = new Array(outputY);
      ${this._mapSubKernels(p=>`const resultY_${p.name} = result_${p.name}[z] = new Array(outputY);
`).join("      ")}
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y] = new ${f}(outputX);
        ${this._mapSubKernels(p=>`const resultX_${p.name} = resultY_${p.name}[y] = new ${f}(outputX);
`).join("        ")}
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${d}
        }
      }
    }`}_mutableKernel3DResults(){const d=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${this._mapSubKernels(f=>`const result_${f.name} = new Array(outputZ);
`).join("    ")}
    ${this._mapSubKernels(f=>`let subKernelResult_${f.name};
`).join("    ")}
    for (let z = 0; z < outputZ; z++) {
      const resultY = result[z] = new Array(outputY);
      ${this._mapSubKernels(f=>`const resultY_${f.name} = result_${f.name}[z] = new Array(outputY);
`).join("      ")}
      for (let y = 0; y < outputY; y++) {
        const resultX = resultY[y] = new ${d}(outputX);
        ${this._mapSubKernels(f=>`const resultX_${f.name} = resultY_${f.name}[y] = new ${d}(outputX);
`).join("        ")}
      }
    }`}_resultMutableKernel3DLoop(d){return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z];
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y];
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${d}
        }
      }
    }`}_kernelOutput(){return this.subKernels?`
    return {
      result: result,
      ${this.subKernels.map(d=>`${d.property}: result_${d.name}`).join(`,
      `)}
    };`:`
    return result;`}_mapSubKernels(d){return this.subKernels===null?[""]:this.subKernels.map(d)}destroy(d){d&&delete this.canvas}static destroyContext(d){}toJSON(){const d=super.toJSON();return d.functionNodes=o.fromKernel(this,a).toJSON(),d}setOutput(d){super.setOutput(d);const[f,p]=this.output;this.graphical&&(this._imageData=this.context.createImageData(f,p),this._colorData=new Uint8ClampedArray(f*p*4))}prependString(d){if(this._kernelString)throw new Error("Kernel already built");this._prependedString.push(d)}hasPrependString(d){return this._prependedString.indexOf(d)>-1}}s.exports={CPUKernel:c}},{"../../utils":114,"../function-builder":9,"../kernel":36,"./function-node":6,"./kernel-string":7}],9:[function(n,s,r){class i{static fromKernel(a,l,u){const{kernelArguments:c,kernelConstants:h,argumentNames:d,argumentSizes:f,argumentBitRatios:p,constants:g,constantBitRatios:m,debug:x,loopMaxIterations:b,nativeFunctions:v,output:y,optimizeFloatMemory:C,precision:I,plugins:$,source:T,subKernels:S,functions:E,leadingReturnStatement:_,followingReturnStatement:N,dynamicArguments:P,dynamicOutput:M}=a,z=new Array(c.length),A={};for(let K=0;K<c.length;K++)z[K]=c[K].type;for(let K=0;K<h.length;K++){const re=h[K];A[re.name]=re.type}const B=(K,re)=>H.needsArgumentType(K,re),L=(K,re,pe)=>{H.assignArgumentType(K,re,pe)},U=(K,re,pe)=>H.lookupReturnType(K,re,pe),j=K=>H.lookupFunctionArgumentTypes(K),Z=(K,re)=>H.lookupFunctionArgumentName(K,re),J=(K,re)=>H.lookupFunctionArgumentBitRatio(K,re),se=(K,re,pe,me)=>{H.assignArgumentType(K,re,pe,me)},fe=(K,re,pe,me)=>{H.assignArgumentBitRatio(K,re,pe,me)},he=(K,re,pe)=>{H.trackFunctionCall(K,re,pe)},ve=(K,re)=>{const pe=[];for(let xe=0;xe<K.params.length;xe++)pe.push(K.params[xe].name);const me=new l(re,Object.assign({},Pe,{returnType:null,ast:K,name:K.id.name,argumentNames:pe,lookupReturnType:U,lookupFunctionArgumentTypes:j,lookupFunctionArgumentName:Z,lookupFunctionArgumentBitRatio:J,needsArgumentType:B,assignArgumentType:L,triggerImplyArgumentType:se,triggerImplyArgumentBitRatio:fe,onFunctionCall:he}));me.traceFunctionAST(K),H.addFunctionNode(me)},Pe=Object.assign({isRootKernel:!1,onNestedFunction:ve,lookupReturnType:U,lookupFunctionArgumentTypes:j,lookupFunctionArgumentName:Z,lookupFunctionArgumentBitRatio:J,needsArgumentType:B,assignArgumentType:L,triggerImplyArgumentType:se,triggerImplyArgumentBitRatio:fe,onFunctionCall:he,optimizeFloatMemory:C,precision:I,constants:g,constantTypes:A,constantBitRatios:m,debug:x,loopMaxIterations:b,output:y,plugins:$,dynamicArguments:P,dynamicOutput:M},u||{}),Ee=Object.assign({},Pe,{isRootKernel:!0,name:"kernel",argumentNames:d,argumentTypes:z,argumentSizes:f,argumentBitRatios:p,leadingReturnStatement:_,followingReturnStatement:N});if(typeof T=="object"&&T.functionNodes)return new i().fromJSON(T.functionNodes,l);const Se=new l(T,Ee);let ze=null;E&&(ze=E.map(K=>new l(K.source,{returnType:K.returnType,argumentTypes:K.argumentTypes,output:y,plugins:$,constants:g,constantTypes:A,constantBitRatios:m,optimizeFloatMemory:C,precision:I,lookupReturnType:U,lookupFunctionArgumentTypes:j,lookupFunctionArgumentName:Z,lookupFunctionArgumentBitRatio:J,needsArgumentType:B,assignArgumentType:L,triggerImplyArgumentType:se,triggerImplyArgumentBitRatio:fe,onFunctionCall:he,onNestedFunction:ve})));let ke=null;S&&(ke=S.map(K=>{const{name:re,source:pe}=K;return new l(pe,Object.assign({},Pe,{name:re,isSubKernel:!0,isRootKernel:!1}))}));const H=new i({kernel:a,rootNode:Se,functionNodes:ze,nativeFunctions:v,subKernelNodes:ke});return H}constructor(a){if(a=a||{},this.kernel=a.kernel,this.rootNode=a.rootNode,this.functionNodes=a.functionNodes||[],this.subKernelNodes=a.subKernelNodes||[],this.nativeFunctions=a.nativeFunctions||[],this.functionMap={},this.nativeFunctionNames=[],this.lookupChain=[],this.functionNodeDependencies={},this.functionCalls={},this.rootNode&&(this.functionMap.kernel=this.rootNode),this.functionNodes)for(let l=0;l<this.functionNodes.length;l++)this.functionMap[this.functionNodes[l].name]=this.functionNodes[l];if(this.subKernelNodes)for(let l=0;l<this.subKernelNodes.length;l++)this.functionMap[this.subKernelNodes[l].name]=this.subKernelNodes[l];if(this.nativeFunctions)for(let l=0;l<this.nativeFunctions.length;l++){const u=this.nativeFunctions[l];this.nativeFunctionNames.push(u.name)}}addFunctionNode(a){if(!a.name)throw new Error("functionNode.name needs set");this.functionMap[a.name]=a,a.isRootKernel&&(this.rootNode=a)}traceFunctionCalls(a,l){if(a=a||"kernel",l=l||[],this.nativeFunctionNames.indexOf(a)>-1){const c=l.indexOf(a);if(c===-1)l.push(a);else{const h=l.splice(c,1)[0];l.push(h)}return l}const u=this.functionMap[a];if(u){const c=l.indexOf(a);if(c===-1){l.push(a),u.toString();for(let h=0;h<u.calledFunctions.length;++h)this.traceFunctionCalls(u.calledFunctions[h],l)}else{const h=l.splice(c,1)[0];l.push(h)}}return l}getPrototypeString(a){return this.getPrototypes(a).join(`
`)}getPrototypes(a){return this.rootNode&&this.rootNode.toString(),a?this.getPrototypesFromFunctionNames(this.traceFunctionCalls(a,[]).reverse()):this.getPrototypesFromFunctionNames(Object.keys(this.functionMap))}getStringFromFunctionNames(a){const l=[];for(let u=0;u<a.length;++u)this.functionMap[a[u]]&&l.push(this.functionMap[a[u]].toString());return l.join(`
`)}getPrototypesFromFunctionNames(a){const l=[];for(let u=0;u<a.length;++u){const c=a[u],h=this.nativeFunctionNames.indexOf(c);if(h>-1){l.push(this.nativeFunctions[h].source);continue}const d=this.functionMap[c];d&&l.push(d.toString())}return l}toJSON(){return this.traceFunctionCalls(this.rootNode.name).reverse().map(a=>{const l=this.nativeFunctions.indexOf(a);if(l>-1)return{name:a,source:this.nativeFunctions[l].source};if(this.functionMap[a])return this.functionMap[a].toJSON();throw new Error(`function ${a} not found`)})}fromJSON(a,l){this.functionMap={};for(let u=0;u<a.length;u++){const c=a[u];this.functionMap[c.settings.name]=new l(c.ast,c.settings)}return this}getString(a){return a?this.getStringFromFunctionNames(this.traceFunctionCalls(a).reverse()):this.getStringFromFunctionNames(Object.keys(this.functionMap))}lookupReturnType(a,l,u){if(l.type!=="CallExpression")throw new Error(`expected ast type of "CallExpression", but is ${l.type}`);if(this._isNativeFunction(a))return this._lookupNativeFunctionReturnType(a);if(this._isFunction(a)){const c=this._getFunction(a);if(c.returnType)return c.returnType;{for(let d=0;d<this.lookupChain.length;d++)if(this.lookupChain[d].ast===l){if(c.argumentTypes.length===0&&l.arguments.length>0){const f=l.arguments;for(let p=0;p<f.length;p++)this.lookupChain.push({name:u.name,ast:f[d],requestingNode:u}),c.argumentTypes[p]=u.getType(f[p]),this.lookupChain.pop();return c.returnType=c.getType(c.getJsAST())}throw new Error("circlical logic detected!")}this.lookupChain.push({name:u.name,ast:l,requestingNode:u});const h=c.getType(c.getJsAST());return this.lookupChain.pop(),c.returnType=h}}return null}_getFunction(a){return this._isFunction(a),this.functionMap[a]}_isFunction(a){return!!this.functionMap[a]}_getNativeFunction(a){for(let l=0;l<this.nativeFunctions.length;l++)if(this.nativeFunctions[l].name===a)return this.nativeFunctions[l];return null}_isNativeFunction(a){return!!this._getNativeFunction(a)}_lookupNativeFunctionReturnType(a){let l=this._getNativeFunction(a);if(l)return l.returnType;throw new Error(`Native function ${a} not found`)}lookupFunctionArgumentTypes(a){return this._isNativeFunction(a)?this._getNativeFunction(a).argumentTypes:this._isFunction(a)?this._getFunction(a).argumentTypes:null}lookupFunctionArgumentName(a,l){return this._getFunction(a).argumentNames[l]}lookupFunctionArgumentBitRatio(a,l){if(!this._isFunction(a))throw new Error("function not found");if(this.rootNode.name===a){const d=this.rootNode.argumentNames.indexOf(l);if(d!==-1)return this.rootNode.argumentBitRatios[d]}const u=this._getFunction(a),c=u.argumentNames.indexOf(l);if(c===-1)throw new Error("argument not found");const h=u.argumentBitRatios[c];if(typeof h!="number")throw new Error("argument bit ratio not found");return h}needsArgumentType(a,l){return this._isFunction(a)?!this._getFunction(a).argumentTypes[l]:!1}assignArgumentType(a,l,u,c){if(!this._isFunction(a))return;const h=this._getFunction(a);h.argumentTypes[l]||(h.argumentTypes[l]=u)}assignArgumentBitRatio(a,l,u,c){const h=this._getFunction(a);if(this._isNativeFunction(u))return null;const d=this._getFunction(u),f=h.argumentNames.indexOf(l);if(f===-1)throw new Error(`Argument ${l} not found in arguments from function ${a}`);const p=h.argumentBitRatios[f];if(typeof p!="number")throw new Error(`Bit ratio for argument ${l} not found in function ${a}`);d.argumentBitRatios||(d.argumentBitRatios=new Array(d.argumentNames.length));const g=d.argumentBitRatios[f];if(typeof g=="number"){if(g!==p)throw new Error(`Incompatible bit ratio found at function ${a} at argument ${l}`);return g}return d.argumentBitRatios[f]=p,p}trackFunctionCall(a,l,u){this.functionNodeDependencies[a]||(this.functionNodeDependencies[a]=new Set,this.functionCalls[a]=[]),this.functionNodeDependencies[a].add(l),this.functionCalls[a].push(u)}getKernelResultType(){return this.rootNode.returnType||this.rootNode.getType(this.rootNode.ast)}getSubKernelResultType(a){const l=this.subKernelNodes[a];let u=!1;for(let c=0;c<this.rootNode.functionCalls.length;c++)this.rootNode.functionCalls[c].ast.callee.name===l.name&&(u=!0);if(!u)throw new Error(`SubKernel ${l.name} never called by kernel`);return l.returnType||l.getType(l.getJsAST())}getReturnTypes(){const a={[this.rootNode.name]:this.rootNode.getType(this.rootNode.ast)},l=this.traceFunctionCalls(this.rootNode.name);for(let u=0;u<l.length;u++){const c=l[u],h=this.functionMap[c];a[c]=h.getType(h.ast)}return a}}s.exports={FunctionBuilder:i}},{}],10:[function(n,s,r){const i=n("acorn"),{utils:o}=n("../utils"),{FunctionTracer:a}=n("./function-tracer");class l{constructor(h,d){if(!h&&!d.ast)throw new Error("source parameter is missing");if(d=d||{},this.source=h,this.ast=null,this.name=typeof h=="string"?d.isRootKernel?"kernel":d.name||o.getFunctionNameFromString(h):null,this.calledFunctions=[],this.constants={},this.constantTypes={},this.constantBitRatios={},this.isRootKernel=!1,this.isSubKernel=!1,this.debug=null,this.functions=null,this.identifiers=null,this.contexts=null,this.functionCalls=null,this.states=[],this.needsArgumentType=null,this.assignArgumentType=null,this.lookupReturnType=null,this.lookupFunctionArgumentTypes=null,this.lookupFunctionArgumentBitRatio=null,this.triggerImplyArgumentType=null,this.triggerImplyArgumentBitRatio=null,this.onNestedFunction=null,this.onFunctionCall=null,this.optimizeFloatMemory=null,this.precision=null,this.loopMaxIterations=null,this.argumentNames=typeof this.source=="string"?o.getArgumentNamesFromString(this.source):null,this.argumentTypes=[],this.argumentSizes=[],this.argumentBitRatios=null,this.returnType=null,this.output=[],this.plugins=null,this.leadingReturnStatement=null,this.followingReturnStatement=null,this.dynamicOutput=null,this.dynamicArguments=null,this.strictTypingChecking=!1,this.fixIntegerDivisionAccuracy=null,d)for(const f in d)d.hasOwnProperty(f)&&this.hasOwnProperty(f)&&(this[f]=d[f]);this.literalTypes={},this.validate(),this._string=null,this._internalVariableNames={}}validate(){if(typeof this.source!="string"&&!this.ast)throw new Error("this.source not a string");if(!this.ast&&!o.isFunctionString(this.source))throw new Error("this.source not a function string");if(!this.name)throw new Error("this.name could not be set");if(this.argumentTypes.length>0&&this.argumentTypes.length!==this.argumentNames.length)throw new Error(`argumentTypes count of ${this.argumentTypes.length} exceeds ${this.argumentNames.length}`);if(this.output.length<1)throw new Error("this.output is not big enough")}isIdentifierConstant(h){return this.constants?this.constants.hasOwnProperty(h):!1}isInput(h){return this.argumentTypes[this.argumentNames.indexOf(h)]==="Input"}pushState(h){this.states.push(h)}popState(h){if(this.state!==h)throw new Error(`Cannot popState ${h} when in ${this.state}`);this.states.pop()}isState(h){return this.state===h}get state(){return this.states[this.states.length-1]}astMemberExpressionUnroll(h){if(h.type==="Identifier")return h.name;if(h.type==="ThisExpression")return"this";if(h.type==="MemberExpression"&&h.object&&h.property)return h.object.hasOwnProperty("name")&&h.object.name!=="Math"?this.astMemberExpressionUnroll(h.property):this.astMemberExpressionUnroll(h.object)+"."+this.astMemberExpressionUnroll(h.property);if(h.hasOwnProperty("expressions")){const d=h.expressions[0];if(d.type==="Literal"&&d.value===0&&h.expressions.length===2)return this.astMemberExpressionUnroll(h.expressions[1])}throw this.astErrorOutput("Unknown astMemberExpressionUnroll",h)}getJsAST(h){if(this.ast)return this.ast;if(typeof this.source=="object")return this.traceFunctionAST(this.source),this.ast=this.source;if(h=h||i,h===null)throw new Error("Missing JS to AST parser");const d=Object.freeze(h.parse(`const parser_${this.name} = ${this.source};`,{locations:!0})),f=d.body[0].declarations[0].init;if(this.traceFunctionAST(f),!d)throw new Error("Failed to parse JS code");return this.ast=f}traceFunctionAST(h){const{contexts:d,declarations:f,functions:p,identifiers:g,functionCalls:m}=new a(h);this.contexts=d,this.identifiers=g,this.functionCalls=m,this.functions=p;for(let x=0;x<f.length;x++){const b=f[x],{ast:v,inForLoopInit:y,inForLoopTest:C}=b,{init:I}=v,$=this.getDependencies(I);let T=null;if(y&&C)T="Integer";else if(I){const S=this.getType(I);switch(S){case"Integer":case"Float":case"Number":I.type==="MemberExpression"?T=S:T="Number";break;case"LiteralInteger":T="Number";break;default:T=S}}b.valueType=T,b.dependencies=$,b.isSafe=this.isSafeDependencies($)}for(let x=0;x<p.length;x++)this.onNestedFunction(p[x],this.source)}getDeclaration(h){for(let d=0;d<this.identifiers.length;d++){const f=this.identifiers[d];if(h===f.ast)return f.declaration}return null}getVariableType(h){if(h.type!=="Identifier")throw new Error(`ast of ${h.type} not "Identifier"`);let d=null;const f=this.argumentNames.indexOf(h.name);if(f===-1){const p=this.getDeclaration(h);if(p)return p.valueType}else{const p=this.argumentTypes[f];p&&(d=p)}if(!d&&this.strictTypingChecking)throw new Error(`Declaration of ${name} not found`);return d}getLookupType(h){if(!u.hasOwnProperty(h))throw new Error(`unknown typeLookupMap ${h}`);return u[h]}getConstantType(h){if(this.constantTypes[h]){const d=this.constantTypes[h];return d==="Float"?"Number":d}throw new Error(`Type for constant "${h}" not declared`)}toString(){return this._string?this._string:this._string=this.astGeneric(this.getJsAST(),[]).join("").trim()}toJSON(){const h={source:this.source,name:this.name,constants:this.constants,constantTypes:this.constantTypes,isRootKernel:this.isRootKernel,isSubKernel:this.isSubKernel,debug:this.debug,output:this.output,loopMaxIterations:this.loopMaxIterations,argumentNames:this.argumentNames,argumentTypes:this.argumentTypes,argumentSizes:this.argumentSizes,returnType:this.returnType,leadingReturnStatement:this.leadingReturnStatement,followingReturnStatement:this.followingReturnStatement};return{ast:this.ast,settings:h}}getType(h){if(Array.isArray(h))return this.getType(h[h.length-1]);switch(h.type){case"BlockStatement":return this.getType(h.body);case"ArrayExpression":switch(this.getType(h.elements[0])){case"Array(2)":case"Array(3)":case"Array(4)":return`Matrix(${h.elements.length})`}return`Array(${h.elements.length})`;case"Literal":const f=this.astKey(h);return this.literalTypes[f]?this.literalTypes[f]:Number.isInteger(h.value)?"LiteralInteger":h.value===!0||h.value===!1?"Boolean":"Number";case"AssignmentExpression":return this.getType(h.left);case"CallExpression":if(this.isAstMathFunction(h))return"Number";if(!h.callee||!h.callee.name){if(h.callee.type==="SequenceExpression"&&h.callee.expressions[h.callee.expressions.length-1].property.name){const b=h.callee.expressions[h.callee.expressions.length-1].property.name;return this.inferArgumentTypesIfNeeded(b,h.arguments),this.lookupReturnType(b,h,this)}if(this.getVariableSignature(h.callee,!0)==="this.color")return null;if(h.callee.type==="MemberExpression"&&h.callee.object&&h.callee.property&&h.callee.property.name&&h.arguments){const b=h.callee.property.name;return this.inferArgumentTypesIfNeeded(b,h.arguments),this.lookupReturnType(b,h,this)}throw this.astErrorOutput("Unknown call expression",h)}if(h.callee&&h.callee.name){const b=h.callee.name;return this.inferArgumentTypesIfNeeded(b,h.arguments),this.lookupReturnType(b,h,this)}throw this.astErrorOutput(`Unhandled getType Type "${h.type}"`,h);case"LogicalExpression":return"Boolean";case"BinaryExpression":switch(h.operator){case"%":case"/":if(this.fixIntegerDivisionAccuracy)return"Number";break;case">":case"<":return"Boolean";case"&":case"|":case"^":case"<<":case">>":case">>>":return"Integer"}const p=this.getType(h.left);if(this.isState("skip-literal-correction"))return p;if(p==="LiteralInteger"){const b=this.getType(h.right);return b==="LiteralInteger"?h.left.value%1===0?"Integer":"Float":b}return u[p]||p;case"UpdateExpression":return this.getType(h.argument);case"UnaryExpression":return h.operator==="~"?"Integer":this.getType(h.argument);case"VariableDeclaration":{const b=h.declarations;let v;for(let y=0;y<b.length;y++){const C=b[y];v=this.getType(C)}if(!v)throw this.astErrorOutput("Unable to find type for declaration",h);return v}case"VariableDeclarator":const g=this.getDeclaration(h.id);if(!g)throw this.astErrorOutput("Unable to find declarator",h);if(!g.valueType)throw this.astErrorOutput("Unable to find declarator valueType",h);return g.valueType;case"Identifier":if(h.name==="Infinity")return"Number";if(this.isAstVariable(h)&&this.getVariableSignature(h)==="value")return this.getCheckVariableType(h);const m=this.findIdentifierOrigin(h);return m&&m.init?this.getType(m.init):null;case"ReturnStatement":return this.getType(h.argument);case"MemberExpression":if(this.isAstMathFunction(h)){switch(h.property.name){case"ceil":return"Integer";case"floor":return"Integer";case"round":return"Integer"}return"Number"}if(this.isAstVariable(h)){switch(this.getVariableSignature(h)){case"value[]":return this.getLookupType(this.getCheckVariableType(h.object));case"value[][]":return this.getLookupType(this.getCheckVariableType(h.object.object));case"value[][][]":return this.getLookupType(this.getCheckVariableType(h.object.object.object));case"value[][][][]":return this.getLookupType(this.getCheckVariableType(h.object.object.object.object));case"value.thread.value":case"this.thread.value":return"Integer";case"this.output.value":return this.dynamicOutput?"Integer":"LiteralInteger";case"this.constants.value":return this.getConstantType(h.property.name);case"this.constants.value[]":return this.getLookupType(this.getConstantType(h.object.property.name));case"this.constants.value[][]":return this.getLookupType(this.getConstantType(h.object.object.property.name));case"this.constants.value[][][]":return this.getLookupType(this.getConstantType(h.object.object.object.property.name));case"this.constants.value[][][][]":return this.getLookupType(this.getConstantType(h.object.object.object.object.property.name));case"fn()[]":case"fn()[][]":case"fn()[][][]":return this.getLookupType(this.getType(h.object));case"value.value":if(this.isAstMathVariable(h))return"Number";switch(h.property.name){case"r":case"g":case"b":case"a":return this.getLookupType(this.getCheckVariableType(h.object))}case"[][]":return"Number"}throw this.astErrorOutput("Unhandled getType MemberExpression",h)}throw this.astErrorOutput("Unhandled getType MemberExpression",h);case"ConditionalExpression":return this.getType(h.consequent);case"FunctionDeclaration":case"FunctionExpression":const x=this.findLastReturn(h.body);return x?this.getType(x):null;case"IfStatement":return this.getType(h.consequent);case"SequenceExpression":return this.getType(h.expressions[h.expressions.length-1]);default:throw this.astErrorOutput(`Unhandled getType Type "${h.type}"`,h)}}getCheckVariableType(h){const d=this.getVariableType(h);if(!d)throw this.astErrorOutput(`${h.type} is not defined`,h);return d}inferArgumentTypesIfNeeded(h,d){for(let f=0;f<d.length;f++){if(!this.needsArgumentType(h,f))continue;const p=this.getType(d[f]);if(!p)throw this.astErrorOutput(`Unable to infer argument ${f}`,d[f]);this.assignArgumentType(h,f,p)}}isAstMathVariable(h){const d=["E","PI","SQRT2","SQRT1_2","LN2","LN10","LOG2E","LOG10E"];return h.type==="MemberExpression"&&h.object&&h.object.type==="Identifier"&&h.object.name==="Math"&&h.property&&h.property.type==="Identifier"&&d.indexOf(h.property.name)>-1}isAstMathFunction(h){const d=["abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","expm1","exp","floor","fround","imul","log","log2","log10","log1p","max","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc"];return h.type==="CallExpression"&&h.callee&&h.callee.type==="MemberExpression"&&h.callee.object&&h.callee.object.type==="Identifier"&&h.callee.object.name==="Math"&&h.callee.property&&h.callee.property.type==="Identifier"&&d.indexOf(h.callee.property.name)>-1}isAstVariable(h){return h.type==="Identifier"||h.type==="MemberExpression"}isSafe(h){return this.isSafeDependencies(this.getDependencies(h))}isSafeDependencies(h){return h&&h.every?h.every(d=>d.isSafe):!0}getDependencies(h,d,f){if(d||(d=[]),!h)return null;if(Array.isArray(h)){for(let p=0;p<h.length;p++)this.getDependencies(h[p],d,f);return d}switch(h.type){case"AssignmentExpression":return this.getDependencies(h.left,d,f),this.getDependencies(h.right,d,f),d;case"ConditionalExpression":return this.getDependencies(h.test,d,f),this.getDependencies(h.alternate,d,f),this.getDependencies(h.consequent,d,f),d;case"Literal":d.push({origin:"literal",value:h.value,isSafe:f===!0?!1:h.value>-1/0&&h.value<1/0&&!isNaN(h.value)});break;case"VariableDeclarator":return this.getDependencies(h.init,d,f);case"Identifier":const p=this.getDeclaration(h);if(p)d.push({name:h.name,origin:"declaration",isSafe:f?!1:this.isSafeDependencies(p.dependencies)});else if(this.argumentNames.indexOf(h.name)>-1)d.push({name:h.name,origin:"argument",isSafe:!1});else if(this.strictTypingChecking)throw new Error(`Cannot find identifier origin "${h.name}"`);break;case"FunctionDeclaration":return this.getDependencies(h.body.body[h.body.body.length-1],d,f);case"ReturnStatement":return this.getDependencies(h.argument,d);case"BinaryExpression":case"LogicalExpression":return f=h.operator==="/"||h.operator==="*",this.getDependencies(h.left,d,f),this.getDependencies(h.right,d,f),d;case"UnaryExpression":case"UpdateExpression":return this.getDependencies(h.argument,d,f);case"VariableDeclaration":return this.getDependencies(h.declarations,d,f);case"ArrayExpression":return d.push({origin:"declaration",isSafe:!0}),d;case"CallExpression":return d.push({origin:"function",isSafe:!0}),d;case"MemberExpression":const g=this.getMemberExpressionDetails(h);switch(g.signature){case"value[]":this.getDependencies(h.object,d,f);break;case"value[][]":this.getDependencies(h.object.object,d,f);break;case"value[][][]":this.getDependencies(h.object.object.object,d,f);break;case"this.output.value":this.dynamicOutput&&d.push({name:g.name,origin:"output",isSafe:!1});break}if(g)return g.property&&this.getDependencies(g.property,d,f),g.xProperty&&this.getDependencies(g.xProperty,d,f),g.yProperty&&this.getDependencies(g.yProperty,d,f),g.zProperty&&this.getDependencies(g.zProperty,d,f),d;case"SequenceExpression":return this.getDependencies(h.expressions,d,f);default:throw this.astErrorOutput(`Unhandled type ${h.type} in getDependencies`,h)}return d}getVariableSignature(h,d){if(!this.isAstVariable(h))throw new Error(`ast of type "${h.type}" is not a variable signature`);if(h.type==="Identifier")return"value";const f=[];for(;h;)h.computed?f.push("[]"):h.type==="ThisExpression"?f.unshift("this"):h.property&&h.property.name?h.property.name==="x"||h.property.name==="y"||h.property.name==="z"?f.unshift(d?"."+h.property.name:".value"):h.property.name==="constants"||h.property.name==="thread"||h.property.name==="output"?f.unshift("."+h.property.name):f.unshift(d?"."+h.property.name:".value"):h.name?f.unshift(d?h.name:"value"):h.callee&&h.callee.name?f.unshift(d?h.callee.name+"()":"fn()"):h.elements?f.unshift("[]"):f.unshift("unknown"),h=h.object;const p=f.join("");return d||["value","value[]","value[][]","value[][][]","value[][][][]","value.value","value.thread.value","this.thread.value","this.output.value","this.constants.value","this.constants.value[]","this.constants.value[][]","this.constants.value[][][]","this.constants.value[][][][]","fn()[]","fn()[][]","fn()[][][]","[][]"].indexOf(p)>-1?p:null}build(){return this.toString().length>0}astGeneric(h,d){if(h===null)throw this.astErrorOutput("NULL ast",h);if(Array.isArray(h)){for(let f=0;f<h.length;f++)this.astGeneric(h[f],d);return d}switch(h.type){case"FunctionDeclaration":return this.astFunctionDeclaration(h,d);case"FunctionExpression":return this.astFunctionExpression(h,d);case"ReturnStatement":return this.astReturnStatement(h,d);case"Literal":return this.astLiteral(h,d);case"BinaryExpression":return this.astBinaryExpression(h,d);case"Identifier":return this.astIdentifierExpression(h,d);case"AssignmentExpression":return this.astAssignmentExpression(h,d);case"ExpressionStatement":return this.astExpressionStatement(h,d);case"EmptyStatement":return this.astEmptyStatement(h,d);case"BlockStatement":return this.astBlockStatement(h,d);case"IfStatement":return this.astIfStatement(h,d);case"SwitchStatement":return this.astSwitchStatement(h,d);case"BreakStatement":return this.astBreakStatement(h,d);case"ContinueStatement":return this.astContinueStatement(h,d);case"ForStatement":return this.astForStatement(h,d);case"WhileStatement":return this.astWhileStatement(h,d);case"DoWhileStatement":return this.astDoWhileStatement(h,d);case"VariableDeclaration":return this.astVariableDeclaration(h,d);case"VariableDeclarator":return this.astVariableDeclarator(h,d);case"ThisExpression":return this.astThisExpression(h,d);case"SequenceExpression":return this.astSequenceExpression(h,d);case"UnaryExpression":return this.astUnaryExpression(h,d);case"UpdateExpression":return this.astUpdateExpression(h,d);case"LogicalExpression":return this.astLogicalExpression(h,d);case"MemberExpression":return this.astMemberExpression(h,d);case"CallExpression":return this.astCallExpression(h,d);case"ArrayExpression":return this.astArrayExpression(h,d);case"DebuggerStatement":return this.astDebuggerStatement(h,d);case"ConditionalExpression":return this.astConditionalExpression(h,d)}throw this.astErrorOutput("Unknown ast type : "+h.type,h)}astErrorOutput(h,d){if(typeof this.source!="string")return new Error(h);const f=o.getAstString(this.source,d),g=this.source.substr(d.start).split(/\n/),m=g.length>0?g[g.length-1]:0;return new Error(`${h} on line ${g.length}, position ${m.length}:
 ${f}`)}astDebuggerStatement(h,d){return d}astConditionalExpression(h,d){if(h.type!=="ConditionalExpression")throw this.astErrorOutput("Not a conditional expression",h);return d.push("("),this.astGeneric(h.test,d),d.push("?"),this.astGeneric(h.consequent,d),d.push(":"),this.astGeneric(h.alternate,d),d.push(")"),d}astFunction(h,d){throw new Error(`"astFunction" not defined on ${this.constructor.name}`)}astFunctionDeclaration(h,d){return this.isChildFunction(h)?d:this.astFunction(h,d)}astFunctionExpression(h,d){return this.isChildFunction(h)?d:this.astFunction(h,d)}isChildFunction(h){for(let d=0;d<this.functions.length;d++)if(this.functions[d]===h)return!0;return!1}astReturnStatement(h,d){return d}astLiteral(h,d){return this.literalTypes[this.astKey(h)]="Number",d}astBinaryExpression(h,d){return d}astIdentifierExpression(h,d){return d}astAssignmentExpression(h,d){return d}astExpressionStatement(h,d){return this.astGeneric(h.expression,d),d.push(";"),d}astEmptyStatement(h,d){return d}astBlockStatement(h,d){return d}astIfStatement(h,d){return d}astSwitchStatement(h,d){return d}astBreakStatement(h,d){return d.push("break;"),d}astContinueStatement(h,d){return d.push(`continue;
`),d}astForStatement(h,d){return d}astWhileStatement(h,d){return d}astDoWhileStatement(h,d){return d}astVariableDeclarator(h,d){return this.astGeneric(h.id,d),h.init!==null&&(d.push("="),this.astGeneric(h.init,d)),d}astThisExpression(h,d){return d}astSequenceExpression(h,d){const{expressions:f}=h,p=[];for(let g=0;g<f.length;g++){const m=f[g],x=[];this.astGeneric(m,x),p.push(x.join(""))}return p.length>1?d.push("(",p.join(","),")"):d.push(p[0]),d}astUnaryExpression(h,d){return this.checkAndUpconvertBitwiseUnary(h,d)||(h.prefix?(d.push(h.operator),this.astGeneric(h.argument,d)):(this.astGeneric(h.argument,d),d.push(h.operator))),d}checkAndUpconvertBitwiseUnary(h,d){}astUpdateExpression(h,d){return h.prefix?(d.push(h.operator),this.astGeneric(h.argument,d)):(this.astGeneric(h.argument,d),d.push(h.operator)),d}astLogicalExpression(h,d){return d.push("("),this.astGeneric(h.left,d),d.push(h.operator),this.astGeneric(h.right,d),d.push(")"),d}astMemberExpression(h,d){return d}astCallExpression(h,d){return d}astArrayExpression(h,d){return d}getMemberExpressionDetails(h){if(h.type!=="MemberExpression")throw this.astErrorOutput(`Expression ${h.type} not a MemberExpression`,h);let d=null,f=null;const p=this.getVariableSignature(h);switch(p){case"value":return null;case"value.thread.value":case"this.thread.value":case"this.output.value":return{signature:p,type:"Integer",name:h.property.name};case"value[]":if(typeof h.object.name!="string")throw this.astErrorOutput("Unexpected expression",h);return d=h.object.name,{name:d,origin:"user",signature:p,type:this.getVariableType(h.object),xProperty:h.property};case"value[][]":if(typeof h.object.object.name!="string")throw this.astErrorOutput("Unexpected expression",h);return d=h.object.object.name,{name:d,origin:"user",signature:p,type:this.getVariableType(h.object.object),yProperty:h.object.property,xProperty:h.property};case"value[][][]":if(typeof h.object.object.object.name!="string")throw this.astErrorOutput("Unexpected expression",h);return d=h.object.object.object.name,{name:d,origin:"user",signature:p,type:this.getVariableType(h.object.object.object),zProperty:h.object.object.property,yProperty:h.object.property,xProperty:h.property};case"value[][][][]":if(typeof h.object.object.object.object.name!="string")throw this.astErrorOutput("Unexpected expression",h);return d=h.object.object.object.object.name,{name:d,origin:"user",signature:p,type:this.getVariableType(h.object.object.object.object),zProperty:h.object.object.property,yProperty:h.object.property,xProperty:h.property};case"value.value":if(typeof h.property.name!="string")throw this.astErrorOutput("Unexpected expression",h);if(this.isAstMathVariable(h))return d=h.property.name,{name:d,origin:"Math",type:"Number",signature:p};switch(h.property.name){case"r":case"g":case"b":case"a":return d=h.object.name,{name:d,property:h.property.name,origin:"user",signature:p,type:"Number"};default:throw this.astErrorOutput("Unexpected expression",h)}case"this.constants.value":if(typeof h.property.name!="string")throw this.astErrorOutput("Unexpected expression",h);if(d=h.property.name,f=this.getConstantType(d),!f)throw this.astErrorOutput("Constant has no type",h);return{name:d,type:f,origin:"constants",signature:p};case"this.constants.value[]":if(typeof h.object.property.name!="string")throw this.astErrorOutput("Unexpected expression",h);if(d=h.object.property.name,f=this.getConstantType(d),!f)throw this.astErrorOutput("Constant has no type",h);return{name:d,type:f,origin:"constants",signature:p,xProperty:h.property};case"this.constants.value[][]":{if(typeof h.object.object.property.name!="string")throw this.astErrorOutput("Unexpected expression",h);if(d=h.object.object.property.name,f=this.getConstantType(d),!f)throw this.astErrorOutput("Constant has no type",h);return{name:d,type:f,origin:"constants",signature:p,yProperty:h.object.property,xProperty:h.property}}case"this.constants.value[][][]":{if(typeof h.object.object.object.property.name!="string")throw this.astErrorOutput("Unexpected expression",h);if(d=h.object.object.object.property.name,f=this.getConstantType(d),!f)throw this.astErrorOutput("Constant has no type",h);return{name:d,type:f,origin:"constants",signature:p,zProperty:h.object.object.property,yProperty:h.object.property,xProperty:h.property}}case"fn()[]":case"fn()[][]":case"[][]":return{signature:p,property:h.property};default:throw this.astErrorOutput("Unexpected expression",h)}}findIdentifierOrigin(h){const d=[this.ast];for(;d.length>0;){const f=d[0];if(f.type==="VariableDeclarator"&&f.id&&f.id.name&&f.id.name===h.name)return f;if(d.shift(),f.argument)d.push(f.argument);else if(f.body)d.push(f.body);else if(f.declarations)d.push(f.declarations);else if(Array.isArray(f))for(let p=0;p<f.length;p++)d.push(f[p])}return null}findLastReturn(h){const d=[h||this.ast];for(;d.length>0;){const f=d.pop();if(f.type==="ReturnStatement")return f;if(f.type!=="FunctionDeclaration")if(f.argument)d.push(f.argument);else if(f.body)d.push(f.body);else if(f.declarations)d.push(f.declarations);else if(Array.isArray(f))for(let p=0;p<f.length;p++)d.push(f[p]);else f.consequent?d.push(f.consequent):f.cases&&d.push(f.cases)}return null}getInternalVariableName(h){return this._internalVariableNames.hasOwnProperty(h)||(this._internalVariableNames[h]=0),this._internalVariableNames[h]++,this._internalVariableNames[h]===1?h:h+this._internalVariableNames[h]}astKey(h,d=","){if(!h.start||!h.end)throw new Error("AST start and end needed");return`${h.start}${d}${h.end}`}}const u={Number:"Number",Float:"Float",Integer:"Integer",Array:"Number","Array(2)":"Number","Array(3)":"Number","Array(4)":"Number","Matrix(2)":"Number","Matrix(3)":"Number","Matrix(4)":"Number",Array2D:"Number",Array3D:"Number",Input:"Number",HTMLCanvas:"Array(4)",OffscreenCanvas:"Array(4)",HTMLImage:"Array(4)",ImageBitmap:"Array(4)",ImageData:"Array(4)",HTMLVideo:"Array(4)",HTMLImageArray:"Array(4)",NumberTexture:"Number",MemoryOptimizedNumberTexture:"Number","Array1D(2)":"Array(2)","Array1D(3)":"Array(3)","Array1D(4)":"Array(4)","Array2D(2)":"Array(2)","Array2D(3)":"Array(3)","Array2D(4)":"Array(4)","Array3D(2)":"Array(2)","Array3D(3)":"Array(3)","Array3D(4)":"Array(4)","ArrayTexture(1)":"Number","ArrayTexture(2)":"Array(2)","ArrayTexture(3)":"Array(3)","ArrayTexture(4)":"Array(4)"};s.exports={FunctionNode:l}},{"../utils":114,"./function-tracer":11,acorn:1}],11:[function(n,s,r){const{utils:i}=n("../utils");function o(u){return u.length>0?u[u.length-1]:null}const a={trackIdentifiers:"trackIdentifiers",memberExpression:"memberExpression",inForLoopInit:"inForLoopInit"};class l{constructor(c){this.runningContexts=[],this.functionContexts=[],this.contexts=[],this.functionCalls=[],this.declarations=[],this.identifiers=[],this.functions=[],this.returnStatements=[],this.trackedIdentifiers=null,this.states=[],this.newFunctionContext(),this.scan(c)}isState(c){return this.states[this.states.length-1]===c}hasState(c){return this.states.indexOf(c)>-1}pushState(c){this.states.push(c)}popState(c){if(this.isState(c))this.states.pop();else throw new Error(`Cannot pop the non-active state "${c}"`)}get currentFunctionContext(){return o(this.functionContexts)}get currentContext(){return o(this.runningContexts)}newFunctionContext(){const c={"@contextType":"function"};this.contexts.push(c),this.functionContexts.push(c)}newContext(c){const h=Object.assign({"@contextType":"const/let"},this.currentContext);this.contexts.push(h),this.runningContexts.push(h),c();const{currentFunctionContext:d}=this;for(const f in d)!d.hasOwnProperty(f)||h.hasOwnProperty(f)||(h[f]=d[f]);return this.runningContexts.pop(),h}useFunctionContext(c){const h=o(this.functionContexts);this.runningContexts.push(h),c(),this.runningContexts.pop()}getIdentifiers(c){const h=this.trackedIdentifiers=[];return this.pushState(a.trackIdentifiers),c(),this.trackedIdentifiers=null,this.popState(a.trackIdentifiers),h}getDeclaration(c){const{currentContext:h,currentFunctionContext:d,runningContexts:f}=this,p=h[c]||d[c]||null;if(!p&&h===d&&f.length>0){const g=f[f.length-2];if(g[c])return g[c]}return p}scan(c){if(c){if(Array.isArray(c)){for(let h=0;h<c.length;h++)this.scan(c[h]);return}switch(c.type){case"Program":this.useFunctionContext(()=>{this.scan(c.body)});break;case"BlockStatement":this.newContext(()=>{this.scan(c.body)});break;case"AssignmentExpression":case"LogicalExpression":this.scan(c.left),this.scan(c.right);break;case"BinaryExpression":this.scan(c.left),this.scan(c.right);break;case"UpdateExpression":if(c.operator==="++"){const h=this.getDeclaration(c.argument.name);h&&(h.suggestedType="Integer")}this.scan(c.argument);break;case"UnaryExpression":this.scan(c.argument);break;case"VariableDeclaration":c.kind==="var"?this.useFunctionContext(()=>{c.declarations=i.normalizeDeclarations(c),this.scan(c.declarations)}):(c.declarations=i.normalizeDeclarations(c),this.scan(c.declarations));break;case"VariableDeclarator":{const{currentContext:h}=this,d=this.hasState(a.inForLoopInit),f={ast:c,context:h,name:c.id.name,origin:"declaration",inForLoopInit:d,inForLoopTest:null,assignable:h===this.currentFunctionContext||!d&&!h.hasOwnProperty(c.id.name),suggestedType:null,valueType:null,dependencies:null,isSafe:null};h[c.id.name]||(h[c.id.name]=f),this.declarations.push(f),this.scan(c.id),this.scan(c.init);break}case"FunctionExpression":case"FunctionDeclaration":this.runningContexts.length===0?this.scan(c.body):this.functions.push(c);break;case"IfStatement":this.scan(c.test),this.scan(c.consequent),c.alternate&&this.scan(c.alternate);break;case"ForStatement":{let h;const d=this.newContext(()=>{this.pushState(a.inForLoopInit),this.scan(c.init),this.popState(a.inForLoopInit),h=this.getIdentifiers(()=>{this.scan(c.test)}),this.scan(c.update),this.newContext(()=>{this.scan(c.body)})});if(h)for(const f in d)f!=="@contextType"&&h.indexOf(f)>-1&&(d[f].inForLoopTest=!0);break}case"DoWhileStatement":case"WhileStatement":this.newContext(()=>{this.scan(c.body),this.scan(c.test)});break;case"Identifier":{this.isState(a.trackIdentifiers)&&this.trackedIdentifiers.push(c.name),this.identifiers.push({context:this.currentContext,declaration:this.getDeclaration(c.name),ast:c});break}case"ReturnStatement":this.returnStatements.push(c),this.scan(c.argument);break;case"MemberExpression":this.pushState(a.memberExpression),this.scan(c.object),this.scan(c.property),this.popState(a.memberExpression);break;case"ExpressionStatement":this.scan(c.expression);break;case"SequenceExpression":this.scan(c.expressions);break;case"CallExpression":this.functionCalls.push({context:this.currentContext,ast:c}),this.scan(c.arguments);break;case"ArrayExpression":this.scan(c.elements);break;case"ConditionalExpression":this.scan(c.test),this.scan(c.alternate),this.scan(c.consequent);break;case"SwitchStatement":this.scan(c.discriminant),this.scan(c.cases);break;case"SwitchCase":this.scan(c.test),this.scan(c.consequent);break;case"ThisExpression":case"Literal":case"DebuggerStatement":case"EmptyStatement":case"BreakStatement":case"ContinueStatement":break;default:throw new Error(`unhandled type "${c.type}"`)}}}}s.exports={FunctionTracer:l}},{"../utils":114}],12:[function(n,s,r){const{glWiretap:i}=n("gl-wiretap"),{utils:o}=n("../../utils");function a(f){return f.toString().replace("=>","").replace(/^function /,"").replace(/utils[.]/g,"/*utils.*/")}function l(f,p,g,m,x){g.built||g.build.apply(g,p),p=p?Array.from(p).map(Ee=>{switch(typeof Ee){case"boolean":return new Boolean(Ee);case"number":return new Number(Ee);default:return Ee}}):null;const b=[],v=i(g.context,{useTrackablePrimitives:!0,onReadPixels:Ee=>{if(he.subKernels){if(!y)b.push(`    const result = { result: ${u(Ee,he)} };`),y=!0;else{const Se=he.subKernels[C++].property;b.push(`    result${isNaN(Se)?"."+Se:`[${Se}]`} = ${u(Ee,he)};`)}C===he.subKernels.length&&b.push("    return result;");return}Ee?b.push(`    return ${u(Ee,he)};`):b.push("    return null;")},onUnrecognizedArgumentLookup:Ee=>{const Se=d(Ee,he.kernelArguments,[],v);if(Se)return Se;const ze=d(Ee,he.kernelConstants,N?Object.keys(N).map(ke=>N[ke]):[],v);return ze||null}});let y=!1,C=0;const{source:I,canvas:$,output:T,pipeline:S,graphical:E,loopMaxIterations:_,constants:N,optimizeFloatMemory:P,precision:M,fixIntegerDivisionAccuracy:z,functions:A,nativeFunctions:B,subKernels:L,immutable:U,argumentTypes:j,constantTypes:Z,kernelArguments:J,kernelConstants:se,tactic:fe}=g,he=new f(I,{canvas:$,context:v,checkContext:!1,output:T,pipeline:S,graphical:E,loopMaxIterations:_,constants:N,optimizeFloatMemory:P,precision:M,fixIntegerDivisionAccuracy:z,functions:A,nativeFunctions:B,subKernels:L,immutable:U,argumentTypes:j,constantTypes:Z,tactic:fe});let ve=[];if(v.setIndent(2),he.build.apply(he,p),ve.push(v.toString()),v.reset(),he.kernelArguments.forEach((Ee,Se)=>{switch(Ee.type){case"Integer":case"Boolean":case"Number":case"Float":case"Array":case"Array(2)":case"Array(3)":case"Array(4)":case"HTMLCanvas":case"HTMLImage":case"HTMLVideo":v.insertVariable(`uploadValue_${Ee.name}`,Ee.uploadValue);break;case"HTMLImageArray":for(let ze=0;ze<p[Se].length;ze++){const ke=p[Se];v.insertVariable(`uploadValue_${Ee.name}[${ze}]`,ke[ze])}break;case"Input":v.insertVariable(`uploadValue_${Ee.name}`,Ee.uploadValue);break;case"MemoryOptimizedNumberTexture":case"NumberTexture":case"Array1D(2)":case"Array1D(3)":case"Array1D(4)":case"Array2D(2)":case"Array2D(3)":case"Array2D(4)":case"Array3D(2)":case"Array3D(3)":case"Array3D(4)":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":v.insertVariable(`uploadValue_${Ee.name}`,p[Se].texture);break;default:throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${Ee.type}`)}}),ve.push("/** start of injected functions **/"),ve.push(`function ${a(o.flattenTo)}`),ve.push(`function ${a(o.flatten2dArrayTo)}`),ve.push(`function ${a(o.flatten3dArrayTo)}`),ve.push(`function ${a(o.flatten4dArrayTo)}`),ve.push(`function ${a(o.isArray)}`),he.renderOutput!==he.renderTexture&&he.formatValues&&ve.push(`  const renderOutput = function ${a(he.formatValues)};`),ve.push("/** end of injected functions **/"),ve.push(`  const innerKernel = function (${he.kernelArguments.map(Ee=>Ee.varName).join(", ")}) {`),v.setIndent(4),he.run.apply(he,p),he.renderKernels?he.renderKernels():he.renderOutput&&he.renderOutput(),ve.push("    /** start setup uploads for kernel values **/"),he.kernelArguments.forEach(Ee=>{ve.push("    "+Ee.getStringValueHandler().split(`
`).join(`
    `))}),ve.push("    /** end setup uploads for kernel values **/"),ve.push(v.toString()),he.renderOutput===he.renderTexture){v.reset();const Ee=v.getContextVariableName(he.framebuffer);if(he.renderKernels){const Se=he.renderKernels(),ze=v.getContextVariableName(he.texture.texture);ve.push(`    return {
      result: {
        texture: ${ze},
        type: '${Se.result.type}',
        toArray: ${h(Se.result,ze,Ee)}
      },`);const{subKernels:ke,mappedTextures:H}=he;for(let K=0;K<ke.length;K++){const re=H[K],pe=ke[K],me=Se[pe.property],xe=v.getContextVariableName(re.texture);ve.push(`
      ${pe.property}: {
        texture: ${xe},
        type: '${me.type}',
        toArray: ${h(me,xe,Ee)}
      },`)}ve.push("    };")}else{const Se=he.renderOutput(),ze=v.getContextVariableName(he.texture.texture);ve.push(`    return {
        texture: ${ze},
        type: '${Se.type}',
        toArray: ${h(Se,ze,Ee)}
      };`)}}ve.push(`    ${x?`
`+x+"    ":""}`),ve.push(b.join(`
`)),ve.push("  };"),he.graphical&&(ve.push(c(he)),ve.push("  innerKernel.getPixels = getPixels;")),ve.push("  return innerKernel;");let Pe=[];return se.forEach(Ee=>{Pe.push(`${Ee.getStringValueHandler()}`)}),`function kernel(settings) {
  const { context, constants } = settings;
  ${Pe.join("")}
  ${m||""}
${ve.join(`
`)}
}`}function u(f,p){const g=p.precision==="single"?f:`new Float32Array(${f}.buffer)`;return p.output[2]?`renderOutput(${g}, ${p.output[0]}, ${p.output[1]}, ${p.output[2]})`:p.output[1]?`renderOutput(${g}, ${p.output[0]}, ${p.output[1]})`:`renderOutput(${g}, ${p.output[0]})`}function c(f){const p=f.getPixels.toString(),g=!/^function/.test(p);return o.flattenFunctionToString(`${g?"function ":""}${p}`,{findDependency:(m,x)=>m==="utils"?`const ${x} = ${o[x].toString()};`:null,thisLookup:m=>{if(m==="context")return null;if(f.hasOwnProperty(m))return JSON.stringify(f[m]);throw new Error(`unhandled thisLookup ${m}`)}})}function h(f,p,g){const m=f.toArray.toString(),x=!/^function/.test(m),b=o.flattenFunctionToString(`${x?"function ":""}${m}`,{findDependency:(v,y)=>{if(v==="utils")return`const ${y} = ${o[y].toString()};`;if(v==="this")return y==="framebuffer"?"":`${x?"function ":""}${f[y].toString()}`;throw new Error("unhandled fromObject")},thisLookup:(v,y)=>{if(v==="texture")return p;if(v==="context")return y?null:"gl";if(f.hasOwnProperty(v))return JSON.stringify(f[v]);throw new Error(`unhandled thisLookup ${v}`)}});return`() => {
  function framebuffer() { return ${g}; };
  ${b}
  return toArray();
  }`}function d(f,p,g,m,x){if(f===null||p===null)return null;switch(typeof f){case"boolean":case"number":return null}if(typeof HTMLImageElement<"u"&&f instanceof HTMLImageElement)for(let b=0;b<p.length;b++){const v=p[b];if(v.type!=="HTMLImageArray"&&v||v.uploadValue!==f)continue;const y=g[b].indexOf(f);if(y===-1)continue;const C=`uploadValue_${v.name}[${y}]`;return m.insertVariable(C,f),C}for(let b=0;b<p.length;b++){const v=p[b];if(f!==v.uploadValue)continue;const y=`uploadValue_${v.name}`;return m.insertVariable(y,v),y}return null}s.exports={glKernelString:l}},{"../../utils":114,"gl-wiretap":3}],13:[function(n,s,r){const{Kernel:i}=n("../kernel"),{utils:o}=n("../../utils"),{GLTextureArray2Float:a}=n("./texture/array-2-float"),{GLTextureArray2Float2D:l}=n("./texture/array-2-float-2d"),{GLTextureArray2Float3D:u}=n("./texture/array-2-float-3d"),{GLTextureArray3Float:c}=n("./texture/array-3-float"),{GLTextureArray3Float2D:h}=n("./texture/array-3-float-2d"),{GLTextureArray3Float3D:d}=n("./texture/array-3-float-3d"),{GLTextureArray4Float:f}=n("./texture/array-4-float"),{GLTextureArray4Float2D:p}=n("./texture/array-4-float-2d"),{GLTextureArray4Float3D:g}=n("./texture/array-4-float-3d"),{GLTextureFloat:m}=n("./texture/float"),{GLTextureFloat2D:x}=n("./texture/float-2d"),{GLTextureFloat3D:b}=n("./texture/float-3d"),{GLTextureMemoryOptimized:v}=n("./texture/memory-optimized"),{GLTextureMemoryOptimized2D:y}=n("./texture/memory-optimized-2d"),{GLTextureMemoryOptimized3D:C}=n("./texture/memory-optimized-3d"),{GLTextureUnsigned:I}=n("./texture/unsigned"),{GLTextureUnsigned2D:$}=n("./texture/unsigned-2d"),{GLTextureUnsigned3D:T}=n("./texture/unsigned-3d"),{GLTextureGraphical:S}=n("./texture/graphical");class E extends i{static get mode(){return"gpu"}static getIsFloatRead(){const P=`function kernelFunction() {
      return 1;
    }`,M=new this(P,{context:this.testContext,canvas:this.testCanvas,validate:!1,output:[1],precision:"single",returnType:"Number",tactic:"speed"});M.build(),M.run();const z=M.renderOutput();return M.destroy(!0),z[0]===1}static getIsIntegerDivisionAccurate(){function P(B,L){return B[this.thread.x]/L[this.thread.x]}const M=new this(P.toString(),{context:this.testContext,canvas:this.testCanvas,validate:!1,output:[2],returnType:"Number",precision:"unsigned",tactic:"speed"}),z=[[6,6030401],[3,3991]];M.build.apply(M,z),M.run.apply(M,z);const A=M.renderOutput();return M.destroy(!0),A[0]===2&&A[1]===1511}static getIsSpeedTacticSupported(){function P(B){return B[this.thread.x]}const M=new this(P.toString(),{context:this.testContext,canvas:this.testCanvas,validate:!1,output:[4],returnType:"Number",precision:"unsigned",tactic:"speed"}),z=[[0,1,2,3]];M.build.apply(M,z),M.run.apply(M,z);const A=M.renderOutput();return M.destroy(!0),Math.round(A[0])===0&&Math.round(A[1])===1&&Math.round(A[2])===2&&Math.round(A[3])===3}static get testCanvas(){throw new Error(`"testCanvas" not defined on ${this.name}`)}static get testContext(){throw new Error(`"testContext" not defined on ${this.name}`)}static getFeatures(){const P=this.testContext,M=this.getIsDrawBuffers();return Object.freeze({isFloatRead:this.getIsFloatRead(),isIntegerDivisionAccurate:this.getIsIntegerDivisionAccurate(),isSpeedTacticSupported:this.getIsSpeedTacticSupported(),isTextureFloat:this.getIsTextureFloat(),isDrawBuffers:M,kernelMap:M,channelCount:this.getChannelCount(),maxTextureSize:this.getMaxTextureSize(),lowIntPrecision:P.getShaderPrecisionFormat(P.FRAGMENT_SHADER,P.LOW_INT),lowFloatPrecision:P.getShaderPrecisionFormat(P.FRAGMENT_SHADER,P.LOW_FLOAT),mediumIntPrecision:P.getShaderPrecisionFormat(P.FRAGMENT_SHADER,P.MEDIUM_INT),mediumFloatPrecision:P.getShaderPrecisionFormat(P.FRAGMENT_SHADER,P.MEDIUM_FLOAT),highIntPrecision:P.getShaderPrecisionFormat(P.FRAGMENT_SHADER,P.HIGH_INT),highFloatPrecision:P.getShaderPrecisionFormat(P.FRAGMENT_SHADER,P.HIGH_FLOAT)})}static setupFeatureChecks(){throw new Error(`"setupFeatureChecks" not defined on ${this.name}`)}static getSignature(P,M){return P.getVariablePrecisionString()+(M.length>0?":"+M.join(","):"")}setFixIntegerDivisionAccuracy(P){return this.fixIntegerDivisionAccuracy=P,this}setPrecision(P){return this.precision=P,this}setFloatTextures(P){return o.warnDeprecated("method","setFloatTextures","setOptimizeFloatMemory"),this.floatTextures=P,this}static nativeFunctionArguments(P){const M=[],z=[],A=[],B=/^[a-zA-Z_]/,L=/[a-zA-Z_0-9]/;let U=0,j=null,Z=null;for(;U<P.length;){const J=P[U],se=P[U+1],fe=A.length>0?A[A.length-1]:null;if(fe==="FUNCTION_ARGUMENTS"&&J==="/"&&se==="*"){A.push("MULTI_LINE_COMMENT"),U+=2;continue}else if(fe==="MULTI_LINE_COMMENT"&&J==="*"&&se==="/"){A.pop(),U+=2;continue}else if(fe==="FUNCTION_ARGUMENTS"&&J==="/"&&se==="/"){A.push("COMMENT"),U+=2;continue}else if(fe==="COMMENT"&&J===`
`){A.pop(),U++;continue}else if(fe===null&&J==="("){A.push("FUNCTION_ARGUMENTS"),U++;continue}else if(fe==="FUNCTION_ARGUMENTS"){if(J===")"){A.pop();break}if(J==="f"&&se==="l"&&P[U+2]==="o"&&P[U+3]==="a"&&P[U+4]==="t"&&P[U+5]===" "){A.push("DECLARE_VARIABLE"),Z="float",j="",U+=6;continue}else if(J==="i"&&se==="n"&&P[U+2]==="t"&&P[U+3]===" "){A.push("DECLARE_VARIABLE"),Z="int",j="",U+=4;continue}else if(J==="v"&&se==="e"&&P[U+2]==="c"&&P[U+3]==="2"&&P[U+4]===" "){A.push("DECLARE_VARIABLE"),Z="vec2",j="",U+=5;continue}else if(J==="v"&&se==="e"&&P[U+2]==="c"&&P[U+3]==="3"&&P[U+4]===" "){A.push("DECLARE_VARIABLE"),Z="vec3",j="",U+=5;continue}else if(J==="v"&&se==="e"&&P[U+2]==="c"&&P[U+3]==="4"&&P[U+4]===" "){A.push("DECLARE_VARIABLE"),Z="vec4",j="",U+=5;continue}}else if(fe==="DECLARE_VARIABLE"){if(j===""){if(J===" "){U++;continue}if(!B.test(J))throw new Error("variable name is not expected string")}j+=J,L.test(se)||(A.pop(),z.push(j),M.push(_[Z]))}U++}if(A.length>0)throw new Error("GLSL function was not parsable");return{argumentNames:z,argumentTypes:M}}static nativeFunctionReturnType(P){return _[P.match(/int|float|vec[2-4]/)[0]]}static combineKernels(P,M){P.apply(null,arguments);const{texSize:z,context:A,threadDim:B}=M.texSize;let L;if(M.precision==="single"){const U=z[0],j=Math.ceil(z[1]/4);L=new Float32Array(U*j*4*4),A.readPixels(0,0,U,j*4,A.RGBA,A.FLOAT,L)}else{const U=new Uint8Array(z[0]*z[1]*4);A.readPixels(0,0,z[0],z[1],A.RGBA,A.UNSIGNED_BYTE,U),L=new Float32Array(U.buffer)}if(L=L.subarray(0,B[0]*B[1]*B[2]),M.output.length===1)return L;if(M.output.length===2)return o.splitArray(L,M.output[0]);if(M.output.length===3)return o.splitArray(L,M.output[0]*M.output[1]).map(function(j){return o.splitArray(j,M.output[0])})}constructor(P,M){super(P,M),this.transferValues=null,this.formatValues=null,this.TextureConstructor=null,this.renderOutput=null,this.renderRawOutput=null,this.texSize=null,this.translatedSource=null,this.compiledFragmentShader=null,this.compiledVertexShader=null,this.switchingKernels=null,this._textureSwitched=null,this._mappedTextureSwitched=null}checkTextureSize(){const{features:P}=this.constructor;if(this.texSize[0]>P.maxTextureSize||this.texSize[1]>P.maxTextureSize)throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${P.maxTextureSize},${P.maxTextureSize}]`)}translateSource(){throw new Error(`"translateSource" not defined on ${this.constructor.name}`)}pickRenderStrategy(P){if(this.graphical)return this.renderRawOutput=this.readPackedPixelsToUint8Array,this.transferValues=M=>M,this.TextureConstructor=S,null;if(this.precision==="unsigned")if(this.renderRawOutput=this.readPackedPixelsToUint8Array,this.transferValues=this.readPackedPixelsToFloat32Array,this.pipeline)switch(this.renderOutput=this.renderTexture,this.subKernels!==null&&(this.renderKernels=this.renderKernelsToTextures),this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.output[2]>0?(this.TextureConstructor=T,null):this.output[1]>0?(this.TextureConstructor=$,null):(this.TextureConstructor=I,null);case"Array(2)":case"Array(3)":case"Array(4)":return this.requestFallback(P)}else switch(this.subKernels!==null&&(this.renderKernels=this.renderKernelsToArrays),this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.renderOutput=this.renderValues,this.output[2]>0?(this.TextureConstructor=T,this.formatValues=o.erect3DPackedFloat,null):this.output[1]>0?(this.TextureConstructor=$,this.formatValues=o.erect2DPackedFloat,null):(this.TextureConstructor=I,this.formatValues=o.erectPackedFloat,null);case"Array(2)":case"Array(3)":case"Array(4)":return this.requestFallback(P)}else if(this.precision==="single"){if(this.renderRawOutput=this.readFloatPixelsToFloat32Array,this.transferValues=this.readFloatPixelsToFloat32Array,this.pipeline)switch(this.renderOutput=this.renderTexture,this.subKernels!==null&&(this.renderKernels=this.renderKernelsToTextures),this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.optimizeFloatMemory?this.output[2]>0?(this.TextureConstructor=C,null):this.output[1]>0?(this.TextureConstructor=y,null):(this.TextureConstructor=v,null):this.output[2]>0?(this.TextureConstructor=b,null):this.output[1]>0?(this.TextureConstructor=x,null):(this.TextureConstructor=m,null);case"Array(2)":return this.output[2]>0?(this.TextureConstructor=u,null):this.output[1]>0?(this.TextureConstructor=l,null):(this.TextureConstructor=a,null);case"Array(3)":return this.output[2]>0?(this.TextureConstructor=d,null):this.output[1]>0?(this.TextureConstructor=h,null):(this.TextureConstructor=c,null);case"Array(4)":return this.output[2]>0?(this.TextureConstructor=g,null):this.output[1]>0?(this.TextureConstructor=p,null):(this.TextureConstructor=f,null)}if(this.renderOutput=this.renderValues,this.subKernels!==null&&(this.renderKernels=this.renderKernelsToArrays),this.optimizeFloatMemory)switch(this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.output[2]>0?(this.TextureConstructor=C,this.formatValues=o.erectMemoryOptimized3DFloat,null):this.output[1]>0?(this.TextureConstructor=y,this.formatValues=o.erectMemoryOptimized2DFloat,null):(this.TextureConstructor=v,this.formatValues=o.erectMemoryOptimizedFloat,null);case"Array(2)":return this.output[2]>0?(this.TextureConstructor=u,this.formatValues=o.erect3DArray2,null):this.output[1]>0?(this.TextureConstructor=l,this.formatValues=o.erect2DArray2,null):(this.TextureConstructor=a,this.formatValues=o.erectArray2,null);case"Array(3)":return this.output[2]>0?(this.TextureConstructor=d,this.formatValues=o.erect3DArray3,null):this.output[1]>0?(this.TextureConstructor=h,this.formatValues=o.erect2DArray3,null):(this.TextureConstructor=c,this.formatValues=o.erectArray3,null);case"Array(4)":return this.output[2]>0?(this.TextureConstructor=g,this.formatValues=o.erect3DArray4,null):this.output[1]>0?(this.TextureConstructor=p,this.formatValues=o.erect2DArray4,null):(this.TextureConstructor=f,this.formatValues=o.erectArray4,null)}else switch(this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.output[2]>0?(this.TextureConstructor=b,this.formatValues=o.erect3DFloat,null):this.output[1]>0?(this.TextureConstructor=x,this.formatValues=o.erect2DFloat,null):(this.TextureConstructor=m,this.formatValues=o.erectFloat,null);case"Array(2)":return this.output[2]>0?(this.TextureConstructor=u,this.formatValues=o.erect3DArray2,null):this.output[1]>0?(this.TextureConstructor=l,this.formatValues=o.erect2DArray2,null):(this.TextureConstructor=a,this.formatValues=o.erectArray2,null);case"Array(3)":return this.output[2]>0?(this.TextureConstructor=d,this.formatValues=o.erect3DArray3,null):this.output[1]>0?(this.TextureConstructor=h,this.formatValues=o.erect2DArray3,null):(this.TextureConstructor=c,this.formatValues=o.erectArray3,null);case"Array(4)":return this.output[2]>0?(this.TextureConstructor=g,this.formatValues=o.erect3DArray4,null):this.output[1]>0?(this.TextureConstructor=p,this.formatValues=o.erect2DArray4,null):(this.TextureConstructor=f,this.formatValues=o.erectArray4,null)}}else throw new Error(`unhandled precision of "${this.precision}"`);throw new Error(`unhandled return type "${this.returnType}"`)}getKernelString(){throw new Error("abstract method call")}getMainResultTexture(){switch(this.returnType){case"LiteralInteger":case"Float":case"Integer":case"Number":return this.getMainResultNumberTexture();case"Array(2)":return this.getMainResultArray2Texture();case"Array(3)":return this.getMainResultArray3Texture();case"Array(4)":return this.getMainResultArray4Texture();default:throw new Error(`unhandled returnType type ${this.returnType}`)}}getMainResultKernelNumberTexture(){throw new Error("abstract method call")}getMainResultSubKernelNumberTexture(){throw new Error("abstract method call")}getMainResultKernelArray2Texture(){throw new Error("abstract method call")}getMainResultSubKernelArray2Texture(){throw new Error("abstract method call")}getMainResultKernelArray3Texture(){throw new Error("abstract method call")}getMainResultSubKernelArray3Texture(){throw new Error("abstract method call")}getMainResultKernelArray4Texture(){throw new Error("abstract method call")}getMainResultSubKernelArray4Texture(){throw new Error("abstract method call")}getMainResultGraphical(){throw new Error("abstract method call")}getMainResultMemoryOptimizedFloats(){throw new Error("abstract method call")}getMainResultPackedPixels(){throw new Error("abstract method call")}getMainResultString(){return this.graphical?this.getMainResultGraphical():this.precision==="single"?this.optimizeFloatMemory?this.getMainResultMemoryOptimizedFloats():this.getMainResultTexture():this.getMainResultPackedPixels()}getMainResultNumberTexture(){return o.linesToString(this.getMainResultKernelNumberTexture())+o.linesToString(this.getMainResultSubKernelNumberTexture())}getMainResultArray2Texture(){return o.linesToString(this.getMainResultKernelArray2Texture())+o.linesToString(this.getMainResultSubKernelArray2Texture())}getMainResultArray3Texture(){return o.linesToString(this.getMainResultKernelArray3Texture())+o.linesToString(this.getMainResultSubKernelArray3Texture())}getMainResultArray4Texture(){return o.linesToString(this.getMainResultKernelArray4Texture())+o.linesToString(this.getMainResultSubKernelArray4Texture())}getFloatTacticDeclaration(){return`precision ${this.getVariablePrecisionString(this.texSize,this.tactic)} float;
`}getIntTacticDeclaration(){return`precision ${this.getVariablePrecisionString(this.texSize,this.tactic,!0)} int;
`}getSampler2DTacticDeclaration(){return`precision ${this.getVariablePrecisionString(this.texSize,this.tactic)} sampler2D;
`}getSampler2DArrayTacticDeclaration(){return`precision ${this.getVariablePrecisionString(this.texSize,this.tactic)} sampler2DArray;
`}renderTexture(){return this.immutable?this.texture.clone():this.texture}readPackedPixelsToUint8Array(){if(this.precision!=="unsigned")throw new Error('Requires this.precision to be "unsigned"');const{texSize:P,context:M}=this,z=new Uint8Array(P[0]*P[1]*4);return M.readPixels(0,0,P[0],P[1],M.RGBA,M.UNSIGNED_BYTE,z),z}readPackedPixelsToFloat32Array(){return new Float32Array(this.readPackedPixelsToUint8Array().buffer)}readFloatPixelsToFloat32Array(){if(this.precision!=="single")throw new Error('Requires this.precision to be "single"');const{texSize:P,context:M}=this,z=P[0],A=P[1],B=new Float32Array(z*A*4);return M.readPixels(0,0,z,A,M.RGBA,M.FLOAT,B),B}getPixels(P){const{context:M,output:z}=this,[A,B]=z,L=new Uint8Array(A*B*4);return M.readPixels(0,0,A,B,M.RGBA,M.UNSIGNED_BYTE,L),new Uint8ClampedArray((P?L:o.flipPixels(L,A,B)).buffer)}renderKernelsToArrays(){const P={result:this.renderOutput()};for(let M=0;M<this.subKernels.length;M++)P[this.subKernels[M].property]=this.mappedTextures[M].toArray();return P}renderKernelsToTextures(){const P={result:this.renderOutput()};if(this.immutable)for(let M=0;M<this.subKernels.length;M++)P[this.subKernels[M].property]=this.mappedTextures[M].clone();else for(let M=0;M<this.subKernels.length;M++)P[this.subKernels[M].property]=this.mappedTextures[M];return P}resetSwitchingKernels(){const P=this.switchingKernels;return this.switchingKernels=null,P}setOutput(P){const M=this.toKernelOutput(P);if(this.program){if(!this.dynamicOutput)throw new Error("Resizing a kernel with dynamicOutput: false is not possible");const z=[M[0],M[1]||1,M[2]||1],A=o.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},z),B=this.texSize;if(B){const U=this.getVariablePrecisionString(B,this.tactic),j=this.getVariablePrecisionString(A,this.tactic);if(U!==j){this.debug&&console.warn("Precision requirement changed, asking GPU instance to recompile"),this.switchKernels({type:"outputPrecisionMismatch",precision:j,needed:P});return}}this.output=M,this.threadDim=z,this.texSize=A;const{context:L}=this;if(L.bindFramebuffer(L.FRAMEBUFFER,this.framebuffer),this.updateMaxTexSize(),this.framebuffer.width=this.texSize[0],this.framebuffer.height=this.texSize[1],L.viewport(0,0,this.maxTexSize[0],this.maxTexSize[1]),this.canvas.width=this.maxTexSize[0],this.canvas.height=this.maxTexSize[1],this.texture&&this.texture.delete(),this.texture=null,this._setupOutputTexture(),this.mappedTextures&&this.mappedTextures.length>0){for(let U=0;U<this.mappedTextures.length;U++)this.mappedTextures[U].delete();this.mappedTextures=null,this._setupSubOutputTextures()}}else this.output=M;return this}renderValues(){return this.formatValues(this.transferValues(),this.output[0],this.output[1],this.output[2])}switchKernels(P){this.switchingKernels?this.switchingKernels.push(P):this.switchingKernels=[P]}getVariablePrecisionString(P=this.texSize,M=this.tactic,z=!1){if(!M){if(!this.constructor.features.isSpeedTacticSupported)return"highp";const A=this.constructor.features[z?"lowIntPrecision":"lowFloatPrecision"],B=this.constructor.features[z?"mediumIntPrecision":"mediumFloatPrecision"],L=this.constructor.features[z?"highIntPrecision":"highFloatPrecision"],U=Math.log2(P[0]*P[1]);if(U<=A.rangeMax)return"lowp";if(U<=B.rangeMax)return"mediump";if(U<=L.rangeMax)return"highp";throw new Error("The required size exceeds that of the ability of your system")}switch(M){case"speed":return"lowp";case"balanced":return"mediump";case"precision":return"highp";default:throw new Error(`Unknown tactic "${M}" use "speed", "balanced", "precision", or empty for auto`)}}updateTextureArgumentRefs(P,M){if(this.immutable){if(this.texture.texture===M.texture){const{prevArg:z}=P;z&&(z.texture._refs===1&&(this.texture.delete(),this.texture=z.clone(),this._textureSwitched=!0),z.delete()),P.prevArg=M.clone()}else if(this.mappedTextures&&this.mappedTextures.length>0){const{mappedTextures:z}=this;for(let A=0;A<z.length;A++){const B=z[A];if(B.texture===M.texture){const{prevArg:L}=P;L&&(L.texture._refs===1&&(B.delete(),z[A]=L.clone(),this._mappedTextureSwitched[A]=!0),L.delete()),P.prevArg=M.clone();return}}}}}onActivate(P){if(this._textureSwitched=!0,this.texture=P.texture,this.mappedTextures){for(let M=0;M<this.mappedTextures.length;M++)this._mappedTextureSwitched[M]=!0;this.mappedTextures=P.mappedTextures}}initCanvas(){}}const _={int:"Integer",float:"Number",vec2:"Array(2)",vec3:"Array(3)",vec4:"Array(4)"};s.exports={GLKernel:E}},{"../../utils":114,"../kernel":36,"./texture/array-2-float":16,"./texture/array-2-float-2d":14,"./texture/array-2-float-3d":15,"./texture/array-3-float":19,"./texture/array-3-float-2d":17,"./texture/array-3-float-3d":18,"./texture/array-4-float":22,"./texture/array-4-float-2d":20,"./texture/array-4-float-3d":21,"./texture/float":25,"./texture/float-2d":23,"./texture/float-3d":24,"./texture/graphical":26,"./texture/memory-optimized":30,"./texture/memory-optimized-2d":28,"./texture/memory-optimized-3d":29,"./texture/unsigned":33,"./texture/unsigned-2d":31,"./texture/unsigned-3d":32}],14:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="ArrayTexture(2)"}toArray(){return i.erect2DArray2(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureArray2Float2D:a}},{"../../../utils":114,"./float":25}],15:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="ArrayTexture(2)"}toArray(){return i.erect3DArray2(this.renderValues(),this.output[0],this.output[1],this.output[2])}}s.exports={GLTextureArray2Float3D:a}},{"../../../utils":114,"./float":25}],16:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="ArrayTexture(2)"}toArray(){return i.erectArray2(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureArray2Float:a}},{"../../../utils":114,"./float":25}],17:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="ArrayTexture(3)"}toArray(){return i.erect2DArray3(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureArray3Float2D:a}},{"../../../utils":114,"./float":25}],18:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="ArrayTexture(3)"}toArray(){return i.erect3DArray3(this.renderValues(),this.output[0],this.output[1],this.output[2])}}s.exports={GLTextureArray3Float3D:a}},{"../../../utils":114,"./float":25}],19:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="ArrayTexture(3)"}toArray(){return i.erectArray3(this.renderValues(),this.output[0])}}s.exports={GLTextureArray3Float:a}},{"../../../utils":114,"./float":25}],20:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="ArrayTexture(4)"}toArray(){return i.erect2DArray4(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureArray4Float2D:a}},{"../../../utils":114,"./float":25}],21:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="ArrayTexture(4)"}toArray(){return i.erect3DArray4(this.renderValues(),this.output[0],this.output[1],this.output[2])}}s.exports={GLTextureArray4Float3D:a}},{"../../../utils":114,"./float":25}],22:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="ArrayTexture(4)"}toArray(){return i.erectArray4(this.renderValues(),this.output[0])}}s.exports={GLTextureArray4Float:a}},{"../../../utils":114,"./float":25}],23:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="ArrayTexture(1)"}toArray(){return i.erect2DFloat(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureFloat2D:a}},{"../../../utils":114,"./float":25}],24:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="ArrayTexture(1)"}toArray(){return i.erect3DFloat(this.renderValues(),this.output[0],this.output[1],this.output[2])}}s.exports={GLTextureFloat3D:a}},{"../../../utils":114,"./float":25}],25:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTexture:o}=n("./index");class a extends o{get textureType(){return this.context.FLOAT}constructor(u){super(u),this.type="ArrayTexture(1)"}renderRawOutput(){const u=this.context,c=this.size;u.bindFramebuffer(u.FRAMEBUFFER,this.framebuffer()),u.framebufferTexture2D(u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,this.texture,0);const h=new Float32Array(c[0]*c[1]*4);return u.readPixels(0,0,c[0],c[1],u.RGBA,u.FLOAT,h),h}renderValues(){return this._deleted?null:this.renderRawOutput()}toArray(){return i.erectFloat(this.renderValues(),this.output[0])}}s.exports={GLTextureFloat:a}},{"../../../utils":114,"./index":27}],26:[function(n,s,r){const{GLTextureUnsigned:i}=n("./unsigned");class o extends i{constructor(l){super(l),this.type="ArrayTexture(4)"}toArray(){return this.renderValues()}}s.exports={GLTextureGraphical:o}},{"./unsigned":33}],27:[function(n,s,r){const{Texture:i}=n("../../../texture");class o extends i{get textureType(){throw new Error(`"textureType" not implemented on ${this.name}`)}clone(){return new this.constructor(this)}beforeMutate(){return this.texture._refs>1?(this.newTexture(),!0):!1}cloneTexture(){this.texture._refs--;const{context:u,size:c,texture:h,kernel:d}=this;d.debug&&console.warn("cloning internal texture"),u.bindFramebuffer(u.FRAMEBUFFER,this.framebuffer()),a(u,h),u.framebufferTexture2D(u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,h,0);const f=u.createTexture();a(u,f),u.texImage2D(u.TEXTURE_2D,0,this.internalFormat,c[0],c[1],0,this.textureFormat,this.textureType,null),u.copyTexSubImage2D(u.TEXTURE_2D,0,0,0,0,0,c[0],c[1]),f._refs=1,this.texture=f}newTexture(){this.texture._refs--;const u=this.context,c=this.size;this.kernel.debug&&console.warn("new internal texture");const d=u.createTexture();a(u,d),u.texImage2D(u.TEXTURE_2D,0,this.internalFormat,c[0],c[1],0,this.textureFormat,this.textureType,null),d._refs=1,this.texture=d}clear(){if(this.texture._refs){this.texture._refs--;const h=this.context,d=this.texture=h.createTexture();a(h,d);const f=this.size;d._refs=1,h.texImage2D(h.TEXTURE_2D,0,this.internalFormat,f[0],f[1],0,this.textureFormat,this.textureType,null)}const{context:u,texture:c}=this;u.bindFramebuffer(u.FRAMEBUFFER,this.framebuffer()),u.bindTexture(u.TEXTURE_2D,c),a(u,c),u.framebufferTexture2D(u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,c,0),u.clearColor(0,0,0,0),u.clear(u.COLOR_BUFFER_BIT|u.DEPTH_BUFFER_BIT)}delete(){this._deleted||(this._deleted=!0,!(this.texture._refs&&(this.texture._refs--,this.texture._refs))&&this.context.deleteTexture(this.texture))}framebuffer(){return this._framebuffer||(this._framebuffer=this.kernel.getRawValueFramebuffer(this.size[0],this.size[1])),this._framebuffer}}function a(l,u){l.activeTexture(l.TEXTURE15),l.bindTexture(l.TEXTURE_2D,u),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_S,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_T,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MIN_FILTER,l.NEAREST),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MAG_FILTER,l.NEAREST)}s.exports={GLTexture:o}},{"../../../texture":113}],28:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="MemoryOptimizedNumberTexture"}toArray(){return i.erectMemoryOptimized2DFloat(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureMemoryOptimized2D:a}},{"../../../utils":114,"./float":25}],29:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="MemoryOptimizedNumberTexture"}toArray(){return i.erectMemoryOptimized3DFloat(this.renderValues(),this.output[0],this.output[1],this.output[2])}}s.exports={GLTextureMemoryOptimized3D:a}},{"../../../utils":114,"./float":25}],30:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureFloat:o}=n("./float");class a extends o{constructor(u){super(u),this.type="MemoryOptimizedNumberTexture"}toArray(){return i.erectMemoryOptimizedFloat(this.renderValues(),this.output[0])}}s.exports={GLTextureMemoryOptimized:a}},{"../../../utils":114,"./float":25}],31:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureUnsigned:o}=n("./unsigned");class a extends o{constructor(u){super(u),this.type="NumberTexture"}toArray(){return i.erect2DPackedFloat(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureUnsigned2D:a}},{"../../../utils":114,"./unsigned":33}],32:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTextureUnsigned:o}=n("./unsigned");class a extends o{constructor(u){super(u),this.type="NumberTexture"}toArray(){return i.erect3DPackedFloat(this.renderValues(),this.output[0],this.output[1],this.output[2])}}s.exports={GLTextureUnsigned3D:a}},{"../../../utils":114,"./unsigned":33}],33:[function(n,s,r){const{utils:i}=n("../../../utils"),{GLTexture:o}=n("./index");class a extends o{get textureType(){return this.context.UNSIGNED_BYTE}constructor(u){super(u),this.type="NumberTexture"}renderRawOutput(){const{context:u}=this;u.bindFramebuffer(u.FRAMEBUFFER,this.framebuffer()),u.framebufferTexture2D(u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,this.texture,0);const c=new Uint8Array(this.size[0]*this.size[1]*4);return u.readPixels(0,0,this.size[0],this.size[1],u.RGBA,u.UNSIGNED_BYTE,c),c}renderValues(){return this._deleted?null:new Float32Array(this.renderRawOutput().buffer)}toArray(){return i.erectPackedFloat(this.renderValues(),this.output[0])}}s.exports={GLTextureUnsigned:a}},{"../../../utils":114,"./index":27}],34:[function(n,s,r){const i=n("gl"),{WebGLKernel:o}=n("../web-gl/kernel"),{glKernelString:a}=n("../gl/kernel-string");let l=null,u=null,c=null,h=null,d=null;class f extends o{static get isSupported(){return l!==null||(this.setupFeatureChecks(),l=c!==null),l}static setupFeatureChecks(){if(u=null,h=null,typeof i=="function")try{if(c=i(2,2,{preserveDrawingBuffer:!0}),!c||!c.getExtension)return;h={STACKGL_resize_drawingbuffer:c.getExtension("STACKGL_resize_drawingbuffer"),STACKGL_destroy_context:c.getExtension("STACKGL_destroy_context"),OES_texture_float:c.getExtension("OES_texture_float"),OES_texture_float_linear:c.getExtension("OES_texture_float_linear"),OES_element_index_uint:c.getExtension("OES_element_index_uint"),WEBGL_draw_buffers:c.getExtension("WEBGL_draw_buffers"),WEBGL_color_buffer_float:c.getExtension("WEBGL_color_buffer_float")},d=this.getFeatures()}catch(g){console.warn(g)}}static isContextMatch(g){try{return g.getParameter(g.RENDERER)==="ANGLE"}catch{return!1}}static getIsTextureFloat(){return!!h.OES_texture_float}static getIsDrawBuffers(){return!!h.WEBGL_draw_buffers}static getChannelCount(){return h.WEBGL_draw_buffers?c.getParameter(h.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL):1}static getMaxTextureSize(){return c.getParameter(c.MAX_TEXTURE_SIZE)}static get testCanvas(){return u}static get testContext(){return c}static get features(){return d}initCanvas(){return{}}initContext(){return i(2,2,{preserveDrawingBuffer:!0})}initExtensions(){this.extensions={STACKGL_resize_drawingbuffer:this.context.getExtension("STACKGL_resize_drawingbuffer"),STACKGL_destroy_context:this.context.getExtension("STACKGL_destroy_context"),OES_texture_float:this.context.getExtension("OES_texture_float"),OES_texture_float_linear:this.context.getExtension("OES_texture_float_linear"),OES_element_index_uint:this.context.getExtension("OES_element_index_uint"),WEBGL_draw_buffers:this.context.getExtension("WEBGL_draw_buffers")}}build(){super.build.apply(this,arguments),this.fallbackRequested||this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0],this.maxTexSize[1])}destroyExtensions(){this.extensions.STACKGL_resize_drawingbuffer=null,this.extensions.STACKGL_destroy_context=null,this.extensions.OES_texture_float=null,this.extensions.OES_texture_float_linear=null,this.extensions.OES_element_index_uint=null,this.extensions.WEBGL_draw_buffers=null}static destroyContext(g){const m=g.getExtension("STACKGL_destroy_context");m&&m.destroy&&m.destroy()}toString(){return a(this.constructor,arguments,this,`const gl = context || require('gl')(1, 1);
`,`    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }
`)}setOutput(g){return super.setOutput(g),this.graphical&&this.extensions.STACKGL_resize_drawingbuffer&&this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0],this.maxTexSize[1]),this}}s.exports={HeadlessGLKernel:f}},{"../gl/kernel-string":12,"../web-gl/kernel":70,gl:2}],35:[function(n,s,r){class i{constructor(a,l){const{name:u,kernel:c,context:h,checkContext:d,onRequestContextHandle:f,onUpdateValueMismatch:p,origin:g,strictIntegers:m,type:x,tactic:b}=l;if(!u)throw new Error("name not set");if(!x)throw new Error("type not set");if(!g)throw new Error("origin not set");if(g!=="user"&&g!=="constants")throw new Error(`origin must be "user" or "constants" value is "${g}"`);if(!f)throw new Error("onRequestContextHandle is not set");this.name=u,this.origin=g,this.tactic=b,this.varName=g==="constants"?`constants.${u}`:u,this.kernel=c,this.strictIntegers=m,this.type=a.type||x,this.size=a.size||null,this.index=null,this.context=h,this.checkContext=d??!0,this.contextHandle=null,this.onRequestContextHandle=f,this.onUpdateValueMismatch=p,this.forceUploadEachRun=null}get id(){return`${this.origin}_${name}`}getSource(){throw new Error(`"getSource" not defined on ${this.constructor.name}`)}updateValue(a){throw new Error(`"updateValue" not defined on ${this.constructor.name}`)}}s.exports={KernelValue:i}},{}],36:[function(n,s,r){const{utils:i}=n("../utils"),{Input:o}=n("../input");class a{static get isSupported(){throw new Error(`"isSupported" not implemented on ${this.name}`)}static isContextMatch(c){throw new Error(`"isContextMatch" not implemented on ${this.name}`)}static getFeatures(){throw new Error(`"getFeatures" not implemented on ${this.name}`)}static destroyContext(c){throw new Error(`"destroyContext" called on ${this.name}`)}static nativeFunctionArguments(){throw new Error(`"nativeFunctionArguments" called on ${this.name}`)}static nativeFunctionReturnType(){throw new Error(`"nativeFunctionReturnType" called on ${this.name}`)}static combineKernels(){throw new Error(`"combineKernels" called on ${this.name}`)}constructor(c,h){if(typeof c!="object"){if(typeof c!="string")throw new Error("source not a string");if(!i.isFunctionString(c))throw new Error("source not a function string")}this.useLegacyEncoder=!1,this.fallbackRequested=!1,this.onRequestFallback=null,this.argumentNames=typeof c=="string"?i.getArgumentNamesFromString(c):null,this.argumentTypes=null,this.argumentSizes=null,this.argumentBitRatios=null,this.kernelArguments=null,this.kernelConstants=null,this.forceUploadKernelConstants=null,this.source=c,this.output=null,this.debug=!1,this.graphical=!1,this.loopMaxIterations=0,this.constants=null,this.constantTypes=null,this.constantBitRatios=null,this.dynamicArguments=!1,this.dynamicOutput=!1,this.canvas=null,this.context=null,this.checkContext=null,this.gpu=null,this.functions=null,this.nativeFunctions=null,this.injectedNative=null,this.subKernels=null,this.validate=!0,this.immutable=!1,this.pipeline=!1,this.precision=null,this.tactic=null,this.plugins=null,this.returnType=null,this.leadingReturnStatement=null,this.followingReturnStatement=null,this.optimizeFloatMemory=null,this.strictIntegers=!1,this.fixIntegerDivisionAccuracy=null,this.built=!1,this.signature=null}mergeSettings(c){for(let h in c)if(!(!c.hasOwnProperty(h)||!this.hasOwnProperty(h))){switch(h){case"output":if(!Array.isArray(c.output)){this.setOutput(c.output);continue}break;case"functions":this.functions=[];for(let d=0;d<c.functions.length;d++)this.addFunction(c.functions[d]);continue;case"graphical":c[h]&&!c.hasOwnProperty("precision")&&(this.precision="unsigned"),this[h]=c[h];continue;case"nativeFunctions":if(!c.nativeFunctions)continue;this.nativeFunctions=[];for(let d=0;d<c.nativeFunctions.length;d++){const f=c.nativeFunctions[d],{name:p,source:g}=f;this.addNativeFunction(p,g,f)}continue}this[h]=c[h]}this.canvas||(this.canvas=this.initCanvas()),this.context||(this.context=this.initContext()),this.plugins||(this.plugins=this.initPlugins(c))}build(){throw new Error(`"build" not defined on ${this.constructor.name}`)}run(){throw new Error(`"run" not defined on ${this.constructor.name}`)}initCanvas(){throw new Error(`"initCanvas" not defined on ${this.constructor.name}`)}initContext(){throw new Error(`"initContext" not defined on ${this.constructor.name}`)}initPlugins(c){throw new Error(`"initPlugins" not defined on ${this.constructor.name}`)}addFunction(c,h={}){if(c.name&&c.source&&c.argumentTypes&&"returnType"in c)this.functions.push(c);else if("settings"in c&&"source"in c)this.functions.push(this.functionToIGPUFunction(c.source,c.settings));else if(typeof c=="string"||typeof c=="function")this.functions.push(this.functionToIGPUFunction(c,h));else throw new Error("function not properly defined");return this}addNativeFunction(c,h,d={}){const{argumentTypes:f,argumentNames:p}=d.argumentTypes?l(d.argumentTypes):this.constructor.nativeFunctionArguments(h)||{};return this.nativeFunctions.push({name:c,source:h,settings:d,argumentTypes:f,argumentNames:p,returnType:d.returnType||this.constructor.nativeFunctionReturnType(h)}),this}setupArguments(c){if(this.kernelArguments=[],this.argumentTypes)for(let h=0;h<this.argumentTypes.length;h++)this.kernelArguments.push({type:this.argumentTypes[h]});else if(!this.argumentTypes){this.argumentTypes=[];for(let h=0;h<c.length;h++){const d=i.getVariableType(c[h],this.strictIntegers),f=d==="Integer"?"Number":d;this.argumentTypes.push(f),this.kernelArguments.push({type:f})}}this.argumentSizes=new Array(c.length),this.argumentBitRatios=new Int32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];this.argumentSizes[h]=d.constructor===o?d.size:null,this.argumentBitRatios[h]=this.getBitRatio(d)}if(this.argumentNames.length!==c.length)throw new Error("arguments are miss-aligned")}setupConstants(){this.kernelConstants=[];let c=this.constantTypes===null;if(c&&(this.constantTypes={}),this.constantBitRatios={},this.constants)for(let h in this.constants){if(c){const d=i.getVariableType(this.constants[h],this.strictIntegers);this.constantTypes[h]=d,this.kernelConstants.push({name:h,type:d})}else this.kernelConstants.push({name:h,type:this.constantTypes[h]});this.constantBitRatios[h]=this.getBitRatio(this.constants[h])}}setOptimizeFloatMemory(c){return this.optimizeFloatMemory=c,this}toKernelOutput(c){return c.hasOwnProperty("x")?c.hasOwnProperty("y")?c.hasOwnProperty("z")?[c.x,c.y,c.z]:[c.x,c.y]:[c.x]:c}setOutput(c){return this.output=this.toKernelOutput(c),this}setDebug(c){return this.debug=c,this}setGraphical(c){return this.graphical=c,this.precision="unsigned",this}setLoopMaxIterations(c){return this.loopMaxIterations=c,this}setConstants(c){return this.constants=c,this}setConstantTypes(c){return this.constantTypes=c,this}setFunctions(c){for(let h=0;h<c.length;h++)this.addFunction(c[h]);return this}setNativeFunctions(c){for(let h=0;h<c.length;h++){const d=c[h],{name:f,source:p}=d;this.addNativeFunction(f,p,d)}return this}setInjectedNative(c){return this.injectedNative=c,this}setPipeline(c){return this.pipeline=c,this}setPrecision(c){return this.precision=c,this}setDimensions(c){return i.warnDeprecated("method","setDimensions","setOutput"),this.output=c,this}setOutputToTexture(c){return i.warnDeprecated("method","setOutputToTexture","setPipeline"),this.pipeline=c,this}setImmutable(c){return this.immutable=c,this}setCanvas(c){return this.canvas=c,this}setStrictIntegers(c){return this.strictIntegers=c,this}setDynamicOutput(c){return this.dynamicOutput=c,this}setHardcodeConstants(c){return i.warnDeprecated("method","setHardcodeConstants"),this.setDynamicOutput(c),this.setDynamicArguments(c),this}setDynamicArguments(c){return this.dynamicArguments=c,this}setUseLegacyEncoder(c){return this.useLegacyEncoder=c,this}setWarnVarUsage(c){return i.warnDeprecated("method","setWarnVarUsage"),this}getCanvas(){return i.warnDeprecated("method","getCanvas"),this.canvas}getWebGl(){return i.warnDeprecated("method","getWebGl"),this.context}setContext(c){return this.context=c,this}setArgumentTypes(c){if(Array.isArray(c))this.argumentTypes=c;else{this.argumentTypes=[];for(const h in c){if(!c.hasOwnProperty(h))continue;const d=this.argumentNames.indexOf(h);if(d===-1)throw new Error(`unable to find argument ${h}`);this.argumentTypes[d]=c[h]}}return this}setTactic(c){return this.tactic=c,this}requestFallback(c){if(!this.onRequestFallback)throw new Error(`"onRequestFallback" not defined on ${this.constructor.name}`);return this.fallbackRequested=!0,this.onRequestFallback(c)}validateSettings(){throw new Error(`"validateSettings" not defined on ${this.constructor.name}`)}addSubKernel(c){if(this.subKernels===null&&(this.subKernels=[]),!c.source)throw new Error('subKernel missing "source" property');if(!c.property&&isNaN(c.property))throw new Error('subKernel missing "property" property');if(!c.name)throw new Error('subKernel missing "name" property');return this.subKernels.push(c),this}destroy(c){throw new Error(`"destroy" called on ${this.constructor.name}`)}getBitRatio(c){if(this.precision==="single")return 4;if(Array.isArray(c[0]))return this.getBitRatio(c[0]);if(c.constructor===o)return this.getBitRatio(c.value);switch(c.constructor){case Uint8ClampedArray:case Uint8Array:case Int8Array:return 1;case Uint16Array:case Int16Array:return 2;case Float32Array:case Int32Array:default:return 4}}getPixels(c){throw new Error(`"getPixels" called on ${this.constructor.name}`)}checkOutput(){if(!this.output||!i.isArray(this.output))throw new Error("kernel.output not an array");if(this.output.length<1)throw new Error("kernel.output is empty, needs at least 1 value");for(let c=0;c<this.output.length;c++)if(isNaN(this.output[c])||this.output[c]<1)throw new Error(`${this.constructor.name}.output[${c}] incorrectly defined as \`${this.output[c]}\`, needs to be numeric, and greater than 0`)}prependString(c){throw new Error(`"prependString" called on ${this.constructor.name}`)}hasPrependString(c){throw new Error(`"hasPrependString" called on ${this.constructor.name}`)}toJSON(){return{settings:{output:this.output,pipeline:this.pipeline,argumentNames:this.argumentNames,argumentsTypes:this.argumentTypes,constants:this.constants,pluginNames:this.plugins?this.plugins.map(c=>c.name):null,returnType:this.returnType}}}buildSignature(c){const h=this.constructor;this.signature=h.getSignature(this,h.getArgumentTypes(this,c))}static getArgumentTypes(c,h){const d=new Array(h.length);for(let f=0;f<h.length;f++){const p=h[f],g=c.argumentTypes[f];if(p.type)d[f]=p.type;else switch(g){case"Number":case"Integer":case"Float":case"ArrayTexture(1)":d[f]=i.getVariableType(p);break;default:d[f]=g}}return d}static getSignature(c,h){throw new Error(`"getSignature" not implemented on ${this.name}`)}functionToIGPUFunction(c,h={}){if(typeof c!="string"&&typeof c!="function")throw new Error("source not a string or function");const d=typeof c=="string"?c:c.toString();let f=[];return Array.isArray(h.argumentTypes)?f=h.argumentTypes:typeof h.argumentTypes=="object"?f=i.getArgumentNamesFromString(d).map(p=>h.argumentTypes[p])||[]:f=h.argumentTypes||[],{name:i.getFunctionNameFromString(d)||null,source:d,argumentTypes:f,returnType:h.returnType||null}}onActivate(c){}}function l(u){const c=Object.keys(u),h=[];for(let d=0;d<c.length;d++){const f=c[d];h.push(u[f])}return{argumentTypes:h,argumentNames:c}}s.exports={Kernel:a}},{"../input":110,"../utils":114}],37:[function(n,s,r){const i=`__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

varying vec2 vTexCoord;

float acosh(float x) {
  return log(x + sqrt(x * x - 1.0));
}

float sinh(float x) {
  return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;
}

float asinh(float x) {
  return log(x + sqrt(x * x + 1.0));
}

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float atanh(float x) {
  x = (x + 1.0) / (x - 1.0);
  if (x < 0.0) {
    return 0.5 * log(-x);
  }
  return 0.5 * log(x);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float cosh(float x) {
  return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; 
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float tanh(float x) {
  float e = exp(2.0 * x);
  return (e - 1.0) / (e + 1.0);
}

float trunc(float x) {
  if (x >= 0.0) {
    return floor(x); 
  } else {
    return ceil(x);
  }
}

vec4 _round(vec4 x) {
  return floor(x + 0.5);
}

float _round(float x) {
  return floor(x + 0.5);
}

const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x / y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(_round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
  if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
  return 0.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  if (channel == 0) return texel.r * 255.0;
  if (channel == 1) return texel.g * 255.0;
  if (channel == 2) return texel.b * 255.0;
  if (channel == 3) return texel.a * 255.0;
  return 0.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return texel.r;
  if (channel == 1) return texel.g;
  if (channel == 2) return texel.b;
  if (channel == 3) return texel.a;
  return 0.0;
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture2D(tex, st / vec2(texSize));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
  
  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

void color(sampler2D image) {
  actualColor = texture2D(image, vTexCoord);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;s.exports={fragmentShader:i}},{}],38:[function(n,s,r){const{utils:i}=n("../../utils"),{FunctionNode:o}=n("../function-node");class a extends o{constructor(h,d){super(h,d),d&&d.hasOwnProperty("fixIntegerDivisionAccuracy")&&(this.fixIntegerDivisionAccuracy=d.fixIntegerDivisionAccuracy)}astConditionalExpression(h,d){if(h.type!=="ConditionalExpression")throw this.astErrorOutput("Not a conditional expression",h);const f=this.getType(h.consequent),p=this.getType(h.alternate);return f===null&&p===null?(d.push("if ("),this.astGeneric(h.test,d),d.push(") {"),this.astGeneric(h.consequent,d),d.push(";"),d.push("} else {"),this.astGeneric(h.alternate,d),d.push(";"),d.push("}"),d):(d.push("("),this.astGeneric(h.test,d),d.push("?"),this.astGeneric(h.consequent,d),d.push(":"),this.astGeneric(h.alternate,d),d.push(")"),d)}astFunction(h,d){if(this.isRootKernel)d.push("void");else{this.returnType||this.findLastReturn()&&(this.returnType=this.getType(h.body),this.returnType==="LiteralInteger"&&(this.returnType="Number"));const{returnType:f}=this;if(!f)d.push("void");else{const p=l[f];if(!p)throw new Error(`unknown type ${f}`);d.push(p)}}if(d.push(" "),d.push(this.name),d.push("("),!this.isRootKernel)for(let f=0;f<this.argumentNames.length;++f){const p=this.argumentNames[f];f>0&&d.push(", ");let g=this.argumentTypes[this.argumentNames.indexOf(p)];if(!g)throw this.astErrorOutput(`Unknown argument ${p} type`,h);g==="LiteralInteger"&&(this.argumentTypes[f]=g="Number");const m=l[g];if(!m)throw this.astErrorOutput("Unexpected expression",h);const x=i.sanitizeName(p);m==="sampler2D"||m==="sampler2DArray"?d.push(`${m} user_${x},ivec2 user_${x}Size,ivec3 user_${x}Dim`):d.push(`${m} user_${x}`)}d.push(`) {
`);for(let f=0;f<h.body.body.length;++f)this.astGeneric(h.body.body[f],d),d.push(`
`);return d.push(`}
`),d}astReturnStatement(h,d){if(!h.argument)throw this.astErrorOutput("Unexpected return statement",h);this.pushState("skip-literal-correction");const f=this.getType(h.argument);this.popState("skip-literal-correction");const p=[];switch(this.returnType||(f==="LiteralInteger"||f==="Integer"?this.returnType="Number":this.returnType=f),this.returnType){case"LiteralInteger":case"Number":case"Float":switch(f){case"Integer":p.push("float("),this.astGeneric(h.argument,p),p.push(")");break;case"LiteralInteger":this.castLiteralToFloat(h.argument,p),this.getType(h)==="Integer"&&(p.unshift("float("),p.push(")"));break;default:this.astGeneric(h.argument,p)}break;case"Integer":switch(f){case"Float":case"Number":this.castValueToInteger(h.argument,p);break;case"LiteralInteger":this.castLiteralToInteger(h.argument,p);break;default:this.astGeneric(h.argument,p)}break;case"Array(4)":case"Array(3)":case"Array(2)":case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":case"Input":this.astGeneric(h.argument,p);break;default:throw this.astErrorOutput(`unhandled return type ${this.returnType}`,h)}return this.isRootKernel?(d.push(`kernelResult = ${p.join("")};`),d.push("return;")):this.isSubKernel?(d.push(`subKernelResult_${this.name} = ${p.join("")};`),d.push(`return subKernelResult_${this.name};`)):d.push(`return ${p.join("")};`),d}astLiteral(h,d){if(isNaN(h.value))throw this.astErrorOutput("Non-numeric literal not supported : "+h.value,h);const f=this.astKey(h);return Number.isInteger(h.value)?this.isState("casting-to-integer")||this.isState("building-integer")?(this.literalTypes[f]="Integer",d.push(`${h.value}`)):this.isState("casting-to-float")||this.isState("building-float")?(this.literalTypes[f]="Number",d.push(`${h.value}.0`)):(this.literalTypes[f]="Number",d.push(`${h.value}.0`)):this.isState("casting-to-integer")||this.isState("building-integer")?(this.literalTypes[f]="Integer",d.push(Math.round(h.value))):(this.literalTypes[f]="Number",d.push(`${h.value}`)),d}astBinaryExpression(h,d){if(this.checkAndUpconvertOperator(h,d))return d;if(this.fixIntegerDivisionAccuracy&&h.operator==="/"){switch(d.push("divWithIntCheck("),this.pushState("building-float"),this.getType(h.left)){case"Integer":this.castValueToFloat(h.left,d);break;case"LiteralInteger":this.castLiteralToFloat(h.left,d);break;default:this.astGeneric(h.left,d)}switch(d.push(", "),this.getType(h.right)){case"Integer":this.castValueToFloat(h.right,d);break;case"LiteralInteger":this.castLiteralToFloat(h.right,d);break;default:this.astGeneric(h.right,d)}return this.popState("building-float"),d.push(")"),d}d.push("(");const f=this.getType(h.left)||"Number",p=this.getType(h.right)||"Number",g=f+" & "+p;switch(g){case"Integer & Integer":this.pushState("building-integer"),this.astGeneric(h.left,d),d.push(u[h.operator]||h.operator),this.astGeneric(h.right,d),this.popState("building-integer");break;case"Number & Float":case"Float & Number":case"Float & Float":case"Number & Number":this.pushState("building-float"),this.astGeneric(h.left,d),d.push(u[h.operator]||h.operator),this.astGeneric(h.right,d),this.popState("building-float");break;case"LiteralInteger & LiteralInteger":this.isState("casting-to-integer")||this.isState("building-integer")?(this.pushState("building-integer"),this.astGeneric(h.left,d),d.push(u[h.operator]||h.operator),this.astGeneric(h.right,d),this.popState("building-integer")):(this.pushState("building-float"),this.castLiteralToFloat(h.left,d),d.push(u[h.operator]||h.operator),this.castLiteralToFloat(h.right,d),this.popState("building-float"));break;case"Integer & Float":case"Integer & Number":if((h.operator===">"||h.operator==="<"&&h.right.type==="Literal")&&!Number.isInteger(h.right.value)){this.pushState("building-float"),this.castValueToFloat(h.left,d),d.push(u[h.operator]||h.operator),this.astGeneric(h.right,d),this.popState("building-float");break}if(this.pushState("building-integer"),this.astGeneric(h.left,d),d.push(u[h.operator]||h.operator),this.pushState("casting-to-integer"),h.right.type==="Literal"){const m=[];if(this.astGeneric(h.right,m),this.getType(h.right)==="Integer")d.push(m.join(""));else throw this.astErrorOutput("Unhandled binary expression with literal",h)}else d.push("int("),this.astGeneric(h.right,d),d.push(")");this.popState("casting-to-integer"),this.popState("building-integer");break;case"Integer & LiteralInteger":this.pushState("building-integer"),this.astGeneric(h.left,d),d.push(u[h.operator]||h.operator),this.castLiteralToInteger(h.right,d),this.popState("building-integer");break;case"Number & Integer":this.pushState("building-float"),this.astGeneric(h.left,d),d.push(u[h.operator]||h.operator),this.castValueToFloat(h.right,d),this.popState("building-float");break;case"Float & LiteralInteger":case"Number & LiteralInteger":this.pushState("building-float"),this.astGeneric(h.left,d),d.push(u[h.operator]||h.operator),this.castLiteralToFloat(h.right,d),this.popState("building-float");break;case"LiteralInteger & Float":case"LiteralInteger & Number":this.isState("casting-to-integer")?(this.pushState("building-integer"),this.castLiteralToInteger(h.left,d),d.push(u[h.operator]||h.operator),this.castValueToInteger(h.right,d),this.popState("building-integer")):(this.pushState("building-float"),this.astGeneric(h.left,d),d.push(u[h.operator]||h.operator),this.pushState("casting-to-float"),this.astGeneric(h.right,d),this.popState("casting-to-float"),this.popState("building-float"));break;case"LiteralInteger & Integer":this.pushState("building-integer"),this.castLiteralToInteger(h.left,d),d.push(u[h.operator]||h.operator),this.astGeneric(h.right,d),this.popState("building-integer");break;case"Boolean & Boolean":this.pushState("building-boolean"),this.astGeneric(h.left,d),d.push(u[h.operator]||h.operator),this.astGeneric(h.right,d),this.popState("building-boolean");break;case"Float & Integer":this.pushState("building-float"),this.astGeneric(h.left,d),d.push(u[h.operator]||h.operator),this.castValueToFloat(h.right,d),this.popState("building-float");break;default:throw this.astErrorOutput(`Unhandled binary expression between ${g}`,h)}return d.push(")"),d}checkAndUpconvertOperator(h,d){const f=this.checkAndUpconvertBitwiseOperators(h,d);if(f)return f;const g={"%":this.fixIntegerDivisionAccuracy?"integerCorrectionModulo":"modulo","**":"pow"}[h.operator];if(!g)return null;switch(d.push(g),d.push("("),this.getType(h.left)){case"Integer":this.castValueToFloat(h.left,d);break;case"LiteralInteger":this.castLiteralToFloat(h.left,d);break;default:this.astGeneric(h.left,d)}switch(d.push(","),this.getType(h.right)){case"Integer":this.castValueToFloat(h.right,d);break;case"LiteralInteger":this.castLiteralToFloat(h.right,d);break;default:this.astGeneric(h.right,d)}return d.push(")"),d}checkAndUpconvertBitwiseOperators(h,d){const p={"&":"bitwiseAnd","|":"bitwiseOr","^":"bitwiseXOR","<<":"bitwiseZeroFillLeftShift",">>":"bitwiseSignedRightShift",">>>":"bitwiseZeroFillRightShift"}[h.operator];if(!p)return null;switch(d.push(p),d.push("("),this.getType(h.left)){case"Number":case"Float":this.castValueToInteger(h.left,d);break;case"LiteralInteger":this.castLiteralToInteger(h.left,d);break;default:this.astGeneric(h.left,d)}switch(d.push(","),this.getType(h.right)){case"Number":case"Float":this.castValueToInteger(h.right,d);break;case"LiteralInteger":this.castLiteralToInteger(h.right,d);break;default:this.astGeneric(h.right,d)}return d.push(")"),d}checkAndUpconvertBitwiseUnary(h,d){const p={"~":"bitwiseNot"}[h.operator];if(!p)return null;switch(d.push(p),d.push("("),this.getType(h.argument)){case"Number":case"Float":this.castValueToInteger(h.argument,d);break;case"LiteralInteger":this.castLiteralToInteger(h.argument,d);break;default:this.astGeneric(h.argument,d)}return d.push(")"),d}castLiteralToInteger(h,d){return this.pushState("casting-to-integer"),this.astGeneric(h,d),this.popState("casting-to-integer"),d}castLiteralToFloat(h,d){return this.pushState("casting-to-float"),this.astGeneric(h,d),this.popState("casting-to-float"),d}castValueToInteger(h,d){return this.pushState("casting-to-integer"),d.push("int("),this.astGeneric(h,d),d.push(")"),this.popState("casting-to-integer"),d}castValueToFloat(h,d){return this.pushState("casting-to-float"),d.push("float("),this.astGeneric(h,d),d.push(")"),this.popState("casting-to-float"),d}astIdentifierExpression(h,d){if(h.type!=="Identifier")throw this.astErrorOutput("IdentifierExpression - not an Identifier",h);const f=this.getType(h),p=i.sanitizeName(h.name);return h.name==="Infinity"?d.push("3.402823466e+38"):f==="Boolean"?this.argumentNames.indexOf(p)>-1?d.push(`bool(user_${p})`):d.push(`user_${p}`):d.push(`user_${p}`),d}astForStatement(h,d){if(h.type!=="ForStatement")throw this.astErrorOutput("Invalid for statement",h);const f=[],p=[],g=[],m=[];let x=null;if(h.init){const{declarations:b}=h.init;b.length>1&&(x=!1),this.astGeneric(h.init,f);for(let v=0;v<b.length;v++)b[v].init&&b[v].init.type!=="Literal"&&(x=!1)}else x=!1;if(h.test?this.astGeneric(h.test,p):x=!1,h.update?this.astGeneric(h.update,g):x=!1,h.body&&(this.pushState("loop-body"),this.astGeneric(h.body,m),this.popState("loop-body")),x===null&&(x=this.isSafe(h.init)&&this.isSafe(h.test)),x){const b=f.join(""),v=b[b.length-1]!==";";d.push(`for (${b}${v?";":""}${p.join("")};${g.join("")}){
`),d.push(m.join("")),d.push(`}
`)}else{const b=this.getInternalVariableName("safeI");f.length>0&&d.push(f.join(""),`
`),d.push(`for (int ${b}=0;${b}<LOOP_MAX;${b}++){
`),p.length>0&&d.push(`if (!${p.join("")}) break;
`),d.push(m.join("")),d.push(`
${g.join("")};`),d.push(`}
`)}return d}astWhileStatement(h,d){if(h.type!=="WhileStatement")throw this.astErrorOutput("Invalid while statement",h);const f=this.getInternalVariableName("safeI");return d.push(`for (int ${f}=0;${f}<LOOP_MAX;${f}++){
`),d.push("if (!"),this.astGeneric(h.test,d),d.push(`) break;
`),this.astGeneric(h.body,d),d.push(`}
`),d}astDoWhileStatement(h,d){if(h.type!=="DoWhileStatement")throw this.astErrorOutput("Invalid while statement",h);const f=this.getInternalVariableName("safeI");return d.push(`for (int ${f}=0;${f}<LOOP_MAX;${f}++){
`),this.astGeneric(h.body,d),d.push("if (!"),this.astGeneric(h.test,d),d.push(`) break;
`),d.push(`}
`),d}astAssignmentExpression(h,d){if(h.operator==="%=")this.astGeneric(h.left,d),d.push("="),d.push("mod("),this.astGeneric(h.left,d),d.push(","),this.astGeneric(h.right,d),d.push(")");else if(h.operator==="**=")this.astGeneric(h.left,d),d.push("="),d.push("pow("),this.astGeneric(h.left,d),d.push(","),this.astGeneric(h.right,d),d.push(")");else{const f=this.getType(h.left),p=this.getType(h.right);return this.astGeneric(h.left,d),d.push(h.operator),f!=="Integer"&&p==="Integer"?(d.push("float("),this.astGeneric(h.right,d),d.push(")")):this.astGeneric(h.right,d),d}}astBlockStatement(h,d){if(this.isState("loop-body")){this.pushState("block-body");for(let f=0;f<h.body.length;f++)this.astGeneric(h.body[f],d);this.popState("block-body")}else{d.push(`{
`);for(let f=0;f<h.body.length;f++)this.astGeneric(h.body[f],d);d.push(`}
`)}return d}astVariableDeclaration(h,d){const f=h.declarations;if(!f||!f[0]||!f[0].init)throw this.astErrorOutput("Unexpected expression",h);const p=[];let g=null;const m=[];let x=[];for(let b=0;b<f.length;b++){const v=f[b],y=v.init,C=this.getDeclaration(v.id),I=this.getType(v.init);let $=I;$==="LiteralInteger"&&(C.suggestedType==="Integer"?$="Integer":$="Number");const T=l[$];if(!T)throw this.astErrorOutput(`Markup type ${$} not handled`,h);const S=[];if(I==="Integer"&&$==="Integer"){if(C.valueType="Number",b===0||g===null)S.push("float ");else if($!==g)throw new Error("Unhandled declaration");g=$,S.push(`user_${i.sanitizeName(v.id.name)}=`),S.push("float("),this.astGeneric(y,S),S.push(")")}else C.valueType=$,b===0||g===null?S.push(`${T} `):$!==g&&(m.push(x.join(",")),x=[],S.push(`${T} `)),g=$,S.push(`user_${i.sanitizeName(v.id.name)}=`),I==="Number"&&$==="Integer"?y.left&&y.left.type==="Literal"?this.astGeneric(y,S):(S.push("int("),this.astGeneric(y,S),S.push(")")):I==="LiteralInteger"&&$==="Integer"?this.castLiteralToInteger(y,S):this.astGeneric(y,S);x.push(S.join(""))}return x.length>0&&m.push(x.join(",")),p.push(m.join(";")),d.push(p.join("")),d.push(";"),d}astIfStatement(h,d){return d.push("if ("),this.astGeneric(h.test,d),d.push(")"),h.consequent.type==="BlockStatement"?this.astGeneric(h.consequent,d):(d.push(` {
`),this.astGeneric(h.consequent,d),d.push(`
}
`)),h.alternate&&(d.push("else "),h.alternate.type==="BlockStatement"||h.alternate.type==="IfStatement"?this.astGeneric(h.alternate,d):(d.push(` {
`),this.astGeneric(h.alternate,d),d.push(`
}
`))),d}astSwitchStatement(h,d){if(h.type!=="SwitchStatement")throw this.astErrorOutput("Invalid switch statement",h);const{discriminant:f,cases:p}=h,g=this.getType(f),m=`switchDiscriminant${this.astKey(h,"_")}`;switch(g){case"Float":case"Number":d.push(`float ${m} = `),this.astGeneric(f,d),d.push(`;
`);break;case"Integer":d.push(`int ${m} = `),this.astGeneric(f,d),d.push(`;
`);break}if(p.length===1&&!p[0].test)return this.astGeneric(p[0].consequent,d),d;let x=!1,b=[],v=!1,y=!1;for(let C=0;C<p.length;C++){if(p[C].test){if(C===0||!y?(y=!0,d.push(`if (${m} == `)):x?(d.push(`${m} == `),x=!1):d.push(` else if (${m} == `),g==="Integer")switch(this.getType(p[C].test)){case"Number":case"Float":this.castValueToInteger(p[C].test,d);break;case"LiteralInteger":this.castLiteralToInteger(p[C].test,d);break}else if(g==="Float")switch(this.getType(p[C].test)){case"LiteralInteger":this.castLiteralToFloat(p[C].test,d);break;case"Integer":this.castValueToFloat(p[C].test,d);break}else throw new Error("unhanlded");if(!p[C].consequent||p[C].consequent.length===0){x=!0,d.push(" || ");continue}d.push(`) {
`)}else if(p.length>C+1){v=!0,this.astGeneric(p[C].consequent,b);continue}else d.push(` else {
`);this.astGeneric(p[C].consequent,d),d.push(`
}`)}return v&&(d.push(" else {"),d.push(b.join("")),d.push("}")),d}astThisExpression(h,d){return d.push("this"),d}astMemberExpression(h,d){const{property:f,name:p,signature:g,origin:m,type:x,xProperty:b,yProperty:v,zProperty:y}=this.getMemberExpressionDetails(h);switch(g){case"value.thread.value":case"this.thread.value":if(p!=="x"&&p!=="y"&&p!=="z")throw this.astErrorOutput("Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`",h);return d.push(`threadId.${p}`),d;case"this.output.value":if(this.dynamicOutput)switch(p){case"x":this.isState("casting-to-float")?d.push("float(uOutputDim.x)"):d.push("uOutputDim.x");break;case"y":this.isState("casting-to-float")?d.push("float(uOutputDim.y)"):d.push("uOutputDim.y");break;case"z":this.isState("casting-to-float")?d.push("float(uOutputDim.z)"):d.push("uOutputDim.z");break;default:throw this.astErrorOutput("Unexpected expression",h)}else switch(p){case"x":this.isState("casting-to-integer")?d.push(this.output[0]):d.push(this.output[0],".0");break;case"y":this.isState("casting-to-integer")?d.push(this.output[1]):d.push(this.output[1],".0");break;case"z":this.isState("casting-to-integer")?d.push(this.output[2]):d.push(this.output[2],".0");break;default:throw this.astErrorOutput("Unexpected expression",h)}return d;case"value":throw this.astErrorOutput("Unexpected expression",h);case"value[]":case"value[][]":case"value[][][]":case"value[][][][]":case"value.value":if(m==="Math")return d.push(Math[p]),d;const I=i.sanitizeName(p);switch(f){case"r":return d.push(`user_${I}.r`),d;case"g":return d.push(`user_${I}.g`),d;case"b":return d.push(`user_${I}.b`),d;case"a":return d.push(`user_${I}.a`),d}break;case"this.constants.value":if(typeof b>"u")switch(x){case"Array(2)":case"Array(3)":case"Array(4)":return d.push(`constants_${i.sanitizeName(p)}`),d}case"this.constants.value[]":case"this.constants.value[][]":case"this.constants.value[][][]":case"this.constants.value[][][][]":break;case"fn()[]":return this.astCallExpression(h.object,d),d.push("["),d.push(this.memberExpressionPropertyMarkup(f)),d.push("]"),d;case"fn()[][]":return this.astCallExpression(h.object.object,d),d.push("["),d.push(this.memberExpressionPropertyMarkup(h.object.property)),d.push("]"),d.push("["),d.push(this.memberExpressionPropertyMarkup(h.property)),d.push("]"),d;case"[][]":return this.astArrayExpression(h.object,d),d.push("["),d.push(this.memberExpressionPropertyMarkup(f)),d.push("]"),d;default:throw this.astErrorOutput("Unexpected expression",h)}if(h.computed===!1)switch(x){case"Number":case"Integer":case"Float":case"Boolean":return d.push(`${m}_${i.sanitizeName(p)}`),d}const C=`${m}_${i.sanitizeName(p)}`;switch(x){case"Array(2)":case"Array(3)":case"Array(4)":this.astGeneric(h.object,d),d.push("["),d.push(this.memberExpressionPropertyMarkup(b)),d.push("]");break;case"HTMLImageArray":d.push(`getImage3D(${C}, ${C}Size, ${C}Dim, `),this.memberExpressionXYZ(b,v,y,d),d.push(")");break;case"ArrayTexture(1)":d.push(`getFloatFromSampler2D(${C}, ${C}Size, ${C}Dim, `),this.memberExpressionXYZ(b,v,y,d),d.push(")");break;case"Array1D(2)":case"Array2D(2)":case"Array3D(2)":d.push(`getMemoryOptimizedVec2(${C}, ${C}Size, ${C}Dim, `),this.memberExpressionXYZ(b,v,y,d),d.push(")");break;case"ArrayTexture(2)":d.push(`getVec2FromSampler2D(${C}, ${C}Size, ${C}Dim, `),this.memberExpressionXYZ(b,v,y,d),d.push(")");break;case"Array1D(3)":case"Array2D(3)":case"Array3D(3)":d.push(`getMemoryOptimizedVec3(${C}, ${C}Size, ${C}Dim, `),this.memberExpressionXYZ(b,v,y,d),d.push(")");break;case"ArrayTexture(3)":d.push(`getVec3FromSampler2D(${C}, ${C}Size, ${C}Dim, `),this.memberExpressionXYZ(b,v,y,d),d.push(")");break;case"Array1D(4)":case"Array2D(4)":case"Array3D(4)":d.push(`getMemoryOptimizedVec4(${C}, ${C}Size, ${C}Dim, `),this.memberExpressionXYZ(b,v,y,d),d.push(")");break;case"ArrayTexture(4)":case"HTMLCanvas":case"OffscreenCanvas":case"HTMLImage":case"ImageBitmap":case"ImageData":case"HTMLVideo":d.push(`getVec4FromSampler2D(${C}, ${C}Size, ${C}Dim, `),this.memberExpressionXYZ(b,v,y,d),d.push(")");break;case"NumberTexture":case"Array":case"Array2D":case"Array3D":case"Array4D":case"Input":case"Number":case"Float":case"Integer":if(this.precision==="single")d.push(`getMemoryOptimized32(${C}, ${C}Size, ${C}Dim, `),this.memberExpressionXYZ(b,v,y,d),d.push(")");else{const I=m==="user"?this.lookupFunctionArgumentBitRatio(this.name,p):this.constantBitRatios[p];switch(I){case 1:d.push(`get8(${C}, ${C}Size, ${C}Dim, `);break;case 2:d.push(`get16(${C}, ${C}Size, ${C}Dim, `);break;case 4:case 0:d.push(`get32(${C}, ${C}Size, ${C}Dim, `);break;default:throw new Error(`unhandled bit ratio of ${I}`)}this.memberExpressionXYZ(b,v,y,d),d.push(")")}break;case"MemoryOptimizedNumberTexture":d.push(`getMemoryOptimized32(${C}, ${C}Size, ${C}Dim, `),this.memberExpressionXYZ(b,v,y,d),d.push(")");break;case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":d.push(`${C}[${this.memberExpressionPropertyMarkup(v)}]`),v&&d.push(`[${this.memberExpressionPropertyMarkup(b)}]`);break;default:throw new Error(`unhandled member expression "${x}"`)}return d}astCallExpression(h,d){if(!h.callee)throw this.astErrorOutput("Unknown CallExpression",h);let f=null;const p=this.isAstMathFunction(h);if(p||h.callee.object&&h.callee.object.type==="ThisExpression"?f=h.callee.property.name:h.callee.type==="SequenceExpression"&&h.callee.expressions[0].type==="Literal"&&!isNaN(h.callee.expressions[0].raw)?f=h.callee.expressions[1].property.name:f=h.callee.name,!f)throw this.astErrorOutput("Unhandled function, couldn't find name",h);switch(f){case"pow":f="_pow";break;case"round":f="_round";break}if(this.calledFunctions.indexOf(f)<0&&this.calledFunctions.push(f),f==="random"&&this.plugins&&this.plugins.length>0)for(let g=0;g<this.plugins.length;g++){const m=this.plugins[g];if(m.functionMatch==="Math.random()"&&m.functionReplace)return d.push(m.functionReplace),d}if(this.onFunctionCall&&this.onFunctionCall(this.name,f,h.arguments),d.push(f),d.push("("),p)for(let g=0;g<h.arguments.length;++g){const m=h.arguments[g],x=this.getType(m);switch(g>0&&d.push(", "),x){case"Integer":this.castValueToFloat(m,d);break;default:this.astGeneric(m,d);break}}else{const g=this.lookupFunctionArgumentTypes(f)||[];for(let m=0;m<h.arguments.length;++m){const x=h.arguments[m];let b=g[m];m>0&&d.push(", ");const v=this.getType(x);switch(b||(this.triggerImplyArgumentType(f,m,v,this),b=v),v){case"Boolean":this.astGeneric(x,d);continue;case"Number":case"Float":if(b==="Integer"){d.push("int("),this.astGeneric(x,d),d.push(")");continue}else if(b==="Number"||b==="Float"){this.astGeneric(x,d);continue}else if(b==="LiteralInteger"){this.castLiteralToFloat(x,d);continue}break;case"Integer":if(b==="Number"||b==="Float"){d.push("float("),this.astGeneric(x,d),d.push(")");continue}else if(b==="Integer"){this.astGeneric(x,d);continue}break;case"LiteralInteger":if(b==="Integer"){this.castLiteralToInteger(x,d);continue}else if(b==="Number"||b==="Float"){this.castLiteralToFloat(x,d);continue}else if(b==="LiteralInteger"){this.astGeneric(x,d);continue}break;case"Array(2)":case"Array(3)":case"Array(4)":if(b===v){if(x.type==="Identifier")d.push(`user_${i.sanitizeName(x.name)}`);else if(x.type==="ArrayExpression"||x.type==="MemberExpression"||x.type==="CallExpression")this.astGeneric(x,d);else throw this.astErrorOutput(`Unhandled argument type ${x.type}`,h);continue}break;case"HTMLCanvas":case"OffscreenCanvas":case"HTMLImage":case"ImageBitmap":case"ImageData":case"HTMLImageArray":case"HTMLVideo":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":case"Array":case"Input":if(b===v){if(x.type!=="Identifier")throw this.astErrorOutput(`Unhandled argument type ${x.type}`,h);this.triggerImplyArgumentBitRatio(this.name,x.name,f,m);const y=i.sanitizeName(x.name);d.push(`user_${y},user_${y}Size,user_${y}Dim`);continue}break}throw this.astErrorOutput(`Unhandled argument combination of ${v} and ${b} for argument named "${x.name}"`,h)}}return d.push(")"),d}astArrayExpression(h,d){const f=this.getType(h),p=h.elements.length;switch(f){case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":d.push(`mat${p}(`);break;default:d.push(`vec${p}(`)}for(let g=0;g<p;++g){g>0&&d.push(", ");const m=h.elements[g];this.astGeneric(m,d)}return d.push(")"),d}memberExpressionXYZ(h,d,f,p){return f?p.push(this.memberExpressionPropertyMarkup(f),", "):p.push("0, "),d?p.push(this.memberExpressionPropertyMarkup(d),", "):p.push("0, "),p.push(this.memberExpressionPropertyMarkup(h)),p}memberExpressionPropertyMarkup(h){if(!h)throw new Error("Property not set");const d=this.getType(h),f=[];switch(d){case"Number":case"Float":this.castValueToInteger(h,f);break;case"LiteralInteger":this.castLiteralToInteger(h,f);break;default:this.astGeneric(h,f)}return f.join("")}}const l={Array:"sampler2D","Array(2)":"vec2","Array(3)":"vec3","Array(4)":"vec4","Matrix(2)":"mat2","Matrix(3)":"mat3","Matrix(4)":"mat4",Array2D:"sampler2D",Array3D:"sampler2D",Boolean:"bool",Float:"float",Input:"sampler2D",Integer:"int",Number:"float",LiteralInteger:"float",NumberTexture:"sampler2D",MemoryOptimizedNumberTexture:"sampler2D","ArrayTexture(1)":"sampler2D","ArrayTexture(2)":"sampler2D","ArrayTexture(3)":"sampler2D","ArrayTexture(4)":"sampler2D",HTMLVideo:"sampler2D",HTMLCanvas:"sampler2D",OffscreenCanvas:"sampler2D",HTMLImage:"sampler2D",ImageBitmap:"sampler2D",ImageData:"sampler2D",HTMLImageArray:"sampler2DArray"},u={"===":"==","!==":"!="};s.exports={WebGLFunctionNode:a}},{"../../utils":114,"../function-node":10}],39:[function(n,s,r){const{WebGLKernelValueBoolean:i}=n("./kernel-value/boolean"),{WebGLKernelValueFloat:o}=n("./kernel-value/float"),{WebGLKernelValueInteger:a}=n("./kernel-value/integer"),{WebGLKernelValueHTMLImage:l}=n("./kernel-value/html-image"),{WebGLKernelValueDynamicHTMLImage:u}=n("./kernel-value/dynamic-html-image"),{WebGLKernelValueHTMLVideo:c}=n("./kernel-value/html-video"),{WebGLKernelValueDynamicHTMLVideo:h}=n("./kernel-value/dynamic-html-video"),{WebGLKernelValueSingleInput:d}=n("./kernel-value/single-input"),{WebGLKernelValueDynamicSingleInput:f}=n("./kernel-value/dynamic-single-input"),{WebGLKernelValueUnsignedInput:p}=n("./kernel-value/unsigned-input"),{WebGLKernelValueDynamicUnsignedInput:g}=n("./kernel-value/dynamic-unsigned-input"),{WebGLKernelValueMemoryOptimizedNumberTexture:m}=n("./kernel-value/memory-optimized-number-texture"),{WebGLKernelValueDynamicMemoryOptimizedNumberTexture:x}=n("./kernel-value/dynamic-memory-optimized-number-texture"),{WebGLKernelValueNumberTexture:b}=n("./kernel-value/number-texture"),{WebGLKernelValueDynamicNumberTexture:v}=n("./kernel-value/dynamic-number-texture"),{WebGLKernelValueSingleArray:y}=n("./kernel-value/single-array"),{WebGLKernelValueDynamicSingleArray:C}=n("./kernel-value/dynamic-single-array"),{WebGLKernelValueSingleArray1DI:I}=n("./kernel-value/single-array1d-i"),{WebGLKernelValueDynamicSingleArray1DI:$}=n("./kernel-value/dynamic-single-array1d-i"),{WebGLKernelValueSingleArray2DI:T}=n("./kernel-value/single-array2d-i"),{WebGLKernelValueDynamicSingleArray2DI:S}=n("./kernel-value/dynamic-single-array2d-i"),{WebGLKernelValueSingleArray3DI:E}=n("./kernel-value/single-array3d-i"),{WebGLKernelValueDynamicSingleArray3DI:_}=n("./kernel-value/dynamic-single-array3d-i"),{WebGLKernelValueArray2:N}=n("./kernel-value/array2"),{WebGLKernelValueArray3:P}=n("./kernel-value/array3"),{WebGLKernelValueArray4:M}=n("./kernel-value/array4"),{WebGLKernelValueUnsignedArray:z}=n("./kernel-value/unsigned-array"),{WebGLKernelValueDynamicUnsignedArray:A}=n("./kernel-value/dynamic-unsigned-array"),B={unsigned:{dynamic:{Boolean:i,Integer:a,Float:o,Array:A,"Array(2)":N,"Array(3)":P,"Array(4)":M,"Array1D(2)":!1,"Array1D(3)":!1,"Array1D(4)":!1,"Array2D(2)":!1,"Array2D(3)":!1,"Array2D(4)":!1,"Array3D(2)":!1,"Array3D(3)":!1,"Array3D(4)":!1,Input:g,NumberTexture:v,"ArrayTexture(1)":v,"ArrayTexture(2)":v,"ArrayTexture(3)":v,"ArrayTexture(4)":v,MemoryOptimizedNumberTexture:x,HTMLCanvas:u,OffscreenCanvas:u,HTMLImage:u,ImageBitmap:u,ImageData:u,HTMLImageArray:!1,HTMLVideo:h},static:{Boolean:i,Float:o,Integer:a,Array:z,"Array(2)":N,"Array(3)":P,"Array(4)":M,"Array1D(2)":!1,"Array1D(3)":!1,"Array1D(4)":!1,"Array2D(2)":!1,"Array2D(3)":!1,"Array2D(4)":!1,"Array3D(2)":!1,"Array3D(3)":!1,"Array3D(4)":!1,Input:p,NumberTexture:b,"ArrayTexture(1)":b,"ArrayTexture(2)":b,"ArrayTexture(3)":b,"ArrayTexture(4)":b,MemoryOptimizedNumberTexture:m,HTMLCanvas:l,OffscreenCanvas:l,HTMLImage:l,ImageBitmap:l,ImageData:l,HTMLImageArray:!1,HTMLVideo:c}},single:{dynamic:{Boolean:i,Integer:a,Float:o,Array:C,"Array(2)":N,"Array(3)":P,"Array(4)":M,"Array1D(2)":$,"Array1D(3)":$,"Array1D(4)":$,"Array2D(2)":S,"Array2D(3)":S,"Array2D(4)":S,"Array3D(2)":_,"Array3D(3)":_,"Array3D(4)":_,Input:f,NumberTexture:v,"ArrayTexture(1)":v,"ArrayTexture(2)":v,"ArrayTexture(3)":v,"ArrayTexture(4)":v,MemoryOptimizedNumberTexture:x,HTMLCanvas:u,OffscreenCanvas:u,HTMLImage:u,ImageBitmap:u,ImageData:u,HTMLImageArray:!1,HTMLVideo:h},static:{Boolean:i,Float:o,Integer:a,Array:y,"Array(2)":N,"Array(3)":P,"Array(4)":M,"Array1D(2)":I,"Array1D(3)":I,"Array1D(4)":I,"Array2D(2)":T,"Array2D(3)":T,"Array2D(4)":T,"Array3D(2)":E,"Array3D(3)":E,"Array3D(4)":E,Input:d,NumberTexture:b,"ArrayTexture(1)":b,"ArrayTexture(2)":b,"ArrayTexture(3)":b,"ArrayTexture(4)":b,MemoryOptimizedNumberTexture:m,HTMLCanvas:l,OffscreenCanvas:l,HTMLImage:l,ImageBitmap:l,ImageData:l,HTMLImageArray:!1,HTMLVideo:c}}};function L(U,j,Z,J){if(!U)throw new Error("type missing");if(!j)throw new Error("dynamic missing");if(!Z)throw new Error("precision missing");J.type&&(U=J.type);const se=B[Z][j];if(se[U]===!1)return null;if(se[U]===void 0)throw new Error(`Could not find a KernelValue for ${U}`);return se[U]}s.exports={lookupKernelValueType:L,kernelValueMaps:B}},{"./kernel-value/array2":41,"./kernel-value/array3":42,"./kernel-value/array4":43,"./kernel-value/boolean":44,"./kernel-value/dynamic-html-image":45,"./kernel-value/dynamic-html-video":46,"./kernel-value/dynamic-memory-optimized-number-texture":47,"./kernel-value/dynamic-number-texture":48,"./kernel-value/dynamic-single-array":49,"./kernel-value/dynamic-single-array1d-i":50,"./kernel-value/dynamic-single-array2d-i":51,"./kernel-value/dynamic-single-array3d-i":52,"./kernel-value/dynamic-single-input":53,"./kernel-value/dynamic-unsigned-array":54,"./kernel-value/dynamic-unsigned-input":55,"./kernel-value/float":56,"./kernel-value/html-image":57,"./kernel-value/html-video":58,"./kernel-value/integer":60,"./kernel-value/memory-optimized-number-texture":61,"./kernel-value/number-texture":62,"./kernel-value/single-array":63,"./kernel-value/single-array1d-i":64,"./kernel-value/single-array2d-i":65,"./kernel-value/single-array3d-i":66,"./kernel-value/single-input":67,"./kernel-value/unsigned-array":68,"./kernel-value/unsigned-input":69}],40:[function(n,s,r){const{WebGLKernelValue:i}=n("./index"),{Input:o}=n("../../../input");class a extends i{checkSize(u,c){if(!this.kernel.validate)return;const{maxTextureSize:h}=this.kernel.constructor.features;if(u>h||c>h)throw u>c?new Error(`Argument texture width of ${u} larger than maximum size of ${h} for your GPU`):u<c?new Error(`Argument texture height of ${c} larger than maximum size of ${h} for your GPU`):new Error(`Argument texture height and width of ${c} larger than maximum size of ${h} for your GPU`)}setup(){this.requestTexture(),this.setupTexture(),this.defineTexture()}requestTexture(){this.texture=this.onRequestTexture()}defineTexture(){const{context:u}=this;u.activeTexture(this.contextHandle),u.bindTexture(u.TEXTURE_2D,this.texture),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_S,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_T,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MIN_FILTER,u.NEAREST),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MAG_FILTER,u.NEAREST)}setupTexture(){this.contextHandle=this.onRequestContextHandle(),this.index=this.onRequestIndex(),this.dimensionsId=this.id+"Dim",this.sizeId=this.id+"Size"}getBitRatio(u){if(Array.isArray(u[0]))return this.getBitRatio(u[0]);if(u.constructor===o)return this.getBitRatio(u.value);switch(u.constructor){case Uint8ClampedArray:case Uint8Array:case Int8Array:return 1;case Uint16Array:case Int16Array:return 2;case Float32Array:case Int32Array:default:return 4}}destroy(){this.prevArg&&this.prevArg.delete(),this.context.deleteTexture(this.texture)}}s.exports={WebGLKernelArray:a}},{"../../../input":110,"./index":59}],41:[function(n,s,r){const{WebGLKernelValue:i}=n("./index");class o extends i{constructor(l,u){super(l,u),this.uploadValue=l}getSource(l){return this.origin==="constants"?`const vec2 ${this.id} = vec2(${l[0]},${l[1]});
`:`uniform vec2 ${this.id};
`}getStringValueHandler(){return this.origin==="constants"?"":`const uploadValue_${this.name} = ${this.varName};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform2fv(this.id,this.uploadValue=l)}}s.exports={WebGLKernelValueArray2:o}},{"./index":59}],42:[function(n,s,r){const{WebGLKernelValue:i}=n("./index");class o extends i{constructor(l,u){super(l,u),this.uploadValue=l}getSource(l){return this.origin==="constants"?`const vec3 ${this.id} = vec3(${l[0]},${l[1]},${l[2]});
`:`uniform vec3 ${this.id};
`}getStringValueHandler(){return this.origin==="constants"?"":`const uploadValue_${this.name} = ${this.varName};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform3fv(this.id,this.uploadValue=l)}}s.exports={WebGLKernelValueArray3:o}},{"./index":59}],43:[function(n,s,r){const{WebGLKernelValue:i}=n("./index");class o extends i{constructor(l,u){super(l,u),this.uploadValue=l}getSource(l){return this.origin==="constants"?`const vec4 ${this.id} = vec4(${l[0]},${l[1]},${l[2]},${l[3]});
`:`uniform vec4 ${this.id};
`}getStringValueHandler(){return this.origin==="constants"?"":`const uploadValue_${this.name} = ${this.varName};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform4fv(this.id,this.uploadValue=l)}}s.exports={WebGLKernelValueArray4:o}},{"./index":59}],44:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValue:o}=n("./index");class a extends o{constructor(u,c){super(u,c),this.uploadValue=u}getSource(u){return this.origin==="constants"?`const bool ${this.id} = ${u};
`:`uniform bool ${this.id};
`}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}updateValue(u){this.origin!=="constants"&&this.kernel.setUniform1i(this.id,this.uploadValue=u)}}s.exports={WebGLKernelValueBoolean:a}},{"../../../utils":114,"./index":59}],45:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueHTMLImage:o}=n("./html-image");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(u){const{width:c,height:h}=u;this.checkSize(c,h),this.dimensions=[c,h,1],this.textureSize=[c,h],this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGLKernelValueDynamicHTMLImage:a}},{"../../../utils":114,"./html-image":57}],46:[function(n,s,r){const{WebGLKernelValueDynamicHTMLImage:i}=n("./dynamic-html-image");class o extends i{}s.exports={WebGLKernelValueDynamicHTMLVideo:o}},{"./dynamic-html-image":45}],47:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueMemoryOptimizedNumberTexture:o}=n("./memory-optimized-number-texture");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(u){this.dimensions=u.dimensions,this.checkSize(u.size[0],u.size[1]),this.textureSize=u.size,this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGLKernelValueDynamicMemoryOptimizedNumberTexture:a}},{"../../../utils":114,"./memory-optimized-number-texture":61}],48:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueNumberTexture:o}=n("./number-texture");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(u){this.dimensions=u.dimensions,this.checkSize(u.size[0],u.size[1]),this.textureSize=u.size,this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGLKernelValueDynamicNumberTexture:a}},{"../../../utils":114,"./number-texture":62}],49:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueSingleArray:o}=n("./single-array");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(u){this.dimensions=i.getDimensions(u,!0),this.textureSize=i.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGLKernelValueDynamicSingleArray:a}},{"../../../utils":114,"./single-array":63}],50:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueSingleArray1DI:o}=n("./single-array1d-i");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(u){this.setShape(u),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGLKernelValueDynamicSingleArray1DI:a}},{"../../../utils":114,"./single-array1d-i":64}],51:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueSingleArray2DI:o}=n("./single-array2d-i");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(u){this.setShape(u),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGLKernelValueDynamicSingleArray2DI:a}},{"../../../utils":114,"./single-array2d-i":65}],52:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueSingleArray3DI:o}=n("./single-array3d-i");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(u){this.setShape(u),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGLKernelValueDynamicSingleArray3DI:a}},{"../../../utils":114,"./single-array3d-i":66}],53:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueSingleInput:o}=n("./single-input");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(u){let[c,h,d]=u.size;this.dimensions=new Int32Array([c||1,h||1,d||1]),this.textureSize=i.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGLKernelValueDynamicSingleInput:a}},{"../../../utils":114,"./single-input":67}],54:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueUnsignedArray:o}=n("./unsigned-array");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(u){this.dimensions=i.getDimensions(u,!0),this.textureSize=i.getMemoryOptimizedPackedTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*(4/this.bitRatio),this.checkSize(this.textureSize[0],this.textureSize[1]);const c=this.getTransferArrayType(u);this.preUploadValue=new c(this.uploadArrayLength),this.uploadValue=new Uint8Array(this.preUploadValue.buffer),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGLKernelValueDynamicUnsignedArray:a}},{"../../../utils":114,"./unsigned-array":68}],55:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueUnsignedInput:o}=n("./unsigned-input");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(u){let[c,h,d]=u.size;this.dimensions=new Int32Array([c||1,h||1,d||1]),this.textureSize=i.getMemoryOptimizedPackedTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*(4/this.bitRatio),this.checkSize(this.textureSize[0],this.textureSize[1]);const f=this.getTransferArrayType(u.value);this.preUploadValue=new f(this.uploadArrayLength),this.uploadValue=new Uint8Array(this.preUploadValue.buffer),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGLKernelValueDynamicUnsignedInput:a}},{"../../../utils":114,"./unsigned-input":69}],56:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValue:o}=n("./index");class a extends o{constructor(u,c){super(u,c),this.uploadValue=u}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}getSource(u){return this.origin==="constants"?Number.isInteger(u)?`const float ${this.id} = ${u}.0;
`:`const float ${this.id} = ${u};
`:`uniform float ${this.id};
`}updateValue(u){this.origin!=="constants"&&this.kernel.setUniform1f(this.id,this.uploadValue=u)}}s.exports={WebGLKernelValueFloat:a}},{"../../../utils":114,"./index":59}],57:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelArray:o}=n("./array");class a extends o{constructor(u,c){super(u,c);const{width:h,height:d}=u;this.checkSize(h,d),this.dimensions=[h,d,1],this.textureSize=[h,d],this.uploadValue=u}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(u){if(u.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(u.constructor);return}const{context:c}=this;c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!0),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,c.RGBA,c.UNSIGNED_BYTE,this.uploadValue=u),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueHTMLImage:a}},{"../../../utils":114,"./array":40}],58:[function(n,s,r){const{WebGLKernelValueHTMLImage:i}=n("./html-image");class o extends i{}s.exports={WebGLKernelValueHTMLVideo:o}},{"./html-image":57}],59:[function(n,s,r){const{utils:i}=n("../../../utils"),{KernelValue:o}=n("../../kernel-value");class a extends o{constructor(u,c){super(u,c),this.dimensionsId=null,this.sizeId=null,this.initialValueConstructor=u.constructor,this.onRequestTexture=c.onRequestTexture,this.onRequestIndex=c.onRequestIndex,this.uploadValue=null,this.textureSize=null,this.bitRatio=null,this.prevArg=null}get id(){return`${this.origin}_${i.sanitizeName(this.name)}`}setup(){}getTransferArrayType(u){if(Array.isArray(u[0]))return this.getTransferArrayType(u[0]);switch(u.constructor){case Array:case Int32Array:case Int16Array:case Int8Array:return Float32Array;case Uint8ClampedArray:case Uint8Array:case Uint16Array:case Uint32Array:case Float32Array:case Float64Array:return u.constructor}return console.warn("Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros"),u.constructor}getStringValueHandler(){throw new Error(`"getStringValueHandler" not implemented on ${this.constructor.name}`)}getVariablePrecisionString(){return this.kernel.getVariablePrecisionString(this.textureSize||void 0,this.tactic||void 0)}destroy(){}}s.exports={WebGLKernelValue:a}},{"../../../utils":114,"../../kernel-value":35}],60:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValue:o}=n("./index");class a extends o{constructor(u,c){super(u,c),this.uploadValue=u}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}getSource(u){return this.origin==="constants"?`const int ${this.id} = ${parseInt(u)};
`:`uniform int ${this.id};
`}updateValue(u){this.origin!=="constants"&&this.kernel.setUniform1i(this.id,this.uploadValue=u)}}s.exports={WebGLKernelValueInteger:a}},{"../../../utils":114,"./index":59}],61:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelArray:o}=n("./array"),a="Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()";class l extends o{constructor(c,h){super(c,h);const[d,f]=c.size;this.checkSize(d,f),this.dimensions=c.dimensions,this.textureSize=c.size,this.uploadValue=c.texture,this.forceUploadEachRun=!0}setup(){this.setupTexture()}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName}.texture;
`}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(c){if(c.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(c.constructor);return}if(this.checkContext&&c.context!==this.context)throw new Error(`Value ${this.name} (${this.type}) must be from same context`);const{kernel:h,context:d}=this;if(h.pipeline)if(h.immutable)h.updateTextureArgumentRefs(this,c);else{if(h.texture&&h.texture.texture===c.texture)throw new Error(a);if(h.mappedTextures){const{mappedTextures:f}=h;for(let p=0;p<f.length;p++)if(f[p].texture===c.texture)throw new Error(a)}}d.activeTexture(this.contextHandle),d.bindTexture(d.TEXTURE_2D,this.uploadValue=c.texture),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueMemoryOptimizedNumberTexture:l,sameError:a}},{"../../../utils":114,"./array":40}],62:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelArray:o}=n("./array"),{sameError:a}=n("./memory-optimized-number-texture");class l extends o{constructor(c,h){super(c,h);const[d,f]=c.size;this.checkSize(d,f);const{size:p,dimensions:g}=c;this.bitRatio=this.getBitRatio(c),this.dimensions=g,this.textureSize=p,this.uploadValue=c.texture,this.forceUploadEachRun=!0}setup(){this.setupTexture()}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName}.texture;
`}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(c){if(c.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(c.constructor);return}if(this.checkContext&&c.context!==this.context)throw new Error(`Value ${this.name} (${this.type}) must be from same context`);const{kernel:h,context:d}=this;if(h.pipeline)if(h.immutable)h.updateTextureArgumentRefs(this,c);else{if(h.texture&&h.texture.texture===c.texture)throw new Error(a);if(h.mappedTextures){const{mappedTextures:f}=h;for(let p=0;p<f.length;p++)if(f[p].texture===c.texture)throw new Error(a)}}d.activeTexture(this.contextHandle),d.bindTexture(d.TEXTURE_2D,this.uploadValue=c.texture),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueNumberTexture:l}},{"../../../utils":114,"./array":40,"./memory-optimized-number-texture":61}],63:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelArray:o}=n("./array");class a extends o{constructor(u,c){super(u,c),this.bitRatio=4,this.dimensions=i.getDimensions(u,!0),this.textureSize=i.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}, uploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(u){if(u.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(u.constructor);return}const{context:c}=this;i.flattenTo(u,this.uploadValue),c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,this.textureSize[0],this.textureSize[1],0,c.RGBA,c.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueSingleArray:a}},{"../../../utils":114,"./array":40}],64:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelArray:o}=n("./array");class a extends o{constructor(u,c){super(u,c),this.bitRatio=4,this.setShape(u)}setShape(u){const c=i.getDimensions(u,!0);this.textureSize=i.getMemoryOptimizedFloatTextureSize(c,this.bitRatio),this.dimensions=new Int32Array([c[1],1,1]),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}, uploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(u){if(u.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(u.constructor);return}const{context:c}=this;i.flatten2dArrayTo(u,this.uploadValue),c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,this.textureSize[0],this.textureSize[1],0,c.RGBA,c.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueSingleArray1DI:a}},{"../../../utils":114,"./array":40}],65:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelArray:o}=n("./array");class a extends o{constructor(u,c){super(u,c),this.bitRatio=4,this.setShape(u)}setShape(u){const c=i.getDimensions(u,!0);this.textureSize=i.getMemoryOptimizedFloatTextureSize(c,this.bitRatio),this.dimensions=new Int32Array([c[1],c[2],1]),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}, uploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(u){if(u.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(u.constructor);return}const{context:c}=this;i.flatten3dArrayTo(u,this.uploadValue),c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,this.textureSize[0],this.textureSize[1],0,c.RGBA,c.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueSingleArray2DI:a}},{"../../../utils":114,"./array":40}],66:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelArray:o}=n("./array");class a extends o{constructor(u,c){super(u,c),this.bitRatio=4,this.setShape(u)}setShape(u){const c=i.getDimensions(u,!0);this.textureSize=i.getMemoryOptimizedFloatTextureSize(c,this.bitRatio),this.dimensions=new Int32Array([c[1],c[2],c[3]]),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}, uploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(u){if(u.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(u.constructor);return}const{context:c}=this;i.flatten4dArrayTo(u,this.uploadValue),c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,this.textureSize[0],this.textureSize[1],0,c.RGBA,c.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueSingleArray3DI:a}},{"../../../utils":114,"./array":40}],67:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelArray:o}=n("./array");class a extends o{constructor(u,c){super(u,c),this.bitRatio=4;let[h,d,f]=u.size;this.dimensions=new Int32Array([h||1,d||1,f||1]),this.textureSize=i.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}.value, uploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(u){if(u.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(u.constructor);return}const{context:c}=this;i.flattenTo(u.value,this.uploadValue),c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,this.textureSize[0],this.textureSize[1],0,c.RGBA,c.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueSingleInput:a}},{"../../../utils":114,"./array":40}],68:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelArray:o}=n("./array");class a extends o{constructor(u,c){super(u,c),this.bitRatio=this.getBitRatio(u),this.dimensions=i.getDimensions(u,!0),this.textureSize=i.getMemoryOptimizedPackedTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*(4/this.bitRatio),this.checkSize(this.textureSize[0],this.textureSize[1]),this.TranserArrayType=this.getTransferArrayType(u),this.preUploadValue=new this.TranserArrayType(this.uploadArrayLength),this.uploadValue=new Uint8Array(this.preUploadValue.buffer)}getStringValueHandler(){return i.linesToString([`const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,`const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,`flattenTo(${this.varName}, preUploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(u){if(u.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(u.constructor);return}const{context:c}=this;i.flattenTo(u,this.preUploadValue),c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,this.textureSize[0],this.textureSize[1],0,c.RGBA,c.UNSIGNED_BYTE,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueUnsignedArray:a}},{"../../../utils":114,"./array":40}],69:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelArray:o}=n("./array");class a extends o{constructor(u,c){super(u,c),this.bitRatio=this.getBitRatio(u);const[h,d,f]=u.size;this.dimensions=new Int32Array([h||1,d||1,f||1]),this.textureSize=i.getMemoryOptimizedPackedTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*(4/this.bitRatio),this.checkSize(this.textureSize[0],this.textureSize[1]),this.TranserArrayType=this.getTransferArrayType(u.value),this.preUploadValue=new this.TranserArrayType(this.uploadArrayLength),this.uploadValue=new Uint8Array(this.preUploadValue.buffer)}getStringValueHandler(){return i.linesToString([`const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,`const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,`flattenTo(${this.varName}.value, preUploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(u){if(u.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(value.constructor);return}const{context:c}=this;i.flattenTo(u.value,this.preUploadValue),c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,this.textureSize[0],this.textureSize[1],0,c.RGBA,c.UNSIGNED_BYTE,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueUnsignedInput:a}},{"../../../utils":114,"./array":40}],70:[function(n,s,r){const{GLKernel:i}=n("../gl/kernel"),{FunctionBuilder:o}=n("../function-builder"),{WebGLFunctionNode:a}=n("./function-node"),{utils:l}=n("../../utils"),u=n("../../plugins/math-random-uniformly-distributed"),{fragmentShader:c}=n("./fragment-shader"),{vertexShader:h}=n("./vertex-shader"),{glKernelString:d}=n("../gl/kernel-string"),{lookupKernelValueType:f}=n("./kernel-value-maps");let p=null,g=null,m=null,x=null,b=null;const v=[u],y=[],C={};class I extends i{static get isSupported(){return p!==null||(this.setupFeatureChecks(),p=this.isContextMatch(m)),p}static setupFeatureChecks(){typeof document<"u"?g=document.createElement("canvas"):typeof OffscreenCanvas<"u"&&(g=new OffscreenCanvas(0,0)),g&&(m=g.getContext("webgl")||g.getContext("experimental-webgl"),!(!m||!m.getExtension)&&(x={OES_texture_float:m.getExtension("OES_texture_float"),OES_texture_float_linear:m.getExtension("OES_texture_float_linear"),OES_element_index_uint:m.getExtension("OES_element_index_uint"),WEBGL_draw_buffers:m.getExtension("WEBGL_draw_buffers")},b=this.getFeatures()))}static isContextMatch(T){return typeof WebGLRenderingContext<"u"?T instanceof WebGLRenderingContext:!1}static getIsTextureFloat(){return!!x.OES_texture_float}static getIsDrawBuffers(){return!!x.WEBGL_draw_buffers}static getChannelCount(){return x.WEBGL_draw_buffers?m.getParameter(x.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL):1}static getMaxTextureSize(){return m.getParameter(m.MAX_TEXTURE_SIZE)}static lookupKernelValueType(T,S,E,_){return f(T,S,E,_)}static get testCanvas(){return g}static get testContext(){return m}static get features(){return b}static get fragmentShader(){return c}static get vertexShader(){return h}constructor(T,S){super(T,S),this.program=null,this.pipeline=S.pipeline,this.endianness=l.systemEndianness(),this.extensions={},this.argumentTextureCount=0,this.constantTextureCount=0,this.fragShader=null,this.vertShader=null,this.drawBuffersMap=null,this.maxTexSize=null,this.onRequestSwitchKernel=null,this.texture=null,this.mappedTextures=null,this.mergeSettings(T.settings||S),this.threadDim=null,this.framebuffer=null,this.buffer=null,this.textureCache=[],this.programUniformLocationCache={},this.uniform1fCache={},this.uniform1iCache={},this.uniform2fCache={},this.uniform2fvCache={},this.uniform2ivCache={},this.uniform3fvCache={},this.uniform3ivCache={},this.uniform4fvCache={},this.uniform4ivCache={}}initCanvas(){if(typeof document<"u"){const T=document.createElement("canvas");return T.width=2,T.height=2,T}else if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(0,0)}initContext(){const T={alpha:!1,depth:!1,antialias:!1};return this.canvas.getContext("webgl",T)||this.canvas.getContext("experimental-webgl",T)}initPlugins(T){const S=[],{source:E}=this;if(typeof E=="string")for(let _=0;_<v.length;_++){const N=v[_];E.match(N.functionMatch)&&S.push(N)}else if(typeof E=="object"&&T.pluginNames)for(let _=0;_<v.length;_++){const N=v[_];T.pluginNames.some(M=>M===N.name)&&S.push(N)}return S}initExtensions(){this.extensions={OES_texture_float:this.context.getExtension("OES_texture_float"),OES_texture_float_linear:this.context.getExtension("OES_texture_float_linear"),OES_element_index_uint:this.context.getExtension("OES_element_index_uint"),WEBGL_draw_buffers:this.context.getExtension("WEBGL_draw_buffers"),WEBGL_color_buffer_float:this.context.getExtension("WEBGL_color_buffer_float")}}validateSettings(T){if(!this.validate){this.texSize=l.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},this.output);return}const{features:S}=this.constructor;if(this.optimizeFloatMemory===!0&&!S.isTextureFloat)throw new Error("Float textures are not supported");if(this.precision==="single"&&!S.isFloatRead)throw new Error("Single precision not supported");if(!this.graphical&&this.precision===null&&S.isTextureFloat&&(this.precision=S.isFloatRead?"single":"unsigned"),this.subKernels&&this.subKernels.length>0&&!this.extensions.WEBGL_draw_buffers)throw new Error("could not instantiate draw buffers extension");if(this.fixIntegerDivisionAccuracy===null?this.fixIntegerDivisionAccuracy=!S.isIntegerDivisionAccurate:this.fixIntegerDivisionAccuracy&&S.isIntegerDivisionAccurate&&(this.fixIntegerDivisionAccuracy=!1),this.checkOutput(),!this.output||this.output.length===0){if(T.length!==1)throw new Error("Auto output only supported for kernels with only one input");const E=l.getVariableType(T[0],this.strictIntegers);switch(E){case"Array":this.output=l.getDimensions(E);break;case"NumberTexture":case"MemoryOptimizedNumberTexture":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":this.output=T[0].output;break;default:throw new Error("Auto output not supported for input type: "+E)}}if(this.graphical){if(this.output.length!==2)throw new Error("Output must have 2 dimensions on graphical mode");this.precision==="precision"&&(this.precision="unsigned",console.warn("Cannot use graphical mode and single precision at the same time")),this.texSize=l.clone(this.output);return}else this.precision===null&&S.isTextureFloat&&(this.precision="single");this.texSize=l.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},this.output),this.checkTextureSize()}updateMaxTexSize(){const{texSize:T,canvas:S}=this;if(this.maxTexSize===null){let E=y.indexOf(S);E===-1&&(E=y.length,y.push(S),C[E]=[T[0],T[1]]),this.maxTexSize=C[E]}this.maxTexSize[0]<T[0]&&(this.maxTexSize[0]=T[0]),this.maxTexSize[1]<T[1]&&(this.maxTexSize[1]=T[1])}setupArguments(T){this.kernelArguments=[],this.argumentTextureCount=0;const S=this.argumentTypes===null;if(S&&(this.argumentTypes=[]),this.argumentSizes=[],this.argumentBitRatios=[],T.length<this.argumentNames.length)throw new Error("not enough arguments for kernel");if(T.length>this.argumentNames.length)throw new Error("too many arguments for kernel");const{context:E}=this;let _=0;const N=()=>this.createTexture(),P=()=>this.constantTextureCount+_++,M=A=>{this.switchKernels({type:"argumentMismatch",needed:A})},z=()=>E.TEXTURE0+this.constantTextureCount+this.argumentTextureCount++;for(let A=0;A<T.length;A++){const B=T[A],L=this.argumentNames[A];let U;S?(U=l.getVariableType(B,this.strictIntegers),this.argumentTypes.push(U)):U=this.argumentTypes[A];const j=this.constructor.lookupKernelValueType(U,this.dynamicArguments?"dynamic":"static",this.precision,T[A]);if(j===null)return this.requestFallback(T);const Z=new j(B,{name:L,type:U,tactic:this.tactic,origin:"user",context:E,checkContext:this.checkContext,kernel:this,strictIntegers:this.strictIntegers,onRequestTexture:N,onRequestIndex:P,onUpdateValueMismatch:M,onRequestContextHandle:z});this.kernelArguments.push(Z),Z.setup(),this.argumentSizes.push(Z.textureSize),this.argumentBitRatios[A]=Z.bitRatio}}createTexture(){const T=this.context.createTexture();return this.textureCache.push(T),T}setupConstants(T){const{context:S}=this;this.kernelConstants=[],this.forceUploadKernelConstants=[];let E=this.constantTypes===null;E&&(this.constantTypes={}),this.constantBitRatios={};let _=0;for(const N in this.constants){const P=this.constants[N];let M;E?(M=l.getVariableType(P,this.strictIntegers),this.constantTypes[N]=M):M=this.constantTypes[N];const z=this.constructor.lookupKernelValueType(M,"static",this.precision,P);if(z===null)return this.requestFallback(T);const A=new z(P,{name:N,type:M,tactic:this.tactic,origin:"constants",context:this.context,checkContext:this.checkContext,kernel:this,strictIntegers:this.strictIntegers,onRequestTexture:()=>this.createTexture(),onRequestIndex:()=>_++,onRequestContextHandle:()=>S.TEXTURE0+this.constantTextureCount++});this.constantBitRatios[N]=A.bitRatio,this.kernelConstants.push(A),A.setup(),A.forceUploadEachRun&&this.forceUploadKernelConstants.push(A)}}build(){if(this.built||(this.initExtensions(),this.validateSettings(arguments),this.setupConstants(arguments),this.fallbackRequested)||(this.setupArguments(arguments),this.fallbackRequested))return;this.updateMaxTexSize(),this.translateSource();const T=this.pickRenderStrategy(arguments);if(T)return T;const{texSize:S,context:E,canvas:_}=this;E.enable(E.SCISSOR_TEST),this.pipeline&&this.precision==="single"?(E.viewport(0,0,this.maxTexSize[0],this.maxTexSize[1]),_.width=this.maxTexSize[0],_.height=this.maxTexSize[1]):(E.viewport(0,0,this.maxTexSize[0],this.maxTexSize[1]),_.width=this.maxTexSize[0],_.height=this.maxTexSize[1]);const N=this.threadDim=Array.from(this.output);for(;N.length<3;)N.push(1);const P=this.getVertexShader(arguments),M=E.createShader(E.VERTEX_SHADER);E.shaderSource(M,P),E.compileShader(M),this.vertShader=M;const z=this.getFragmentShader(arguments),A=E.createShader(E.FRAGMENT_SHADER);if(E.shaderSource(A,z),E.compileShader(A),this.fragShader=A,this.debug&&(console.log("GLSL Shader Output:"),console.log(z)),!E.getShaderParameter(M,E.COMPILE_STATUS))throw new Error("Error compiling vertex shader: "+E.getShaderInfoLog(M));if(!E.getShaderParameter(A,E.COMPILE_STATUS))throw new Error("Error compiling fragment shader: "+E.getShaderInfoLog(A));const B=this.program=E.createProgram();E.attachShader(B,M),E.attachShader(B,A),E.linkProgram(B),this.framebuffer=E.createFramebuffer(),this.framebuffer.width=S[0],this.framebuffer.height=S[1],this.rawValueFramebuffers={};const L=new Float32Array([-1,-1,1,-1,-1,1,1,1]),U=new Float32Array([0,0,1,0,0,1,1,1]),j=L.byteLength;let Z=this.buffer;Z?E.bindBuffer(E.ARRAY_BUFFER,Z):(Z=this.buffer=E.createBuffer(),E.bindBuffer(E.ARRAY_BUFFER,Z),E.bufferData(E.ARRAY_BUFFER,L.byteLength+U.byteLength,E.STATIC_DRAW)),E.bufferSubData(E.ARRAY_BUFFER,0,L),E.bufferSubData(E.ARRAY_BUFFER,j,U);const J=E.getAttribLocation(this.program,"aPos");E.enableVertexAttribArray(J),E.vertexAttribPointer(J,2,E.FLOAT,!1,0,0);const se=E.getAttribLocation(this.program,"aTexCoord");E.enableVertexAttribArray(se),E.vertexAttribPointer(se,2,E.FLOAT,!1,0,j),E.bindFramebuffer(E.FRAMEBUFFER,this.framebuffer);let fe=0;E.useProgram(this.program);for(let he in this.constants)this.kernelConstants[fe++].updateValue(this.constants[he]);this._setupOutputTexture(),this.subKernels!==null&&this.subKernels.length>0&&(this._mappedTextureSwitched={},this._setupSubOutputTextures()),this.buildSignature(arguments),this.built=!0}translateSource(){const T=o.fromKernel(this,a,{fixIntegerDivisionAccuracy:this.fixIntegerDivisionAccuracy});this.translatedSource=T.getPrototypeString("kernel"),this.setupReturnTypes(T)}setupReturnTypes(T){if(!this.graphical&&!this.returnType&&(this.returnType=T.getKernelResultType()),this.subKernels&&this.subKernels.length>0)for(let S=0;S<this.subKernels.length;S++){const E=this.subKernels[S];E.returnType||(E.returnType=T.getSubKernelResultType(S))}}run(){const{kernelArguments:T,texSize:S,forceUploadKernelConstants:E,context:_}=this;_.useProgram(this.program),_.scissor(0,0,S[0],S[1]),this.dynamicOutput&&(this.setUniform3iv("uOutputDim",new Int32Array(this.threadDim)),this.setUniform2iv("uTexSize",S)),this.setUniform2f("ratio",S[0]/this.maxTexSize[0],S[1]/this.maxTexSize[1]);for(let N=0;N<E.length;N++){const P=E[N];if(P.updateValue(this.constants[P.name]),this.switchingKernels)return}for(let N=0;N<T.length;N++)if(T[N].updateValue(arguments[N]),this.switchingKernels)return;if(this.plugins)for(let N=0;N<this.plugins.length;N++){const P=this.plugins[N];P.onBeforeRun&&P.onBeforeRun(this)}if(this.graphical){if(this.pipeline)return _.bindRenderbuffer(_.RENDERBUFFER,null),_.bindFramebuffer(_.FRAMEBUFFER,this.framebuffer),this.immutable&&this._replaceOutputTexture(),_.drawArrays(_.TRIANGLE_STRIP,0,4),this.immutable?this.texture.clone():this.texture;_.bindRenderbuffer(_.RENDERBUFFER,null),_.bindFramebuffer(_.FRAMEBUFFER,null),_.drawArrays(_.TRIANGLE_STRIP,0,4);return}_.bindFramebuffer(_.FRAMEBUFFER,this.framebuffer),this.immutable&&this._replaceOutputTexture(),this.subKernels!==null&&(this.immutable&&this._replaceSubOutputTextures(),this.drawBuffers()),_.drawArrays(_.TRIANGLE_STRIP,0,4)}drawBuffers(){this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap)}getInternalFormat(){return this.context.RGBA}getTextureFormat(){const{context:T}=this;switch(this.getInternalFormat()){case T.RGBA:return T.RGBA;default:throw new Error("Unknown internal format")}}_replaceOutputTexture(){if(this.texture.beforeMutate()||this._textureSwitched){const T=this.context;T.framebufferTexture2D(T.FRAMEBUFFER,T.COLOR_ATTACHMENT0,T.TEXTURE_2D,this.texture.texture,0),this._textureSwitched=!1}}_setupOutputTexture(){const T=this.context,S=this.texSize;if(this.texture){T.framebufferTexture2D(T.FRAMEBUFFER,T.COLOR_ATTACHMENT0,T.TEXTURE_2D,this.texture.texture,0);return}const E=this.createTexture();T.activeTexture(T.TEXTURE0+this.constantTextureCount+this.argumentTextureCount),T.bindTexture(T.TEXTURE_2D,E),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_WRAP_S,T.CLAMP_TO_EDGE),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_WRAP_T,T.CLAMP_TO_EDGE),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MIN_FILTER,T.NEAREST),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MAG_FILTER,T.NEAREST);const _=this.getInternalFormat();this.precision==="single"?T.texImage2D(T.TEXTURE_2D,0,_,S[0],S[1],0,T.RGBA,T.FLOAT,null):T.texImage2D(T.TEXTURE_2D,0,_,S[0],S[1],0,_,T.UNSIGNED_BYTE,null),T.framebufferTexture2D(T.FRAMEBUFFER,T.COLOR_ATTACHMENT0,T.TEXTURE_2D,E,0),this.texture=new this.TextureConstructor({texture:E,size:S,dimensions:this.threadDim,output:this.output,context:this.context,internalFormat:this.getInternalFormat(),textureFormat:this.getTextureFormat(),kernel:this})}_replaceSubOutputTextures(){const T=this.context;for(let S=0;S<this.mappedTextures.length;S++){const E=this.mappedTextures[S];(E.beforeMutate()||this._mappedTextureSwitched[S])&&(T.framebufferTexture2D(T.FRAMEBUFFER,T.COLOR_ATTACHMENT0+S+1,T.TEXTURE_2D,E.texture,0),this._mappedTextureSwitched[S]=!1)}}_setupSubOutputTextures(){const T=this.context;if(this.mappedTextures){for(let E=0;E<this.subKernels.length;E++)T.framebufferTexture2D(T.FRAMEBUFFER,T.COLOR_ATTACHMENT0+E+1,T.TEXTURE_2D,this.mappedTextures[E].texture,0);return}const S=this.texSize;this.drawBuffersMap=[T.COLOR_ATTACHMENT0],this.mappedTextures=[];for(let E=0;E<this.subKernels.length;E++){const _=this.createTexture();this.drawBuffersMap.push(T.COLOR_ATTACHMENT0+E+1),T.activeTexture(T.TEXTURE0+this.constantTextureCount+this.argumentTextureCount+E),T.bindTexture(T.TEXTURE_2D,_),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_WRAP_S,T.CLAMP_TO_EDGE),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_WRAP_T,T.CLAMP_TO_EDGE),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MIN_FILTER,T.NEAREST),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MAG_FILTER,T.NEAREST),this.precision==="single"?T.texImage2D(T.TEXTURE_2D,0,T.RGBA,S[0],S[1],0,T.RGBA,T.FLOAT,null):T.texImage2D(T.TEXTURE_2D,0,T.RGBA,S[0],S[1],0,T.RGBA,T.UNSIGNED_BYTE,null),T.framebufferTexture2D(T.FRAMEBUFFER,T.COLOR_ATTACHMENT0+E+1,T.TEXTURE_2D,_,0),this.mappedTextures.push(new this.TextureConstructor({texture:_,size:S,dimensions:this.threadDim,output:this.output,context:this.context,internalFormat:this.getInternalFormat(),textureFormat:this.getTextureFormat(),kernel:this}))}}setUniform1f(T,S){if(this.uniform1fCache.hasOwnProperty(T)){const _=this.uniform1fCache[T];if(S===_)return}this.uniform1fCache[T]=S;const E=this.getUniformLocation(T);this.context.uniform1f(E,S)}setUniform1i(T,S){if(this.uniform1iCache.hasOwnProperty(T)){const _=this.uniform1iCache[T];if(S===_)return}this.uniform1iCache[T]=S;const E=this.getUniformLocation(T);this.context.uniform1i(E,S)}setUniform2f(T,S,E){if(this.uniform2fCache.hasOwnProperty(T)){const N=this.uniform2fCache[T];if(S===N[0]&&E===N[1])return}this.uniform2fCache[T]=[S,E];const _=this.getUniformLocation(T);this.context.uniform2f(_,S,E)}setUniform2fv(T,S){if(this.uniform2fvCache.hasOwnProperty(T)){const _=this.uniform2fvCache[T];if(S[0]===_[0]&&S[1]===_[1])return}this.uniform2fvCache[T]=S;const E=this.getUniformLocation(T);this.context.uniform2fv(E,S)}setUniform2iv(T,S){if(this.uniform2ivCache.hasOwnProperty(T)){const _=this.uniform2ivCache[T];if(S[0]===_[0]&&S[1]===_[1])return}this.uniform2ivCache[T]=S;const E=this.getUniformLocation(T);this.context.uniform2iv(E,S)}setUniform3fv(T,S){if(this.uniform3fvCache.hasOwnProperty(T)){const _=this.uniform3fvCache[T];if(S[0]===_[0]&&S[1]===_[1]&&S[2]===_[2])return}this.uniform3fvCache[T]=S;const E=this.getUniformLocation(T);this.context.uniform3fv(E,S)}setUniform3iv(T,S){if(this.uniform3ivCache.hasOwnProperty(T)){const _=this.uniform3ivCache[T];if(S[0]===_[0]&&S[1]===_[1]&&S[2]===_[2])return}this.uniform3ivCache[T]=S;const E=this.getUniformLocation(T);this.context.uniform3iv(E,S)}setUniform4fv(T,S){if(this.uniform4fvCache.hasOwnProperty(T)){const _=this.uniform4fvCache[T];if(S[0]===_[0]&&S[1]===_[1]&&S[2]===_[2]&&S[3]===_[3])return}this.uniform4fvCache[T]=S;const E=this.getUniformLocation(T);this.context.uniform4fv(E,S)}setUniform4iv(T,S){if(this.uniform4ivCache.hasOwnProperty(T)){const _=this.uniform4ivCache[T];if(S[0]===_[0]&&S[1]===_[1]&&S[2]===_[2]&&S[3]===_[3])return}this.uniform4ivCache[T]=S;const E=this.getUniformLocation(T);this.context.uniform4iv(E,S)}getUniformLocation(T){return this.programUniformLocationCache.hasOwnProperty(T)?this.programUniformLocationCache[T]:this.programUniformLocationCache[T]=this.context.getUniformLocation(this.program,T)}_getFragShaderArtifactMap(T){return{HEADER:this._getHeaderString(),LOOP_MAX:this._getLoopMaxString(),PLUGINS:this._getPluginsString(),CONSTANTS:this._getConstantsString(),DECODE32_ENDIANNESS:this._getDecode32EndiannessString(),ENCODE32_ENDIANNESS:this._getEncode32EndiannessString(),DIVIDE_WITH_INTEGER_CHECK:this._getDivideWithIntegerCheckString(),INJECTED_NATIVE:this._getInjectedNative(),MAIN_CONSTANTS:this._getMainConstantsString(),MAIN_ARGUMENTS:this._getMainArgumentsString(T),KERNEL:this.getKernelString(),MAIN_RESULT:this.getMainResultString(),FLOAT_TACTIC_DECLARATION:this.getFloatTacticDeclaration(),INT_TACTIC_DECLARATION:this.getIntTacticDeclaration(),SAMPLER_2D_TACTIC_DECLARATION:this.getSampler2DTacticDeclaration(),SAMPLER_2D_ARRAY_TACTIC_DECLARATION:this.getSampler2DArrayTacticDeclaration()}}_getVertShaderArtifactMap(T){return{FLOAT_TACTIC_DECLARATION:this.getFloatTacticDeclaration(),INT_TACTIC_DECLARATION:this.getIntTacticDeclaration(),SAMPLER_2D_TACTIC_DECLARATION:this.getSampler2DTacticDeclaration(),SAMPLER_2D_ARRAY_TACTIC_DECLARATION:this.getSampler2DArrayTacticDeclaration()}}_getHeaderString(){return this.subKernels!==null?`#extension GL_EXT_draw_buffers : require
`:""}_getLoopMaxString(){return this.loopMaxIterations?` ${parseInt(this.loopMaxIterations)};
`:` 1000;
`}_getPluginsString(){return this.plugins?this.plugins.map(T=>T.source&&this.source.match(T.functionMatch)?T.source:"").join(`
`):`
`}_getConstantsString(){const T=[],{threadDim:S,texSize:E}=this;return this.dynamicOutput?T.push("uniform ivec3 uOutputDim","uniform ivec2 uTexSize"):T.push(`ivec3 uOutputDim = ivec3(${S[0]}, ${S[1]}, ${S[2]})`,`ivec2 uTexSize = ivec2(${E[0]}, ${E[1]})`),l.linesToString(T)}_getTextureCoordinate(){const T=this.subKernels;return T===null||T.length<1?`varying vec2 vTexCoord;
`:`out vec2 vTexCoord;
`}_getDecode32EndiannessString(){return this.endianness==="LE"?"":`  texel.rgba = texel.abgr;
`}_getEncode32EndiannessString(){return this.endianness==="LE"?"":`  texel.rgba = texel.abgr;
`}_getDivideWithIntegerCheckString(){return this.fixIntegerDivisionAccuracy?`float divWithIntCheck(float x, float y) {
  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
    return float(int(x) / int(y));
  }
  return x / y;
}

float integerCorrectionModulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -(number - (divisor * floor(divWithIntCheck(number, divisor))));
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return number - (divisor * floor(divWithIntCheck(number, divisor)));
}`:""}_getMainArgumentsString(T){const S=[],{argumentNames:E}=this;for(let _=0;_<E.length;_++)S.push(this.kernelArguments[_].getSource(T[_]));return S.join("")}_getInjectedNative(){return this.injectedNative||""}_getMainConstantsString(){const T=[],{constants:S}=this;if(S){let E=0;for(const _ in S)this.constants.hasOwnProperty(_)&&T.push(this.kernelConstants[E++].getSource(this.constants[_]))}return T.join("")}getRawValueFramebuffer(T,S){if(this.rawValueFramebuffers[T]||(this.rawValueFramebuffers[T]={}),!this.rawValueFramebuffers[T][S]){const E=this.context.createFramebuffer();E.width=T,E.height=S,this.rawValueFramebuffers[T][S]=E}return this.rawValueFramebuffers[T][S]}getKernelResultDeclaration(){switch(this.returnType){case"Array(2)":return"vec2 kernelResult";case"Array(3)":return"vec3 kernelResult";case"Array(4)":return"vec4 kernelResult";case"LiteralInteger":case"Float":case"Number":case"Integer":return"float kernelResult";default:if(this.graphical)return"float kernelResult";throw new Error(`unrecognized output type "${this.returnType}"`)}}getKernelString(){const T=[this.getKernelResultDeclaration()],{subKernels:S}=this;if(S!==null)switch(this.returnType){case"Number":case"Float":case"Integer":for(let E=0;E<S.length;E++){const _=S[E];T.push(_.returnType==="Integer"?`int subKernelResult_${_.name} = 0`:`float subKernelResult_${_.name} = 0.0`)}break;case"Array(2)":for(let E=0;E<S.length;E++)T.push(`vec2 subKernelResult_${S[E].name}`);break;case"Array(3)":for(let E=0;E<S.length;E++)T.push(`vec3 subKernelResult_${S[E].name}`);break;case"Array(4)":for(let E=0;E<S.length;E++)T.push(`vec4 subKernelResult_${S[E].name}`);break}return l.linesToString(T)+this.translatedSource}getMainResultGraphical(){return l.linesToString(["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragColor = actualColor"])}getMainResultPackedPixels(){switch(this.returnType){case"LiteralInteger":case"Number":case"Integer":case"Float":return this.getMainResultKernelPackedPixels()+this.getMainResultSubKernelPackedPixels();default:throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`)}}getMainResultKernelPackedPixels(){return l.linesToString(["  threadId = indexTo3D(index, uOutputDim)","  kernel()",`  gl_FragData[0] = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(kernelResult)`])}getMainResultSubKernelPackedPixels(){const T=[];if(!this.subKernels)return"";for(let S=0;S<this.subKernels.length;S++)this.subKernels[S].returnType==="Integer"?T.push(`  gl_FragData[${S+1}] = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(float(subKernelResult_${this.subKernels[S].name}))`):T.push(`  gl_FragData[${S+1}] = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(subKernelResult_${this.subKernels[S].name})`);return l.linesToString(T)}getMainResultMemoryOptimizedFloats(){const T=["  index *= 4"];switch(this.returnType){case"Number":case"Integer":case"Float":const S=["r","g","b","a"];for(let E=0;E<S.length;E++){const _=S[E];this.getMainResultKernelMemoryOptimizedFloats(T,_),this.getMainResultSubKernelMemoryOptimizedFloats(T,_),E+1<S.length&&T.push("  index += 1")}break;default:throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`)}return l.linesToString(T)}getMainResultKernelMemoryOptimizedFloats(T,S){T.push("  threadId = indexTo3D(index, uOutputDim)","  kernel()",`  gl_FragData[0].${S} = kernelResult`)}getMainResultSubKernelMemoryOptimizedFloats(T,S){if(!this.subKernels)return T;for(let E=0;E<this.subKernels.length;E++)this.subKernels[E].returnType==="Integer"?T.push(`  gl_FragData[${E+1}].${S} = float(subKernelResult_${this.subKernels[E].name})`):T.push(`  gl_FragData[${E+1}].${S} = subKernelResult_${this.subKernels[E].name}`)}getMainResultKernelNumberTexture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragData[0][0] = kernelResult"]}getMainResultSubKernelNumberTexture(){const T=[];if(!this.subKernels)return T;for(let S=0;S<this.subKernels.length;++S){const E=this.subKernels[S];E.returnType==="Integer"?T.push(`  gl_FragData[${S+1}][0] = float(subKernelResult_${E.name})`):T.push(`  gl_FragData[${S+1}][0] = subKernelResult_${E.name}`)}return T}getMainResultKernelArray2Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragData[0][0] = kernelResult[0]","  gl_FragData[0][1] = kernelResult[1]"]}getMainResultSubKernelArray2Texture(){const T=[];if(!this.subKernels)return T;for(let S=0;S<this.subKernels.length;++S)T.push(`  gl_FragData[${S+1}][0] = subKernelResult_${this.subKernels[S].name}[0]`,`  gl_FragData[${S+1}][1] = subKernelResult_${this.subKernels[S].name}[1]`);return T}getMainResultKernelArray3Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragData[0][0] = kernelResult[0]","  gl_FragData[0][1] = kernelResult[1]","  gl_FragData[0][2] = kernelResult[2]"]}getMainResultSubKernelArray3Texture(){const T=[];if(!this.subKernels)return T;for(let S=0;S<this.subKernels.length;++S)T.push(`  gl_FragData[${S+1}][0] = subKernelResult_${this.subKernels[S].name}[0]`,`  gl_FragData[${S+1}][1] = subKernelResult_${this.subKernels[S].name}[1]`,`  gl_FragData[${S+1}][2] = subKernelResult_${this.subKernels[S].name}[2]`);return T}getMainResultKernelArray4Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragData[0] = kernelResult"]}getMainResultSubKernelArray4Texture(){const T=[];if(!this.subKernels)return T;switch(this.returnType){case"Number":case"Float":case"Integer":for(let S=0;S<this.subKernels.length;++S)this.subKernels[S].returnType==="Integer"?T.push(`  gl_FragData[${S+1}] = float(subKernelResult_${this.subKernels[S].name})`):T.push(`  gl_FragData[${S+1}] = subKernelResult_${this.subKernels[S].name}`);break;case"Array(2)":for(let S=0;S<this.subKernels.length;++S)T.push(`  gl_FragData[${S+1}][0] = subKernelResult_${this.subKernels[S].name}[0]`,`  gl_FragData[${S+1}][1] = subKernelResult_${this.subKernels[S].name}[1]`);break;case"Array(3)":for(let S=0;S<this.subKernels.length;++S)T.push(`  gl_FragData[${S+1}][0] = subKernelResult_${this.subKernels[S].name}[0]`,`  gl_FragData[${S+1}][1] = subKernelResult_${this.subKernels[S].name}[1]`,`  gl_FragData[${S+1}][2] = subKernelResult_${this.subKernels[S].name}[2]`);break;case"Array(4)":for(let S=0;S<this.subKernels.length;++S)T.push(`  gl_FragData[${S+1}][0] = subKernelResult_${this.subKernels[S].name}[0]`,`  gl_FragData[${S+1}][1] = subKernelResult_${this.subKernels[S].name}[1]`,`  gl_FragData[${S+1}][2] = subKernelResult_${this.subKernels[S].name}[2]`,`  gl_FragData[${S+1}][3] = subKernelResult_${this.subKernels[S].name}[3]`);break}return T}replaceArtifacts(T,S){return T.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\n/g,(E,_)=>{if(S.hasOwnProperty(_))return S[_];throw`unhandled artifact ${_}`})}getFragmentShader(T){return this.compiledFragmentShader!==null?this.compiledFragmentShader:this.compiledFragmentShader=this.replaceArtifacts(this.constructor.fragmentShader,this._getFragShaderArtifactMap(T))}getVertexShader(T){return this.compiledVertexShader!==null?this.compiledVertexShader:this.compiledVertexShader=this.replaceArtifacts(this.constructor.vertexShader,this._getVertShaderArtifactMap(T))}toString(){const T=l.linesToString(["const gl = context"]);return d(this.constructor,arguments,this,T)}destroy(T){if(!this.context)return;this.buffer&&this.context.deleteBuffer(this.buffer),this.framebuffer&&this.context.deleteFramebuffer(this.framebuffer);for(const E in this.rawValueFramebuffers){for(const _ in this.rawValueFramebuffers[E])this.context.deleteFramebuffer(this.rawValueFramebuffers[E][_]),delete this.rawValueFramebuffers[E][_];delete this.rawValueFramebuffers[E]}if(this.vertShader&&this.context.deleteShader(this.vertShader),this.fragShader&&this.context.deleteShader(this.fragShader),this.program&&this.context.deleteProgram(this.program),this.texture){this.texture.delete();const E=this.textureCache.indexOf(this.texture.texture);E>-1&&this.textureCache.splice(E,1),this.texture=null}if(this.mappedTextures&&this.mappedTextures.length){for(let E=0;E<this.mappedTextures.length;E++){const _=this.mappedTextures[E];_.delete();const N=this.textureCache.indexOf(_.texture);N>-1&&this.textureCache.splice(N,1)}this.mappedTextures=null}if(this.kernelArguments)for(let E=0;E<this.kernelArguments.length;E++)this.kernelArguments[E].destroy();if(this.kernelConstants)for(let E=0;E<this.kernelConstants.length;E++)this.kernelConstants[E].destroy();for(;this.textureCache.length>0;){const E=this.textureCache.pop();this.context.deleteTexture(E)}if(T){const E=y.indexOf(this.canvas);E>=0&&(y[E]=null,C[E]=null)}if(this.destroyExtensions(),delete this.context,delete this.canvas,!this.gpu)return;const S=this.gpu.kernels.indexOf(this);S!==-1&&this.gpu.kernels.splice(S,1)}destroyExtensions(){this.extensions.OES_texture_float=null,this.extensions.OES_texture_float_linear=null,this.extensions.OES_element_index_uint=null,this.extensions.WEBGL_draw_buffers=null}static destroyContext(T){const S=T.getExtension("WEBGL_lose_context");S&&S.loseContext()}toJSON(){const T=super.toJSON();return T.functionNodes=o.fromKernel(this,a).toJSON(),T.settings.threadDim=this.threadDim,T}}s.exports={WebGLKernel:I}},{"../../plugins/math-random-uniformly-distributed":112,"../../utils":114,"../function-builder":9,"../gl/kernel":13,"../gl/kernel-string":12,"./fragment-shader":37,"./function-node":38,"./kernel-value-maps":39,"./vertex-shader":71}],71:[function(n,s,r){const i=`__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

attribute vec2 aPos;
attribute vec2 aTexCoord;

varying vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;s.exports={vertexShader:i}},{}],72:[function(n,s,r){const i=`#version 300 es
__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;
__SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

in vec2 vTexCoord;

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float _round(float x) {
  return floor(x + 0.5);
}


const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x/y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  return texel[channel] * 255.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  index = index / 4;
  vec4 texel = texture(tex, st / vec2(texSize));
  return texel[channel];
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, st / vec2(texSize));
}

vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, vec3(st / vec2(texSize), z));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));

  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;s.exports={fragmentShader:i}},{}],73:[function(n,s,r){const{utils:i}=n("../../utils"),{WebGLFunctionNode:o}=n("../web-gl/function-node");class a extends o{astIdentifierExpression(u,c){if(u.type!=="Identifier")throw this.astErrorOutput("IdentifierExpression - not an Identifier",u);const h=this.getType(u),d=i.sanitizeName(u.name);return u.name==="Infinity"?c.push("intBitsToFloat(2139095039)"):h==="Boolean"?this.argumentNames.indexOf(d)>-1?c.push(`bool(user_${d})`):c.push(`user_${d}`):c.push(`user_${d}`),c}}s.exports={WebGL2FunctionNode:a}},{"../../utils":114,"../web-gl/function-node":38}],74:[function(n,s,r){const{WebGL2KernelValueBoolean:i}=n("./kernel-value/boolean"),{WebGL2KernelValueFloat:o}=n("./kernel-value/float"),{WebGL2KernelValueInteger:a}=n("./kernel-value/integer"),{WebGL2KernelValueHTMLImage:l}=n("./kernel-value/html-image"),{WebGL2KernelValueDynamicHTMLImage:u}=n("./kernel-value/dynamic-html-image"),{WebGL2KernelValueHTMLImageArray:c}=n("./kernel-value/html-image-array"),{WebGL2KernelValueDynamicHTMLImageArray:h}=n("./kernel-value/dynamic-html-image-array"),{WebGL2KernelValueHTMLVideo:d}=n("./kernel-value/html-video"),{WebGL2KernelValueDynamicHTMLVideo:f}=n("./kernel-value/dynamic-html-video"),{WebGL2KernelValueSingleInput:p}=n("./kernel-value/single-input"),{WebGL2KernelValueDynamicSingleInput:g}=n("./kernel-value/dynamic-single-input"),{WebGL2KernelValueUnsignedInput:m}=n("./kernel-value/unsigned-input"),{WebGL2KernelValueDynamicUnsignedInput:x}=n("./kernel-value/dynamic-unsigned-input"),{WebGL2KernelValueMemoryOptimizedNumberTexture:b}=n("./kernel-value/memory-optimized-number-texture"),{WebGL2KernelValueDynamicMemoryOptimizedNumberTexture:v}=n("./kernel-value/dynamic-memory-optimized-number-texture"),{WebGL2KernelValueNumberTexture:y}=n("./kernel-value/number-texture"),{WebGL2KernelValueDynamicNumberTexture:C}=n("./kernel-value/dynamic-number-texture"),{WebGL2KernelValueSingleArray:I}=n("./kernel-value/single-array"),{WebGL2KernelValueDynamicSingleArray:$}=n("./kernel-value/dynamic-single-array"),{WebGL2KernelValueSingleArray1DI:T}=n("./kernel-value/single-array1d-i"),{WebGL2KernelValueDynamicSingleArray1DI:S}=n("./kernel-value/dynamic-single-array1d-i"),{WebGL2KernelValueSingleArray2DI:E}=n("./kernel-value/single-array2d-i"),{WebGL2KernelValueDynamicSingleArray2DI:_}=n("./kernel-value/dynamic-single-array2d-i"),{WebGL2KernelValueSingleArray3DI:N}=n("./kernel-value/single-array3d-i"),{WebGL2KernelValueDynamicSingleArray3DI:P}=n("./kernel-value/dynamic-single-array3d-i"),{WebGL2KernelValueArray2:M}=n("./kernel-value/array2"),{WebGL2KernelValueArray3:z}=n("./kernel-value/array3"),{WebGL2KernelValueArray4:A}=n("./kernel-value/array4"),{WebGL2KernelValueUnsignedArray:B}=n("./kernel-value/unsigned-array"),{WebGL2KernelValueDynamicUnsignedArray:L}=n("./kernel-value/dynamic-unsigned-array"),U={unsigned:{dynamic:{Boolean:i,Integer:a,Float:o,Array:L,"Array(2)":M,"Array(3)":z,"Array(4)":A,"Array1D(2)":!1,"Array1D(3)":!1,"Array1D(4)":!1,"Array2D(2)":!1,"Array2D(3)":!1,"Array2D(4)":!1,"Array3D(2)":!1,"Array3D(3)":!1,"Array3D(4)":!1,Input:x,NumberTexture:C,"ArrayTexture(1)":C,"ArrayTexture(2)":C,"ArrayTexture(3)":C,"ArrayTexture(4)":C,MemoryOptimizedNumberTexture:v,HTMLCanvas:u,OffscreenCanvas:u,HTMLImage:u,ImageBitmap:u,ImageData:u,HTMLImageArray:h,HTMLVideo:f},static:{Boolean:i,Float:o,Integer:a,Array:B,"Array(2)":M,"Array(3)":z,"Array(4)":A,"Array1D(2)":!1,"Array1D(3)":!1,"Array1D(4)":!1,"Array2D(2)":!1,"Array2D(3)":!1,"Array2D(4)":!1,"Array3D(2)":!1,"Array3D(3)":!1,"Array3D(4)":!1,Input:m,NumberTexture:y,"ArrayTexture(1)":y,"ArrayTexture(2)":y,"ArrayTexture(3)":y,"ArrayTexture(4)":y,MemoryOptimizedNumberTexture:v,HTMLCanvas:l,OffscreenCanvas:l,HTMLImage:l,ImageBitmap:l,ImageData:l,HTMLImageArray:c,HTMLVideo:d}},single:{dynamic:{Boolean:i,Integer:a,Float:o,Array:$,"Array(2)":M,"Array(3)":z,"Array(4)":A,"Array1D(2)":S,"Array1D(3)":S,"Array1D(4)":S,"Array2D(2)":_,"Array2D(3)":_,"Array2D(4)":_,"Array3D(2)":P,"Array3D(3)":P,"Array3D(4)":P,Input:g,NumberTexture:C,"ArrayTexture(1)":C,"ArrayTexture(2)":C,"ArrayTexture(3)":C,"ArrayTexture(4)":C,MemoryOptimizedNumberTexture:v,HTMLCanvas:u,OffscreenCanvas:u,HTMLImage:u,ImageBitmap:u,ImageData:u,HTMLImageArray:h,HTMLVideo:f},static:{Boolean:i,Float:o,Integer:a,Array:I,"Array(2)":M,"Array(3)":z,"Array(4)":A,"Array1D(2)":T,"Array1D(3)":T,"Array1D(4)":T,"Array2D(2)":E,"Array2D(3)":E,"Array2D(4)":E,"Array3D(2)":N,"Array3D(3)":N,"Array3D(4)":N,Input:p,NumberTexture:y,"ArrayTexture(1)":y,"ArrayTexture(2)":y,"ArrayTexture(3)":y,"ArrayTexture(4)":y,MemoryOptimizedNumberTexture:b,HTMLCanvas:l,OffscreenCanvas:l,HTMLImage:l,ImageBitmap:l,ImageData:l,HTMLImageArray:c,HTMLVideo:d}}};function j(Z,J,se,fe){if(!Z)throw new Error("type missing");if(!J)throw new Error("dynamic missing");if(!se)throw new Error("precision missing");fe.type&&(Z=fe.type);const he=U[se][J];if(he[Z]===!1)return null;if(he[Z]===void 0)throw new Error(`Could not find a KernelValue for ${Z}`);return he[Z]}s.exports={kernelValueMaps:U,lookupKernelValueType:j}},{"./kernel-value/array2":75,"./kernel-value/array3":76,"./kernel-value/array4":77,"./kernel-value/boolean":78,"./kernel-value/dynamic-html-image":80,"./kernel-value/dynamic-html-image-array":79,"./kernel-value/dynamic-html-video":81,"./kernel-value/dynamic-memory-optimized-number-texture":82,"./kernel-value/dynamic-number-texture":83,"./kernel-value/dynamic-single-array":84,"./kernel-value/dynamic-single-array1d-i":85,"./kernel-value/dynamic-single-array2d-i":86,"./kernel-value/dynamic-single-array3d-i":87,"./kernel-value/dynamic-single-input":88,"./kernel-value/dynamic-unsigned-array":89,"./kernel-value/dynamic-unsigned-input":90,"./kernel-value/float":91,"./kernel-value/html-image":93,"./kernel-value/html-image-array":92,"./kernel-value/html-video":94,"./kernel-value/integer":95,"./kernel-value/memory-optimized-number-texture":96,"./kernel-value/number-texture":97,"./kernel-value/single-array":98,"./kernel-value/single-array1d-i":99,"./kernel-value/single-array2d-i":100,"./kernel-value/single-array3d-i":101,"./kernel-value/single-input":102,"./kernel-value/unsigned-array":103,"./kernel-value/unsigned-input":104}],75:[function(n,s,r){const{WebGLKernelValueArray2:i}=n("../../web-gl/kernel-value/array2");class o extends i{}s.exports={WebGL2KernelValueArray2:o}},{"../../web-gl/kernel-value/array2":41}],76:[function(n,s,r){const{WebGLKernelValueArray3:i}=n("../../web-gl/kernel-value/array3");class o extends i{}s.exports={WebGL2KernelValueArray3:o}},{"../../web-gl/kernel-value/array3":42}],77:[function(n,s,r){const{WebGLKernelValueArray4:i}=n("../../web-gl/kernel-value/array4");class o extends i{}s.exports={WebGL2KernelValueArray4:o}},{"../../web-gl/kernel-value/array4":43}],78:[function(n,s,r){const{WebGLKernelValueBoolean:i}=n("../../web-gl/kernel-value/boolean");class o extends i{}s.exports={WebGL2KernelValueBoolean:o}},{"../../web-gl/kernel-value/boolean":44}],79:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGL2KernelValueHTMLImageArray:o}=n("./html-image-array");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2DArray ${this.id}`,`uniform ${u} ivec2 ${this.sizeId}`,`uniform ${u} ivec3 ${this.dimensionsId}`])}updateValue(u){const{width:c,height:h}=u[0];this.checkSize(c,h),this.dimensions=[c,h,u.length],this.textureSize=[c,h],this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGL2KernelValueDynamicHTMLImageArray:a}},{"../../../utils":114,"./html-image-array":92}],80:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueDynamicHTMLImage:o}=n("../../web-gl/kernel-value/dynamic-html-image");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`uniform ${u} ivec2 ${this.sizeId}`,`uniform ${u} ivec3 ${this.dimensionsId}`])}}s.exports={WebGL2KernelValueDynamicHTMLImage:a}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-html-image":45}],81:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGL2KernelValueDynamicHTMLImage:o}=n("./dynamic-html-image");class a extends o{}s.exports={WebGL2KernelValueDynamicHTMLVideo:a}},{"../../../utils":114,"./dynamic-html-image":80}],82:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueDynamicMemoryOptimizedNumberTexture:o}=n("../../web-gl/kernel-value/dynamic-memory-optimized-number-texture");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}}s.exports={WebGL2KernelValueDynamicMemoryOptimizedNumberTexture:a}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture":47}],83:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueDynamicNumberTexture:o}=n("../../web-gl/kernel-value/dynamic-number-texture");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`uniform ${u} ivec2 ${this.sizeId}`,`uniform ${u} ivec3 ${this.dimensionsId}`])}}s.exports={WebGL2KernelValueDynamicNumberTexture:a}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-number-texture":48}],84:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGL2KernelValueSingleArray:o}=n("../../web-gl2/kernel-value/single-array");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`uniform ${u} ivec2 ${this.sizeId}`,`uniform ${u} ivec3 ${this.dimensionsId}`])}updateValue(u){this.dimensions=i.getDimensions(u,!0),this.textureSize=i.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGL2KernelValueDynamicSingleArray:a}},{"../../../utils":114,"../../web-gl2/kernel-value/single-array":98}],85:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGL2KernelValueSingleArray1DI:o}=n("../../web-gl2/kernel-value/single-array1d-i");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`uniform ${u} ivec2 ${this.sizeId}`,`uniform ${u} ivec3 ${this.dimensionsId}`])}updateValue(u){this.setShape(u),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGL2KernelValueDynamicSingleArray1DI:a}},{"../../../utils":114,"../../web-gl2/kernel-value/single-array1d-i":99}],86:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGL2KernelValueSingleArray2DI:o}=n("../../web-gl2/kernel-value/single-array2d-i");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`uniform ${u} ivec2 ${this.sizeId}`,`uniform ${u} ivec3 ${this.dimensionsId}`])}updateValue(u){this.setShape(u),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGL2KernelValueDynamicSingleArray2DI:a}},{"../../../utils":114,"../../web-gl2/kernel-value/single-array2d-i":100}],87:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGL2KernelValueSingleArray3DI:o}=n("../../web-gl2/kernel-value/single-array3d-i");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`uniform ${u} ivec2 ${this.sizeId}`,`uniform ${u} ivec3 ${this.dimensionsId}`])}updateValue(u){this.setShape(u),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGL2KernelValueDynamicSingleArray3DI:a}},{"../../../utils":114,"../../web-gl2/kernel-value/single-array3d-i":101}],88:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGL2KernelValueSingleInput:o}=n("../../web-gl2/kernel-value/single-input");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`uniform ${u} ivec2 ${this.sizeId}`,`uniform ${u} ivec3 ${this.dimensionsId}`])}updateValue(u){let[c,h,d]=u.size;this.dimensions=new Int32Array([c||1,h||1,d||1]),this.textureSize=i.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(u)}}s.exports={WebGL2KernelValueDynamicSingleInput:a}},{"../../../utils":114,"../../web-gl2/kernel-value/single-input":102}],89:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueDynamicUnsignedArray:o}=n("../../web-gl/kernel-value/dynamic-unsigned-array");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`uniform ${u} ivec2 ${this.sizeId}`,`uniform ${u} ivec3 ${this.dimensionsId}`])}}s.exports={WebGL2KernelValueDynamicUnsignedArray:a}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-array":54}],90:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueDynamicUnsignedInput:o}=n("../../web-gl/kernel-value/dynamic-unsigned-input");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`uniform ${u} ivec2 ${this.sizeId}`,`uniform ${u} ivec3 ${this.dimensionsId}`])}}s.exports={WebGL2KernelValueDynamicUnsignedInput:a}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-input":55}],91:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueFloat:o}=n("../../web-gl/kernel-value/float");class a extends o{}s.exports={WebGL2KernelValueFloat:a}},{"../../../utils":114,"../../web-gl/kernel-value/float":56}],92:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelArray:o}=n("../../web-gl/kernel-value/array");class a extends o{constructor(u,c){super(u,c),this.checkSize(u[0].width,u[0].height),this.dimensions=[u[0].width,u[0].height,u.length],this.textureSize=[u[0].width,u[0].height]}defineTexture(){const{context:u}=this;u.activeTexture(this.contextHandle),u.bindTexture(u.TEXTURE_2D_ARRAY,this.texture),u.texParameteri(u.TEXTURE_2D_ARRAY,u.TEXTURE_MAG_FILTER,u.NEAREST),u.texParameteri(u.TEXTURE_2D_ARRAY,u.TEXTURE_MIN_FILTER,u.NEAREST)}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2DArray ${this.id}`,`${u} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${u} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(u){const{context:c}=this;c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D_ARRAY,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!0),c.texImage3D(c.TEXTURE_2D_ARRAY,0,c.RGBA,u[0].width,u[0].height,u.length,0,c.RGBA,c.UNSIGNED_BYTE,null);for(let h=0;h<u.length;h++)c.texSubImage3D(c.TEXTURE_2D_ARRAY,0,0,0,h,u[h].width,u[h].height,1,c.RGBA,c.UNSIGNED_BYTE,this.uploadValue=u[h]);this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGL2KernelValueHTMLImageArray:a}},{"../../../utils":114,"../../web-gl/kernel-value/array":40}],93:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueHTMLImage:o}=n("../../web-gl/kernel-value/html-image");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`${u} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${u} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}}s.exports={WebGL2KernelValueHTMLImage:a}},{"../../../utils":114,"../../web-gl/kernel-value/html-image":57}],94:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGL2KernelValueHTMLImage:o}=n("./html-image");class a extends o{}s.exports={WebGL2KernelValueHTMLVideo:a}},{"../../../utils":114,"./html-image":93}],95:[function(n,s,r){const{WebGLKernelValueInteger:i}=n("../../web-gl/kernel-value/integer");class o extends i{getSource(l){const u=this.getVariablePrecisionString();return this.origin==="constants"?`const ${u} int ${this.id} = ${parseInt(l)};
`:`uniform ${u} int ${this.id};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform1i(this.id,this.uploadValue=l)}}s.exports={WebGL2KernelValueInteger:o}},{"../../web-gl/kernel-value/integer":60}],96:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueMemoryOptimizedNumberTexture:o}=n("../../web-gl/kernel-value/memory-optimized-number-texture");class a extends o{getSource(){const{id:u,sizeId:c,textureSize:h,dimensionsId:d,dimensions:f}=this,p=this.getVariablePrecisionString();return i.linesToString([`uniform sampler2D ${u}`,`${p} ivec2 ${c} = ivec2(${h[0]}, ${h[1]})`,`${p} ivec3 ${d} = ivec3(${f[0]}, ${f[1]}, ${f[2]})`])}}s.exports={WebGL2KernelValueMemoryOptimizedNumberTexture:a}},{"../../../utils":114,"../../web-gl/kernel-value/memory-optimized-number-texture":61}],97:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueNumberTexture:o}=n("../../web-gl/kernel-value/number-texture");class a extends o{getSource(){const{id:u,sizeId:c,textureSize:h,dimensionsId:d,dimensions:f}=this,p=this.getVariablePrecisionString();return i.linesToString([`uniform ${p} sampler2D ${u}`,`${p} ivec2 ${c} = ivec2(${h[0]}, ${h[1]})`,`${p} ivec3 ${d} = ivec3(${f[0]}, ${f[1]}, ${f[2]})`])}}s.exports={WebGL2KernelValueNumberTexture:a}},{"../../../utils":114,"../../web-gl/kernel-value/number-texture":62}],98:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueSingleArray:o}=n("../../web-gl/kernel-value/single-array");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`${u} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${u} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(u){if(u.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(u.constructor);return}const{context:c}=this;i.flattenTo(u,this.uploadValue),c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.texImage2D(c.TEXTURE_2D,0,c.RGBA32F,this.textureSize[0],this.textureSize[1],0,c.RGBA,c.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGL2KernelValueSingleArray:a}},{"../../../utils":114,"../../web-gl/kernel-value/single-array":63}],99:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueSingleArray1DI:o}=n("../../web-gl/kernel-value/single-array1d-i");class a extends o{updateValue(u){if(u.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(u.constructor);return}const{context:c}=this;i.flattenTo(u,this.uploadValue),c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.texImage2D(c.TEXTURE_2D,0,c.RGBA32F,this.textureSize[0],this.textureSize[1],0,c.RGBA,c.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGL2KernelValueSingleArray1DI:a}},{"../../../utils":114,"../../web-gl/kernel-value/single-array1d-i":64}],100:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueSingleArray2DI:o}=n("../../web-gl/kernel-value/single-array2d-i");class a extends o{updateValue(u){if(u.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(u.constructor);return}const{context:c}=this;i.flattenTo(u,this.uploadValue),c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.texImage2D(c.TEXTURE_2D,0,c.RGBA32F,this.textureSize[0],this.textureSize[1],0,c.RGBA,c.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGL2KernelValueSingleArray2DI:a}},{"../../../utils":114,"../../web-gl/kernel-value/single-array2d-i":65}],101:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueSingleArray3DI:o}=n("../../web-gl/kernel-value/single-array3d-i");class a extends o{updateValue(u){if(u.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(u.constructor);return}const{context:c}=this;i.flattenTo(u,this.uploadValue),c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.texImage2D(c.TEXTURE_2D,0,c.RGBA32F,this.textureSize[0],this.textureSize[1],0,c.RGBA,c.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGL2KernelValueSingleArray3DI:a}},{"../../../utils":114,"../../web-gl/kernel-value/single-array3d-i":66}],102:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueSingleInput:o}=n("../../web-gl/kernel-value/single-input");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`${u} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${u} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(u){const{context:c}=this;i.flattenTo(u.value,this.uploadValue),c.activeTexture(this.contextHandle),c.bindTexture(c.TEXTURE_2D,this.texture),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.texImage2D(c.TEXTURE_2D,0,c.RGBA32F,this.textureSize[0],this.textureSize[1],0,c.RGBA,c.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGL2KernelValueSingleInput:a}},{"../../../utils":114,"../../web-gl/kernel-value/single-input":67}],103:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueUnsignedArray:o}=n("../../web-gl/kernel-value/unsigned-array");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`${u} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${u} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}}s.exports={WebGL2KernelValueUnsignedArray:a}},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-array":68}],104:[function(n,s,r){const{utils:i}=n("../../../utils"),{WebGLKernelValueUnsignedInput:o}=n("../../web-gl/kernel-value/unsigned-input");class a extends o{getSource(){const u=this.getVariablePrecisionString();return i.linesToString([`uniform ${u} sampler2D ${this.id}`,`${u} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${u} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}}s.exports={WebGL2KernelValueUnsignedInput:a}},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-input":69}],105:[function(n,s,r){const{WebGLKernel:i}=n("../web-gl/kernel"),{WebGL2FunctionNode:o}=n("./function-node"),{FunctionBuilder:a}=n("../function-builder"),{utils:l}=n("../../utils"),{fragmentShader:u}=n("./fragment-shader"),{vertexShader:c}=n("./vertex-shader"),{lookupKernelValueType:h}=n("./kernel-value-maps");let d=null,f=null,p=null,g=null;class m extends i{static get isSupported(){return d!==null||(this.setupFeatureChecks(),d=this.isContextMatch(p)),d}static setupFeatureChecks(){typeof document<"u"?f=document.createElement("canvas"):typeof OffscreenCanvas<"u"&&(f=new OffscreenCanvas(0,0)),f&&(p=f.getContext("webgl2"),!(!p||!p.getExtension)&&(p.getExtension("EXT_color_buffer_float"),p.getExtension("OES_texture_float_linear"),g=this.getFeatures()))}static isContextMatch(b){return typeof WebGL2RenderingContext<"u"?b instanceof WebGL2RenderingContext:!1}static getFeatures(){const b=this.testContext;return Object.freeze({isFloatRead:this.getIsFloatRead(),isIntegerDivisionAccurate:this.getIsIntegerDivisionAccurate(),isSpeedTacticSupported:this.getIsSpeedTacticSupported(),kernelMap:!0,isTextureFloat:!0,isDrawBuffers:!0,channelCount:this.getChannelCount(),maxTextureSize:this.getMaxTextureSize(),lowIntPrecision:b.getShaderPrecisionFormat(b.FRAGMENT_SHADER,b.LOW_INT),lowFloatPrecision:b.getShaderPrecisionFormat(b.FRAGMENT_SHADER,b.LOW_FLOAT),mediumIntPrecision:b.getShaderPrecisionFormat(b.FRAGMENT_SHADER,b.MEDIUM_INT),mediumFloatPrecision:b.getShaderPrecisionFormat(b.FRAGMENT_SHADER,b.MEDIUM_FLOAT),highIntPrecision:b.getShaderPrecisionFormat(b.FRAGMENT_SHADER,b.HIGH_INT),highFloatPrecision:b.getShaderPrecisionFormat(b.FRAGMENT_SHADER,b.HIGH_FLOAT)})}static getIsTextureFloat(){return!0}static getChannelCount(){return p.getParameter(p.MAX_DRAW_BUFFERS)}static getMaxTextureSize(){return p.getParameter(p.MAX_TEXTURE_SIZE)}static lookupKernelValueType(b,v,y,C){return h(b,v,y,C)}static get testCanvas(){return f}static get testContext(){return p}static get features(){return g}static get fragmentShader(){return u}static get vertexShader(){return c}initContext(){const b={alpha:!1,depth:!1,antialias:!1};return this.canvas.getContext("webgl2",b)}initExtensions(){this.extensions={EXT_color_buffer_float:this.context.getExtension("EXT_color_buffer_float"),OES_texture_float_linear:this.context.getExtension("OES_texture_float_linear")}}validateSettings(b){if(!this.validate){this.texSize=l.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},this.output);return}const{features:v}=this.constructor;if(this.precision==="single"&&!v.isFloatRead)throw new Error("Float texture outputs are not supported");if(!this.graphical&&this.precision===null&&(this.precision=v.isFloatRead?"single":"unsigned"),this.fixIntegerDivisionAccuracy===null?this.fixIntegerDivisionAccuracy=!v.isIntegerDivisionAccurate:this.fixIntegerDivisionAccuracy&&v.isIntegerDivisionAccurate&&(this.fixIntegerDivisionAccuracy=!1),this.checkOutput(),!this.output||this.output.length===0){if(b.length!==1)throw new Error("Auto output only supported for kernels with only one input");const y=l.getVariableType(b[0],this.strictIntegers);switch(y){case"Array":this.output=l.getDimensions(y);break;case"NumberTexture":case"MemoryOptimizedNumberTexture":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":this.output=b[0].output;break;default:throw new Error("Auto output not supported for input type: "+y)}}if(this.graphical){if(this.output.length!==2)throw new Error("Output must have 2 dimensions on graphical mode");this.precision==="single"&&(console.warn("Cannot use graphical mode and single precision at the same time"),this.precision="unsigned"),this.texSize=l.clone(this.output);return}else!this.graphical&&this.precision===null&&v.isTextureFloat&&(this.precision="single");this.texSize=l.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},this.output),this.checkTextureSize()}translateSource(){const b=a.fromKernel(this,o,{fixIntegerDivisionAccuracy:this.fixIntegerDivisionAccuracy});this.translatedSource=b.getPrototypeString("kernel"),this.setupReturnTypes(b)}drawBuffers(){this.context.drawBuffers(this.drawBuffersMap)}getTextureFormat(){const{context:b}=this;switch(this.getInternalFormat()){case b.R32F:return b.RED;case b.RG32F:return b.RG;case b.RGBA32F:return b.RGBA;case b.RGBA:return b.RGBA;default:throw new Error("Unknown internal format")}}getInternalFormat(){const{context:b}=this;if(this.precision==="single"){if(this.pipeline)switch(this.returnType){case"Number":case"Float":case"Integer":return this.optimizeFloatMemory?b.RGBA32F:b.R32F;case"Array(2)":return b.RG32F;case"Array(3)":case"Array(4)":return b.RGBA32F;default:throw new Error("Unhandled return type")}return b.RGBA32F}return b.RGBA}_setupOutputTexture(){const b=this.context;if(this.texture){b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0,b.TEXTURE_2D,this.texture.texture,0);return}b.bindFramebuffer(b.FRAMEBUFFER,this.framebuffer);const v=b.createTexture(),y=this.texSize;b.activeTexture(b.TEXTURE0+this.constantTextureCount+this.argumentTextureCount),b.bindTexture(b.TEXTURE_2D,v),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.REPEAT),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.REPEAT),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);const C=this.getInternalFormat();this.precision==="single"?b.texStorage2D(b.TEXTURE_2D,1,C,y[0],y[1]):b.texImage2D(b.TEXTURE_2D,0,C,y[0],y[1],0,C,b.UNSIGNED_BYTE,null),b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0,b.TEXTURE_2D,v,0),this.texture=new this.TextureConstructor({texture:v,size:y,dimensions:this.threadDim,output:this.output,context:this.context,internalFormat:this.getInternalFormat(),textureFormat:this.getTextureFormat(),kernel:this})}_setupSubOutputTextures(){const b=this.context;if(this.mappedTextures){for(let y=0;y<this.subKernels.length;y++)b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0+y+1,b.TEXTURE_2D,this.mappedTextures[y].texture,0);return}const v=this.texSize;this.drawBuffersMap=[b.COLOR_ATTACHMENT0],this.mappedTextures=[];for(let y=0;y<this.subKernels.length;y++){const C=this.createTexture();this.drawBuffersMap.push(b.COLOR_ATTACHMENT0+y+1),b.activeTexture(b.TEXTURE0+this.constantTextureCount+this.argumentTextureCount+y),b.bindTexture(b.TEXTURE_2D,C),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);const I=this.getInternalFormat();this.precision==="single"?b.texStorage2D(b.TEXTURE_2D,1,I,v[0],v[1]):b.texImage2D(b.TEXTURE_2D,0,b.RGBA,v[0],v[1],0,b.RGBA,b.UNSIGNED_BYTE,null),b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0+y+1,b.TEXTURE_2D,C,0),this.mappedTextures.push(new this.TextureConstructor({texture:C,size:v,dimensions:this.threadDim,output:this.output,context:this.context,internalFormat:this.getInternalFormat(),textureFormat:this.getTextureFormat(),kernel:this}))}}_getHeaderString(){return""}_getTextureCoordinate(){const b=this.subKernels,v=this.getVariablePrecisionString(this.texSize,this.tactic);return b===null||b.length<1?`in ${v} vec2 vTexCoord;
`:`out ${v} vec2 vTexCoord;
`}_getMainArgumentsString(b){const v=[],y=this.argumentNames;for(let C=0;C<y.length;C++)v.push(this.kernelArguments[C].getSource(b[C]));return v.join("")}getKernelString(){const b=[this.getKernelResultDeclaration()],v=this.subKernels;if(v!==null)switch(b.push("layout(location = 0) out vec4 data0"),this.returnType){case"Number":case"Float":case"Integer":for(let y=0;y<v.length;y++){const C=v[y];b.push(C.returnType==="Integer"?`int subKernelResult_${C.name} = 0`:`float subKernelResult_${C.name} = 0.0`,`layout(location = ${y+1}) out vec4 data${y+1}`)}break;case"Array(2)":for(let y=0;y<v.length;y++)b.push(`vec2 subKernelResult_${v[y].name}`,`layout(location = ${y+1}) out vec4 data${y+1}`);break;case"Array(3)":for(let y=0;y<v.length;y++)b.push(`vec3 subKernelResult_${v[y].name}`,`layout(location = ${y+1}) out vec4 data${y+1}`);break;case"Array(4)":for(let y=0;y<v.length;y++)b.push(`vec4 subKernelResult_${v[y].name}`,`layout(location = ${y+1}) out vec4 data${y+1}`);break}else b.push("out vec4 data0");return l.linesToString(b)+this.translatedSource}getMainResultGraphical(){return l.linesToString(["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0 = actualColor"])}getMainResultPackedPixels(){switch(this.returnType){case"LiteralInteger":case"Number":case"Integer":case"Float":return this.getMainResultKernelPackedPixels()+this.getMainResultSubKernelPackedPixels();default:throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`)}}getMainResultKernelPackedPixels(){return l.linesToString(["  threadId = indexTo3D(index, uOutputDim)","  kernel()",`  data0 = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(kernelResult)`])}getMainResultSubKernelPackedPixels(){const b=[];if(!this.subKernels)return"";for(let v=0;v<this.subKernels.length;v++)this.subKernels[v].returnType==="Integer"?b.push(`  data${v+1} = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(float(subKernelResult_${this.subKernels[v].name}))`):b.push(`  data${v+1} = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(subKernelResult_${this.subKernels[v].name})`);return l.linesToString(b)}getMainResultKernelMemoryOptimizedFloats(b,v){b.push("  threadId = indexTo3D(index, uOutputDim)","  kernel()",`  data0.${v} = kernelResult`)}getMainResultSubKernelMemoryOptimizedFloats(b,v){if(!this.subKernels)return b;for(let y=0;y<this.subKernels.length;y++){const C=this.subKernels[y];C.returnType==="Integer"?b.push(`  data${y+1}.${v} = float(subKernelResult_${C.name})`):b.push(`  data${y+1}.${v} = subKernelResult_${C.name}`)}}getMainResultKernelNumberTexture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0[0] = kernelResult"]}getMainResultSubKernelNumberTexture(){const b=[];if(!this.subKernels)return b;for(let v=0;v<this.subKernels.length;++v){const y=this.subKernels[v];y.returnType==="Integer"?b.push(`  data${v+1}[0] = float(subKernelResult_${y.name})`):b.push(`  data${v+1}[0] = subKernelResult_${y.name}`)}return b}getMainResultKernelArray2Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0[0] = kernelResult[0]","  data0[1] = kernelResult[1]"]}getMainResultSubKernelArray2Texture(){const b=[];if(!this.subKernels)return b;for(let v=0;v<this.subKernels.length;++v){const y=this.subKernels[v];b.push(`  data${v+1}[0] = subKernelResult_${y.name}[0]`,`  data${v+1}[1] = subKernelResult_${y.name}[1]`)}return b}getMainResultKernelArray3Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0[0] = kernelResult[0]","  data0[1] = kernelResult[1]","  data0[2] = kernelResult[2]"]}getMainResultSubKernelArray3Texture(){const b=[];if(!this.subKernels)return b;for(let v=0;v<this.subKernels.length;++v){const y=this.subKernels[v];b.push(`  data${v+1}[0] = subKernelResult_${y.name}[0]`,`  data${v+1}[1] = subKernelResult_${y.name}[1]`,`  data${v+1}[2] = subKernelResult_${y.name}[2]`)}return b}getMainResultKernelArray4Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0 = kernelResult"]}getMainResultSubKernelArray4Texture(){const b=[];if(!this.subKernels)return b;for(let v=0;v<this.subKernels.length;++v)b.push(`  data${v+1} = subKernelResult_${this.subKernels[v].name}`);return b}destroyExtensions(){this.extensions.EXT_color_buffer_float=null,this.extensions.OES_texture_float_linear=null}toJSON(){const b=super.toJSON();return b.functionNodes=a.fromKernel(this,o).toJSON(),b.settings.threadDim=this.threadDim,b}}s.exports={WebGL2Kernel:m}},{"../../utils":114,"../function-builder":9,"../web-gl/kernel":70,"./fragment-shader":72,"./function-node":73,"./kernel-value-maps":74,"./vertex-shader":106}],106:[function(n,s,r){const i=`#version 300 es
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

in vec2 aPos;
in vec2 aTexCoord;

out vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;s.exports={vertexShader:i}},{}],107:[function(n,s,r){const i=n("./index"),o=i.GPU;for(const l in i)i.hasOwnProperty(l)&&l!=="GPU"&&(o[l]=i[l]);typeof window<"u"&&a(window),typeof self<"u"&&a(self);function a(l){l.GPU||Object.defineProperty(l,"GPU",{get(){return o}})}s.exports=i},{"./index":109}],108:[function(n,s,r){const{gpuMock:i}=n("gpu-mock.js"),{utils:o}=n("./utils"),{Kernel:a}=n("./backend/kernel"),{CPUKernel:l}=n("./backend/cpu/kernel"),{HeadlessGLKernel:u}=n("./backend/headless-gl/kernel"),{WebGL2Kernel:c}=n("./backend/web-gl2/kernel"),{WebGLKernel:h}=n("./backend/web-gl/kernel"),{kernelRunShortcut:d}=n("./kernel-run-shortcut"),f=[u,c,h],p=["gpu","cpu"],g={headlessgl:u,webgl2:c,webgl:h};let m=!0;class x{static disableValidation(){m=!1}static enableValidation(){m=!0}static get isGPUSupported(){return f.some(y=>y.isSupported)}static get isKernelMapSupported(){return f.some(y=>y.isSupported&&y.features.kernelMap)}static get isOffscreenCanvasSupported(){return typeof Worker<"u"&&typeof OffscreenCanvas<"u"||typeof importScripts<"u"}static get isWebGLSupported(){return h.isSupported}static get isWebGL2Supported(){return c.isSupported}static get isHeadlessGLSupported(){return u.isSupported}static get isCanvasSupported(){return typeof HTMLCanvasElement<"u"}static get isGPUHTMLImageArraySupported(){return c.isSupported}static get isSinglePrecisionSupported(){return f.some(y=>y.isSupported&&y.features.isFloatRead&&y.features.isTextureFloat)}constructor(y){if(y=y||{},this.canvas=y.canvas||null,this.context=y.context||null,this.mode=y.mode,this.Kernel=null,this.kernels=[],this.functions=[],this.nativeFunctions=[],this.injectedNative=null,this.mode!=="dev"){if(this.chooseKernel(),y.functions)for(let C=0;C<y.functions.length;C++)this.addFunction(y.functions[C]);if(y.nativeFunctions)for(const C in y.nativeFunctions){if(!y.nativeFunctions.hasOwnProperty(C))continue;const I=y.nativeFunctions[C],{name:$,source:T}=I;this.addNativeFunction($,T,I)}}}chooseKernel(){if(this.Kernel)return;let y=null;if(this.context){for(let C=0;C<f.length;C++){const I=f[C];if(I.isContextMatch(this.context)){if(!I.isSupported)throw new Error(`Kernel type ${I.name} not supported`);y=I;break}}if(y===null)throw new Error("unknown Context")}else if(this.mode){if(this.mode in g)(!m||g[this.mode].isSupported)&&(y=g[this.mode]);else if(this.mode==="gpu"){for(let C=0;C<f.length;C++)if(f[C].isSupported){y=f[C];break}}else this.mode==="cpu"&&(y=l);if(!y)throw new Error(`A requested mode of "${this.mode}" and is not supported`)}else{for(let C=0;C<f.length;C++)if(f[C].isSupported){y=f[C];break}y||(y=l)}this.mode||(this.mode=y.mode),this.Kernel=y}createKernel(y,C){if(typeof y>"u")throw new Error("Missing source parameter");if(typeof y!="object"&&!o.isFunction(y)&&typeof y!="string")throw new Error("source parameter not a function");const I=this.kernels;if(this.mode==="dev"){const M=i(y,b(C));return I.push(M),M}y=typeof y=="function"?y.toString():y;const $={},T=b(C)||{};C&&typeof C.argumentTypes=="object"&&(T.argumentTypes=Object.keys(C.argumentTypes).map(M=>C.argumentTypes[M]));function S(M){console.warn("Falling back to CPU");const z=new l(y,{argumentTypes:P.argumentTypes,constantTypes:P.constantTypes,graphical:P.graphical,loopMaxIterations:P.loopMaxIterations,constants:P.constants,dynamicOutput:P.dynamicOutput,dynamicArgument:P.dynamicArguments,output:P.output,precision:P.precision,pipeline:P.pipeline,immutable:P.immutable,optimizeFloatMemory:P.optimizeFloatMemory,fixIntegerDivisionAccuracy:P.fixIntegerDivisionAccuracy,functions:P.functions,nativeFunctions:P.nativeFunctions,injectedNative:P.injectedNative,subKernels:P.subKernels,strictIntegers:P.strictIntegers,debug:P.debug});z.build.apply(z,M);const A=z.run.apply(z,M);return P.replaceKernel(z),A}function E(M,z,A){A.debug&&console.warn("Switching kernels");let B=null;if(A.signature&&!$[A.signature]&&($[A.signature]=A),A.dynamicOutput)for(let se=M.length-1;se>=0;se--){const fe=M[se];fe.type==="outputPrecisionMismatch"&&(B=fe.needed)}const L=A.constructor,U=L.getArgumentTypes(A,z),j=L.getSignature(A,U),Z=$[j];if(Z)return Z.onActivate(A),Z;const J=$[j]=new L(y,{argumentTypes:U,constantTypes:A.constantTypes,graphical:A.graphical,loopMaxIterations:A.loopMaxIterations,constants:A.constants,dynamicOutput:A.dynamicOutput,dynamicArgument:A.dynamicArguments,context:A.context,canvas:A.canvas,output:B||A.output,precision:A.precision,pipeline:A.pipeline,immutable:A.immutable,optimizeFloatMemory:A.optimizeFloatMemory,fixIntegerDivisionAccuracy:A.fixIntegerDivisionAccuracy,functions:A.functions,nativeFunctions:A.nativeFunctions,injectedNative:A.injectedNative,subKernels:A.subKernels,strictIntegers:A.strictIntegers,debug:A.debug,gpu:A.gpu,validate:m,returnType:A.returnType,tactic:A.tactic,onRequestFallback:S,onRequestSwitchKernel:E,texture:A.texture,mappedTextures:A.mappedTextures,drawBuffersMap:A.drawBuffersMap});return J.build.apply(J,z),P.replaceKernel(J),I.push(J),J}const _=Object.assign({context:this.context,canvas:this.canvas,functions:this.functions,nativeFunctions:this.nativeFunctions,injectedNative:this.injectedNative,gpu:this,validate:m,onRequestFallback:S,onRequestSwitchKernel:E},T),N=new this.Kernel(y,_),P=d(N);return this.canvas||(this.canvas=N.canvas),this.context||(this.context=N.context),I.push(N),P}createKernelMap(){let y,C;const I=typeof arguments[arguments.length-2];if(I==="function"||I==="string"?(y=arguments[arguments.length-2],C=arguments[arguments.length-1]):y=arguments[arguments.length-1],this.mode!=="dev"&&(!this.Kernel.isSupported||!this.Kernel.features.kernelMap)&&this.mode&&p.indexOf(this.mode)<0)throw new Error(`kernelMap not supported on ${this.Kernel.name}`);const $=b(C);if(C&&typeof C.argumentTypes=="object"&&($.argumentTypes=Object.keys(C.argumentTypes).map(T=>C.argumentTypes[T])),Array.isArray(arguments[0])){$.subKernels=[];const T=arguments[0];for(let S=0;S<T.length;S++){const E=T[S].toString(),_=o.getFunctionNameFromString(E);$.subKernels.push({name:_,source:E,property:S})}}else{$.subKernels=[];const T=arguments[0];for(let S in T){if(!T.hasOwnProperty(S))continue;const E=T[S].toString(),_=o.getFunctionNameFromString(E);$.subKernels.push({name:_||S,source:E,property:S})}}return this.createKernel(y,$)}combineKernels(){const y=arguments[0],C=arguments[arguments.length-1];if(y.kernel.constructor.mode==="cpu")return C;const I=arguments[0].canvas,$=arguments[0].context,T=arguments.length-1;for(let S=0;S<T;S++)arguments[S].setCanvas(I).setContext($).setPipeline(!0);return function(){const S=C.apply(this,arguments);return S.toArray?S.toArray():S}}setFunctions(y){return this.functions=y,this}setNativeFunctions(y){return this.nativeFunctions=y,this}addFunction(y,C){return this.functions.push({source:y,settings:C}),this}addNativeFunction(y,C,I){if(this.kernels.length>0)throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');return this.nativeFunctions.push(Object.assign({name:y,source:C},I)),this}injectNative(y){return this.injectedNative=y,this}destroy(){return new Promise((y,C)=>{this.kernels||y(),setTimeout(()=>{try{for(let $=0;$<this.kernels.length;$++)this.kernels[$].destroy(!0);let I=this.kernels[0];I&&(I.kernel&&(I=I.kernel),I.constructor.destroyContext&&I.constructor.destroyContext(this.context))}catch(I){C(I)}y()},0)})}}function b(v){if(!v)return{};const y=Object.assign({},v);return v.hasOwnProperty("floatOutput")&&(o.warnDeprecated("setting","floatOutput","precision"),y.precision=v.floatOutput?"single":"unsigned"),v.hasOwnProperty("outputToTexture")&&(o.warnDeprecated("setting","outputToTexture","pipeline"),y.pipeline=!!v.outputToTexture),v.hasOwnProperty("outputImmutable")&&(o.warnDeprecated("setting","outputImmutable","immutable"),y.immutable=!!v.outputImmutable),v.hasOwnProperty("floatTextures")&&(o.warnDeprecated("setting","floatTextures","optimizeFloatMemory"),y.optimizeFloatMemory=!!v.floatTextures),y}s.exports={GPU:x,kernelOrder:f,kernelTypes:p}},{"./backend/cpu/kernel":8,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/kernel":70,"./backend/web-gl2/kernel":105,"./kernel-run-shortcut":111,"./utils":114,"gpu-mock.js":4}],109:[function(n,s,r){const{GPU:i}=n("./gpu"),{alias:o}=n("./alias"),{utils:a}=n("./utils"),{Input:l,input:u}=n("./input"),{Texture:c}=n("./texture"),{FunctionBuilder:h}=n("./backend/function-builder"),{FunctionNode:d}=n("./backend/function-node"),{CPUFunctionNode:f}=n("./backend/cpu/function-node"),{CPUKernel:p}=n("./backend/cpu/kernel"),{HeadlessGLKernel:g}=n("./backend/headless-gl/kernel"),{WebGLFunctionNode:m}=n("./backend/web-gl/function-node"),{WebGLKernel:x}=n("./backend/web-gl/kernel"),{kernelValueMaps:b}=n("./backend/web-gl/kernel-value-maps"),{WebGL2FunctionNode:v}=n("./backend/web-gl2/function-node"),{WebGL2Kernel:y}=n("./backend/web-gl2/kernel"),{kernelValueMaps:C}=n("./backend/web-gl2/kernel-value-maps"),{GLKernel:I}=n("./backend/gl/kernel"),{Kernel:$}=n("./backend/kernel"),{FunctionTracer:T}=n("./backend/function-tracer"),S=n("./plugins/math-random-uniformly-distributed");s.exports={alias:o,CPUFunctionNode:f,CPUKernel:p,GPU:i,FunctionBuilder:h,FunctionNode:d,HeadlessGLKernel:g,Input:l,input:u,Texture:c,utils:a,WebGL2FunctionNode:v,WebGL2Kernel:y,webGL2KernelValueMaps:C,WebGLFunctionNode:m,WebGLKernel:x,webGLKernelValueMaps:b,GLKernel:I,Kernel:$,FunctionTracer:T,plugins:{mathRandom:S}}},{"./alias":5,"./backend/cpu/function-node":6,"./backend/cpu/kernel":8,"./backend/function-builder":9,"./backend/function-node":10,"./backend/function-tracer":11,"./backend/gl/kernel":13,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/function-node":38,"./backend/web-gl/kernel":70,"./backend/web-gl/kernel-value-maps":39,"./backend/web-gl2/function-node":73,"./backend/web-gl2/kernel":105,"./backend/web-gl2/kernel-value-maps":74,"./gpu":108,"./input":110,"./plugins/math-random-uniformly-distributed":112,"./texture":113,"./utils":114}],110:[function(n,s,r){class i{constructor(l,u){this.value=l,Array.isArray(u)?this.size=u:(this.size=new Int32Array(3),u.z?this.size=new Int32Array([u.x,u.y,u.z]):u.y?this.size=new Int32Array([u.x,u.y]):this.size=new Int32Array([u.x]));const[c,h,d]=this.size;if(d){if(this.value.length!==c*h*d)throw new Error(`Input size ${this.value.length} does not match ${c} * ${h} * ${d} = ${h*c*d}`)}else if(h){if(this.value.length!==c*h)throw new Error(`Input size ${this.value.length} does not match ${c} * ${h} = ${h*c}`)}else if(this.value.length!==c)throw new Error(`Input size ${this.value.length} does not match ${c}`)}toArray(){const{utils:l}=n("./utils"),[u,c,h]=this.size;return h?l.erectMemoryOptimized3DFloat(this.value.subarray?this.value:new Float32Array(this.value),u,c,h):c?l.erectMemoryOptimized2DFloat(this.value.subarray?this.value:new Float32Array(this.value),u,c):this.value}}function o(a,l){return new i(a,l)}s.exports={Input:i,input:o}},{"./utils":114}],111:[function(n,s,r){const{utils:i}=n("./utils");function o(l){let u=function(){return l.build.apply(l,arguments),u=function(){let h=l.run.apply(l,arguments);if(l.switchingKernels){const d=l.resetSwitchingKernels(),f=l.onRequestSwitchKernel(d,arguments,l);c.kernel=l=f,h=f.run.apply(f,arguments)}return l.renderKernels?l.renderKernels():l.renderOutput?l.renderOutput():h},u.apply(l,arguments)};const c=function(){return u.apply(l,arguments)};return c.exec=function(){return new Promise((h,d)=>{try{h(u.apply(this,arguments))}catch(f){d(f)}})},c.replaceKernel=function(h){l=h,a(l,c)},a(l,c),c}function a(l,u){if(u.kernel){u.kernel=l;return}const c=i.allPropertiesOf(l);for(let h=0;h<c.length;h++){const d=c[h];d[0]==="_"&&d[1]==="_"||(typeof l[d]=="function"?d.substring(0,3)==="add"||d.substring(0,3)==="set"?u[d]=function(){return u.kernel[d].apply(u.kernel,arguments),u}:u[d]=function(){return u.kernel[d].apply(u.kernel,arguments)}:(u.__defineGetter__(d,()=>u.kernel[d]),u.__defineSetter__(d,f=>{u.kernel[d]=f})))}u.kernel=l}s.exports={kernelRunShortcut:o}},{"./utils":114}],112:[function(n,s,r){const h={name:"math-random-uniformly-distributed",onBeforeRun:d=>{d.setUniform1f("randomSeed1",Math.random()),d.setUniform1f("randomSeed2",Math.random())},functionMatch:"Math.random()",functionReplace:"nrand(vTexCoord)",functionReturnType:"Number",source:`// https://www.shadertoy.com/view/4t2SDh
//note: uniformly distributed, normalized rand, [0,1]
highp float randomSeedShift = 1.0;
highp float slide = 1.0;
uniform highp float randomSeed1;
uniform highp float randomSeed2;

highp float nrand(highp vec2 n) {
  highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);
  randomSeedShift = result;
  if (randomSeedShift > 0.5) {
    slide += 0.00009; 
  } else {
    slide += 0.0009;
  }
  return result;
}`};s.exports=h},{}],113:[function(n,s,r){class i{constructor(a){const{texture:l,size:u,dimensions:c,output:h,context:d,type:f="NumberTexture",kernel:p,internalFormat:g,textureFormat:m}=a;if(!h)throw new Error('settings property "output" required.');if(!d)throw new Error('settings property "context" required.');if(!l)throw new Error('settings property "texture" required.');if(!p)throw new Error('settings property "kernel" required.');this.texture=l,l._refs?l._refs++:l._refs=1,this.size=u,this.dimensions=c,this.output=h,this.context=d,this.kernel=p,this.type=f,this._deleted=!1,this.internalFormat=g,this.textureFormat=m}toArray(){throw new Error(`Not implemented on ${this.constructor.name}`)}clone(){throw new Error(`Not implemented on ${this.constructor.name}`)}delete(){throw new Error(`Not implemented on ${this.constructor.name}`)}clear(){throw new Error(`Not implemented on ${this.constructor.name}`)}}s.exports={Texture:i}},{}],114:[function(n,s,r){const i=n("acorn"),{Input:o}=n("./input"),{Texture:a}=n("./texture"),l=/function ([^(]*)/,u=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,c=/([^\s,]+)/g,h={systemEndianness(){return g},getSystemEndianness(){const m=new ArrayBuffer(4),x=new Uint32Array(m),b=new Uint8Array(m);if(x[0]=3735928559,b[0]===239)return"LE";if(b[0]===222)return"BE";throw new Error("unknown endianness")},isFunction(m){return typeof m=="function"},isFunctionString(m){return typeof m=="string"?m.slice(0,8).toLowerCase()==="function":!1},getFunctionNameFromString(m){const x=l.exec(m);return!x||x.length===0?null:x[1].trim()},getFunctionBodyFromString(m){return m.substring(m.indexOf("{")+1,m.lastIndexOf("}"))},getArgumentNamesFromString(m){const x=m.replace(u,"");let b=x.slice(x.indexOf("(")+1,x.indexOf(")")).match(c);return b===null&&(b=[]),b},clone(m){if(m===null||typeof m!="object"||m.hasOwnProperty("isActiveClone"))return m;const x=m.constructor();for(let b in m)Object.prototype.hasOwnProperty.call(m,b)&&(m.isActiveClone=null,x[b]=h.clone(m[b]),delete m.isActiveClone);return x},isArray(m){return!isNaN(m.length)},getVariableType(m,x){if(h.isArray(m))return m.length>0&&m[0].nodeName==="IMG"?"HTMLImageArray":"Array";switch(m.constructor){case Boolean:return"Boolean";case Number:return x&&Number.isInteger(m)?"Integer":"Float";case a:return m.type;case o:return"Input"}if("nodeName"in m)switch(m.nodeName){case"IMG":return"HTMLImage";case"CANVAS":return"HTMLImage";case"VIDEO":return"HTMLVideo"}else{if(m.hasOwnProperty("type"))return m.type;if(typeof OffscreenCanvas<"u"&&m instanceof OffscreenCanvas)return"OffscreenCanvas";if(typeof ImageBitmap<"u"&&m instanceof ImageBitmap)return"ImageBitmap";if(typeof ImageData<"u"&&m instanceof ImageData)return"ImageData"}return"Unknown"},getKernelTextureSize(m,x){let[b,v,y]=x,C=(b||1)*(v||1)*(y||1);return m.optimizeFloatMemory&&m.precision==="single"&&(b=C=Math.ceil(C/4)),v>1&&b*v===C?new Int32Array([b,v]):h.closestSquareDimensions(C)},closestSquareDimensions(m){const x=Math.sqrt(m);let b=Math.ceil(x),v=Math.floor(x);for(;b*v<m;)b--,v=Math.ceil(m/b);return new Int32Array([v,Math.ceil(m/v)])},getMemoryOptimizedFloatTextureSize(m,x){const v=h.roundTo((m[0]||1)*(m[1]||1)*(m[2]||1)*(m[3]||1),4)/x;return h.closestSquareDimensions(v)},getMemoryOptimizedPackedTextureSize(m,x){const[b,v,y]=m,I=h.roundTo((b||1)*(v||1)*(y||1),4)/(4/x);return h.closestSquareDimensions(I)},roundTo(m,x){return Math.floor((m+x-1)/x)*x},getDimensions(m,x){let b;if(h.isArray(m)){const v=[];let y=m;for(;h.isArray(y);)v.push(y.length),y=y[0];b=v.reverse()}else if(m instanceof a)b=m.output;else if(m instanceof o)b=m.size;else throw new Error(`Unknown dimensions of ${m}`);if(x)for(b=Array.from(b);b.length<3;)b.push(1);return new Int32Array(b)},flatten2dArrayTo(m,x){let b=0;for(let v=0;v<m.length;v++)x.set(m[v],b),b+=m[v].length},flatten3dArrayTo(m,x){let b=0;for(let v=0;v<m.length;v++)for(let y=0;y<m[v].length;y++)x.set(m[v][y],b),b+=m[v][y].length},flatten4dArrayTo(m,x){let b=0;for(let v=0;v<m.length;v++)for(let y=0;y<m[v].length;y++)for(let C=0;C<m[v][y].length;C++)x.set(m[v][y][C],b),b+=m[v][y][C].length},flattenTo(m,x){h.isArray(m[0])?h.isArray(m[0][0])?h.isArray(m[0][0][0])?h.flatten4dArrayTo(m,x):h.flatten3dArrayTo(m,x):h.flatten2dArrayTo(m,x):x.set(m)},splitArray(m,x){const b=[];for(let v=0;v<m.length;v+=x)b.push(new m.constructor(m.buffer,v*4+m.byteOffset,x));return b},getAstString(m,x){const b=Array.isArray(m)?m:m.split(/\r?\n/g),v=x.loc.start,y=x.loc.end,C=[];if(v.line===y.line)C.push(b[v.line-1].substring(v.column,y.column));else{C.push(b[v.line-1].slice(v.column));for(let I=v.line;I<y.line;I++)C.push(b[I]);C.push(b[y.line-1].slice(0,y.column))}return C.join(`
`)},allPropertiesOf(m){const x=[];do x.push.apply(x,Object.getOwnPropertyNames(m));while(m=Object.getPrototypeOf(m));return x},linesToString(m){return m.length>0?m.join(`;
`)+`;
`:`
`},warnDeprecated(m,x,b){console.warn(b?`You are using a deprecated ${m} "${x}". It has been replaced with "${b}". Fixing, but please upgrade as it will soon be removed.`:`You are using a deprecated ${m} "${x}". It has been removed. Fixing, but please upgrade as it will soon be removed.`)},flipPixels:(m,x,b)=>{const v=b/2|0,y=x*4,C=new Uint8ClampedArray(x*4),I=m.slice(0);for(let $=0;$<v;++$){const T=$*y,S=(b-$-1)*y;C.set(I.subarray(T,T+y)),I.copyWithin(T,S,S+y),I.set(C,S)}return I},erectPackedFloat:(m,x)=>m.subarray(0,x),erect2DPackedFloat:(m,x,b)=>{const v=new Array(b);for(let y=0;y<b;y++){const C=y*x,I=C+x;v[y]=m.subarray(C,I)}return v},erect3DPackedFloat:(m,x,b,v)=>{const y=new Array(v);for(let C=0;C<v;C++){const I=new Array(b);for(let $=0;$<b;$++){const T=C*b*x+$*x,S=T+x;I[$]=m.subarray(T,S)}y[C]=I}return y},erectMemoryOptimizedFloat:(m,x)=>m.subarray(0,x),erectMemoryOptimized2DFloat:(m,x,b)=>{const v=new Array(b);for(let y=0;y<b;y++){const C=y*x;v[y]=m.subarray(C,C+x)}return v},erectMemoryOptimized3DFloat:(m,x,b,v)=>{const y=new Array(v);for(let C=0;C<v;C++){const I=new Array(b);for(let $=0;$<b;$++){const T=C*b*x+$*x;I[$]=m.subarray(T,T+x)}y[C]=I}return y},erectFloat:(m,x)=>{const b=new Float32Array(x);let v=0;for(let y=0;y<x;y++)b[y]=m[v],v+=4;return b},erect2DFloat:(m,x,b)=>{const v=new Array(b);let y=0;for(let C=0;C<b;C++){const I=new Float32Array(x);for(let $=0;$<x;$++)I[$]=m[y],y+=4;v[C]=I}return v},erect3DFloat:(m,x,b,v)=>{const y=new Array(v);let C=0;for(let I=0;I<v;I++){const $=new Array(b);for(let T=0;T<b;T++){const S=new Float32Array(x);for(let E=0;E<x;E++)S[E]=m[C],C+=4;$[T]=S}y[I]=$}return y},erectArray2:(m,x)=>{const b=new Array(x),v=x*4;let y=0;for(let C=0;C<v;C+=4)b[y++]=m.subarray(C,C+2);return b},erect2DArray2:(m,x,b)=>{const v=new Array(b),y=x*4;for(let C=0;C<b;C++){const I=new Array(x),$=C*y;let T=0;for(let S=0;S<y;S+=4)I[T++]=m.subarray(S+$,S+$+2);v[C]=I}return v},erect3DArray2:(m,x,b,v)=>{const y=x*4,C=new Array(v);for(let I=0;I<v;I++){const $=new Array(b);for(let T=0;T<b;T++){const S=new Array(x),E=I*y*b+T*y;let _=0;for(let N=0;N<y;N+=4)S[_++]=m.subarray(N+E,N+E+2);$[T]=S}C[I]=$}return C},erectArray3:(m,x)=>{const b=new Array(x),v=x*4;let y=0;for(let C=0;C<v;C+=4)b[y++]=m.subarray(C,C+3);return b},erect2DArray3:(m,x,b)=>{const v=x*4,y=new Array(b);for(let C=0;C<b;C++){const I=new Array(x),$=C*v;let T=0;for(let S=0;S<v;S+=4)I[T++]=m.subarray(S+$,S+$+3);y[C]=I}return y},erect3DArray3:(m,x,b,v)=>{const y=x*4,C=new Array(v);for(let I=0;I<v;I++){const $=new Array(b);for(let T=0;T<b;T++){const S=new Array(x),E=I*y*b+T*y;let _=0;for(let N=0;N<y;N+=4)S[_++]=m.subarray(N+E,N+E+3);$[T]=S}C[I]=$}return C},erectArray4:(m,x)=>{const b=new Array(m),v=x*4;let y=0;for(let C=0;C<v;C+=4)b[y++]=m.subarray(C,C+4);return b},erect2DArray4:(m,x,b)=>{const v=x*4,y=new Array(b);for(let C=0;C<b;C++){const I=new Array(x),$=C*v;let T=0;for(let S=0;S<v;S+=4)I[T++]=m.subarray(S+$,S+$+4);y[C]=I}return y},erect3DArray4:(m,x,b,v)=>{const y=x*4,C=new Array(v);for(let I=0;I<v;I++){const $=new Array(b);for(let T=0;T<b;T++){const S=new Array(x),E=I*y*b+T*y;let _=0;for(let N=0;N<y;N+=4)S[_++]=m.subarray(N+E,N+E+4);$[T]=S}C[I]=$}return C},flattenFunctionToString:(m,x)=>{const{findDependency:b,thisLookup:v,doNotDefine:y}=x;let C=x.flattened;C||(C=x.flattened={});const I=i.parse(m),$=[];let T=0;function S(_){if(Array.isArray(_)){const N=[];for(let P=0;P<_.length;P++)N.push(S(_[P]));return N.join("")}switch(_.type){case"Program":return S(_.body)+(_.body[0].type==="VariableDeclaration"?";":"");case"FunctionDeclaration":return`function ${_.id.name}(${_.params.map(S).join(", ")}) ${S(_.body)}`;case"BlockStatement":{const P=[];T+=2;for(let M=0;M<_.body.length;M++){const z=S(_.body[M]);z&&P.push(" ".repeat(T)+z,`;
`)}return T-=2,`{
${P.join("")}}`}case"VariableDeclaration":const N=h.normalizeDeclarations(_).map(S).filter(P=>P!==null);return N.length<1?"":`${_.kind} ${N.join(",")}`;case"VariableDeclarator":return _.init.object&&_.init.object.type==="ThisExpression"?v(_.init.property.name,!0)?`${_.id.name} = ${S(_.init)}`:null:`${_.id.name} = ${S(_.init)}`;case"CallExpression":{if(_.callee.property.name==="subarray")return`${S(_.callee.object)}.${S(_.callee.property)}(${_.arguments.map(P=>S(P)).join(", ")})`;if(_.callee.object.name==="gl"||_.callee.object.name==="context")return`${S(_.callee.object)}.${S(_.callee.property)}(${_.arguments.map(P=>S(P)).join(", ")})`;if(_.callee.object.type==="ThisExpression")return $.push(b("this",_.callee.property.name)),`${_.callee.property.name}(${_.arguments.map(P=>S(P)).join(", ")})`;if(_.callee.object.name){const P=b(_.callee.object.name,_.callee.property.name);return P===null?`${_.callee.object.name}.${_.callee.property.name}(${_.arguments.map(M=>S(M)).join(", ")})`:($.push(P),`${_.callee.property.name}(${_.arguments.map(M=>S(M)).join(", ")})`)}else{if(_.callee.object.type==="MemberExpression")return`${S(_.callee.object)}.${_.callee.property.name}(${_.arguments.map(P=>S(P)).join(", ")})`;throw new Error("unknown ast.callee")}}case"ReturnStatement":return`return ${S(_.argument)}`;case"BinaryExpression":return`(${S(_.left)}${_.operator}${S(_.right)})`;case"UnaryExpression":return _.prefix?`${_.operator} ${S(_.argument)}`:`${S(_.argument)} ${_.operator}`;case"ExpressionStatement":return`${S(_.expression)}`;case"SequenceExpression":return`(${S(_.expressions)})`;case"ArrowFunctionExpression":return`(${_.params.map(S).join(", ")}) => ${S(_.body)}`;case"Literal":return _.raw;case"Identifier":return _.name;case"MemberExpression":return _.object.type==="ThisExpression"?v(_.property.name):_.computed?`${S(_.object)}[${S(_.property)}]`:S(_.object)+"."+S(_.property);case"ThisExpression":return"this";case"NewExpression":return`new ${S(_.callee)}(${_.arguments.map(P=>S(P)).join(", ")})`;case"ForStatement":return`for (${S(_.init)};${S(_.test)};${S(_.update)}) ${S(_.body)}`;case"AssignmentExpression":return`${S(_.left)}${_.operator}${S(_.right)}`;case"UpdateExpression":return`${S(_.argument)}${_.operator}`;case"IfStatement":return`if (${S(_.test)}) ${S(_.consequent)}`;case"ThrowStatement":return`throw ${S(_.argument)}`;case"ObjectPattern":return _.properties.map(S).join(", ");case"ArrayPattern":return _.elements.map(S).join(", ");case"DebuggerStatement":return"debugger;";case"ConditionalExpression":return`${S(_.test)}?${S(_.consequent)}:${S(_.alternate)}`;case"Property":if(_.kind==="init")return S(_.key)}throw new Error(`unhandled ast.type of ${_.type}`)}const E=S(I);if($.length>0){const _=[];for(let N=0;N<$.length;N++){const P=$[N];C[P]||(C[P]=!0),P&&_.push(h.flattenFunctionToString(P,x)+`
`)}return _.join("")+E}return E},normalizeDeclarations:m=>{if(m.type!=="VariableDeclaration")throw new Error('Ast is not of type "VariableDeclaration"');const x=[];for(let b=0;b<m.declarations.length;b++){const v=m.declarations[b];if(v.id&&v.id.type==="ObjectPattern"&&v.id.properties){const{properties:y}=v.id;for(let C=0;C<y.length;C++){const I=y[C];if(I.value.type==="ObjectPattern"&&I.value.properties)for(let $=0;$<I.value.properties.length;$++){const T=I.value.properties[$];if(T.type==="Property")x.push({type:"VariableDeclarator",id:{type:"Identifier",name:T.key.name},init:{type:"MemberExpression",object:{type:"MemberExpression",object:v.init,property:{type:"Identifier",name:I.key.name},computed:!1},property:{type:"Identifier",name:T.key.name},computed:!1}});else throw new Error("unexpected state")}else if(I.value.type==="Identifier")x.push({type:"VariableDeclarator",id:{type:"Identifier",name:I.value&&I.value.name?I.value.name:I.key.name},init:{type:"MemberExpression",object:v.init,property:{type:"Identifier",name:I.key.name},computed:!1}});else throw new Error("unexpected state")}}else if(v.id&&v.id.type==="ArrayPattern"&&v.id.elements){const{elements:y}=v.id;for(let C=0;C<y.length;C++){const I=y[C];if(I.type==="Identifier")x.push({type:"VariableDeclarator",id:{type:"Identifier",name:I.name},init:{type:"MemberExpression",object:v.init,property:{type:"Literal",value:C,raw:C.toString(),start:I.start,end:I.end},computed:!0}});else throw new Error("unexpected state")}}else x.push(v)}return x},splitHTMLImageToRGB:(m,x)=>{const b=m.createKernel(function($){return $[this.thread.y][this.thread.x].r*255},{output:[x.width,x.height],precision:"unsigned",argumentTypes:{a:"HTMLImage"}}),v=m.createKernel(function($){return $[this.thread.y][this.thread.x].g*255},{output:[x.width,x.height],precision:"unsigned",argumentTypes:{a:"HTMLImage"}}),y=m.createKernel(function($){return $[this.thread.y][this.thread.x].b*255},{output:[x.width,x.height],precision:"unsigned",argumentTypes:{a:"HTMLImage"}}),C=m.createKernel(function($){return $[this.thread.y][this.thread.x].a*255},{output:[x.width,x.height],precision:"unsigned",argumentTypes:{a:"HTMLImage"}}),I=[b(x),v(x),y(x),C(x)];return I.rKernel=b,I.gKernel=v,I.bKernel=y,I.aKernel=C,I.gpu=m,I},splitRGBAToCanvases:(m,x,b,v)=>{const y=m.createKernel(function(T){const S=T[this.thread.y][this.thread.x];this.color(S.r/255,0,0,255)},{output:[b,v],graphical:!0,argumentTypes:{v:"Array2D(4)"}});y(x);const C=m.createKernel(function(T){const S=T[this.thread.y][this.thread.x];this.color(0,S.g/255,0,255)},{output:[b,v],graphical:!0,argumentTypes:{v:"Array2D(4)"}});C(x);const I=m.createKernel(function(T){const S=T[this.thread.y][this.thread.x];this.color(0,0,S.b/255,255)},{output:[b,v],graphical:!0,argumentTypes:{v:"Array2D(4)"}});I(x);const $=m.createKernel(function(T){const S=T[this.thread.y][this.thread.x];this.color(255,255,255,S.a/255)},{output:[b,v],graphical:!0,argumentTypes:{v:"Array2D(4)"}});return $(x),[y.canvas,C.canvas,I.canvas,$.canvas]},getMinifySafeName:m=>{try{const x=i.parse(`const value = ${m.toString()}`),{init:b}=x.body[0].declarations[0];return b.body.name||b.body.body[0].argument.name}catch{throw new Error("Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }")}},sanitizeName:function(m){return d.test(m)&&(m=m.replace(d,"S_S")),f.test(m)?m=m.replace(f,"U_U"):p.test(m)&&(m=m.replace(p,"u_u")),m}},d=/\$/,f=/__/,p=/_/,g=h.getSystemEndianness();s.exports={utils:h}},{"./input":110,"./texture":113,acorn:1}]},{},[107])(107)})})(PE);var TX=PE.exports;let Hm=null;try{Hm=new TX.GPU}catch(t){console.error("GPU.js :",t),Hm=null}const IX=t=>{let e=0,n=0;return e=-Math.log((1-t)*(1+t)),e<5?(e=e-2.5,n=281022636e-16,n=343273939e-15+n*e,n=-35233877e-13+n*e,n=-439150654e-14+n*e,n=.00021858087+n*e,n=-.00125372503+n*e,n=-.00417768164+n*e,n=.246640727+n*e,n=1.50140941+n*e):(e=Math.sqrt(e)-3,n=-.000200214257,n=.000100950558+n*e,n=.00134934322+n*e,n=-.00367342844+n*e,n=.00573950773+n*e,n=-.0076224613+n*e,n=.00943887047+n*e,n=1.00167406+n*e,n=2.83297682+n*e),n*t},kX=t=>{const e=new Float32Array(t);for(let n=0;n<t;n++){const s=(n+.5)/t;e[n]=Math.sqrt(2)*IX(2*s-1)}return e},EX=t=>Hm?Hm.createKernel(function(n){function s(i){let o=0,a=0;return o=-Math.log((1-i)*(1+i)),o<5?(o=o-2.5,a=281022636e-16,a=343273939e-15+a*o,a=-35233877e-13+a*o,a=-439150654e-14+a*o,a=.00021858087+a*o,a=-.00125372503+a*o,a=-.00417768164+a*o,a=.246640727+a*o,a=1.50140941+a*o):(o=Math.sqrt(o)-3,a=-.000200214257,a=.000100950558+a*o,a=.00134934322+a*o,a=-.00367342844+a*o,a=.00573950773+a*o,a=-.0076224613+a*o,a=.00943887047+a*o,a=1.00167406+a*o,a=2.83297682+a*o),a*i}const r=(this.thread.x+.5)/n;return Math.sqrt(2)*s(2*r-1)},{output:[t],precision:"single"})(t):(console.warn("GPU.js  CPU "),kX(t));function _X(t,e,n){const s=t.width,r=t.height,i=s*r,o=EX(i),a=new Uint8Array(i);for(let l=0;l<i;l++){const u=e[l*3],c=e[l*3+1],h=e[l*3+2],d=o[l];if(u<i&&!(a[u]&1)){const f=u*4;n.data[f]=d,a[u]===0&&(n.data[f+3]=t.data[f+3]),a[u]|=1}if(c<i&&!(a[c]&2)){const f=c*4;n.data[f+1]=d,a[c]===0&&(n.data[f+3]=t.data[f+3]),a[c]|=2}if(h<i&&!(a[h]&4)){const f=h*4;n.data[f+2]=d,a[h]===0&&(n.data[f+3]=t.data[f+3]),a[h]|=4}}}async function $X(t,e){let n=await qo(CX)(t,e);const s=t.width*t.height;let i={data:new Array(s*4).fill(0),width:t.width,height:t.height};return qo(_X)(t,n,i),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RX=1e-7,AX=1e-4;class lv{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class t0{refCount(e){return rr("refCount")}incRef(e){return rr("incRef")}timerAvailable(){return!0}time(e){return rr("time")}read(e){return rr("read")}readSync(e){return rr("readSync")}readToGPU(e,n){return rr("readToGPU")}numDataIds(){return rr("numDataIds")}disposeData(e,n){return rr("disposeData")}write(e,n,s){return rr("write")}move(e,n,s,r,i){return rr("move")}createTensorFromGPUData(e,n,s){return rr("createTensorFromGPUData")}memory(){return rr("memory")}floatPrecision(){return rr("floatPrecision")}epsilon(){return this.floatPrecision()===32?RX:AX}dispose(){return rr("dispose")}}function rr(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PX(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,gu(t,e,n)}function cl(t,e,n){return Math.max(t,Math.min(e,n))}function uv(t){return t%2===0?t:t+1}function gu(t,e,n){const s=t[e];t[e]=t[n],t[n]=s}function DE(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function G(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function n0(t,e,n=""){G(Pt(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function NE(t){G(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function oe(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function oC(t){return t.length===0}function Pt(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function Fu(t){return t%1===0}function A1(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function Ru(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function aC(t,e=r=>0,n,s){return new Promise((r,i)=>{let o=0;const a=()=>{if(t()){r();return}o++;const l=e(o);if(n!=null&&o>=n){i();return}s!=null?s(a,l):setTimeout(a,l)};a()})}function cv(t,e){let n=1,s=-1;for(let i=0;i<t.length;++i)if(t[i]>=0)n*=t[i];else if(t[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(t[i]<0)throw Error(`Shapes can not be < 0. Found ${t[i]} at dim ${i}`);if(s===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const r=t.slice();return r[s]=e/n,r}function wt(t,e){const n=e.length;return t=t==null?e.map((s,r)=>r):[].concat(t),G(t.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),G(t.every(s=>Fu(s)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(s=>s<0?n+s:s)}function pa(t,e){const n=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||r?null:wt(e,t).sort();let o=0;for(let a=0;a<t.length;++a){if(i!=null){if(i[o]===a&&t[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(i[o]==null||i[o]>a)&&t[a]===1&&(n.push(t[a]),s.push(a)),i[o]<=a&&o++}t[a]!==1&&(n.push(t[a]),s.push(a))}return{newShape:n,keptDims:s}}function cs(t,e){return _n(t,e)}function _n(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function DX(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function NX(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function hv(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function Km(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function MX(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function ec(t){return typeof t=="string"||t instanceof String}function LX(t){return typeof t=="boolean"}function P1(t){return typeof t=="number"}function _l(t){return Array.isArray(t)?_l(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":P1(t)?"float32":ec(t)?"string":LX(t)?"bool":"float32"}function D1(t){return!!(t&&t.constructor&&t.call&&t.apply)}function N1(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function lt(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let s=e-3;s>=0;--s)n[s]=n[s+1]*t[s+1];return n}function ME(t,e,n,s=!1){const r=new Array;if(e.length===1){const i=e[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=n[t+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,u)=>l*u)*(s?2:1);for(let l=0;l<i;l++)r[l]=ME(t+l*a,o,n,s)}return r}function ni(t,e,n=!1){if(t.length===0)return e[0];const s=t.reduce((r,i)=>r*i)*(n?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return ME(0,t,e,n)}function Tm(t,e){if(Array.isArray(t))return t;if(e==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(e==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${e}`)}function dv(t,e){const n=vs(t,e);for(let s=0;s<n.length;s++)n[s]=1;return n}function vs(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function LE(t,e){const n=t.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return ni(t,new Float32Array(n));if(e==="int32")return ni(t,new Int32Array(n));if(e==="bool")return ni(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function Ao(t){t.forEach(e=>{G(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function zi(t,e,n){if(e===0)return 0;if(e===1)return t[0];let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=n[r]*t[r];return s}function tc(t,e,n){if(e===0)return[];if(e===1)return[t];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(t/n[r]),t-=s[r]*n[r];return s[s.length-1]=t,s}function fv(t){return t&&t.then&&typeof t.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lC="tfjsflags";class OX{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=FX,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(ue().getBool("IS_TEST")||ue().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,s){if(this.flagRegistry[e]={evaluationFn:n,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];ue().getBool("IS_TEST")||ue().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(fv(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);lC in e&&e[lC].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=BX(r,i)})}}function FX(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>(UX(e,s[0],s[1]),s.join("="))),e}function UX(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function BX(t,e){const n=e.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:e}function ue(){return OE}let OE=null;function zX(t){OE=t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $b;function FE(){if($b==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");$b=t}return $b}function GX(){const t=FE();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function pv(t,e){const n=GX();if(n.has(t))return n.get(t);{const s=e();return n.set(t,s),n.get(t)}}const qd="Abs",nc="Acos",sc="Acosh",$l="Add",s0="AddN",r0="All",i0="Any",Yd="ArgMax",Zd="ArgMin",rc="Asin",ic="Asinh",oc="Atan",ac="Atanh",lc="Atan2",Qd="AvgPool",o0="AvgPoolGrad",Jd="AvgPool3D",a0="AvgPool3DGrad",ef="BatchMatMul",tf="BatchToSpaceND",l0="Bincount",mv="BitwiseAnd",VX="BroadcastTo",gv="BroadcastArgs",uc="Cast",cc="Ceil",hc="ClipByValue",u0="Complex",nf="ComplexAbs",sf="Concat",rf="Conv2D",c0="Conv2DBackpropFilter",of="Conv2DBackpropInput",af="Conv3D",h0="Conv3DBackpropFilterV2",d0="Conv3DBackpropInputV2",dc="Cos",fc="Cosh",f0="Cumprod",lf="Cumsum",p0="CropAndResize",m0="DenseBincount",g0="DepthToSpace",uf="DepthwiseConv2dNative",x0="DepthwiseConv2dNativeBackpropFilter",b0="DepthwiseConv2dNativeBackpropInput",xv="Diag",cf="Dilation2D",jm="Dilation2DBackpropInput",Xm="Dilation2DBackpropFilter",UE="Draw",pc="RealDiv",y0="Einsum",mc="Elu",v0="EluGrad",gc="Erf",hf="Equal",xc="Exp",df="ExpandDims",bc="Expm1",w0="FFT",S0="Fill",C0="FlipLeftRight",yc="Floor",vc="FloorDiv",ff="FusedBatchNorm",pf="GatherV2",bv="GatherNd",mf="Greater",wc="GreaterEqual",Sc="Identity",T0="IFFT",I0="Imag",Cc="IsFinite",Tc="IsInf",Ic="IsNan",gf="LeakyRelu",xf="Less",bf="LessEqual",yv="LinSpace",kc="Log",Ec="Log1p",yf="LogicalAnd",vf="LogicalNot",wf="LogicalOr",WX="LogSoftmax",Sf="LRN",k0="LRNGrad",Cf="Max",_c="Maximum",Tf="MaxPool",E0="MaxPoolGrad",If="MaxPool3D",_0="MaxPool3DGrad",vv="MaxPoolWithArgmax",kf="Mean",Ef="Min",$c="Minimum",_f="MirrorPad",Rc="Mod",wv="Multinomial",Ac="Multiply",$f="Neg",Rf="NotEqual",$0="NonMaxSuppressionV3",Sv="NonMaxSuppressionV4",R0="NonMaxSuppressionV5",Af="OnesLike",Pf="OneHot",Df="Pack",Nf="PadV2",Pc="Pow",Mf="Prelu",Lf="Prod",BE="RaggedGather",zE="RaggedRange",GE="RaggedTensorToTensor",A0="Range",P0="Real",Dc="Reciprocal",Nc="Relu",Of="Reshape",Ff="ResizeNearestNeighbor",D0="ResizeNearestNeighborGrad",Uf="ResizeBilinear",N0="ResizeBilinearGrad",Mc="Relu6",Bf="Reverse",Lc="Round",Oc="Rsqrt",Cv="ScatterNd",Tv="TensorScatterUpdate",Iv="SearchSorted",zf="Select",Fc="Selu",Gf="Slice",Uc="Sin",Bc="Sinh",zc="Sign",Gc="Sigmoid",Vc="Softplus",Wc="Sqrt",Vf="Sum",Wf="SpaceToBatchND",Hf="SplitV",Kf="Softmax",VE="SparseFillEmptyRows",WE="SparseReshape",kv="SparseSegmentMean",Ev="SparseSegmentSum",_v="SparseToDense",Hc="SquaredDifference",M0="Square",$v="StaticRegexReplace",L0="StridedSlice",Rv="StringNGrams",HE="StringSplit",KE="StringToHashBucketFast",Kc="Sub",jc="Tan",Xc="Tanh",qc="Tile",O0="TopK",F0="Transform",rl="Transpose",Av="Unique",jf="Unpack",Xf="UnsortedSegmentSum",qf="ZerosLike",Yc="Step",jE="FromPixels",U0="RotateWithOffset",wd="_FusedMatMul",Sd="FusedConv2D",Pv="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yr(...t){ue().getBool("IS_TEST")||ue().getBool("PROD")||console.warn(...t)}function HX(...t){ue().getBool("IS_TEST")||ue().getBool("PROD")||console.log(...t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qm=pv("kernelRegistry",()=>new Map),M1=pv("gradRegistry",()=>new Map);function uC(t,e){const n=XE(t,e);return qm.get(n)}function cC(t){return M1.get(t)}function hC(t){const e=qm.entries(),n=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,o]=r,[a]=i.split("_");a===t&&n.push(o)}return n}function Dv(t){const{kernelName:e,backendName:n}=t,s=XE(e,n);qm.has(s)&&yr(`The kernel '${e}' for backend '${n}' is already registered`),qm.set(s,t)}function KX(t){const{kernelName:e}=t;M1.has(e)&&ue().getBool("DEBUG")&&yr(`Overriding the gradient for '${e}'`),M1.set(e,t)}function XE(t,e){return`${e}_${t}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qE(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var YE=pn,Ur=null;try{Ur=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function pn(t,e,n){this.low=t|0,this.high=e|0,this.unsigned=!!n}pn.prototype.__isLong__;Object.defineProperty(pn.prototype,"__isLong__",{value:!0});function mr(t){return(t&&t.__isLong__)===!0}pn.isLong=mr;var dC={},fC={};function Rl(t,e){var n,s,r;return e?(t>>>=0,(r=0<=t&&t<256)&&(s=fC[t],s)?s:(n=mn(t,(t|0)<0?-1:0,!0),r&&(fC[t]=n),n)):(t|=0,(r=-128<=t&&t<128)&&(s=dC[t],s)?s:(n=mn(t,t<0?-1:0,!1),r&&(dC[t]=n),n))}pn.fromInt=Rl;function Br(t,e){if(isNaN(t))return e?Xa:zr;if(e){if(t<0)return Xa;if(t>=ZE)return e_}else{if(t<=-mC)return ur;if(t+1>=mC)return JE}return t<0?Br(-t,e).neg():mn(t%Uu|0,t/Uu|0,e)}pn.fromNumber=Br;function mn(t,e,n){return new pn(t,e,n)}pn.fromBits=mn;var Ym=Math.pow;function Nv(t,e,n){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return zr;if(typeof e=="number"?(n=e,e=!1):e=!!e,n=n||10,n<2||36<n)throw RangeError("radix");var s;if((s=t.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return Nv(t.substring(1),e,n).neg();for(var r=Br(Ym(n,8)),i=zr,o=0;o<t.length;o+=8){var a=Math.min(8,t.length-o),l=parseInt(t.substring(o,o+a),n);if(a<8){var u=Br(Ym(n,a));i=i.mul(u).add(Br(l))}else i=i.mul(r),i=i.add(Br(l))}return i.unsigned=e,i}pn.fromString=Nv;function mi(t,e){return typeof t=="number"?Br(t,e):typeof t=="string"?Nv(t,e):mn(t.low,t.high,typeof e=="boolean"?e:t.unsigned)}pn.fromValue=mi;var pC=65536,jX=1<<24,Uu=pC*pC,ZE=Uu*Uu,mC=ZE/2,gC=Rl(jX),zr=Rl(0);pn.ZERO=zr;var Xa=Rl(0,!0);pn.UZERO=Xa;var wu=Rl(1);pn.ONE=wu;var QE=Rl(1,!0);pn.UONE=QE;var L1=Rl(-1);pn.NEG_ONE=L1;var JE=mn(-1,2147483647,!1);pn.MAX_VALUE=JE;var e_=mn(-1,-1,!0);pn.MAX_UNSIGNED_VALUE=e_;var ur=mn(0,-2147483648,!1);pn.MIN_VALUE=ur;var qe=pn.prototype;qe.toInt=function(){return this.unsigned?this.low>>>0:this.low};qe.toNumber=function(){return this.unsigned?(this.high>>>0)*Uu+(this.low>>>0):this.high*Uu+(this.low>>>0)};qe.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(ur)){var n=Br(e),s=this.div(n),r=s.mul(n).sub(this);return s.toString(e)+r.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var i=Br(Ym(e,6),this.unsigned),o=this,a="";;){var l=o.div(i),u=o.sub(l.mul(i)).toInt()>>>0,c=u.toString(e);if(o=l,o.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};qe.getHighBits=function(){return this.high};qe.getHighBitsUnsigned=function(){return this.high>>>0};qe.getLowBits=function(){return this.low};qe.getLowBitsUnsigned=function(){return this.low>>>0};qe.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ur)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,n=31;n>0&&!(e&1<<n);n--);return this.high!=0?n+33:n+1};qe.isZero=function(){return this.high===0&&this.low===0};qe.eqz=qe.isZero;qe.isNegative=function(){return!this.unsigned&&this.high<0};qe.isPositive=function(){return this.unsigned||this.high>=0};qe.isOdd=function(){return(this.low&1)===1};qe.isEven=function(){return(this.low&1)===0};qe.equals=function(e){return mr(e)||(e=mi(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};qe.eq=qe.equals;qe.notEquals=function(e){return!this.eq(e)};qe.neq=qe.notEquals;qe.ne=qe.notEquals;qe.lessThan=function(e){return this.comp(e)<0};qe.lt=qe.lessThan;qe.lessThanOrEqual=function(e){return this.comp(e)<=0};qe.lte=qe.lessThanOrEqual;qe.le=qe.lessThanOrEqual;qe.greaterThan=function(e){return this.comp(e)>0};qe.gt=qe.greaterThan;qe.greaterThanOrEqual=function(e){return this.comp(e)>=0};qe.gte=qe.greaterThanOrEqual;qe.ge=qe.greaterThanOrEqual;qe.compare=function(e){if(mr(e)||(e=mi(e)),this.eq(e))return 0;var n=this.isNegative(),s=e.isNegative();return n&&!s?-1:!n&&s?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};qe.comp=qe.compare;qe.negate=function(){return!this.unsigned&&this.eq(ur)?ur:this.not().add(wu)};qe.neg=qe.negate;qe.add=function(e){mr(e)||(e=mi(e));var n=this.high>>>16,s=this.high&65535,r=this.low>>>16,i=this.low&65535,o=e.high>>>16,a=e.high&65535,l=e.low>>>16,u=e.low&65535,c=0,h=0,d=0,f=0;return f+=i+u,d+=f>>>16,f&=65535,d+=r+l,h+=d>>>16,d&=65535,h+=s+a,c+=h>>>16,h&=65535,c+=n+o,c&=65535,mn(d<<16|f,c<<16|h,this.unsigned)};qe.subtract=function(e){return mr(e)||(e=mi(e)),this.add(e.neg())};qe.sub=qe.subtract;qe.multiply=function(e){if(this.isZero())return zr;if(mr(e)||(e=mi(e)),Ur){var n=Ur.mul(this.low,this.high,e.low,e.high);return mn(n,Ur.get_high(),this.unsigned)}if(e.isZero())return zr;if(this.eq(ur))return e.isOdd()?ur:zr;if(e.eq(ur))return this.isOdd()?ur:zr;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(gC)&&e.lt(gC))return Br(this.toNumber()*e.toNumber(),this.unsigned);var s=this.high>>>16,r=this.high&65535,i=this.low>>>16,o=this.low&65535,a=e.high>>>16,l=e.high&65535,u=e.low>>>16,c=e.low&65535,h=0,d=0,f=0,p=0;return p+=o*c,f+=p>>>16,p&=65535,f+=i*c,d+=f>>>16,f&=65535,f+=o*u,d+=f>>>16,f&=65535,d+=r*c,h+=d>>>16,d&=65535,d+=i*u,h+=d>>>16,d&=65535,d+=o*l,h+=d>>>16,d&=65535,h+=s*c+r*u+i*l+o*a,h&=65535,mn(f<<16|p,h<<16|d,this.unsigned)};qe.mul=qe.multiply;qe.divide=function(e){if(mr(e)||(e=mi(e)),e.isZero())throw Error("division by zero");if(Ur){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var n=(this.unsigned?Ur.div_u:Ur.div_s)(this.low,this.high,e.low,e.high);return mn(n,Ur.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Xa:zr;var s,r,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Xa;if(e.gt(this.shru(1)))return QE;i=Xa}else{if(this.eq(ur)){if(e.eq(wu)||e.eq(L1))return ur;if(e.eq(ur))return wu;var o=this.shr(1);return s=o.div(e).shl(1),s.eq(zr)?e.isNegative()?wu:L1:(r=this.sub(e.mul(s)),i=s.add(r.div(e)),i)}else if(e.eq(ur))return this.unsigned?Xa:zr;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=zr}for(r=this;r.gte(e);){s=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(s)/Math.LN2),l=a<=48?1:Ym(2,a-48),u=Br(s),c=u.mul(e);c.isNegative()||c.gt(r);)s-=l,u=Br(s,this.unsigned),c=u.mul(e);u.isZero()&&(u=wu),i=i.add(u),r=r.sub(c)}return i};qe.div=qe.divide;qe.modulo=function(e){if(mr(e)||(e=mi(e)),Ur){var n=(this.unsigned?Ur.rem_u:Ur.rem_s)(this.low,this.high,e.low,e.high);return mn(n,Ur.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};qe.mod=qe.modulo;qe.rem=qe.modulo;qe.not=function(){return mn(~this.low,~this.high,this.unsigned)};qe.and=function(e){return mr(e)||(e=mi(e)),mn(this.low&e.low,this.high&e.high,this.unsigned)};qe.or=function(e){return mr(e)||(e=mi(e)),mn(this.low|e.low,this.high|e.high,this.unsigned)};qe.xor=function(e){return mr(e)||(e=mi(e)),mn(this.low^e.low,this.high^e.high,this.unsigned)};qe.shiftLeft=function(e){return mr(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?mn(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):mn(0,this.low<<e-32,this.unsigned)};qe.shl=qe.shiftLeft;qe.shiftRight=function(e){return mr(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?mn(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):mn(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};qe.shr=qe.shiftRight;qe.shiftRightUnsigned=function(e){if(mr(e)&&(e=e.toInt()),e&=63,e===0)return this;var n=this.high;if(e<32){var s=this.low;return mn(s>>>e|n<<32-e,n>>>e,this.unsigned)}else return e===32?mn(n,0,this.unsigned):mn(n>>>e-32,0,this.unsigned)};qe.shru=qe.shiftRightUnsigned;qe.shr_u=qe.shiftRightUnsigned;qe.toSigned=function(){return this.unsigned?mn(this.low,this.high,!1):this};qe.toUnsigned=function(){return this.unsigned?this:mn(this.low,this.high,!0)};qe.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};qe.toBytesLE=function(){var e=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};qe.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};pn.fromBytes=function(e,n,s){return s?pn.fromBytesLE(e,n):pn.fromBytesBE(e,n)};pn.fromBytesLE=function(e,n){return new pn(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)};pn.fromBytesBE=function(e,n){return new pn(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)};const t_=rF(YE),XX=$M({__proto__:null,default:t_},[YE]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wa=t_||XX;function B0(t){return Wa.fromString(t,!0,16)}const n_=B0("c3a5c85c97cb3127"),za=B0("b492b66fbe98f273"),Ns=B0("9ae16a3b2f90404f");function O1(t){return t.xor(t.shru(47))}function s_(t,e,n){const s=t.slice(e,e+n);return Wa.fromBytes(Array.from(s),!0,!0)}function nn(t,e){return s_(t,e,8)}function xC(t,e){return s_(t,e,4)}function ls(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function na(t,e,n=B0("9ddfea08eb382d69")){let s=t.xor(e).mul(n);s=s.xor(s.shru(47));let r=e.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function qX(t,e,n,s,r,i){r=r.add(t),i=ls(i.add(r).add(s),21);const o=r;return r=r.add(e),r=r.add(n),i=i.add(ls(r,44)),[r.add(s),i.add(o)]}function Gp(t,e,n,s){return qX(nn(t,e),nn(t,e+8),nn(t,e+16),nn(t,e+24),n,s)}function YX(t,e=t.length){if(e>=8){const n=Ns.add(e*2),s=nn(t,0).add(Ns),r=nn(t,e-8),i=ls(r,37).mul(n).add(s),o=ls(s,25).add(r).mul(n);return na(i,o,n)}if(e>=4){const n=Ns.add(e*2),s=xC(t,0);return na(s.shl(3).add(e),xC(t,e-4),n)}if(e>0){const n=t[0],s=t[e>>1],r=t[e-1],i=n+(s<<8),o=e+(r<<2);return O1(Ns.mul(i).xor(n_.mul(o))).mul(Ns)}return Ns}function ZX(t,e=t.length){const n=Ns.add(e*2),s=nn(t,0).mul(za),r=nn(t,8),i=nn(t,e-8).mul(n),o=nn(t,e-16).mul(Ns);return na(ls(s.add(r),43).add(ls(i,30)).add(o),s.add(ls(r.add(Ns),18)).add(i),n)}function QX(t,e=t.length){const n=Ns.add(e*2),s=nn(t,0).mul(Ns),r=nn(t,8),i=nn(t,e-8).mul(n),o=nn(t,e-16).mul(Ns),a=ls(s.add(r),43).add(ls(i,30)).add(o),l=na(a,s.add(ls(r.add(Ns),18)).add(i),n),u=nn(t,16).mul(n),c=nn(t,24),h=a.add(nn(t,e-32)).mul(n),d=l.add(nn(t,e-24)).mul(n);return na(ls(u.add(c),43).add(ls(h,30)).add(d),u.add(ls(c.add(s),18)).add(h),n)}function JX(t,e=t.length){const n=Wa.fromNumber(81,!0);if(e<=32)return e<=16?YX(t,e):ZX(t,e);if(e<=64)return QX(t,e);let s=n,r=n.mul(za).add(113),i=O1(r.mul(Ns).add(113)).mul(Ns),o=[Wa.UZERO,Wa.UZERO],a=[Wa.UZERO,Wa.UZERO];s=s.mul(Ns).add(nn(t,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do s=ls(s.add(r).add(o[0]).add(nn(t,l+8)),37).mul(za),r=ls(r.add(o[1]).add(nn(t,l+48)),42).mul(za),s=s.xor(a[1]),r=r.add(o[0]).add(nn(t,l+40)),i=ls(i.add(a[0]),33).mul(za),o=Gp(t,l,o[1].mul(za),s.add(a[0])),a=Gp(t,l+32,i.add(a[1]),r.add(nn(t,l+16))),[i,s]=[s,i],l+=64;while(l!==u);const h=za.add(i.and(255).shl(1));return l=c,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),s=ls(s.add(r).add(o[0]).add(nn(t,l+8)),37).mul(h),r=ls(r.add(o[1]).add(nn(t,l+48)),42).mul(h),s=s.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(nn(t,l+40))),i=ls(i.add(a[0]),33).mul(h),o=Gp(t,l,o[1].mul(h),s.add(a[0])),a=Gp(t,l+32,i.add(a[1]),r.add(nn(t,l+16))),[i,s]=[s,i],na(na(o[0],a[0],h).add(O1(r).mul(n_)).add(i),na(o[1],a[1],h).add(s),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ma(t,e){return e==="string"?vo(t):Al([t],e)}function eq(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function Al(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Eo(t)),ue().getBool("DEBUG")&&DX(t,e),eq(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let s=0;s<n.length;++s)Math.round(t[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Hs(){return ue().platform.now()}function vo(t,e="utf-8"){return e=e||"utf-8",ue().platform.encode(t,e)}function li(t,e="utf-8"){return e=e||"utf-8",ue().platform.decode(t,e)}function Kr(t){return ue().platform.isTypedArray!=null?ue().platform.isTypedArray(t):qE(t)}function Eo(t,e=[],n=!1){if(e==null&&(e=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||fv(t)||t==null||Kr(t)&&n)e.push(t);else if(Array.isArray(t)||Kr(t))for(let s=0;s<t.length;++s)Eo(t[s],e,n);else{let s=-1;for(const r of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Eo(t[r],e,n)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tq{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new sq)}profileKernel(e,n,s){let r;const i=()=>{r=s()};let o;const a=Hs();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const u of r)u.dataSync();o=Promise.resolve({kernelMs:Hs()-a})}if(ue().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){const c=r[u];c.data().then(h=>{nq(h,c.dtype,e)})}return{kernelName:e,outputs:r,inputs:n,timeMs:o.then(u=>u.kernelMs),extraInfo:o.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:s,timeMs:r,inputs:i,extraInfo:o}=e;s.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(n,a,l[0],l[1],i,l[2])})})}}function nq(t,e,n){if(e!=="float32")return!1;for(let s=0;s<t.length;s++){const r=t[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class sq{logKernelProfile(e,n,s,r,i,o){const a=typeof r=="number"?Ru(`${r}ms`,9):r.error,l=Ru(e,25),u=n.rank,c=n.size,h=Ru(n.shape.toString(),14);let d="";for(const f in i){const p=i[f];if(p!=null){const g=p.shape||n.shape,m=g.length;d+=`${f}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${h}	%c${c}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rq(t,e,n){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<t.length;l++){const u=t[l],c=u.inputs;for(const h in c){const d=c[h];let f=!1;for(let p=0;p<e.length;p++)if(s[d.id]){u.outputs.forEach(g=>s[g.id]=!0),f=!0,r[u.id]=!0;break}if(f)break}}const i={};i[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const u=t[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(i[u.outputs[h].id]){for(const d in c)i[c[d].id]=!0,o[u.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const u=t[l];if(r[u.id]&&o[u.id]){const c={};for(const d in u.inputs){const f=u.inputs[d];s[f.id]&&(c[d]=f)}const h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,a.push(h)}}return a}function iq(t,e,n,s){for(let r=e.length-1;r>=0;r--){const i=e[r],o=[];if(i.outputs.forEach(l=>{const u=t[l.id];u!=null?o.push(u):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=n(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=i.inputs[l];if(!Pt(u.shape,c.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(t[c.id]==null)t[c.id]=u;else{const h=t[c.id];t[c.id]=s(h,u),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bC=20,yh=3,Rb=7;function oq(t,e,n,s){const r=lt(e),i=aq(t,e,n,r),o=e.length,a=Im(t,e,n,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function aq(t,e,n,s){const r=oe(e),i=s[s.length-1],o=new Array(i).fill(0),a=e.length,l=n==="complex64"?Mh(t):t;if(a>1)for(let u=0;u<r/i;u++){const c=u*i;for(let h=0;h<i;h++)o[h]=Math.max(o[h],Nh(l[c+h],0,n).length)}return o}function Nh(t,e,n){let s;return Array.isArray(t)?s=`${parseFloat(t[0].toFixed(Rb))} + ${parseFloat(t[1].toFixed(Rb))}j`:ec(t)?s=`'${t}'`:n==="bool"?s=r_(t):s=parseFloat(t.toFixed(Rb)).toString(),Ru(s,e)}function r_(t){return t===0?"false":"true"}function Im(t,e,n,s,r,i=!0){const o=n==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(n==="complex64"){const g=Mh(t);return[Nh(g[0],0,n)]}return n==="bool"?[r_(t[0])]:[t[0].toString()]}if(l===1){if(a>bC){const m=yh*o;let x=Array.from(t.slice(0,m)),b=Array.from(t.slice((a-yh)*o,a*o));return n==="complex64"&&(x=Mh(x),b=Mh(b)),["["+x.map((v,y)=>Nh(v,r[y],n)).join(", ")+", ..., "+b.map((v,y)=>Nh(v,r[a-yh+y],n)).join(", ")+"]"]}return["["+(n==="complex64"?Mh(t):Array.from(t)).map((m,x)=>Nh(m,r[x],n)).join(", ")+"]"]}const u=e.slice(1),c=s.slice(1),h=s[0]*o,d=[];if(a>bC){for(let g=0;g<yh;g++){const m=g*h,x=m+h;d.push(...Im(t.slice(m,x),u,n,c,r,!1))}d.push("...");for(let g=a-yh;g<a;g++){const m=g*h,x=m+h;d.push(...Im(t.slice(m,x),u,n,c,r,g===a-1))}}else for(let g=0;g<a;g++){const m=g*h,x=m+h;d.push(...Im(t.slice(m,x),u,n,c,r,g===a-1))}const f=l===2?",":"";d[0]="["+(a>0?d[0]+f:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+f;let p=`,
`;for(let g=2;g<l;g++)p+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":p),d}function Mh(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bs{constructor(e,n,s){if(this.dtype=n,this.shape=e.slice(),this.size=oe(e),s!=null){const r=s.length;G(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||_n(n,this.size),this.strides=lt(e)}set(e,...n){n.length===0&&(n=[0]),G(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const r of e){if(r<0||r>=this.shape[n]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}n++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let s=0;s<e.length-1;++s)n+=this.strides[s]*e[s];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(e/this.strides[s]),e-=n[s]*this.strides[s];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return Qr().makeTensor(this.values,this.shape,this.dtype)}}let Qr=null,xu=null;function lq(t){Qr=t}function uq(t){xu=t}class Qn{constructor(e,n,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=oe(e),this.strides=lt(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return xu.buffer(this.shape,this.dtype,e)}bufferSync(){return xu.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ni(this.shape,e,this.dtype==="complex64")}arraySync(){return ni(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Qr().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(s=>li(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Qr().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Qr().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>li(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Qr().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Qr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return xu.print(this,e)}clone(){return this.throwIfDisposed(),xu.clone(this)}toString(e=!1){const n=this.dataSync();return oq(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),xu.cast(this,e)}variable(e=!0,n,s){return this.throwIfDisposed(),Qr().makeVariable(this,e,n,s)}}Object.defineProperty(Qn,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function be(){return pv("Tensor",()=>Qn)}be();class Zm extends Qn{constructor(e,n,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=n,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Pt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Qr().disposeTensor(this),this.dataId=e.dataId,Qr().incRef(this,null)}dispose(){Qr().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Zm,Symbol.hasInstance,{value:t=>t instanceof Qn&&t.assign!=null&&t.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var yC;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(yC||(yC={}));var F1;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(F1||(F1={}));var U1;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(U1||(U1={}));var B1;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(B1||(B1={}));var z1;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(z1||(z1={}));const cq={float32:B1,int32:F1,bool:U1,complex64:z1};function hs(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return cq[t][e]}function z0(t){return hs(t,"int32")}function i_(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function o_(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bn(t,e){if(t.dtype===e.dtype)return[t,e];const n=hs(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function a_(t){const e=[];return l_(t,e,new Set),e}function l_(t,e,n){if(t==null)return;if(t instanceof Qn){e.push(t);return}if(!hq(t))return;const s=t;for(const r in s){const i=s[r];n.has(i)||(n.add(i),l_(i,e,n))}}function hq(t){return Array.isArray(t)||typeof t=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ab(t){return t.kernelName!=null}class vC{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Bu{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new vC}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,s=1){return e in this.registryFactory?(yr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(e);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new tq(this.backendInstance),!0}setupRegisteredKernels(){hC(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){hC(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=n.factory();if(s&&!(s instanceof t0)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,yr(`Initialization of backend ${e} failed`),yr(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return yr(`Initialization of backend ${e} failed`),yr(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const s=this.state.tensorInfo.get(n),r=s.backend,i=this.readSync(n),o=r.refCount(n);r.disposeData(n,!0),s.backend=e,e.move(n,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let s=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,n,s){e();try{const r=s();return n(),r}catch(r){throw n(),r}}nextTensorId(){return Bu.nextTensorId++}nextVariableId(){return Bu.nextVariableId++}clone(e){const n=ne.runKernel(Sc,{x:e}),s={x:e},r=o=>({x:()=>{const a="float32",l={x:o},u={dtype:a};return ne.runKernel(uc,l,u)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[n],r,i,{}),n}runKernel(e,n,s){if(this.backendName==null&&this.backend,!(uC(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,s){const r=this.backend.numDataIds();let i=0;s.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-n-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let n,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const u=Ab(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Ab(e)){const{kernelName:p,inputs:g,attrs:m}=e;this.backendName==null&&this.backend;const x=uC(p,this.backendName);G(x!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=x.kernelFunc({inputs:g,attrs:m,backend:this.backend});const v=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,b,v);const y=v.map(C=>C.rank!=null?C:this.makeTensorFromTensorInfo(C));if(r){const C=this.getTensorsForGradient(p,g,y);s=this.saveTensorsForBackwardMode(C)}return y}}else{const{forwardFunc:p}=e,g=m=>{r&&(s=m.map(x=>this.keep(this.clone(x))))};a=()=>{const m=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,g));const x=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,m,x),x}}const{inputs:c,attrs:h}=e,d=Ab(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=a():(f=this.profiler.profileKernel(u,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),n=f.outputs)}),r&&this.addTapeNode(u,c,n,d,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(p=>c[p]!=null?c[p].shape:null),outputShapes:n.map(p=>p.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,n,s){const r=cC(e);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?(G(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(n).map(u=>n[u])):a=i.map(u=>n[u]);const l=s.filter((u,c)=>o[c]);return a.concat(l)}return[]}makeTensor(e,n,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=e;s==="string"&&ec(e[0])&&(i=e.map(l=>vo(l)));const o=r.write(i,n,s),a=new Qn(n,s,o,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const l=this.state.tensorInfo.get(o),u=MX(i);this.state.numBytes+=u-l.bytes,l.bytes=u}return a}makeTensorFromDataId(e,n,s,r){s=s||"float32";const i={dataId:e,shape:n,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,n){const{dataId:s,shape:r,dtype:i}=e,o=new Qn(r,i,s,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(e,n=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const i=new Zm(e,n,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Km(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Zm||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Km(e.dtype);this.state.numBytes-=s}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,s,r,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:s,saved:i},l=cC(e);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=u=>(u=u.map((c,h)=>{if(c==null){const d=s[h],f=vs(d.size,d.dtype);return this.makeTensor(f,d.shape,d.dtype)}return c}),r(u.length>1?u:u[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=a_(e),s=new Set(n.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(e,n,s,r=!1){if(G(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));G(i instanceof Qn,()=>"The result y returned by f() must be a tensor.");const o=rq(this.state.activeTape,n,i);if(!r&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=s??dq(i.shape),iq(a,o,u=>this.tidy(u),fq);const l=n.map(u=>a[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return G(D1(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{G(n.every(a=>a instanceof Qn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};n.forEach((a,l)=>{r[l]=a});const i=(a,l)=>(s=e(...n,l),G(s.value instanceof Qn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),G(D1(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(a,l)=>{const u=s.gradFunc(a,l),c=Array.isArray(u)?u:[u];G(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),G(c.every(d=>d instanceof Qn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((d,f)=>{h[f]=()=>d}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Hs(),s=await this.backend.time(e);return s.wallMs=Hs()-n,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new vC;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Bu.nextTensorId=0;Bu.nextVariableId=0;function dq(t){const e=dv(oe(t),"float32");return ne.makeTensor(e,t,"float32")}function u_(){const t=FE();if(t._tfengine==null){const e=new OX(t);t._tfengine=new Bu(e)}return zX(t._tfengine.ENV),lq(()=>t._tfengine),t._tfengine}const ne=u_();function fq(t,e){const n={a:t,b:e};return ne.runKernel($l,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pq(){return typeof navigator<"u"&&navigator!=null}function c_(t){if(t||pq()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function h_(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Js=ue();Js.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Js.registerFlag("IS_BROWSER",()=>h_());Js.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Js.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Js.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Js.registerFlag("PROD",()=>!1);Js.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Js.getBool("DEBUG"));Js.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Js.registerFlag("IS_TEST",()=>!1);Js.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Js.getBool("DEBUG"));Js.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Js.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Js.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G0(t,e){let n=t;if(Kr(t))return e==="string"?[]:[t.length];if(i_(t)){const r=t.channels||"RGBA";return[t.height,t.width*r.length]}else if(o_(t))return[t.buffer.size/(e==null?4:Km(e))];if(!Array.isArray(t))return[];const s=[];for(;Array.isArray(n)||Kr(n)&&e!=="string";)s.push(n.length),n=n[0];return Array.isArray(t)&&ue().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&d_(t,s,[]),s}function d_(t,e,n){if(n=n||[],!Array.isArray(t)&&!Kr(t)){G(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}G(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),G(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const s=e.slice(1);for(let r=0;r<t.length;++r)d_(t[r],s,n.concat(r))}function wC(t,e,n,s){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${t} tensor, but got ${e} tensor`)}}function q(t,e,n,s="numeric"){if(t instanceof be())return wC(s,t.dtype,e,n),t;let r=_l(t);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),wC(s,r,e,n),t==null||!Kr(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const l=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const i=G0(t,r);!Kr(t)&&!Array.isArray(t)&&(t=[t]);const a=r!=="string"?Al(t,r):Eo(t,[],!0);return ne.makeTensor(a,i,r)}function f_(t,e,n,s="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((i,o)=>q(i,`${e}[${o}]`,n,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mq="__op";function ae(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+mq;const r=(...i)=>{ne.startScope(n);try{const o=s(...i);return fv(o)&&console.error("Cannot return a Promise inside of tidy."),ne.endScope(o),o}catch(o){throw ne.endScope(null),o}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gq(t,e){const n=q(t,"real","complex"),s=q(e,"imag","complex");n0(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return ne.runKernel(u0,r)}const zu=ae({complex_:gq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V0(t,e,n,s){if(s==null)s=_l(t);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(o_(t)||i_(t)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return ne.backend.createTensorFromGPUData(t,e||n,s)}if(!Kr(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Ao(e);const r=oe(e),i=oe(n);G(r===i,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<n.length;++o){const a=n[o],l=o===n.length-1?a!==oe(e.slice(o)):!0;G(n[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!Kr(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=s!=="string"?Al(t,s):Eo(t,[],!0),ne.makeTensor(t,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p_(t,e,n){const s=G0(t,n);return V0(t,e,s,n)}class Zc{static join(e){return new Zc(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>Kr(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let n=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=n+r.byteLength;this.shards.push({buffer:r,start:n,end:i}),n=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,n=isNaN(Number(n))?0:n,e=Math.max(0,e),n=Math.min(this.byteLength,n),n<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=n-e,i=new ArrayBuffer(r),o=new Uint8Array(i);let a=0;for(let l=s;l<this.shards.length;l++){const u=this.shards[l],h=e+a-u.start,d=a,p=Math.min(n,u.end)-u.start,g=new Uint8Array(u.buffer,h,p-h);if(o.set(g,d),a+=g.length,n<u.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function n(r){return e<r.start?-1:e>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=xq(this.shards,n);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function xq(t,e){let n=0,s=t.length;for(;n<=s;){const r=Math.floor((s-n)/2)+n,i=e(t[r]);if(i===0)return r;i<0?s=r:n=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function br(){return ne}function SC(){return ne.memory()}function de(t,e){return ne.tidy(t,e)}function At(t){a_(t).forEach(n=>n.dispose())}function Gi(t){return ne.keep(t)}function m_(t){return ne.setBackend(t)}function g_(){return ne.ready()}function bq(){return ne.backendName}function Mv(t,e,n=1){return ne.registerBackend(t,e,n)}function yq(){return ne.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CC=4;async function TC(t,e){const n=[],s=[],r=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);for(let o=0;o<r.length;++o){const a=r[o],l=Array.isArray(t)?t[o].tensor:t[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async h=>{const d=await l.bytes(),f=d.reduce((m,x)=>m+x.length,0)+CC*d.length,p=new Uint8Array(f);let g=0;for(let m=0;m<d.length;m++){const x=d[m],b=new Uint8Array(new Uint32Array([x.length]).buffer);p.set(b,g),g+=CC,p.set(x,g),g+=x.length}h(p)});s.push(c)}else s.push(l.data());e!=null&&(u.group=e),n.push(u)}const i=await Promise.all(s);return{data:vq(i),specs:n}}function vq(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(i=>{if(e+=i.byteLength,n.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(e);let r=0;return n.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const Lv=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function IC(t){return Lv?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function wq(t){if(Lv)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let s=0,r=e.length;s<r;s++)n+=String.fromCharCode(e[s]);return btoa(n)}function Sq(t){if(Lv){const s=Buffer.from(t,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<e.length;++s)n.set([e.charCodeAt(s)],s);return n.buffer}function Cq(t){return Zc.join(t)}function x_(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:IC(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:IC(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new Zc(t.weightData).byteLength}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rs{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Rs.instance==null&&(Rs.instance=new Rs),Rs.instance}static registerSaveRouter(e){Rs.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Rs.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Rs.getHandlers(e,"save")}static getLoadHandlers(e,n){return Rs.getHandlers(e,"load",n)}static getHandlers(e,n,s){const r=[];return(n==="load"?Rs.getInstance().loadRouters:Rs.getInstance().saveRouters).forEach(o=>{const a=o(e,s);a!==null&&r.push(a)}),r}}const Tq=t=>Rs.getSaveHandlers(t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G1="tensorflowjs",V1=1,qa="models_store",Yo="model_info_store";function b_(){if(!ue().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function W1(t){const e=t.result;e.createObjectStore(qa,{keyPath:"modelPath"}),e.createObjectStore(Yo,{keyPath:"modelPath"})}class hl{constructor(e){if(this.indexedDB=b_(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((s,r)=>{const i=this.indexedDB.open(G1,V1);i.onupgradeneeded=()=>W1(i),i.onsuccess=()=>{const o=i.result;if(n==null){const a=o.transaction(qa,"readonly"),u=a.objectStore(qa).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(u.result.modelArtifacts)},u.onerror=c=>(o.close(),r(u.error)),a.oncomplete=()=>o.close()}else{n.weightData=Zc.join(n.weightData);const a=x_(n),l=o.transaction(Yo,"readwrite");let u=l.objectStore(Yo),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(d){return r(d)}let h;c.onsuccess=()=>{h=o.transaction(qa,"readwrite");const d=h.objectStore(qa);let f;try{f=d.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:a})}catch(p){return r(p)}f.onsuccess=()=>s({modelArtifactsInfo:a}),f.onerror=p=>{u=l.objectStore(Yo);const g=u.delete(this.modelPath);g.onsuccess=()=>(o.close(),r(f.error)),g.onerror=m=>(o.close(),r(f.error))}},c.onerror=d=>(o.close(),r(c.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}hl.URL_SCHEME="indexeddb://";const y_=t=>ue().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(hl.URL_SCHEME)?Iq(t.slice(hl.URL_SCHEME.length)):null;Rs.registerSaveRouter(y_);Rs.registerLoadRouter(y_);function Iq(t){return new hl(t)}function kq(t){return t.startsWith(hl.URL_SCHEME)?t.slice(hl.URL_SCHEME.length):t}class Eq{constructor(){this.indexedDB=b_()}async listModels(){return new Promise((e,n)=>{const s=this.indexedDB.open(G1,V1);s.onupgradeneeded=()=>W1(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(Yo,"readonly"),a=i.objectStore(Yo).getAll();a.onsuccess=()=>{const l={};for(const u of a.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},a.onerror=l=>(r.close(),n(a.error)),i.oncomplete=()=>r.close()},s.onerror=r=>n(s.error)})}async removeModel(e){return e=kq(e),new Promise((n,s)=>{const r=this.indexedDB.open(G1,V1);r.onupgradeneeded=()=>W1(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(Yo,"readwrite"),a=o.objectStore(Yo),l=a.get(e);let u;l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=a.delete(e),h=()=>{u=i.transaction(qa,"readwrite");const f=u.objectStore(qa).delete(e);f.onsuccess=()=>n(l.result.modelArtifactsInfo),f.onerror=p=>s(l.error)};c.onsuccess=h,c.onerror=d=>(h(),i.close(),s(l.error))}},l.onerror=c=>(i.close(),s(l.error)),o.oncomplete=()=>{u==null?i.close():u.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const go="/",bu="tensorflowjs_models",v_="info",_q="model_topology",$q="weight_specs",Rq="weight_data",Aq="model_metadata";function w_(t){return{info:[bu,t,v_].join(go),topology:[bu,t,_q].join(go),weightSpecs:[bu,t,$q].join(go),weightData:[bu,t,Rq].join(go),modelMetadata:[bu,t,Aq].join(go)}}function S_(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function Pq(t){const e=t.split(go);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(go)}function Dq(t){return t.startsWith(dl.URL_SCHEME)?t.slice(dl.URL_SCHEME.length):t}class dl{constructor(e){if(!ue().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=w_(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=x_(e),i=Zc.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,wq(i));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw S_(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);n.format=a.format,n.generatedBy=a.generatedBy,n.convertedBy=a.convertedBy,a.signature!=null&&(n.signature=a.signature),a.userDefinedMetadata!=null&&(n.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(n.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(n.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(n.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=Sq(o),n}}dl.URL_SCHEME="localstorage://";const C_=t=>ue().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(dl.URL_SCHEME)?Nq(t.slice(dl.URL_SCHEME.length)):null;Rs.registerSaveRouter(C_);Rs.registerLoadRouter(C_);function Nq(t){return new dl(t)}class Mq{constructor(){G(ue().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),G(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=bu+go,s=go+v_;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(n)&&i.endsWith(s)){const o=Pq(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=Dq(e);const n=w_(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(n.info));return S_(n),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kC="://";class $i{constructor(){this.managers={}}static getInstance(){return $i.instance==null&&($i.instance=new $i),$i.instance}static registerManager(e,n){G(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(kC)&&(e=e.slice(0,e.indexOf(kC))),G(e.length>0,()=>"scheme must not be an empty string.");const s=$i.getInstance();G(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=n}static getManager(e){const n=$i.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys($i.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lq{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(typeof window>"u"||!ue().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return qE(e)}}if(ue().get("IS_BROWSER")){ue().setPlatform("browser",new Lq);try{$i.registerManager(dl.URL_SCHEME,new Mq)}catch{}try{$i.registerManager(hl.URL_SCHEME,new Eq)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oq={importFetch:()=>require("node-fetch")};let Pb;class Fq{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return ue().global.fetch!=null?ue().global.fetch(e,n):(Pb==null&&(Pb=Oq.importFetch()),Pb(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ue().get("IS_NODE")&&!ue().get("IS_BROWSER")&&ue().setPlatform("node",new Fq);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ct(t,e="float32",n){return e=e||"float32",Ao(t),new bs(t,e,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uq(t,e){const n=q(t,"x","cast");if(!NX(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:n},r={dtype:e};return ne.runKernel(uc,s,r)}const Ze=ae({cast_:Uq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bq(t){const n={x:q(t,"x","clone","string_or_numeric")};return ne.runKernel(Sc,n)}const il=ae({clone_:Bq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zq(t,e=!1){console.log(t.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */u_();const Gq={buffer:Ct,cast:Ze,clone:il,print:zq};uq(Gq);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vq(t,e){let n=q(t,"a","add"),s=q(e,"b","add");[n,s]=Bn(n,s);const r={a:n,b:s};return ne.runKernel($l,r)}const Me=ae({add_:Vq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wq(t,e){let n=q(t,"a","floorDiv"),s=q(e,"b","floorDiv");[n,s]=Bn(n,s);const r={a:n,b:s};return ne.runKernel(vc,r)}const T_=ae({floorDiv_:Wq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hq(t,e){let n=q(t,"a","div"),s=q(e,"b","div");if([n,s]=Bn(n,s),n.dtype==="int32"&&s.dtype==="int32")return T_(n,s);const r={a:n,b:s},i={};return ne.runKernel(pc,r,i)}const ct=ae({div_:Hq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kq(t,e){let n=q(t,"a","mul"),s=q(e,"b","mul");[n,s]=Bn(n,s);const r={a:n,b:s};return ne.runKernel(Ac,r)}const te=ae({mul_:Kq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jq(t){const e=q(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return ne.runKernel(nf,n)}else{const n={x:e};return ne.runKernel(qd,n)}}const As=ae({abs_:jq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xq(t){const n={x:q(t,"x","acos")};return ne.runKernel(nc,n)}const qq=ae({acos_:Xq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yq(t){const n={x:q(t,"x","acosh")};return ne.runKernel(sc,n)}const Zq=ae({acosh_:Yq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qq(t,e=null,n=!1){const r={x:q(t,"x","all","bool")},i={axis:e,keepDims:n};return ne.runKernel(r0,r,i)}const I_=ae({all_:Qq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jq(t,e=null,n=!1){const r={x:q(t,"x","any","bool")},i={axis:e,keepDims:n};return ne.runKernel(i0,r,i)}const H1=ae({any_:Jq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eY(t,e=0){const s={x:q(t,"x","argMax")},r={axis:e};return ne.runKernel(Yd,s,r)}const Cd=ae({argMax_:eY});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tY(t,e=0){const s={x:q(t,"x","argMin")},r={axis:e};return ne.runKernel(Zd,s,r)}const nY=ae({argMin_:tY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sY(t){const n={x:q(t,"x","asin")};return ne.runKernel(rc,n)}const rY=ae({asin_:sY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iY(t){const n={x:q(t,"x","asinh")};return ne.runKernel(ic,n)}const oY=ae({asinh_:iY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aY(t){const n={x:q(t,"x","atan")};return ne.runKernel(oc,n)}const lY=ae({atan_:aY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uY(t,e){let n=q(t,"a","atan2"),s=q(e,"b","atan2");[n,s]=Bn(n,s);const r={a:n,b:s};return ne.runKernel(lc,r)}const cY=ae({atan2_:uY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hY(t){const n={x:q(t,"x","atanh")};return ne.runKernel(ac,n)}const dY=ae({atanh_:hY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ga(t,e,n,s,r="NHWC",i){const o=t[3],a=[...e,o],l=gr(r);return gn(t,a,n,i,s,null,null,l)}function ks(t,e,n,s,r,i,o="channelsLast"){const[a,l]=Td(e);let u;if(o==="channelsLast")u=[a,l,t[3],t[3]];else if(o==="channelsFirst")u=[a,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${o}`);return gn(t,u,n,s,r,i,!1,o)}function Er(t,e,n,s,r,i,o="NDHWC"){const[a,l,u]=K1(e);let c,h;if(o==="NDHWC")h="channelsLast",c=[a,l,u,t[4],t[4]];else if(o==="NCDHW")h="channelsFirst",c=[a,l,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${o}`);return gi(t,c,n,s,r,!1,h,i)}function gn(t,e,n,s,r,i,o=!1,a="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,h]=t;else if(a==="channelsFirst")[l,h,u,c]=t;else throw new Error(`Unknown dataFormat ${a}`);const[d,f,,p]=e,[g,m]=Td(n),[x,b]=Td(s),v=Au(d,x),y=Au(f,b),{padInfo:C,outHeight:I,outWidth:$}=mY(r,u,c,g,m,v,y,i,a),T=o?p*h:p;let S;return a==="channelsFirst"?S=[l,T,I,$]:a==="channelsLast"&&(S=[l,I,$,T]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:h,outHeight:I,outWidth:$,outChannels:T,padInfo:C,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:f,effectiveFilterHeight:v,effectiveFilterWidth:y,dilationHeight:x,dilationWidth:b,inShape:t,outShape:S,filterShape:e}}function gi(t,e,n,s,r,i=!1,o="channelsLast",a){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,h,d]=t;else if(o==="channelsFirst")[l,d,u,c,h]=t;else throw new Error(`Unknown dataFormat ${o}`);const[f,p,g,,m]=e,[x,b,v]=K1(n),[y,C,I]=K1(s),$=Au(f,y),T=Au(p,C),S=Au(g,I),{padInfo:E,outDepth:_,outHeight:N,outWidth:P}=gY(r,u,c,h,x,b,v,$,T,S,a),M=i?m*d:m;let z;return o==="channelsFirst"?z=[l,M,_,N,P]:o==="channelsLast"&&(z=[l,_,N,P,M]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:_,outHeight:N,outWidth:P,outChannels:M,padInfo:E,strideDepth:x,strideHeight:b,strideWidth:v,filterDepth:f,filterHeight:p,filterWidth:g,effectiveFilterDepth:$,effectiveFilterHeight:T,effectiveFilterWidth:S,dilationDepth:y,dilationHeight:C,dilationWidth:I,inShape:t,outShape:z,filterShape:e}}function fY(t,e,n,s,r){s==null&&(s=Ov(t,e,n));const i=t[0],o=t[1],a=Id((i-e+2*s)/n+1,r),l=Id((o-e+2*s)/n+1,r);return[a,l]}function pY(t,e,n,s,r,i){r==null&&(r=Ov(t,e[0],s[0]));const o=[0,0,0,n];for(let a=0;a<3;a++)t[a]+2*r>=e[a]&&(o[a]=Id((t[a]-e[a]+2*r)/s[a]+1,i));return o}function Ov(t,e,n,s=1){const r=Au(e,s);return Math.floor((t[0]*(n-1)-n+r)/2)}function Td(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function K1(t){return typeof t=="number"?[t,t,t]:t}function Au(t,e){return e<=1?t:t+(t-1)*(e-1)}function mY(t,e,n,s,r,i,o,a,l){let u,c,h;if(typeof t=="number"){u={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const f=fY([e,n],i,s,t,a);c=f[0],h=f[1]}else if(t==="same"){c=Math.ceil(e/s),h=Math.ceil(n/r);const d=Math.max(0,(c-1)*s+i-e),f=Math.max(0,(h-1)*r+o-n),p=Math.floor(d/2),g=d-p,m=Math.floor(f/2),x=f-m;u={top:p,bottom:g,left:m,right:x,type:"SAME"}}else if(t==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-i+1)/s),h=Math.ceil((n-o+1)/r);else if(typeof t=="object"){const d=l==="channelsLast"?t[1][0]:t[2][0],f=l==="channelsLast"?t[1][1]:t[2][1],p=l==="channelsLast"?t[2][0]:t[3][0],g=l==="channelsLast"?t[2][1]:t[3][1];u={top:d,bottom:f,left:p,right:g,type:d===0&&f===0&&p===0&&g===0?"VALID":"EXPLICIT"},c=Id((e-i+d+f)/s+1,a),h=Id((n-o+p+g)/r+1,a)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:u,outHeight:c,outWidth:h}}function gY(t,e,n,s,r,i,o,a,l,u,c){let h,d,f,p;if(t==="valid"&&(t=0),typeof t=="number"){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const m=pY([e,n,s,1],[a,l,u],1,[r,i,o],t,c);d=m[0],f=m[1],p=m[2]}else if(t==="same"){d=Math.ceil(e/r),f=Math.ceil(n/i),p=Math.ceil(s/o);const g=(d-1)*r+a-e,m=(f-1)*i+l-n,x=(p-1)*o+u-s,b=Math.floor(g/2),v=g-b,y=Math.floor(m/2),C=m-y,I=Math.floor(x/2),$=x-I;h={top:y,bottom:C,left:I,right:$,front:b,back:v,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:h,outDepth:d,outHeight:f,outWidth:p}}function Id(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function fl(t){const[e,n,s]=Td(t);return e===1&&n===1&&s===1}function ds(t,e){return fl(t)||fl(e)}function pl(t){return Td(t).every(e=>e>0)}function gr(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function tr(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")G(Fu(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{G(Fu(r),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xY(t,e){const s={x:q(t,"x","reshape","string_or_numeric")},r={shape:e};return ne.runKernel(Of,s,r)}const ie=ae({reshape_:xY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bY(t,e,n,s,r){const i=q(t,"x","avgPool","float32"),o=1;G(ds(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),G(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),tr("avgPool",s,r);const u={x:a},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r};let h=ne.runKernel(Qd,u,c);return h=Ze(h,i.dtype),l?ie(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Fv=ae({avgPool_:bY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yY(t,e,n,s,r,i="NDHWC"){const o=q(t,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),G(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),G(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),G(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),tr("avgPool3d",s,r);const u={x:a},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:i};let h=ne.runKernel(Jd,u,c);return h=Ze(h,a.dtype),l?ie(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const vY=ae({avgPool3d_:yY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wY(t,e=0){G(t.length>=1,()=>"Pass at least one tensor to concat");const n=f_(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),n.length===1)return il(n[0]);const s=n,r={axis:e};return ne.runKernel(sf,s,r)}const Ys=ae({concat_:wY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SY(t,e,n=!1,s=!1){let r=q(t,"a","matMul"),i=q(e,"b","matMul");[r,i]=Bn(r,i);const o={a:r,b:i},a={transposeA:n,transposeB:s};return ne.runKernel(ef,o,a)}const Lt=ae({matMul_:SY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CY(t){const n={x:q(t,"x","sigmoid","float32")};return ne.runKernel(Gc,n)}const Qc=ae({sigmoid_:CY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TY(t,e,n){const s=q(t,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:e,size:n};return ne.runKernel(Gf,r,i)}const sn=ae({slice_:TY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IY(t){const n={x:q(t,"x","tanh","float32")};return ne.runKernel(Xc,n)}const W0=ae({tanh_:IY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kY(t,e,n){const s=q(t,"x","batchToSpaceND"),r=e.reduce((a,l)=>a*l);G(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),G(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),G(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const i={x:s},o={blockShape:e,crops:n};return ne.runKernel(tf,i,o)}const Uv=ae({batchToSpaceND_:kY});function EY(t){let e;return t.rank===0||t.rank===1?e=ie(t,[1,1,1,t.size]):t.rank===2?e=ie(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=ie(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Y(t,e,n,s,r,i){i==null&&(i=.001);const o=q(t,"x","batchNorm"),a=q(e,"mean","batchNorm"),l=q(n,"variance","batchNorm");let u;r!=null&&(u=q(r,"scale","batchNorm"));let c;s!=null&&(c=q(s,"offset","batchNorm")),G(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),G(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),G(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:EY(o),scale:u,offset:c,mean:a,variance:l},f={varianceEpsilon:i},p=ne.runKernel(ff,d,f);return ie(p,o.shape)}const H0=ae({batchNorm_:_Y});function $Y(t,e,n,s,r,i){const o=q(t,"x","batchNorm"),a=q(e,"mean","batchNorm"),l=q(n,"variance","batchNorm");let u;r!=null&&(u=q(r,"scale","batchNorm"));let c;return s!=null&&(c=q(s,"offset","batchNorm")),G(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),G(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),G(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&G(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&G(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),H0(o,a,l,c,u,i)}const RY=ae({batchNorm2d_:$Y});function AY(t,e,n,s,r,i){const o=q(t,"x","batchNorm"),a=q(e,"mean","batchNorm"),l=q(n,"variance","batchNorm");let u;r!=null&&(u=q(r,"scale","batchNorm"));let c;return s!=null&&(c=q(s,"offset","batchNorm")),G(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),G(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),G(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&G(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&G(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),H0(o,a,l,c,u,i)}const PY=ae({batchNorm3d_:AY});function DY(t,e,n,s,r,i){const o=q(t,"x","batchNorm"),a=q(e,"mean","batchNorm"),l=q(n,"variance","batchNorm");let u;r!=null&&(u=q(r,"scale","batchNorm"));let c;return s!=null&&(c=q(s,"offset","batchNorm")),G(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),G(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),G(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&G(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&G(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),H0(o,a,l,c,u,i)}const NY=ae({batchNorm4d_:DY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MY(t,e,n){const s=q(t,"x","bincount"),r=q(e,"weights","bincount");G(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),G(n>=0,()=>`size must be non-negative, but got ${n}.`),G(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:n};return ne.runKernel(l0,i,o)}const LY=ae({bincount_:MY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OY(t,e){let n=q(t,"broadcastTo","x");const s=n.shape;if(Ao(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const u=n.shape.slice();for(;u.length<e.length;)u.unshift(1);n=ie(n,u)}const r=n.shape,i=Array.from(e);for(let u=e.length-1;u>=0;u--)if(r[u]===e[u])i[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(i.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return il(n);const a={x:n},l={reps:i};return ne.runKernel(qc,a,l)}const nd=ae({broadcastTo_:OY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FY(t){const n={x:q(t,"x","ceil","float32")};return ne.runKernel(cc,n)}const UY=ae({ceil_:FY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K0(t,e,n){Ao(t),n=n||_l(e);const s={shape:t,value:e,dtype:n};return ne.runKernel(S0,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BY(t,e,n){const s=q(t,"x","clipByValue");if(G(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return K0(s.shape,e,s.dtype);const r={x:s},i={clipValueMin:e,clipValueMax:n};return ne.runKernel(hc,r,i)}const Ir=ae({clipByValue_:BY});function zY(t){return Ys(t,0)}const GY=ae({concat1d_:zY});function VY(t,e){return Ys(t,e)}const WY=ae({concat2d_:VY});function HY(t,e){return Ys(t,e)}const KY=ae({concat3d_:HY});function jY(t,e){return Ys(t,e)}const XY=ae({concat4d_:jY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qY(t,e,n,s,r="NHWC",i=[1,1],o){const a=q(t,"x","conv2d","float32"),l=q(e,"filter","conv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),G(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),G(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),tr("conv2d",s,o);const h=r==="NHWC"?u.shape[3]:u.shape[1];G(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),G(ds(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),G(pl(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),G(pl(n),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:u,filter:l},f={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},p=ne.runKernel(rf,d,f);return c?ie(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const ml=ae({conv2d_:qY});function YY(t,e,n,s,r="NWC",i=1,o){const a=q(t,"x","conv1d"),l=q(e,"filter","conv1d");let u=a,c=!1;a.rank===2&&(c=!0,u=ie(a,[1,a.shape[0],a.shape[1]])),G(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),G(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),tr("conv1d",s,o),G(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),G(ds(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),G(pl(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),G(pl(n),()=>"Error in conv1D: Stride should be larger than 0."),G(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=ie(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=ie(u,[u.shape[0],1,u.shape[1],u.shape[2]]),m=ml(d,h,[1,n],s,"NHWC",[1,i],o);return c?ie(m,[m.shape[2],m.shape[3]]):ie(m,[m.shape[0],m.shape[2],m.shape[3]])}const k_=ae({conv1d_:YY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZY(t,e,n,s,r,i="NHWC",o){G(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,l=e,u=!1;e.rank===3&&(u=!0,l=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),G(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),G(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),G(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=i==="NHWC"?a[3]:a[1],h=i==="NHWC"?l.shape[3]:l.shape[1];G(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),G(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),tr("conv2dDerInput",r,o);const d={dy:l,filter:n},f={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:a},p=ne.runKernel(of,d,f);return u?ie(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Bv=ae({conv2DBackpropInput_:ZY});function QY(t,e,n,s,r,i){const o=q(t,"x","conv2dTranspose"),a=q(e,"filter","conv2dTranspose");return Bv(n,o,a,s,r,"NHWC",i)}const E_=ae({conv2dTranspose_:QY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JY(t,e,n,s,r="NDHWC",i=[1,1,1]){const o=q(t,"x","conv3d"),a=q(e,"filter","conv3d");let l=o,u=!1;o.rank===4&&(u=!0,l=ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),G(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),G(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),G(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),G(ds(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),G(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),G(pl(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),G(pl(n),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:a},h={strides:n,pad:s,dataFormat:r,dilations:i},d=ne.runKernel(af,c,h);return u?ie(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const eZ=ae({conv3d_:JY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tZ(t,e,n,s,r){G(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,o=e,a=!1;e.rank===4&&(a=!0,o=ie(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,t[0],t[1],t[2],t[3]]);const l=i[4],u=o.shape[4];G(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),G(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),G(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),G(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),G(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c={dy:o,filter:n},h={pad:r,strides:s,inputShape:i},d=ne.runKernel(d0,c,h);return a?ie(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const __=ae({conv3DBackpropInput_:tZ});function nZ(t,e,n,s,r){const i=q(t,"x","conv3dTranspose"),o=q(e,"filter","conv3dTranspose");return __(n,i,o,s,r)}const sZ=ae({conv3dTranspose_:nZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rZ(t){const n={x:q(t,"x","cos","float32")};return ne.runKernel(dc,n)}const zv=ae({cos_:rZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iZ(t){const n={x:q(t,"x","cosh","float32")};return ne.runKernel(fc,n)}const $_=ae({cosh_:iZ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oZ(t,e=0,n=!1,s=!1){const i={x:q(t,"x","cumprod")},o={axis:e,exclusive:n,reverse:s};return ne.runKernel(f0,i,o)}const j1=ae({cumprod_:oZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aZ(t,e=0,n=!1,s=!1){const i={x:q(t,"x","cumsum")},o={axis:e,exclusive:n,reverse:s};return ne.runKernel(lf,i,o)}const R_=ae({cumsum_:aZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lZ(t,e,n,s=!1){const r=q(t,"x","denseBincount"),i=q(e,"weights","denseBincount");G(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),G(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),G(n>=0,()=>`size must be non-negative, but got ${n}.`),G(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},a={size:n,binaryOutput:s};return ne.runKernel(m0,o,a)}const EC=ae({denseBincount_:lZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uZ(t,e,n="NHWC"){const s=q(t,"x","depthToSpace","float32"),r=n==="NHWC"?s.shape[1]:s.shape[2],i=n==="NHWC"?s.shape[2]:s.shape[3],o=n==="NHWC"?s.shape[3]:s.shape[1];G(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),G(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),G(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${s.shape}`),G(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${s.shape}`);const a={x:s},l={blockSize:e,dataFormat:n};return ne.runKernel(g0,a,l)}const cZ=ae({depthToSpace_:uZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hZ(t,e,n,s,r="NHWC",i=[1,1],o){const a=q(t,"x","depthwiseConv2d","float32"),l=q(e,"filter","depthwiseConv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),G(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),G(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=r==="NHWC"?u.shape[3]:u.shape[1];G(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),tr("depthwiseConv2d",s,o);const d={x:u,filter:l},f={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},p=ne.runKernel(uf,d,f);return c?ie(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Gv=ae({depthwiseConv2d_:hZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dZ(t,e,n,s,r=[1,1],i="NHWC"){const o=q(t,"x","dilation2d"),a=q(e,"filter","dilation2d");G(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),G(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),G(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,u=!1;o.rank===3&&(l=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0),G(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const c={x:l,filter:a},h={strides:n,pad:s,dilations:r},d=ne.runKernel(cf,c,h);return u?ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const fZ=ae({dilation2d_:dZ});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oa(t,e){const n=t.length,s=[];for(let r=0;r<n;r++){const i=n-1-r,o=t[i]||1;(e[e.length-1-r]||1)>1&&o===1&&s.unshift(i)}return s}function rs(t,e){const n=[];for(let s=0;s<e.length;s++){const r=t[t.length-s-1],i=e.length-s-1,o=e[i];(r==null||r===1&&o>1)&&n.unshift(i)}return n}function pt(t,e){const n=Math.max(t.length,e.length),s=new Array(n);for(let r=0;r<n;r++){let i=t[t.length-r-1];i==null&&(i=1);let o=e[e.length-r-1];if(o==null&&(o=1),i===1)s[n-r-1]=o;else if(o===1)s[n-r-1]=i;else if(i!==o){const a=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(a)}else s[n-r-1]=i}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pZ(t,e){let n=q(t,"a","equal","string_or_numeric"),s=q(e,"b","equal","string_or_numeric");[n,s]=Bn(n,s),pt(n.shape,s.shape);const r={a:n,b:s};return ne.runKernel(hf,r)}const Hi=ae({equal_:pZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mZ(t,e,n){const s=q(e,"a","where"),r=q(n,"b","where"),i=q(t,"condition","where","bool"),o=pt(pt(i.shape,s.shape),r.shape),a=nd(i,o),l=nd(s,o),u=nd(r,o),c={condition:a,t:l,e:u};return ne.runKernel(zf,c)}const Fs=ae({where_:mZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gZ(t){const n={x:q(t,"x","zerosLike")};return ne.runKernel(qf,n)}const Ft=ae({zerosLike_:gZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xZ(t,e){let n=q(t,"a","div"),s=q(e,"b","div");[n,s]=Bn(n,s);const r=ct(n,s),i=Ft(r),o=Hi(s,i);return Fs(o,i,r)}const bZ=ae({divNoNan_:xZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yZ(t,e){const n=q(t,"t1","dot"),s=q(e,"t2","dot");G((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=n.rank===1?n.size:n.shape[1],i=s.rank===1?s.size:s.shape[0];if(G(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),n.rank===1&&s.rank===1){const o=ie(n,[1,-1]),a=ie(s,[-1,1]),l=Lt(o,a);return ie(l,[])}else if(n.rank===1&&s.rank===2){const o=ie(n,[1,-1]),a=ie(s,[s.shape[0],s.shape[1]]),l=Lt(o,a);return ie(l,[l.size])}else if(n.rank===2&&s.rank===1){const o=ie(s,[-1,1]),a=Lt(n,o);return ie(a,[a.size])}else{const o=ie(s,[s.shape[0],s.shape[1]]);return Lt(n,o)}}const vZ=ae({dot_:yZ});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wZ(t,...e){const n=e.map((r,i)=>q(r,`tensors${i}`,"einsum")),s={equation:t};return ne.runKernel(y0,n,s)}const vh=ae({einsum_:wZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SZ(t){const n={x:q(t,"x","elu","float32")};return ne.runKernel(mc,n)}const j0=ae({elu_:SZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CZ(t){let e=q(t,"x","erf");G(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ze(e,"float32"));const n={x:e};return ne.runKernel(gc,n)}const A_=ae({erf_:CZ});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vv(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function P_(t,e,n){const s=t.length+e.length,r=[];let i=0,o=0;for(let a=0;a<s;a++)n.indexOf(a)===-1?r.push(t[i++]):r.push(e[o++]);return r}function Gn(t,e){const n=[],s=t.length;for(let i=0;i<s;i++)e.indexOf(i)===-1&&n.push(t[i]);const r=e.map(i=>t[i]);return[n,r]}function zn(t,e){const n=e.map(s=>1);return P_(t,n,e)}function qn(t,e,n){G(Vv(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function Jt(t,e){if(Vv(t,e))return null;const n=[];for(let s=0;s<e;++s)t.indexOf(s)===-1&&n.push(s);return t.forEach(s=>n.push(s)),n}function Qi(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function an(t,e){const n=[];for(let s=e-t;s<e;++s)n.push(s);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TZ(t,e=null,n=!1){const r={x:q(t,"x","max")},i={reductionIndices:e,keepDims:n};return ne.runKernel(Cf,r,i)}const si=ae({max_:TZ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IZ(t,e=null,n=!1){const r={x:q(t,"x","min")},i={axis:e,keepDims:n};return ne.runKernel(Ef,r,i)}const Qm=ae({min_:IZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kZ(t,e){let n=q(t,"base","pow"),s=q(e,"exp","pow");[n,s]=Bn(n,s);const r={a:n,b:s};return ne.runKernel(Pc,r)}const gl=ae({pow_:kZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ht(t,e){if((Kr(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Kr(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return V0(t,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EZ(t){const n={x:q(t,"x","sqrt","float32")};return ne.runKernel(Wc,n)}const Is=ae({sqrt_:EZ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Z(t){const e=q(t,"x","square"),n={};return ne.runKernel("Square",{x:e},n)}const dn=ae({square_:_Z});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Z(t,e=null,n=!1){let s=q(t,"x","sum");s.dtype==="bool"&&(s=Ze(s,"int32"));const r={x:s},i={axis:e,keepDims:n};return ne.runKernel(Vf,r,i)}const ut=ae({sum_:$Z});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RZ(t,e="euclidean",n=null,s=!1){t=q(t,"x","norm");const r=D_(t,e,n);let i=r.shape;if(s){const o=wt(n,t.shape);i=zn(r.shape,o)}return ie(r,i)}function D_(t,e,n=null){if(t.rank===0)return As(t);if(t.rank!==1&&n===null)return D_(ie(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return ut(As(t),n);if(e===1/0)return si(As(t),n);if(e===-1/0)return Qm(As(t),n);if(e==="euclidean"||e===2)return Is(ut(gl(As(t),Ht(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return si(ut(As(t),n[0]),n[1]-1);if(e===1/0)return si(ut(As(t),n[1]),n[0]);if(e===-1/0)return Qm(ut(As(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return Is(ut(dn(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const X0=ae({norm_:RZ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AZ(t,e=null,n=!1){return X0(t,"euclidean",e,n)}const PZ=ae({euclideanNorm_:AZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DZ(t){const n={x:q(t,"x","exp")};return ne.runKernel(xc,n)}const Ki=ae({exp_:DZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NZ(t,e=0){const n=q(t,"x","expandDims","string_or_numeric");G(e<=n.rank,()=>"Axis must be <= rank of the tensor");const s={input:n},r={dim:e};return ne.runKernel(df,s,r)}const js=ae({expandDims_:NZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MZ(t){const n={x:q(t,"x","expm1")};return ne.runKernel(bc,n)}const LZ=ae({expm1_:MZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OZ(t,e){const n=q(t,"x","tile","string_or_numeric");G(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const s={x:n},r={reps:e};return ne.runKernel(qc,s,r)}const ei=ae({tile_:OZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FZ(t,e,n,s="float32"){e==null&&(e=t);const r=Ct([t,e],s),i=t<=e?t:e;for(let a=0;a<i;++a)r.set(1,a,a);const o=ie(r.toTensor(),[t,e]);if(n==null)return o;if(n.length===1)return ei(js(o,0),[n[0],1,1]);if(n.length===2)return ei(js(js(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return ei(js(js(js(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const Wv=ae({eye_:FZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UZ(t){const n={x:q(t,"x","floor","float32")};return ne.runKernel(yc,n)}const q0=ae({floor_:UZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BZ(t,e,n=0,s=0){const r=q(t,"x","gather"),i=q(e,"indices","gather","int32"),o={x:r,indices:i},a={axis:n,batchDims:s};return ne.runKernel(pf,o,a)}const Hv=ae({gather_:BZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zZ(t,e){let n=q(t,"a","greater","string_or_numeric"),s=q(e,"b","greater","string_or_numeric");[n,s]=Bn(n,s),pt(n.shape,s.shape);const r={a:n,b:s};return ne.runKernel(mf,r)}const _r=ae({greater_:zZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GZ(t,e){let n=q(t,"a","greaterEqual","string_or_numeric"),s=q(e,"b","greaterEqual","string_or_numeric");[n,s]=Bn(n,s),pt(n.shape,s.shape);const r={a:n,b:s};return ne.runKernel(wc,r)}const Pl=ae({greaterEqual_:GZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VZ(t){const n={input:q(t,"input","imag")};return ne.runKernel(I0,n)}const Kv=ae({imag_:VZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WZ(t){const n={x:q(t,"x","isFinite")};return ne.runKernel(Cc,n)}const HZ=ae({isFinite_:WZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KZ(t){const n={x:q(t,"x","isInf")};return ne.runKernel(Tc,n)}const jZ=ae({isInf_:KZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XZ(t){const n={x:q(t,"x","isNaN")};return ne.runKernel(Ic,n)}const qZ=ae({isNaN_:XZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YZ(t,e=.2){const s={x:q(t,"x","leakyRelu")},r={alpha:e};return ne.runKernel(gf,s,r)}const jv=ae({leakyRelu_:YZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZZ(t,e){let n=q(t,"a","less","string_or_numeric"),s=q(e,"b","less","string_or_numeric");[n,s]=Bn(n,s),pt(n.shape,s.shape);const r={a:n,b:s};return ne.runKernel(xf,r)}const Jm=ae({less_:ZZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QZ(t,e){let n=q(t,"a","lessEqual","string_or_numeric"),s=q(e,"b","lessEqual","string_or_numeric");[n,s]=Bn(n,s),pt(n.shape,s.shape);const r={a:n,b:s};return ne.runKernel(bf,r)}const Jc=ae({lessEqual_:QZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JZ(t,e=5,n=1,s=1,r=.5){const i=q(t,"x","localResponseNormalization");G(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),G(Fu(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},u={depthRadius:e,bias:n,alpha:s,beta:r},c=ne.runKernel(Sf,l,u);return a?ie(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const eQ=ae({localResponseNormalization_:JZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tQ(t){const n={x:q(t,"x","log","float32")};return ne.runKernel(kc,n)}const ji=ae({log_:tQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nQ(t){const n={x:q(t,"x","log1p")};return ne.runKernel(Ec,n)}const N_=ae({log1p_:nQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sQ(t,e){G(D1(t),()=>"The f passed in variableGrads(f) must be a function"),G(e==null||Array.isArray(e)&&e.every(u=>u instanceof Zm),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const u in ne.registeredVariables)e.push(ne.registeredVariables[u])}const s=n?e.filter(u=>!u.trainable):null,r=e.length;e=e.filter(u=>u.trainable),G(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:o,grads:a}=ne.gradients(t,e,null,i);G(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),G(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),s!=null&&s.forEach(u=>l[u.name]=null),{value:o,grads:l}}function Gu(t){return ne.customGrad(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rQ(t){const n={x:q(t,"x","neg")};return ne.runKernel($f,n)}const Un=ae({neg_:rQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iQ(t){const n={x:q(t,"x","softplus")};return ne.runKernel(Vc,n)}const Yf=ae({softplus_:iQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oQ(t){const e=q(t,"x","logSigmoid");return Gu(s=>({value:Un(Yf(Un(s))),gradFunc:o=>te(o,Qc(Un(s)))}))(e)}const aQ=ae({logSigmoid_:oQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lQ(t,e){let n=q(t,"a","sub"),s=q(e,"b","sub");[n,s]=Bn(n,s);const r={a:n,b:s};return ne.runKernel(Kc,r)}const mt=ae({sub_:lQ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uQ(t,e=-1){const n=q(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return Gu((r,i)=>{const a=si(r,e,!0),l=mt(r,a),u=mt(Ze(l,"float32"),ji(ut(Ki(l),e,!0)));return i([u]),{value:u,gradFunc:(h,d)=>{const[f]=d,p=!0,g=Ki(f);return mt(h,te(ut(h,e,p),g))}}})(n)}const M_=ae({logSoftmax_:uQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cQ(t,e=null,n=!1){const s=q(t,"x","logSumExp"),r=wt(e,s.shape),i=si(s,r,!0),o=mt(s,i),a=Ki(o),l=ut(a,r),u=ji(l),c=Me(ie(i,u.shape),u);if(n){const h=zn(c.shape,r);return ie(c,h)}return c}const L_=ae({logSumExp_:cQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hQ(t,e){const n=q(t,"a","logicalAnd","bool"),s=q(e,"b","logicalAnd","bool");pt(n.shape,s.shape);const r={a:n,b:s};return ne.runKernel(yf,r)}const _o=ae({logicalAnd_:hQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dQ(t){const n={x:q(t,"x","logicalNot","bool")};return ne.runKernel(vf,n)}const Xv=ae({logicalNot_:dQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fQ(t,e){const n=q(t,"a","logicalOr","bool"),s=q(e,"b","logicalOr","bool");pt(n.shape,s.shape);const r={a:n,b:s};return ne.runKernel(wf,r)}const O_=ae({logicalOr_:fQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pQ(t,e){const n=q(t,"a","logicalXor","bool"),s=q(e,"b","logicalXor","bool");return pt(n.shape,s.shape),_o(O_(t,e),Xv(_o(t,e)))}const mQ=ae({logicalXor_:pQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gQ(t,e,n,s,r){const i=q(t,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),G(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),G(ds(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),tr("maxPool",s,r);const u={x:a},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r},h=ne.runKernel(Tf,u,c);return l?ie(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const qv=ae({maxPool_:gQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xQ(t,e=[1,1,1],n,s,r,i="NDHWC"){const o=q(t,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),G(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),G(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),tr("maxPool3d",s,r);const u={x:a},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:i},h=ne.runKernel(If,u,c);return l?ie(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const bQ=ae({maxPool3d_:xQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yQ(t,e){let n=q(t,"a","maximum"),s=q(e,"b","maximum");[n,s]=Bn(n,s),n.dtype==="bool"&&(n=Ze(n,"int32"),s=Ze(s,"int32")),pt(n.shape,s.shape);const r={a:n,b:s};return ne.runKernel(_c,r)}const xa=ae({maximum_:yQ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vQ(t,e=null,n=!1){const r={x:q(t,"x","mean")},i={axis:e,keepDims:n};return ne.runKernel(kf,r,i)}const Hn=ae({mean_:vQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jn(t,e="float32"){if(Ao(t),e==="complex64"){const s=Jn(t,"float32"),r=Jn(t,"float32");return zu(s,r)}const n=vs(oe(t),e);return ne.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ba(t,e="float32"){if(Ao(t),e==="complex64"){const s=ba(t,"float32"),r=Jn(t,"float32");return zu(s,r)}const n=dv(oe(t),e);return ne.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wQ(t,e){let n=q(t,"a","minimum"),s=q(e,"b","minimum");[n,s]=Bn(n,s),n.dtype==="bool"&&(n=Ze(n,"int32"),s=Ze(s,"int32")),pt(n.shape,s.shape);const r={a:n,b:s};return ne.runKernel($c,r)}const kd=ae({minimum_:wQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SQ(t,e,n){G(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=q(t,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");G(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=n==="reflect"?1:0;for(let a=0;a<s.rank;a++)G(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),G(e[a][0]>=0&&e[a][0]<=s.shape[a]-r&&e[a][1]>=0&&e[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:e,mode:n},o={x:s};return ne.runKernel(_f,o,i)}const CQ=ae({mirrorPad_:SQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TQ(t,e){let n=q(t,"a","mod"),s=q(e,"b","mod");[n,s]=Bn(n,s);const r={a:n,b:s};return ne.runKernel(Rc,r)}const IQ=ae({mod_:TQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kQ(t,e=null,n=!1){t=q(t,"x","moments");const s=wt(e,t.shape),r=Hn(t,s,n);let i=r.shape;n||(i=zn(r.shape,s));const o=dn(mt(Ze(t,"float32"),ie(r,i))),a=Hn(o,s,n);return{mean:r,variance:a}}const Yv=ae({moments_:kQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EQ(t,e){let n=q(t,"a","notEqual","string_or_numeric"),s=q(e,"b","notEqual","string_or_numeric");[n,s]=Bn(n,s),pt(n.shape,s.shape);const r={a:n,b:s};return ne.runKernel(Rf,r)}const eg=ae({notEqual_:EQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Q(t,e,n=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:q(t,"indices","oneHot","int32")},a={dtype:r,depth:e,onValue:n,offValue:s};return ne.runKernel(Pf,o,a)}const F_=ae({oneHot_:_Q});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Q(t){const n={x:q(t,"x","onesLike")};return ne.runKernel(Af,n)}const jr=ae({onesLike_:$Q});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RQ(t,e,n=0){const s=q(t,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:n},i={x:s};return ne.runKernel(Nf,i,r)}const Zv=ae({pad_:RQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AQ(t,e,n){const s=q(t,"x","spaceToBatchND");G(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),G(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),G(s.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+n[l-1][0]+n[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},i={blockShape:e,paddings:n};return ne.runKernel(Wf,r,i)}const Qv=ae({spaceToBatchND_:AQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PQ(t,e,n,s,r,i,o){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const a=q(t,"x","maxPool");let l=a,u=!1;a.rank===3&&(u=!0,l=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),G(ds(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const c=ks(l.shape,e,i,r,s),h=[c.dilationHeight,c.dilationWidth];let d;s==="same"?d=NQ([c.filterHeight,c.filterWidth],h):d=[[0,0],[0,0]];const f=h[0]===1&&h[1]===1,[p,g]=DQ([c.inHeight,c.inWidth],h,d),m=f?s:"valid",x=f?l:Qv(l,h,p),v=(n==="avg"?()=>Fv(x,e,i,m,o):()=>qv(x,e,i,m,o))(),y=f?v:Uv(v,h,g);return u?ie(y,[y.shape[1],y.shape[2],y.shape[3]]):y}function DQ(t,e,n){const s=n.map(c=>c[0]),r=n.map(c=>c[1]),i=t.concat(s,r),o=e.map((c,h)=>(c-i[h]%c)%c),a=r.map((c,h)=>c+o[h]),l=e.map((c,h)=>[s[h],a[h]]),u=e.map((c,h)=>[0,o[h]]);return[l,u]}function NQ(t,e){const s=t.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),i=s.map((o,a)=>o-r[a]);return s.map((o,a)=>[r[a],i[a]])}const MQ=ae({pool_:PQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LQ(t,e){const n=q(t,"x","prelu"),s=q(e,"alpha","prelu"),r={x:n,alpha:s};return ne.runKernel(Mf,r)}const Jv=ae({prelu_:LQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OQ(t,e=null,n=!1){let s=q(t,"x","prod");s.dtype==="bool"&&(s=Ze(s,"int32"));const r={x:s},i={axis:e,keepDims:n};return ne.runKernel(Lf,r,i)}const FQ=ae({prod_:OQ});var e2={exports:{}};e2.exports;(function(t){(function(e,n,s){function r(l){var u=this,c=a();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function i(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function o(l,u){var c=new r(l),h=u&&u.state,d=c.next;return d.int32=function(){return c.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&i(h,c),d.state=function(){return i(c,{})}),d}function a(){var l=4022871197,u=function(c){c=String(c);for(var h=0;h<c.length;h++){l+=c.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return u}n&&n.exports?n.exports=o:this.alea=o})(kl,t)})(e2);var UQ=e2.exports,t2={exports:{}};t2.exports;(function(t){(function(e,n,s){function r(a){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,f=(u.next()>>>0)/4294967296,p=(d+f)/(1<<21);while(p===0);return p},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&i(c,u),h.state=function(){return i(u,{})}),h}n&&n.exports?n.exports=o:this.xor128=o})(kl,t)})(t2);var BQ=t2.exports,n2={exports:{}};n2.exports;(function(t){(function(e,n,s){function r(a){var l=this,u="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,f=(u.next()>>>0)/4294967296,p=(d+f)/(1<<21);while(p===0);return p},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&i(c,u),h.state=function(){return i(u,{})}),h}n&&n.exports?n.exports=o:this.xorwow=o})(kl,t)})(n2);var zQ=n2.exports,s2={exports:{}};s2.exports;(function(t){(function(e,n,s){function r(a){var l=this;l.next=function(){var c=l.x,h=l.i,d,f;return d=c[h],d^=d>>>7,f=d^d<<24,d=c[h+1&7],f^=d^d>>>10,d=c[h+3&7],f^=d^d>>>3,d=c[h+4&7],f^=d^d<<7,d=c[h+7&7],d=d^d<<13,f^=d^d<<9,c[h]=f,l.i=h+1&7,f};function u(c,h){var d,f=[];if(h===(h|0))f[0]=h;else for(h=""+h,d=0;d<h.length;++d)f[d&7]=f[d&7]<<15^h.charCodeAt(d)+f[d+1&7]<<13;for(;f.length<8;)f.push(0);for(d=0;d<8&&f[d]===0;++d);for(d==8?f[7]=-1:f[d],c.x=f,c.i=0,d=256;d>0;--d)c.next()}u(l,a)}function i(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,f=(u.next()>>>0)/4294967296,p=(d+f)/(1<<21);while(p===0);return p},h.int32=u.next,h.quick=h,c&&(c.x&&i(c,u),h.state=function(){return i(u,{})}),h}n&&n.exports?n.exports=o:this.xorshift7=o})(kl,t)})(s2);var GQ=s2.exports,r2={exports:{}};r2.exports;(function(t){(function(e,n,s){function r(a){var l=this;l.next=function(){var c=l.w,h=l.X,d=l.i,f,p;return l.w=c=c+1640531527|0,p=h[d+34&127],f=h[d=d+1&127],p^=p<<13,f^=f<<17,p^=p>>>15,f^=f>>>12,p=h[d]=p^f,l.i=d,p+(c^c>>>16)|0};function u(c,h){var d,f,p,g,m,x=[],b=128;for(h===(h|0)?(f=h,h=null):(h=h+"\0",f=0,b=Math.max(b,h.length)),p=0,g=-32;g<b;++g)h&&(f^=h.charCodeAt((g+32)%h.length)),g===0&&(m=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,g>=0&&(m=m+1640531527|0,d=x[g&127]^=f+m,p=d==0?p+1:0);for(p>=128&&(x[(h&&h.length||0)&127]=-1),p=127,g=4*128;g>0;--g)f=x[p+34&127],d=x[p=p+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,x[p]=f^d;c.w=m,c.X=x,c.i=p}u(l,a)}function i(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,f=(u.next()>>>0)/4294967296,p=(d+f)/(1<<21);while(p===0);return p},h.int32=u.next,h.quick=h,c&&(c.X&&i(c,u),h.state=function(){return i(u,{})}),h}n&&n.exports?n.exports=o:this.xor4096=o})(kl,t)})(r2);var VQ=r2.exports,i2={exports:{}};i2.exports;(function(t){(function(e,n,s){function r(a){var l=this,u="";l.next=function(){var h=l.b,d=l.c,f=l.d,p=l.a;return h=h<<25^h>>>7^d,d=d-f|0,f=f<<24^f>>>8^p,p=p-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-f|0,l.d=f<<16^d>>>16^p,l.a=p-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):u+=a;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function i(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,f=(u.next()>>>0)/4294967296,p=(d+f)/(1<<21);while(p===0);return p},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&i(c,u),h.state=function(){return i(u,{})}),h}n&&n.exports?n.exports=o:this.tychei=o})(kl,t)})(i2);var WQ=i2.exports,U_={exports:{}};const HQ={},KQ=Object.freeze(Object.defineProperty({__proto__:null,default:HQ},Symbol.toStringTag,{value:"Module"})),jQ=iF(KQ);(function(t){(function(e,n,s){var r=256,i=6,o=52,a="random",l=s.pow(r,i),u=s.pow(2,o),c=u*2,h=r-1,d;function f(y,C,I){var $=[];C=C==!0?{entropy:!0}:C||{};var T=x(m(C.entropy?[y,v(n)]:y??b(),3),$),S=new p($),E=function(){for(var _=S.g(i),N=l,P=0;_<u;)_=(_+P)*r,N*=r,P=S.g(1);for(;_>=c;)_/=2,N/=2,P>>>=1;return(_+P)/N};return E.int32=function(){return S.g(4)|0},E.quick=function(){return S.g(4)/4294967296},E.double=E,x(v(S.S),n),(C.pass||I||function(_,N,P,M){return M&&(M.S&&g(M,S),_.state=function(){return g(S,{})}),P?(s[a]=_,N):_})(E,T,"global"in C?C.global:this==s,C.state)}function p(y){var C,I=y.length,$=this,T=0,S=$.i=$.j=0,E=$.S=[];for(I||(y=[I++]);T<r;)E[T]=T++;for(T=0;T<r;T++)E[T]=E[S=h&S+y[T%I]+(C=E[T])],E[S]=C;($.g=function(_){for(var N,P=0,M=$.i,z=$.j,A=$.S;_--;)N=A[M=h&M+1],P=P*r+A[h&(A[M]=A[z=h&z+N])+(A[z]=N)];return $.i=M,$.j=z,P})(r)}function g(y,C){return C.i=y.i,C.j=y.j,C.S=y.S.slice(),C}function m(y,C){var I=[],$=typeof y,T;if(C&&$=="object")for(T in y)try{I.push(m(y[T],C-1))}catch{}return I.length?I:$=="string"?y:y+"\0"}function x(y,C){for(var I=y+"",$,T=0;T<I.length;)C[h&T]=h&($^=C[h&T]*19)+I.charCodeAt(T++);return v(C)}function b(){try{var y;return d&&(y=d.randomBytes)?y=y(r):(y=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(y)),v(y)}catch{var C=e.navigator,I=C&&C.plugins;return[+new Date,e,I,e.screen,v(n)]}}function v(y){return String.fromCharCode.apply(0,y)}if(x(s.random(),n),t.exports){t.exports=f;try{d=jQ}catch{}}else s["seed"+a]=f})(typeof self<"u"?self:kl,[],Math)})(U_);var XQ=U_.exports,qQ=UQ,YQ=BQ,ZQ=zQ,QQ=GQ,JQ=VQ,eJ=WQ,Dl=XQ;Dl.alea=qQ;Dl.xor128=YQ;Dl.xorwow=ZQ;Dl.xorshift7=QQ;Dl.xor4096=JQ;Dl.tychei=eJ;var o2=Dl;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B_{constructor(e,n,s,r,i){this.mean=e,this.stdDev=n,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=o2.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,n,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*a,n=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class tJ{constructor(e=0,n=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=o2.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nJ(t,e=0,n=1,s,r){if(Ao(t),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new B_(e,n,s,!1,r),o=Ct(t,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const sJ=ae({randomNormal_:nJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rJ(t,e=0,n=1,s="float32",r){Ao(t);const i=Ct(t,s),o=new tJ(e,n,null,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Zf=ae({randomUniform_:rJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ed(t,e,n=1,s="float32"){if(n===0)throw new Error("Cannot have a step of zero");const r={start:t,stop:e,step:n,dtype:s};return ne.runKernel(A0,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iJ(t){const n={input:q(t,"input","real")};return ne.runKernel(P0,n)}const tg=ae({real_:iJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oJ(t){const n={x:q(t,"x","reciprocal")};return ne.runKernel(Dc,n)}const aJ=ae({reciprocal_:oJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lJ(t){const n={x:q(t,"x","relu")};return ne.runKernel(Nc,n)}const Nl=ae({relu_:lJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uJ(t){const n={x:q(t,"x","relu6")};return ne.runKernel(Mc,n)}const z_=ae({relu6_:uJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cJ(t,e){const s={x:q(t,"x","reverse")},r={dims:e};return ne.runKernel(Bf,s,r)}const xl=ae({reverse_:cJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hJ(t){const n={x:q(t,"x","round")};return ne.runKernel(Lc,n)}const G_=ae({round_:hJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dJ(t){const n={x:q(t,"x","rsqrt","float32")};return ne.runKernel(Oc,n)}const V_=ae({rsqrt_:dJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fJ(t){const n={x:q(t,"x","selu")};return ne.runKernel(Fc,n)}const W_=ae({selu_:fJ});function pJ(t,e,n,s,r,i=[1,1],o="NHWC"){const a=q(t,"x","separableConv2d"),l=q(e,"depthwiseFilter","separableConv2d"),u=q(n,"pointwiseFilter","separableConv2d");let c=a,h=!1;if(a.rank===3&&(h=!0,c=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");G(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),G(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),G(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),G(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),G(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],f=l.shape[3];G(u.shape[2]===d*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*f}, but got ${u.shape[2]}.`);const p=Gv(c,l,s,r,o,i),m=ml(p,u,1,"valid",o);return h?ie(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const H_=ae({separableConv2d_:pJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mJ(t){const n={x:q(t,"x","sign")};return ne.runKernel(zc,n)}const gJ=ae({sign_:mJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xJ(t){const n={x:q(t,"x","sin","float32")};return ne.runKernel(Uc,n)}const K_=ae({sin_:xJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bJ(t){const n={x:q(t,"x","sinh")};return ne.runKernel(Bc,n)}const j_=ae({sinh_:bJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yJ(t,e,n){const s=q(t,"x","slice1d");return G(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),sn(s,[e],[n])}const a2=ae({slice1d_:yJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vJ(t,e,n){const s=q(t,"x","slice2d");return G(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),sn(s,e,n)}const X_=ae({slice2d_:vJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wJ(t,e,n){const s=q(t,"x","slice3d");return G(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),sn(s,e,n)}const l2=ae({slice3d_:wJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SJ(t,e,n){const s=q(t,"x","slice4d");return G(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),sn(s,e,n)}const ng=ae({slice4d_:SJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CJ(t,e=-1){const n=q(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const s={logits:n},r={dim:e};return ne.runKernel(Kf,s,r)}const u2=ae({softmax_:CJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TJ(t){G(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return ne.runKernel(w0,e)}const q_=ae({fft_:TJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IJ(t){G(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return ne.runKernel(T0,e)}const X1=ae({ifft_:IJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kJ(t){const e=t.shape[t.shape.length-1],n=t.size/e;let s;if(e<=2){const r=ie(t,[n,e]);s=X1(r)}else{const r=[n,2*(e-1)],i=ie(tg(t),[n,e]),o=ie(Kv(t),[n,e]),a=xl(sn(i,[0,1],[n,e-2]),1),l=te(xl(sn(o,[0,1],[n,e-2]),1),Ht(-1)),u=Ys([i,a],1),c=Ys([o,l],1),h=ie(zu(u,c),[r[0],r[1]]);s=X1(h)}if(s=tg(s),t.rank===3&&t.shape[0]!==0){const r=s,i=t.shape[0];s=ie(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const EJ=ae({irfft_:kJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _J(t,e,n=0){const r={x:q(t,"x","split")},i={numOrSizeSplits:e,axis:n};return ne.runKernel(Hf,r,i)}const Cr=ae({split_:_J});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $J(t,e){G(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const s=t.size/n;let r;if(e!=null&&e<n){const p=t.shape.map(m=>0),g=t.shape.map(m=>m);g[t.shape.length-1]=e,r=sn(t,p,g),n=e}else if(e!=null&&e>n){const p=t.shape.map(g=>g);p[t.shape.length-1]=e-n,r=Ys([t,Jn(p)],t.shape.length-1),n=e}else r=t;const i=Ft(r),o=ie(zu(r,i),[s,n]),a=q_(o),l=Math.floor(n/2)+1,u=tg(a),c=Kv(a),h=Cr(u,[l,n-l],u.shape.length-1),d=Cr(c,[l,n-l],c.shape.length-1),f=r.shape.slice();return f[r.shape.length-1]=l,ie(zu(h[0],d[0]),f)}const RJ=ae({rfft_:$J});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AJ(t,e){let n=q(t,"a","squaredDifference"),s=q(e,"b","squaredDifference");[n,s]=Bn(n,s),pt(n.shape,s.shape);const r={a:n,b:s},i={};return ne.runKernel(Hc,r,i)}const PJ=ae({squaredDifference_:AJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DJ(t,e){const n=q(t,"x","squeeze","string_or_numeric");return ie(n,pa(n.shape,e).newShape)}const Qf=ae({squeeze_:DJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NJ(t,e=0){const n=f_(t,"tensors","stack","string_or_numeric");G(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&G(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const s=n,r={axis:e};return ne.runKernel(Df,s,r)}const $o=ae({stack_:NJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MJ(t,e=0){const s={x:q(t,"x","step")},r={alpha:e};return ne.runKernel(Yc,s,r)}const Jf=ae({step_:MJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LJ(t,e,n,s,r=0,i=0,o=0,a=0,l=0){const c={x:q(t,"x","stridedSlice","string_or_numeric")},h={begin:e,end:n,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return ne.runKernel(L0,c,h)}const OJ=ae({stridedSlice_:LJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FJ(t){const n={x:q(t,"x","tan","float32")};return ne.runKernel(jc,n)}const UJ=ae({tan_:FJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cr(t,e){NE(t);const n=G0(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return V0(t,null,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sd(t,e,n){if(NE(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=G0(t,n);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return V0(t,e,s,n)}function Y_(t,e,n){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(i+` update.rank < ${r}. `);if(t.length<s+(n.rank-r))throw new Error(i+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+t.length-s)throw new Error(i+` update.rank != ${r+t.length-s}`);for(let o=0;o<r;++o)if(n.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<n.rank-r;++o)if(n.shape[o+r]!==t[o+s])throw new Error(i+` updates.shape[${o+r}] (${n.shape[o+r]}) != shape[${o+r}] (${t[o+r]})`)}function BJ(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}Y_(n,e,t)}function Ji(t,e,n){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=n.length;let o=1;for(let h=r;h<i;++h)o*=n[h];const a=r<1?1:r,l=oe(e.shape)/a,u=[...lt(n.slice(0,r)),1],c=oe(n);return{sliceRank:r,numUpdates:l,sliceSize:o,strides:u,outputSize:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zJ(t,e=1,n=!0){const s=q(t,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},o={k:e,sorted:n},[a,l]=ne.runKernel(O0,i,o);return{values:a,indices:l}}const GJ=ae({topk_:zJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VJ(t,e=0,n=1,s,r){if(Ao(t),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new B_(e,n,s,!0,r),o=Ct(t,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Z_=ae({truncatedNormal_:VJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WJ(t,e=0){const n=q(t,"x","unique","string_or_numeric");G(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:e},[i,o]=ne.runKernel(Av,s,r);return{values:i,indices:o}}const HJ=ae({unique_:WJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KJ(t,e,n){const s=q(t,"x","unsortedSegmentSum"),r=q(e,"segmentIds","unsortedSegmentSum","int32");G(Fu(n),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},o={numSegments:n};return ne.runKernel(Xf,i,o)}const Q_=ae({unsortedSegmentSum_:KJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jJ(t,e=0){const n=q(t,"x","unstack","string_or_numeric");G(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const s={value:n},r={axis:e};return ne.runKernel(jf,s,r)}const bl=ae({unstack_:jJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XJ(t,e=!0,n,s){return ne.makeVariable(t,e,n,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_(t,e){const n=[];for(let i=0;i<e.length;i++)e[i]&&n.push(i);const s=Ct(t,"int32"),r=Ct([n.length,t.length],"int32");for(let i=0;i<n.length;i++){const o=s.indexToLoc(n[i]),a=i*t.length;r.values.set(o,a)}return r.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qJ(t,e,n){const s=q(t,"x","transpose");if(e==null&&(e=s.shape.map((o,a)=>a).reverse()),G(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(o=>{G(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:e};return s.dtype==="complex64"?de(()=>{let o=tg(s),a=Kv(s);return o=ne.runKernel(rl,{x:o},i),a=ne.runKernel(rl,{x:a},i),n&&(a=Un(a)),zu(o,a)}):ne.runKernel(rl,r,i)}const Ot=ae({transpose_:qJ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YJ(t,e){if(e==null)return t.shape.slice();if(Pt(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let s=0;s<t.shape.length;s++)e[s]==null&&t.shape[s]!=null?n.push(t.shape[s]):n.push(e[s]);return n}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZJ(t,e,n,s){const r=q(t,"x","dropout");if(G(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),G(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof Qn?r.clone():r;const i=YJ(r,n),o=1-e,a=ct(q0(Me(Zf(i,0,1,"float32",s),o)),o);return te(r,a)}const QJ=ae({dropout_:ZJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JJ(t,e,n,s,r,i="NHWC",o){let a=t;t.rank===3&&(a=ie(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]])),G(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),G(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),G(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u=i==="NHWC"?a.shape[3]:a.shape[1],c=i==="NHWC"?l.shape[3]:l.shape[1];G(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),G(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),tr("conv2dDerFilter",r,o);const h={x:a,dy:l},d={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:n};return ne.runKernel(c0,h,d)}const c2=ae({conv2DBackpropFilter_:JJ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return te(t,Jf(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function d2(t,e){let n=e;const s=rs(t.shape,e.shape);return s.length>0&&(n=ut(n,s)),ie(n,t.shape)}function f2(t,e,n,s){if(e==="linear")return t;if(e==="relu")return Nl(t);if(e==="elu")return j0(t);if(e==="relu6")return z_(t);if(e==="prelu")return Jv(t,n);if(e==="leakyrelu")return jv(t,s);if(e==="sigmoid")return Qc(t);throw new Error(`Unknown fused activation ${e}.`)}const p2=(t,e)=>!(t>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eee({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",p2(ne.state.gradientDepth,l)===!1){G(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let I=ml(t,e,n,s,r,i,o);return a!=null&&(I=Me(I,a)),f2(I,l,u,c)}const h=q(t,"x","conv2d","float32"),d=q(e,"filter","conv2d","float32");let f=h,p=!1;h.rank===3&&(p=!0,f=ie(h,[1,h.shape[0],h.shape[1],h.shape[2]])),G(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),G(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),tr("fused conv2d",s,o);const g=r==="NHWC"?f.shape[3]:f.shape[1];G(d.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`),G(ds(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const m=gn(f.shape,d.shape,n,i,s,o);let x;a!=null&&(x=q(a,"bias","fused conv2d"),[x]=Bn(x,h),r==="NHWC"?pt(m.outShape,x.shape):(G(x.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`),G(x.shape.length===0||x.shape[0]===m.outChannels||x.shape[0]===1,()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let b;if(u!=null){const I=u.shape;if(G(I.length<=1||I.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${I.length}.`),I.length===1)G(I[0]===1||I[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the number of output channels (${m.outChannels}).`);else if(I.length===3)try{pt(I,m.outShape)}catch{const T=`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(T)}b=q(u,"prelu weights","fused conv2d")}const v=(I,$)=>{G(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[T,S,E,_]=$,N=h2(I,E,l);G(fl(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const P=Bv(S.shape,N,T,n,s),M=c2(S,N,T.shape,n,s),z=[P,M];if(_!=null){const A=d2(_,N);z.push(A)}return z},y={x:f,filter:d,bias:x,preluActivationWeights:b},C={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return a==null?Gu(($,T,S)=>{let E=ne.runKernel(Sd,y,C);return S([T,$,E]),p&&(E=ie(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:v}})(f,d):Gu(($,T,S,E)=>{let _=ne.runKernel(Sd,y,C);return E([T,$,_,S]),p&&(_=ie(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:v}})(f,d,x)}const tee=ae({fusedConv2d_:eee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nee(t,e,n,s,r,i=[1,1],o){let a=t;t.rank===3&&(a=ie(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:a,dy:l},c={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:n};return ne.runKernel(x0,u,c)}const see=ae({depthwiseConv2dNativeBackpropFilter_:nee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ree(t,e,n,s,r,i=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:a,filter:n},c={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:t},h=ne.runKernel(b0,u,c);return l?ie(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const iee=ae({depthwiseConv2dNativeBackpropInput_:ree});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oee({a:t,b:e,transposeA:n=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(p2(ne.state.gradientDepth,i)===!1){let _=Lt(t,e,n,s);return r!=null&&(_=Me(_,r)),f2(_,i,o,a)}let l=q(t,"a","fused matMul"),u=q(e,"b","fused matMul");[l,u]=Bn(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],f=s?u.shape[u.rank-2]:u.shape[u.rank-1],p=l.shape.slice(0,-2),g=u.shape.slice(0,-2),m=oe(p),x=oe(g);G(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${s} must match.`);const v=pt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,f]),y=n?ie(l,[m,c,d]):ie(l,[m,d,c]),C=s?ie(u,[x,f,h]):ie(u,[x,h,f]);let I;r!=null&&(I=q(r,"bias","fused matMul"),[I]=Bn(I,l),pt(v,I.shape));let $;o!=null&&($=q(o,"prelu weights","fused matMul"));const T=(_,N)=>{const[P,M,z,A]=N,B=h2(ie(_,z.shape),z,i);let L,U;if(!n&&!s?(L=Lt(B,M,!1,!0),U=Lt(P,B,!0,!1)):!n&&s?(L=Lt(B,M,!1,!1),U=Lt(B,P,!0,!1)):n&&!s?(L=Lt(M,B,!1,!0),U=Lt(P,B,!1,!1)):(L=Lt(M,B,!0,!0),U=Lt(B,P,!0,!0)),r!=null){const j=d2(A,B);return[L,U,j]}else return[L,U]},S={a:y,b:C,bias:I,preluActivationWeights:$},E={transposeA:n,transposeB:s,activation:i,leakyreluAlpha:a};return r==null?Gu((N,P,M)=>{const z=ne.runKernel(wd,S,E);return M([N,P,z]),{value:ie(z,v),gradFunc:T}})(y,C):Gu((N,P,M,z)=>{const A=ne.runKernel(wd,S,E);return z([N,P,A,M]),{value:ie(A,v),gradFunc:T}})(y,C,I)}const _C=ae({fusedMatMul_:oee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aee(t,e,n,s,r="bilinear",i=0){const o=q(t,"image","cropAndResize"),a=q(e,"boxes","cropAndResize","float32"),l=q(n,"boxInd","cropAndResize","int32"),u=a.shape[0];G(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),G(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),G(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),G(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),G(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),G(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const c={image:o,boxes:a,boxInd:l},h={method:r,extrapolationValue:i,cropSize:s};return ne.runKernel(p0,c,h)}const lee=ae({cropAndResize_:aee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uee(t){const e=q(t,"image","flipLeftRight","float32");G(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return ne.runKernel(C0,n,{})}const cee=ae({flipLeftRight_:uee});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hee(t){const e=q(t,"image","grayscaleToRGB"),n=e.rank-1,s=e.shape[n];G(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),G(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,n),r[n]=3,ei(e,r)}const dee=ae({grayscaleToRGB_:hee});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fee(t){const e=q(t,"image","RGBToGrayscale"),n=e.rank-1,s=e.shape[n];G(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),G(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,i=Ze(e,"float32"),o=cr([.2989,.587,.114]);let a;switch(e.rank){case 2:a=vh("ij,j->i",i,o);break;case 3:a=vh("ijk,k->ij",i,o);break;case 4:a=vh("ijkl,l->ijk",i,o);break;case 5:a=vh("ijklm,m->ijkl",i,o);break;case 6:a=vh("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=js(a,-1),Ze(a,r)}const pee=ae({rgbToGrayscale_:fee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mee(t,e,n=0,s=.5){const r=q(t,"image","rotateWithOffset","float32");G(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:e,fillValue:n,center:s};return ne.runKernel(U0,i,o)}const gee=ae({rotateWithOffset_:mee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eh(t,e,n,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=t.shape[0];return n=Math.min(n,o),G(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),G(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),G(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),G(e.rank===1,()=>"scores must be a 1D tensor"),G(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),G(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xee(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const i=q(t,"boxes","nonMaxSuppression","float32"),o=q(e,"scores","nonMaxSuppression","float32"),a=eh(i,o,n,s,r);n=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:n,iouThreshold:s,scoreThreshold:r};return ne.runKernel($0,{boxes:i,scores:o},l)}const bee=ae({nonMaxSuppression_:xee});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yee(t,e,n){const s=vee(t,e,n),r=s<0?-(s+1):s;t.splice(r,0,e)}function vee(t,e,n){return See(t,e,n||wee)}function wee(t,e){return t>e?1:t<e?-1:0}function See(t,e,n){let s=0,r=t.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const a=n(e,t[i]);a>0?s=i+1:(r=i,o=!a)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y0(t,e,n,s,r){return g2(t,e,n,s,r,0)}function m2(t,e,n,s,r,i){return g2(t,e,n,s,r,0,!1,i,!0)}function Z0(t,e,n,s,r,i){return g2(t,e,n,s,r,i,!0)}function g2(t,e,n,s,r,i,o=!1,a=!1,l=!1){const u=[];for(let m=0;m<e.length;m++)e[m]>r&&u.push({score:e[m],boxIndex:m,suppressBeginIndex:0});u.sort($C);const c=i>0?-.5/i:0,h=[],d=[];for(;h.length<n&&u.length>0;){const m=u.pop(),{score:x,boxIndex:b,suppressBeginIndex:v}=m;if(x<r)break;let y=!1;for(let C=h.length-1;C>=v;--C){const I=Cee(t,b,h[C]);if(I>=s){y=!0;break}if(m.score=m.score*Tee(s,c,I),m.score<=r)break}m.suppressBeginIndex=h.length,y||(m.score===x?(h.push(b),d.push(m.score)):m.score>r&&yee(u,m,$C))}const f=h.length,p=n-f;a&&p>0&&(h.push(...new Array(p).fill(0)),d.push(...new Array(p).fill(0)));const g={selectedIndices:h};return o&&(g.selectedScores=d),l&&(g.validOutputs=f),g}function Cee(t,e,n){const s=t.subarray(e*4,e*4+4),r=t.subarray(n*4,n*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),f=(a-i)*(l-o),p=(h-u)*(d-c);if(f<=0||p<=0)return 0;const g=Math.max(i,u),m=Math.max(o,c),x=Math.min(a,h),b=Math.min(l,d),v=Math.max(x-g,0)*Math.max(b-m,0);return v/(f+p-v)}function Tee(t,e,n){const s=Math.exp(e*n*n);return n<=t?s:0}function $C(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Iee(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const i=q(t,"boxes","nonMaxSuppressionAsync"),o=q(e,"scores","nonMaxSuppressionAsync"),a=eh(i,o,n,s,r);n=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),u=l[0],c=l[1],{selectedIndices:h}=Y0(u,c,n,s,r);return i!==t&&i.dispose(),o!==e&&o.dispose(),cr(h,"int32")}const kee=Iee;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eee(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=q(t,"boxes","nonMaxSuppression"),a=q(e,"scores","nonMaxSuppression"),l=eh(o,a,n,s,r,i);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const u={boxes:o,scores:a},c={maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},h=ne.runKernel(R0,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}const _ee=ae({nonMaxSuppressionWithScore_:Eee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function $ee(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=q(t,"boxes","nonMaxSuppressionAsync"),a=q(e,"scores","nonMaxSuppressionAsync"),l=eh(o,a,n,s,r,i);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const u=await Promise.all([o.data(),a.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:f}=Z0(c,h,n,s,r,i);return o!==t&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:cr(d,"int32"),selectedScores:cr(f)}}const Ree=$ee;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aee(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=q(t,"boxes","nonMaxSuppression"),a=q(e,"scores","nonMaxSuppression"),l=eh(o,a,n,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,d={boxes:o,scores:a},f={maxOutputSize:u,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:i},p=ne.runKernel(Sv,d,f);return{selectedIndices:p[0],validOutputs:p[1]}}const Pee=ae({nonMaxSuppressionPadded_:Aee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Dee(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=q(t,"boxes","nonMaxSuppressionAsync"),a=q(e,"scores","nonMaxSuppressionAsync"),l=eh(o,a,n,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,f]=await Promise.all([o.data(),a.data()]),{selectedIndices:p,validOutputs:g}=m2(d,f,u,c,h,i);return o!==t&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:cr(p,"int32"),validOutputs:Ht(g,"int32")}}const Nee=Dee;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mee(t,e,n=!1,s=!1){const r=q(t,"images","resizeBilinear");G(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),G(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),G(s===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=ie(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:n,halfPixelCenters:s,size:e},u=ne.runKernel(Uf,a,l);return o?ie(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const e$=ae({resizeBilinear_:Mee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lee(t,e,n=!1,s=!1){const r=q(t,"images","resizeNearestNeighbor");G(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),G(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),G(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),G(s===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=ie(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:n,halfPixelCenters:s,size:e},u=ne.runKernel(Ff,a,l);return o?ie(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const t$=ae({resizeNearestNeighbor_:Lee});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oee(t,e="binary",n=!1,s=.5){const r=q(t,"image","threshold"),i=.2989,o=.587,a=.114,l=r.shape[0]*r.shape[1];let u=te(cr([s]),255),c,h,d,f;if(G(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),G(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),G(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),G(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[c,h,d]=Cr(r,[1,1,1],-1);const m=te(c,i),x=te(h,o),b=te(d,a);f=Me(Me(m,x),b)}else f=t;if(e==="otsu"){const m=LY(Ze(G_(f),"int32"),p_([]),256);u=Fee(m,l)}const p=n?Jc(f,u):_r(f,u);return Ze(te(p,255),"int32")}function Fee(t,e){let n=cr([-1]),s=cr([0]),r=cr([0]),i,o,a,l,u,c;for(let h=0;h<t.size-1;h++){i=sn(t,0,h+1),o=sn(t,h+1),u=ct(ut(i),e),c=ct(ut(o),e);const d=ut(te(i,Ed(0,i.size)));a=ct(d,ut(i));const f=K0(o.shape,i.size),p=Me(Ed(0,o.size),f),g=te(o,p);l=ct(ut(g),ut(o));const m=mt(a,l),x=mt(a,l),b=te(u,c);r=te(te(b,m),x);const v=_r(r,s);s=Fs(v,r,s),n=Fs(v,cr([h]),n)}return n}const Uee=ae({threshold_:Oee});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bee(t,e,n="nearest",s="constant",r=0,i){const o=q(t,"image","transform","float32"),a=q(e,"transforms","transform","float32");G(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),G(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),G(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},u={interpolation:n,fillMode:s,fillValue:r,outputShape:i};return ne.runKernel(F0,l,u)}const zee=ae({transform_:Bee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gee(t,e,n){const s=q(t,"a","bandPart");G(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);let a,l;typeof e=="number"?(G(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),G(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),a=q(e<0?i:e,"numLower","bandPart")):(G(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=Fs(Jm(e,0),i,kd(e,i))),typeof n=="number"?(G(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),G(n<=o,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`),l=q(n<0?o:n,"numUpper","bandPart")):(G(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Fs(Jm(n,0),o,kd(n,o)));const u=ie(Ed(0,i,1,"int32"),[-1,1]),c=Ed(0,o,1,"int32"),h=mt(u,c),d=_o(Jc(h,a),Pl(h,Un(l))),f=Jn([i,o],s.dtype);return ie($o(bl(ie(s,[-1,i,o])).map(p=>Fs(d,p,f))),r)}const Vee=ae({bandPart_:Gee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wee(t){let e;if(Array.isArray(t)){e=!1,G(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=t[0].shape[0];for(let i=1;i<t.length;++i)G(t[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[i].shape[0]} vs. ${r})`)}else e=!0,t=Cr(t,t.shape[0],0).map(r=>Qf(r,[0]));G(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],s=t;for(let r=0;r<t.length;++r)n.push(ne.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const a=te(ut(te(n[o],i)),n[o]);i=mt(i,a)}return ct(i,X0(i,"euclidean"))}));return e?$o(n,0):n}const Hee=ae({gramSchmidt_:Wee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kee(t,e=!1){if(G(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return RC(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((l,u)=>l*u),s=bl(ie(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],i=[];s.forEach(l=>{const[u,c]=RC(l,e);r.push(u),i.push(c)});const o=ie($o(r,0),t.shape),a=ie($o(i,0),t.shape);return[o,a]}}function RC(t,e=!1){return ne.tidy(()=>{G(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],s=t.shape[1];let r=Wv(n),i=il(t);const o=sd([[1]],[1,1]);let a=il(o);const l=n>=s?s:n;for(let u=0;u<l;++u){const c=i,h=a,d=r;[a,i,r]=ne.tidy(()=>{const f=sn(i,[u,u],[n-u,1]),p=X0(f),g=sn(i,[u,u],[1,1]),m=Fs(_r(g,0),sd([[-1]]),sd([[1]])),x=mt(g,te(m,p)),b=ct(f,x);b.shape[0]===1?a=il(o):a=Ys([o,sn(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const v=Un(ct(Lt(m,x),p)),y=sn(i,[u,0],[n-u,s]),C=te(v,a),I=Ot(a);if(u===0)i=mt(y,Lt(C,Lt(I,y)));else{const S=mt(y,Lt(C,Lt(I,y)));i=Ys([sn(i,[0,0],[u,s]),S],0)}const $=Ot(C),T=sn(r,[0,u],[n,r.shape[1]-u]);if(u===0)r=mt(T,Lt(Lt(T,a),$));else{const S=mt(T,Lt(Lt(T,a),$));r=Ys([sn(r,[0,0],[n,u]),S],1)}return[a,i,r]}),At([c,h,d])}return!e&&n>s&&(r=sn(r,[0,0],[n,s]),i=sn(i,[0,0],[s,s])),[r,i]})}const jee=ae({qr_:Kee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xo={flipLeftRight:cee,grayscaleToRGB:dee,resizeNearestNeighbor:t$,resizeBilinear:e$,rgbToGrayscale:pee,rotateWithOffset:gee,cropAndResize:lee,nonMaxSuppression:bee,nonMaxSuppressionAsync:kee,nonMaxSuppressionWithScore:_ee,nonMaxSuppressionWithScoreAsync:Ree,nonMaxSuppressionPadded:Pee,nonMaxSuppressionPaddedAsync:Nee,threshold:Uee,transform:zee},Xee={bandPart:Vee,gramSchmidt:Hee,qr:jee};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qee=new Map,Yee=new Map;class th{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class Or{constructor(){this.classNameMap={}}static getMap(){return Or.instance==null&&(Or.instance=new Or),Or.instance}static register(e){Or.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function $e(t,e,n){G(t.className!=null,()=>"Class being registered does not have the static className property defined."),G(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),G(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof n>"u"&&(n=t.className);const s=n,r=e+">"+s;return Or.register(t),qee.set(r,t),Yee.set(t,r),t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ya extends th{minimize(e,n=!1,s){const{value:r,grads:i}=this.computeGradients(e,s);if(s!=null){const o=s.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return At(i),n?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return sQ(e,n)}dispose(){this.iterations_!=null&&At(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Ht(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(ya,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n$ extends ya{static get className(){return"Adadelta"}constructor(e,n,s=null){super(),this.learningRate=e,this.rho=n,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=ne.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=ne.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:de(()=>Ft(i).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:de(()=>Ft(i).variable(o))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const l=this.accumulatedGrads[r].variable,u=this.accumulatedUpdates[r].variable;de(()=>{const c=Me(te(l,this.rho),te(dn(a),1-this.rho)),h=te(ct(Is(Me(u,this.epsilon)),Is(Me(l,this.epsilon))),a),d=Me(te(u,this.rho),te(dn(h),1-this.rho));l.assign(c),u.assign(d);const f=Me(te(h,-this.learningRate),i);i.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(At(this.accumulatedGrads.map(e=>e.variable)),At(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s$ extends ya{static get className(){return"Adagrad"}constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=ne.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:de(()=>K0(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const a=this.accumulatedGrads[r].variable;de(()=>{const l=Me(a,dn(o));a.assign(l);const u=Me(te(ct(o,Is(Me(l,ne.backend.epsilon()))),-this.learningRate),i);i.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&At(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r$ extends ya{static get className(){return"Adam"}constructor(e,n,s,r=null){super(),this.learningRate=e,this.beta1=n,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],de(()=>{this.accBeta1=Ht(n).variable(),this.accBeta2=Ht(s).variable()}),r==null&&(this.epsilon=ne.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);de(()=>{const s=mt(1,this.accBeta1),r=mt(1,this.accBeta2);n.forEach((i,o)=>{const a=ne.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:de(()=>Ft(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:de(()=>Ft(a).variable(l))});const u=Array.isArray(e)?e[o].tensor:e[i];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,d=Me(te(c,this.beta1),te(u,1-this.beta1)),f=Me(te(h,this.beta2),te(dn(u),1-this.beta2)),p=ct(d,s),g=ct(f,r);c.assign(d),h.assign(f);const m=Me(te(ct(p,Me(Is(g),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(te(this.accBeta1,this.beta1)),this.accBeta2.assign(te(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&At(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&At(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),de(()=>{this.accBeta1.assign(gl(this.beta1,this.iterations_+1)),this.accBeta2.assign(gl(this.beta2,this.iterations_+1))});const n=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i$ extends ya{static get className(){return"Adamax"}constructor(e,n,s,r=null,i=0){super(),this.learningRate=e,this.beta1=n,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],de(()=>{this.iteration=Ht(0).variable(),this.accBeta1=Ht(n).variable()}),r==null&&(this.epsilon=ne.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);de(()=>{const s=mt(1,this.accBeta1),r=ct(-this.learningRate,Me(te(this.iteration,this.decay),1));n.forEach((i,o)=>{const a=ne.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:Ft(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:Ft(a).variable(l)});const u=Array.isArray(e)?e[o].tensor:e[i];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,d=Me(te(c,this.beta1),te(u,1-this.beta1)),f=te(h,this.beta2),p=As(u),g=xa(f,p);c.assign(d),h.assign(g);const m=Me(te(ct(r,s),ct(d,Me(g,this.epsilon))),a);a.assign(m)}),this.iteration.assign(Me(this.iteration,1)),this.accBeta1.assign(te(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&At(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&At(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x2 extends ya{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const o=ne.registeredVariables[s];de(()=>{const a=Me(te(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Gi(Ht(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o$ extends x2{static get className(){return"Momentum"}constructor(e,n,s=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=s,this.accumulations=[],this.m=Ht(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=ne.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:de(()=>Ft(i).variable(!1))});const o=this.accumulations[r].variable,a=Array.isArray(e)?e[r].tensor:e[s];a!=null&&de(()=>{let l;const u=Me(te(this.m,o),a);this.useNesterov?l=Me(te(this.c,Me(a,te(u,this.m))),i):l=Me(te(this.c,u),i),o.assign(u),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&At(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a$ extends ya{static get className(){return"RMSProp"}constructor(e,n=.9,s=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=ne.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=ne.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:de(()=>Ft(i).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:de(()=>Ft(i).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:de(()=>Ft(i).variable(o))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const l=this.accumulatedMeanSquares[r].variable,u=this.accumulatedMoments[r].variable;de(()=>{const c=Me(te(l,this.decay),te(dn(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[r].variable,d=Me(te(h,this.decay),te(a,1-this.decay)),f=ct(te(a,this.learningRate),Is(mt(c,Me(dn(d),this.epsilon)))),p=Me(te(u,this.momentum),f);l.assign(c),h.assign(d),u.assign(p);const g=mt(i,p);i.assign(g)}else{const h=Me(te(l,this.decay),te(dn(a),1-this.decay)),d=Me(te(u,this.momentum),ct(te(a,this.learningRate),Is(Me(h,this.epsilon))));l.assign(h),u.assign(d);const f=mt(i,d);i.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&At(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&At(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&At(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zee=[n$,s$,r$,i$,o$,a$,x2];function Qee(){for(const t of Zee)$e(t)}function Q0(t,e){const n=t.shape.length,s=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${n}`);if(oe(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const r=e.shape,i=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const a=t.shape,l=r.slice();l.pop();let u=1;for(let h=i;h<n;++h)u*=a[h],l.push(a[h]);const c=[...lt(t.shape).map(h=>h/u),1].slice(0,i);return[l,o,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q1=-2,Jee=-1;function J0(t,e,n){const s=t.shape.length;G(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),G(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)G(e[r]+n[r]<=t.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function ete(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function ex(t,e,n){const s=[];for(let r=0;r<t.length;r++)s[r]=Math.ceil((e[r]-t[r])/n[r]);return s}function l$(t,e,n,s){const r=[...t];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<n;i++)i===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function u$(t,e,n){return n<=t?n:n-(e-1)}function c$(t,e){const n=[];for(let s=0;s<t;s++)n.push(e+s);return n}function tte(t,e,n,s,r,i,o,a,l){const u=t.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&n>0){const f=e[0],p=n+1;c=h$(o,f,p,s,t),h=d$(a,f,p,r,t),d=l$(i,f,p,t)}else for(let f=0;f<u;f++)c[f]=p$(o,s,i,t,f,l),h[f]=m$(a,r,i,t,f,l),d[f]=f$(i,f,l);return{begin:c,end:h,strides:d}}function h$(t,e,n,s,r){const i=[...r],o=c$(n,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=u$(e,n,a);let u=s[l];t&1<<l&&(u=0),i[a]=u}return i}function d$(t,e,n,s,r){const i=[...r],o=c$(n,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=u$(e,n,a);let u=s[l];t&1<<l&&(u=Number.MAX_SAFE_INTEGER),i[a]=u}for(let a=0;a<i.length;a++){const l=r[a];i[a]<0&&(i[a]+=l),i[a]=cl(0,i[a],r[a])}return i}function f$(t,e,n){let s=t[e];return(n&1<<e||s==null)&&(s=1),s}function p$(t,e,n,s,r,i){let o=e[r];const a=n[r]||1;(t&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),o=cl(0,o,l-1),o}function m$(t,e,n,s,r,i){let o=e[r];const a=n[r]||1;(t&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),a>0?o=cl(0,o,l):o=cl(-1,o,l-1),o}function b2(t,e,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(e[r]>0||n[r]!==t[r])return!1;return!0}function y2(t,e){let n=t.length>0?t[t.length-1]:1;for(let s=0;s<t.length-1;s++)n+=t[s]*e[s];return n}function ep(t,e,n){let s;const r=t.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(o=>{G(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return n==null?i=new Array(r).fill(-1):typeof n=="number"?i=[n,...new Array(r-1).fill(-1)]:n.length<r?i=n.concat(new Array(r-n.length).fill(-1)):i=n,i=i.map((o,a)=>o>=0?o:(G(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),t.shape[a]-s[a])),[s,i]}function tx(t,e,n,s,r,i,o,a,l){let u;if(s==null?(u=new Array(e.length),u.fill(1)):u=s,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:u.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let v=0;v<h.dims;v++)c&&1<<v&a&&h.numAddAxisAfterEllipsis++,1<<v&o&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};nte(h,d);let f=!0,p=!0,g=!0;const m=[],x=[];for(let v=0;v<t.length;++v){if(d.strides[v]===0)throw Error(`strides[${v}] must be non-zero`);const y=!!(d.shrinkAxisMask&1<<v),C=t[v];if(C===-1){m.push(y?1:-1);continue}const I=[d.beginMask&1<<v,d.endMask&1<<v],$=[d.strides[v]>0?0:-1,d.strides[v]>0?C:C-1];if(y&&d.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&d.strides[v]===1;const T=!!(d.beginMask&1<<v&&d.endMask&1<<v);if(d.beginValid&&d.endValid){if(y){const N=d.begin[v]<0?C+d.begin[v]:d.begin[v];if(d.begin[v]=N,d.end[v]=d.begin[v]+1,N<0||N>=C)throw Error(`slice index ${d.begin[v]} of dimension ${v} out of bounds.`)}else d.begin[v]=AC(d.begin[v],0,d.strides[v],C,I,$),d.end[v]=AC(d.end[v],1,d.strides[v],C,I,$);const _=d.strides[v]===1&&d.begin[v]===0&&d.end[v]===C;f=f&&_,p=p&&(v===0&&d.strides[v]===1||_)}else f=f&&d.strides[v]===1&&T,p=p&&(v===0&&d.strides[v]===1||T);let S,E=!1;if(d.beginValid&&d.endValid?(S=d.end[v]-d.begin[v],E=!0):y?(S=1,E=!0):T&&C>=0&&(d.strides[v]<0?S=-C:S=C,E=!0),E){let _;S===0||S<0!=d.strides[v]<0?_=0:_=Math.trunc(S/d.strides[v])+(S%d.strides[v]!==0?1:0),m.push(_)}else m.push(-1)}for(let v=0;v<d.finalShapeGatherIndices.length;++v){const y=d.finalShapeGatherIndices[v];y>=0?x.push(m[y]):y===q1&&x.push(1)}return{finalShapeSparse:x.filter((v,y)=>d.finalShapeGatherIndices[y]!==q1),finalShape:x,isIdentity:f,sliceDim0:p,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function nte(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<t.dims;s++)if(1<<s&t.ellipsisMask){const r=Math.min(e.dims-(t.dims-s)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<r;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=s}else if(1<<s&t.newAxisMask)e.finalShapeGatherIndices.push(q1),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[s]),t.end!=null&&(e.end[n]=t.end[s]),e.strides[n]=t.strides[s],t.beginMask&1<<s&&(e.beginMask|=1<<n),t.endMask&1<<s&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(Jee),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[n]=s,n++}}function AC(t,e,n,s,r,i){if(r[e])return n>0?i[e]:i[e+1&1];{const o=t<0?s+t:t;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const ste=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:J0,computeFlatOffset:y2,computeOutShape:ex,getNormalizedAxes:tte,isSliceContinous:b2,maskToAxes:ete,parseSliceParams:ep,sliceInfo:tx,startForAxis:p$,startIndicesWithElidedDims:h$,stopForAxis:m$,stopIndicesWithElidedDims:d$,stridesForAxis:f$,stridesWithElidedDims:l$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rte{static sgd(e){return new x2(e)}static momentum(e,n,s=!1){return new o$(e,n,s)}static rmsprop(e,n=.9,s=0,r=null,i=!1){return new a$(e,n,s,r,i)}static adam(e=.001,n=.9,s=.999,r=null){return new r$(e,n,s,r)}static adadelta(e=.001,n=.95,s=null){return new n$(e,n,s)}static adamax(e=.002,n=.9,s=.999,r=null,i=0){return new i$(e,n,s,r,i)}static adagrad(e,n=.1){return new s$(e,n)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ou=rte;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ite=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function g$(){return new Promise(t=>ite(()=>t()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nx(t,e){const n=t[0].length;t.forEach((r,i)=>{G(r.length===n,()=>`Error in concat${n}D: rank of tensors[${i}] must be the same as the rank of the rest (${n})`)}),G(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=t[0];t.forEach((r,i)=>{for(let o=0;o<n;o++)G(o===e||r[o]===s[o],()=>`Error in concat${n}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function Zs(t,e){const n=t[0].slice();for(let s=1;s<t.length;s++)n[e]+=t[s][e];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Jr;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(Jr||(Jr={}));function x$(t,e,n){let s=new Array;if(n==null&&e==null)return s;if(e==null)for(;s.length<t+n.length;)s.push(-1);else s=e.slice();if(n==null)return s;if(t+n.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${s.length}`);for(let r=1;r<n.length;++r){const i=n[r],o=s[s.length-n.length+r],a=s[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+t}] = ${i} but shape[${r+t}] = ${a}`)}else s[o]=i}return s}function b$(t){const e={FIRST_DIM_SIZE:Jr.FIRST_DIM_SIZE,VALUE_ROWIDS:Jr.VALUE_ROWIDS,ROW_LENGTHS:Jr.ROW_LENGTHS,ROW_SPLITS:Jr.ROW_SPLITS,ROW_LIMITS:Jr.ROW_LIMITS,ROW_STARTS:Jr.ROW_STARTS},n=[];for(const s of t)if(s in e)n.push(e[s]);else break;return n}function y$(t){return t.length===0?0:t[0]===Jr.FIRST_DIM_SIZE?t.length-1:t.length}function v$(t,e){if(t==null||e==null)return;const n=t.length,s=e.length;if(n>=s)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(n,s-1);++r){const i=t[r],o=e[r+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-t.length}] = ${i} but ragged tensor input.flatValues.shape[${r-t.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v2=30;function sx(t){return t<=v2?t:N1(t,Math.floor(Math.sqrt(t)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rx(t,e,n){const s=n*(typeof t=="number"?t:t[0]),r=e*(typeof t=="number"?t:t[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ml(t,e,n,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const i=e.length;for(let o=0;o<i;++o)r=r.concat([t[o+1]/e[o],e[o]]);r=r.concat(t.slice(i+1))}return r}function Ll(t,e,n=!0){const s=[];if(n){s.push(e);for(let r=e+1;r<t;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],i=[];for(let o=1;o<t;++o)o>=e*2+1||o%2===1?i.push(o):r.push(o);s.push(...r),s.push(0),s.push(...i)}return s}function Ol(t,e,n,s=!0){const r=[];s?r.push(t[0]/n):r.push(t[0]*n);for(let i=1;i<t.length;++i)i<=e.length?s?r.push(e[i-1]*t[i]):r.push(t[i]/e[i-1]):r.push(t[i]);return r}function ix(t,e){const n=[0];for(let s=0;s<e;++s)n.push(t[s][0]);return n}function ox(t,e,n){const s=t.slice(0,1);for(let r=0;r<n;++r)s.push(t[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tp=1.7580993408473768,np=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ax=.3275911,lx=.254829592,ux=-.284496736,cx=1.421413741,hx=-1.453152027,dx=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ui(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let s=0;s<n.length;s+=2)n[s]=t[s/2],n[s+1]=e[s/2];return n}function w$(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let s=0;s<t.length;s+=2)e[s/2]=t[s],n[s/2]=t[s+1];return{real:e,imag:n}}function S$(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function C$(t){const e=Math.floor(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function w2(t,e){const n=t[e*2],s=t[e*2+1];return{real:n,imag:s}}function T$(t,e,n,s){t[s*2]=e,t[s*2+1]=n}function I$(t,e){const n=new Float32Array(t/2),s=new Float32Array(t/2);for(let r=0;r<Math.ceil(t/2);r++){const i=(e?2:-2)*Math.PI*(r/t);n[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:n,imag:s}}function k$(t,e,n){const s=(n?2:-2)*Math.PI*(t/e),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Db="->",ote=/->/g,PC=",",DC="...";function fx(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(ote,"").length)/Db.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Db}").`);const[s,r]=t.split(Db);G(s.indexOf(DC)===-1,()=>`The ellipsis notation ("${DC}") is not supported yet.`);const i=s.split(PC),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<r.length;++d){const f=r[d];if(!i.some(p=>p.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let d=0;d<s.length;++d){const f=s[d];a.indexOf(f)===-1&&f!==PC&&a.push(f)}const l=new Array(i.length);for(let d=0;d<o;++d){if(new Set(i[d].split("")).size!==i[d].length)throw new Error(`Found duplicate axes in input component ${i[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let f=0;f<i[d].length;++f)l[d].push(a.indexOf(i[d][f]))}const u=a.length,c=r.length,h=[];for(let d=c;d<u;++d)h.push(d);return{allDims:a,summedDims:h,idDims:l}}function px(t,e){let n=new Array(t);n.fill(-1);for(let r=0;r<e.length;++r)n[e[r]]=r;const s=[];for(let r=0;r<t;++r)n[r]===-1&&s.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:s}}function mx(t,e,n){const s=new Array(t);for(let r=0;r<n.length;++r){const i=n[r].shape;for(let o=0;o<e[r].length;++o)s[e[r][o]]===void 0?s[e[r][o]]=i[o]:G(s[e[r][o]]===i[o],()=>`Expected dimension ${s[e[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function gx(t,e){const n=t,s=[];let r=0;t.length===0&&n.push(-1),r=t.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<n.length;++o){const a=n[o],l=ate(e,a);for(const u of l)i.indexOf(u)===-1&&(s[o].push(u),i.push(u))}return{path:n,steps:s}}function xx(t){return t.every((e,n)=>e===n)}function ate(t,e){const n=[];for(let s=0;s<t.length;++s)(t[s].length===0||t[s].indexOf(e)!==-1||e===-1)&&n.push(s);return n}function bx(t,e,n=0){let s=[];if(typeof e=="number")G(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(t.shape[n]/e);else{const r=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);G(r<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[i]=t.shape[n]-o}G(t.shape[n]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function _$(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function $$(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R$(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function A$(t,e){return`size ${t} must be non-negative, not ${e}`}function P$(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function D$(t,e){const n=oe(t),s=oe(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${t} outputShape= ${e}`}function N$(t,e){const n=oe(t),s=oe(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${t} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y1(){return"segment ids must be >= 0"}function M$(){return"segment ids are not increasing"}function L$(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function O$(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F$(t,e){let n=!1,s;for(t<=v2?(s=t,n=!0):s=N1(t,Math.floor(Math.sqrt(t)));!n;)s>e||s===t?n=!0:s=N1(t,s+1);return s}function S2(t,e,n){const s=[],r=t.length;for(let i=0;i<r;i++)i!==e?s.push(t[i]):s.push(n);return s}function yx(t,e,n,s){const r=e.shape.length,i=t.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let h=0;h<s;++h)if(t.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=t.shape[n],a=[];let l=1,u=1,c=1;for(let h=0;h<s;++h)a.push(t.shape[h]),l*=t.shape[h];for(let h=s;h<n;h++)a.push(t.shape[h]),u*=t.shape[h];for(let h=s;h<r;h++)a.push(e.shape[h]);for(let h=n+1;h<i;h++)a.push(t.shape[h]),c*=t.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:o,outputShape:a}}const lte=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:yx,computeOutShape:S2,segOpComputeOptimalWindowSize:F$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ci(t){try{return t.map(e=>li(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function U$(t){return t.map(e=>vo(e))}const ute=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:lx,ERF_A2:ux,ERF_A3:cx,ERF_A4:hx,ERF_A5:dx,ERF_P:ax,PARALLELIZE_THRESHOLD:v2,get RowPartitionType(){return Jr},SELU_SCALE:np,SELU_SCALEALPHA:tp,applyActivation:f2,assertAndGetBroadcastShape:pt,assertAxesAreInnerMostDims:qn,assertParamsConsistent:nx,assignToTypedArray:T$,axesAreInnerMostDims:Vv,calculateShapes:Ji,checkEinsumDimSizes:mx,checkPadOnDimRoundingMode:tr,combineLocations:P_,combineRaggedTensorToTensorShapes:x$,complexWithEvenIndex:S$,complexWithOddIndex:C$,computeConv2DInfo:gn,computeConv3DInfo:gi,computeDefaultPad:Ov,computeDilation2DInfo:ga,computeOptimalWindowSize:sx,computeOutAndReduceShapes:Gn,computeOutShape:Zs,computePool2DInfo:ks,computePool3DInfo:Er,convertConv2DDataFormat:gr,decodeEinsumEquation:fx,eitherStridesOrDilationsAreOne:ds,expandShapeToKeepDim:zn,exponent:k$,exponents:I$,fromStringArrayToUint8:U$,fromUint8ToStringArray:ci,getAxesPermutation:Jt,getBroadcastDims:oa,getComplexWithIndex:w2,getEinsumComputePath:gx,getEinsumPermutation:px,getFusedBiasGradient:d2,getFusedDyActivation:h2,getImageCenter:rx,getInnerMostAxes:an,getPermuted:Ll,getRaggedRank:y$,getReductionAxes:rs,getReshaped:Ml,getReshapedPermuted:Ol,getRowPartitionTypesHelper:b$,getSliceBeginCoords:ix,getSliceSize:ox,getSparseFillEmptyRowsIndicesDenseShapeMismatch:E$,getSparseFillEmptyRowsNegativeIndexErrorMessage:_$,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:$$,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:P$,getSparseReshapeInputOutputMismatchErrorMessage:N$,getSparseReshapeInputOutputMultipleErrorMessage:D$,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:R$,getSparseReshapeNegativeOutputDimErrorMessage:A$,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:O$,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Y1,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:M$,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:L$,getUndoAxesPermutation:Qi,isIdentityPermutation:xx,log:HX,mergeRealAndImagArrays:ui,prepareAndValidate:Q0,prepareSplitSize:bx,segment_util:lte,shouldFuse:p2,slice_util:ste,splitRealAndImagArrays:w$,stridesOrDilationsArePositive:pl,tupleValuesAreOne:fl,upcastType:hs,validateDefaultValueShape:v$,validateInput:BJ,validateUpdateShape:Y_,warn:yr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Qee();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B$={kernelName:qd,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,Jf(Ze(n,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cte={kernelName:nc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=dn(Ze(n,"float32")),r=Is(mt(Ht(1),s));return Un(ct(t,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hte={kernelName:sc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=Is(mt(dn(Ze(n,"float32")),1));return ct(t,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dte={kernelName:$l,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=pt(n.shape,s.shape);return{a:()=>{let a=t;const l=rs(n.shape,r);return l.length>0&&(a=ut(a,l)),ie(a,n.shape)},b:()=>{let a=t;const l=rs(s.shape,r);return l.length>0&&(a=ut(a,l)),ie(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fte={kernelName:s0,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((s,r)=>{n[r]=()=>t.clone()}),n}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pte={kernelName:Yd,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ft(n)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mte={kernelName:Zd,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ft(n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gte={kernelName:rc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ct(t,Is(mt(Ht(1),dn(Ze(n,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xte={kernelName:ic,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=Is(Me(Ht(1),dn(Ze(n,"float32"))));return ct(t,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bte={kernelName:lc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=pt(n.shape,s.shape);return{a:()=>{const a=Me(dn(n),dn(s));let l=te(t,ct(s,a));const u=rs(n.shape,r);return u.length>0&&(l=ut(l,u)),ie(l,n.shape)},b:()=>{const a=Me(dn(n),dn(s));let l=Un(te(t,ct(n,a)));const u=rs(s.shape,r);return u.length>0&&(l=ut(l,u)),ie(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yte={kernelName:oc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ct(t,Me(dn(Ze(n,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vte={kernelName:ac,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ct(t,mt(Ht(1),dn(Ze(n,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wte(t,e,n,s,r,i){const o=q(t,"dy","avgPool3dGrad"),a=q(e,"input","avgPool3dGrad");let l=o,u=a,c=!1;a.rank===4&&(c=!0,l=ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=ie(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),G(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),G(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),tr("avgPool3dGrad",r,i);const h={dy:l,input:u},d={filterSize:n,strides:s,pad:r,dimRoundingMode:i},f=ne.runKernel(a0,h,d);return c?ie(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const Ste=ae({avgPool3dGrad_:wte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cte={kernelName:Jd,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:i,pad:o,dimRoundingMode:a}=n;return{x:()=>Ste(t,s,r,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tte(t,e,n,s,r){const i=q(t,"dy","avgPoolGrad"),o=q(e,"input","avgPoolGrad");G(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,u=!1;o.rank===3&&(u=!0,a=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),G(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),G(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const c={dy:l,input:a},h={filterSize:n,strides:s,pad:r},d=ne.runKernel(o0,c,h);return u?ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Ite=ae({avgPoolGrad_:Tte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kte={kernelName:Qd,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:i,pad:o}=n;return{x:()=>Ite(t,s,r,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ete={kernelName:ef,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[s,r]=e,{transposeA:i,transposeB:o}=n;return!i&&!o?{a:()=>Lt(t,r,!1,!0),b:()=>Lt(s,t,!0,!1)}:!i&&o?{a:()=>Lt(t,r,!1,!1),b:()=>Lt(t,s,!0,!1)}:i&&!o?{a:()=>Lt(r,t,!1,!0),b:()=>Lt(s,t,!1,!1)}:{a:()=>Lt(r,t,!0,!0),b:()=>Lt(t,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _te={kernelName:tf,gradFunc:(t,e,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>Qv(t,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $te={kernelName:VX,gradFunc:(t,e,n)=>{const s=n,r=s.inputShape,i=s.shape,o=Array.from(i);for(let l=r.length-1;l>=0;l--)if(r[l]===i[l])o[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>ut(t,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rte={kernelName:uc,gradFunc:t=>({x:()=>t.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ate={kernelName:cc,gradFunc:t=>({x:()=>Ft(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pte={kernelName:hc,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=n;return{x:()=>Fs(_o(Pl(s,r),Jc(s,i)),t,Ft(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dte={kernelName:nf,inputsToSave:["x"],gradFunc:B$.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nte={kernelName:sf,saveAllInputs:!0,gradFunc:(t,e,n)=>{const s=e.map(l=>l.shape),{axis:r}=n,i=wt(r,e[0].shape)[0],o=s.map(l=>l[i]);return Cr(t,o,i).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mte={kernelName:rf,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{dilations:i,strides:o,pad:a,dataFormat:l}=n;return G(fl(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>Bv(s.shape,t,r,o,a,l),filter:()=>c2(s,t,r.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lte={kernelName:of,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=n;return{dy:()=>ml(t,r,i,o,a,1,l),filter:()=>c2(t,s,r.shape,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ote(t,e,n,s,r){let i=t;t.rank===4&&(i=ie(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;o.rank===4&&(o=ie(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),G(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),G(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),G(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),G(i.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`),G(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`);const a={x:i,dy:o},l={strides:s,pad:r,filterShape:n};return ne.runKernel(h0,a,l)}const Fte=ae({conv3DBackpropFilter_:Ote});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ute={kernelName:af,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:i}=n;G(fl(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,a]=e;return{x:()=>__(o.shape,t,a,r,i),filter:()=>Fte(o,t,a.shape,r,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bte={kernelName:dc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(Un(K_(Ze(n,"float32"))),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zte={kernelName:fc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(j_(Ze(n,"float32")),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gte={kernelName:lf,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r,exclusive:i,reverse:o}=n;return{x:()=>{const a=Jt([r],s.rank);let l=R_(t,r,i,!o);return a!=null&&(l=Ot(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vte={kernelName:uf,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=n,a=s??[1,1];G(fl(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=e;return G(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),G(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),G(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),G(ds(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),tr("depthwiseConv2d",i,o),{x:()=>iee(l.shape,t,u,r,i,a,o),filter:()=>see(l,t,u.shape,r,i,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wte={kernelName:cf,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,i={x:s,filter:r,dy:t},o={x:s,filter:r,dy:t};return{x:()=>ne.runKernel(jm,i,n),filter:()=>ne.runKernel(Xm,o,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hte={kernelName:mc,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,s={dy:t,y:n};return{x:()=>ne.runKernel(v0,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kte={kernelName:gc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=te(Ki(Un(dn(n))),2/Math.sqrt(Math.PI));return{x:()=>te(t,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jte={kernelName:xc,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xte={kernelName:df,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>ie(t,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qte={kernelName:bc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,Ki(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yte={kernelName:yc,gradFunc:t=>({x:()=>Ft(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zte={kernelName:vc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=pt(n.shape,s.shape);return{a:()=>{const a=ct(t,Ze(s,"float32")),l=rs(n.shape,r);return l.length>0?ie(ut(a,l),n.shape):a},b:()=>{let a=te(t,Ze(n,"float32"));const l=rs(s.shape,r);l.length>0&&(a=ie(ut(a,l),s.shape));const u=dn(s);return Un(ct(a,Ze(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qte={kernelName:ff,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:s}=n,[r,i,o,a]=e,l=a??Ht(1),u=rs(i.shape,r.shape),c=[];if(i.rank===1){for(let y=0;y<r.shape.length-1;++y)c.push(r.shape[y]);c.push(1)}const h=mt(r,i),d=te(t,l),f=V_(Me(o,Ht(s))),p=te(te(te(f,f),f),Ht(-.5));return{x:()=>i.rank===1?ie(te(te(t,ei(ie(f,[1,1,1,i.shape[0]]),c)),l),r.shape):ie(te(te(t,f),l),r.shape),mean:()=>{let y=te(te(f,Ht(-1)),d);return i.rank===1&&(y=ut(y,u)),ie(y,i.shape)},variance:()=>{let y=te(te(p,h),d);return i.rank===1&&(y=ut(y,u)),ie(y,i.shape)},scale:()=>{const y=te(h,f);let C=te(t,y);return i.rank===1&&(C=ut(C,u)),ie(C,i.shape)},offset:()=>{let y=t;return i.rank===1&&(y=ut(y,u)),ie(y,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jte={kernelName:pf,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[s,r]=e,{axis:i,batchDims:o}=n,a=wt(i,s.shape)[0],l=(u,c,h)=>()=>{const d=u.shape,f=c.size,p=d.slice(0,a),g=p.length,m=d.slice(i,d.length).slice(1),x=m.length,b=NC(0,g),v=NC(g+1,g+1+x),y=MC([p,[f],m]),C=ie(h,y),I=ie(c,[f]),$=MC([[g],b,v]),T=Ot(C,$);let S=Q_(T,I,u.shape[a]);const E=Qi($);return S=Ot(S,E),S};if(o===1){const u=s.shape[0],c=s.split(u,0);return{x:()=>$o(c.map((f,p)=>l(f,r.slice(p,1),t.slice(p,1))())).reshape(s.shape),indices:()=>r}}else return{x:l(s,r,t),indices:()=>r}}};function NC(t,e){const n=[];for(let s=t;s<e;++s)n.push(s);return n}function MC(t){const e=[];for(let n=0;n<t.length;++n)for(let s=0;s<t[n].length;++s)e.push(t[n][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ene={kernelName:wc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>Ft(n),b:()=>Ft(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tne={kernelName:Sc,gradFunc:t=>({x:()=>Ze(t,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nne={kernelName:Cc,gradFunc:t=>({x:()=>Ft(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sne={kernelName:Tc,gradFunc:t=>({x:()=>Ft(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rne={kernelName:Ic,gradFunc:t=>({x:()=>Ft(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ine={kernelName:gf,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{alpha:r}=n,i=_r(s,0);return{x:()=>Fs(i,t,te(t,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const one={kernelName:Ec,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ct(t,Me(n,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ane={kernelName:kc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ct(t,Ze(n,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lne={kernelName:WX,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;return{logits:()=>{const o=Ki(s);return mt(t,te(ut(t,r,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function une(t,e,n,s=5,r=1,i=1,o=.5){const a={x:t,y:e,dy:n},l={depthRadius:s,bias:r,alpha:i,beta:o};return ne.runKernel(k0,a,l)}const cne=ae({localResponseNormalizationBackprop_:une});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hne={kernelName:Sf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{depthRadius:i,bias:o,alpha:a,beta:l}=n;return{x:()=>cne(s,r,t,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$(t,e,n,s){return e.rank<n.rank&&(e=ie(e,zn(e.shape,s))),t.rank<n.rank&&(t=ie(t,zn(t.shape,s))),{x:()=>te(t,Ze(Hi(n,e),t.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LC={kernelName:Cf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{reductionIndices:r}=s,i=e[0],o=e[1],a=wt(r,i.shape),l=z$(t,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dne={kernelName:_c,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>te(t,Ze(Pl(n,s),"float32")),b:()=>te(t,Ze(Jm(n,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fne(t,e,n,s,r,i,o){const a=q(t,"dy","maxPool3dGrad"),l=q(e,"input","maxPool3dGrad"),u=q(n,"output","maxPool3dGrad");let c=a,h=l,d=u,f=!1;l.rank===4&&(f=!0,c=ie(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=ie(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=ie(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),G(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),G(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),G(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),tr("maxPool3dGrad",i,o);const p={dy:c,input:h,output:d},g={filterSize:s,strides:r,pad:i,dimRoundingMode:o},m=ne.runKernel(_0,p,g);return f?ie(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const pne=ae({maxPool3dGrad_:fne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mne={kernelName:If,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=n;return{x:()=>pne(t,s,r,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gne(t,e,n,s,r,i,o){const a=q(t,"dy","maxPoolGrad"),l=q(e,"input","maxPoolGrad"),u=q(n,"output","maxPoolGrad");G(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),G(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),G(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),tr("maxPoolGrad",i,o);const c={dy:a,input:l,output:u},h={filterSize:s,strides:r,pad:i,dimRoundingMode:o};return ne.runKernel(E0,c,h)}const xne=ae({maxPoolGrad_:gne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bne={kernelName:Tf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:i,strides:o,pad:a}=n;return{x:()=>xne(t,s,r,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yne={kernelName:kf,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n,i=wt(r,s.shape),a=Gn(s.shape,i)[1],l=oe(a);return{x:()=>{const c=s.shape.slice();i.forEach(f=>{c[f]=1});const h=ie(t,c);return ct(te(h,ba(s.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vne={kernelName:Ef,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{axis:r}=s,[i,o]=e,a=wt(r,i.shape),l=z$(t,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wne={kernelName:$c,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>te(t,Ze(Jc(n,s),"float32")),b:()=>te(t,Ze(_r(n,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sne={kernelName:_f,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,i=r.map(o=>o[0]);return{x:()=>sn(t,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cne={kernelName:Rc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=pt(n.shape,s.shape);return{a:()=>{const a=rs(n.shape,r);return a.length>0?ie(ut(t,a),n.shape):t},b:()=>{const a=te(t,Un(q0(ct(n,s)))),l=rs(s.shape,r);return l.length>0?ie(ut(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tne={kernelName:Ac,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=pt(n.shape,s.shape);return{a:()=>{const a=te(t,Ze(s,"float32")),l=rs(n.shape,r);return l.length>0?ie(ut(a,l),n.shape):a},b:()=>{const a=te(t,Ze(n,"float32")),l=rs(s.shape,r);return l.length>0?ie(ut(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ine={kernelName:$f,gradFunc:t=>({x:()=>Un(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kne={kernelName:Pf,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>Jn(n.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ene={kernelName:Af,gradFunc:t=>({x:()=>Ft(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ne={kernelName:Df,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:s}=n;return bl(t,s).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OC={kernelName:Nf,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,i=r.map(o=>o[0]);return{x:()=>sn(t,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ne={kernelName:Pc,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,s,r]=e,i=n,o=s,a=pt(i.shape,o.shape);return{a:()=>{const c=Ze(o,"float32");let h=te(t,te(c,gl(i,mt(c,Ht(1)))));const d=rs(i.shape,a);return d.length>0&&(h=ut(h,d)),ie(h,i.shape)},b:()=>{const c=_r(i,0),h=Fs(c,ji(i),Ft(i));let d=te(t,te(r,h));const f=rs(o.shape,a);return f.length>0&&(d=ut(d,f)),ie(d,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rne={kernelName:Mf,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,s]=e,r=_r(n,0);return{x:()=>Fs(r,t,te(t,s)),alpha:()=>{let i=Fs(r,Ft(t),te(t,n));const o=rs(s.shape,t.shape);return o.length>0&&(i=ut(i,o)),ie(i,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ane(t,e,n){const s=t.shape.slice();s[n]=1;const r=ie(e,s),i=j1(t,n,!0,!1),o=j1(t,n,!0,!0),a=te(i,o);return te(r,a)}function Pne(t,e,n){const s=t.shape.length,r=s-n.length,i=Jt(n,s);let o=t;i!=null&&(o=Ot(t,i));const a=o.shape.slice(),u=a.splice(s-n.length,n.length).reduce((d,f)=>d*f,1);a.push(u);const c=o.reshape(a);let h=Ane(c,e,r);if(h=h.reshape(o.shape),i!=null){const d=Qi(i);h=Ot(h,d)}return h}const Dne={kernelName:Lf,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;let i=[];return r==null?i=s.shape.map((o,a)=>a):typeof r=="number"?i=[r]:i=r,{x:()=>Pne(s,t,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nne={kernelName:pc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=pt(n.shape,s.shape);return{a:()=>{const a=ct(t,Ze(s,"float32")),l=rs(n.shape,r);return l.length>0?ie(ut(a,l),n.shape):a},b:()=>{let a=te(t,Ze(n,"float32"));const l=rs(s.shape,r);l.length>0&&(a=ie(ut(a,l),s.shape));const u=dn(s);return Un(ct(a,Ze(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mne={kernelName:Dc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ct(t,Un(dn(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lne={kernelName:Mc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=te(Jc(n,6),Jf(n));return{x:()=>te(t,Ze(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const One={kernelName:Nc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,Ze(Jf(n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fne={kernelName:Of,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ie(t,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Une={kernelName:Uf,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>ne.runKernel(N0,r,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bne={kernelName:Ff,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>ne.runKernel(D0,r,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zne={kernelName:Bf,gradFunc:(t,e,n)=>{const{dims:s}=n,r=wt(s,t.shape);return{x:()=>xl(t,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gne={kernelName:Lc,gradFunc:t=>({x:()=>Ft(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vne={kernelName:Oc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Un(ct(t,te(gl(n,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wne={kernelName:zf,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>Ze(Ft(n),"float32"),t:()=>te(t,Ze(n,t.dtype)),e:()=>te(t,Ze(Xv(n),t.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hne={kernelName:Fc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=_r(n,Ht(0)),r=Ht(tp),i=Ht(np),o=te(t,i),a=te(te(t,r),Ki(Ze(n,"float32")));return Fs(s,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kne={kernelName:Gc,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,te(n,mt(Ht(1),n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jne={kernelName:zc,gradFunc:t=>({x:()=>Ft(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xne={kernelName:Uc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(zv(Ze(n,"float32")),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qne={kernelName:Bc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te($_(Ze(n,"float32")),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yne={kernelName:Gf,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{begin:r,size:i}=n,o=s.shape,[a,l]=ep(s,r,i),u=[];for(let c=0;c<t.rank;c++)u.push([a[c],o[c]-a[c]-l[c]]);return{x:()=>Zv(t,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zne={kernelName:Kf,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{dim:r}=n,i=!0,o=te(t,s);return{logits:()=>mt(o,te(ut(o,[r],i),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qne={kernelName:Vc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,Qc(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FC={kernelName:Wf,gradFunc:(t,e,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>Uv(t,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UC={kernelName:Hf,gradFunc:(t,e,n)=>{const{axis:s}=n;return{x:()=>Ys(t,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jne={kernelName:Wc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ct(t,te(Is(Ze(n,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ese={kernelName:M0,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,te(Ze(n,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tse={kernelName:Hc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Ht(2);return{a:()=>te(t,te(r,mt(n,s))),b:()=>te(t,te(r,mt(s,n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nse={kernelName:Yc,gradFunc:t=>({x:()=>Ft(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sse={kernelName:Kc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=pt(n.shape,s.shape);return{a:()=>{let a=t;const l=rs(n.shape,r);return l.length>0&&(a=ut(a,l)),ie(a,n.shape)},b:()=>{let a=t;const l=rs(s.shape,r);return l.length>0&&(a=ut(a,l)),ie(Un(a),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rse={kernelName:Vf,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,r=s.shape.slice(),{axis:i}=n;wt(i,s.shape).forEach(u=>{r[u]=1});const a=ie(t,r),l=te(a,ba(s.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ise={kernelName:jc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ct(t,dn(zv(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ose={kernelName:Xc,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(mt(Ht(1),dn(n)),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ase={kernelName:qc,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{reps:r}=n;return{x:()=>{let o=Ft(s);if(s.rank===1)for(let a=0;a<r[0];++a)o=Me(o,sn(t,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)o=Me(o,sn(t,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)o=Me(o,sn(t,[a*s.shape[0],l*s.shape[1],u*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)for(let c=0;c<r[3];++c)o=Me(o,sn(t,[a*s.shape[0],l*s.shape[1],u*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lse={kernelName:rl,gradFunc:(t,e,n)=>{const s=n,{perm:r}=s,i=Qi(r);return{x:()=>Ot(t,i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const use={kernelName:jf,gradFunc:(t,e,n)=>{const s=n,{axis:r}=s;return{value:()=>$o(t,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cse={kernelName:Xf,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>hse(t,n)}}};function hse(t,e){const n=xa(e,Ft(e)),s=Hv(t,n);let r=Pl(e,Ht(0,"int32"));const i=s.rank-r.rank;for(let a=0;a<i;++a)r=js(r,a+1);r=_o(r,ba(s.shape,"bool"));const o=Ft(s);return Fs(r,s,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dse={kernelName:qf,gradFunc:t=>({x:()=>Ft(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fse=[B$,cte,hte,dte,fte,pte,mte,gte,xte,bte,yte,vte,Cte,kte,Ete,_te,$te,Rte,Ate,Pte,Dte,Nte,Lte,Mte,Ute,Bte,zte,Gte,Vte,Wte,Nne,Hte,Kte,jte,Xte,qte,Zte,Yte,Qte,Jte,ene,tne,nne,sne,rne,ine,one,ane,lne,hne,LC,LC,dne,mne,bne,yne,vne,wne,Sne,Cne,Tne,Ine,kne,Ene,_ne,OC,OC,$ne,Rne,Dne,Mne,Lne,One,Fne,Une,Bne,zne,Gne,Vne,Wne,Hne,Kne,jne,Xne,qne,Yne,Zne,Qne,FC,FC,UC,UC,Jne,tse,ese,nse,sse,rse,ise,ose,ase,lse,use,cse,dse];for(const t of fse)KX(t);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.abs=function(){return this.throwIfDisposed(),As(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.acos=function(){return this.throwIfDisposed(),qq(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.acosh=function(){return this.throwIfDisposed(),Zq(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.add=function(t){return this.throwIfDisposed(),Me(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.all=function(t,e){return this.throwIfDisposed(),I_(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.any=function(t,e){return this.throwIfDisposed(),H1(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.argMax=function(t){return this.throwIfDisposed(),Cd(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.argMin=function(t){return this.throwIfDisposed(),nY(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.asScalar=function(){return this.throwIfDisposed(),G(this.size===1,()=>"The array must have only 1 element."),ie(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.asType=function(t){return this.throwIfDisposed(),Ze(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.as1D=function(){return this.throwIfDisposed(),ie(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.as2D=function(t,e){return this.throwIfDisposed(),ie(this,[t,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),ie(this,[t,e,n])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.as4D=function(t,e,n,s){return this.throwIfDisposed(),ie(this,[t,e,n,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.as5D=function(t,e,n,s,r){return this.throwIfDisposed(),ie(this,[t,e,n,s,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.asin=function(){return this.throwIfDisposed(),rY(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.asinh=function(){return this.throwIfDisposed(),oY(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.atan=function(){return this.throwIfDisposed(),lY(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.atan2=function(t){return this.throwIfDisposed(),cY(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.atanh=function(){return this.throwIfDisposed(),dY(this)};be().prototype.avgPool=function(t,e,n,s){return this.throwIfDisposed(),Fv(this,t,e,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),Uv(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.batchNorm=function(t,e,n,s,r){return this.throwIfDisposed(),H0(this,t,e,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.broadcastTo=function(t){return this.throwIfDisposed(),nd(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.cast=function(t){return this.throwIfDisposed(),Ze(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.ceil=function(){return this.throwIfDisposed(),UY(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),Ir(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof Qn&&(t=[t]),Ys([this,...t],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.conv1d=function(t,e,n,s,r,i){return this.throwIfDisposed(),k_(this,t,e,n,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.conv2dTranspose=function(t,e,n,s,r){return this.throwIfDisposed(),E_(this,t,e,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.conv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),ml(this,t,e,n,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.cos=function(){return this.throwIfDisposed(),zv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.cosh=function(){return this.throwIfDisposed(),$_(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),j1(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),R_(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),cZ(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.depthwiseConv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),Gv(this,t,e,n,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.dilation2d=function(t,e,n,s,r){return this.throwIfDisposed(),fZ(this,t,e,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.divNoNan=function(t){return this.throwIfDisposed(),bZ(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.div=function(t){return this.throwIfDisposed(),ct(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.dot=function(t){return this.throwIfDisposed(),vZ(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.elu=function(){return this.throwIfDisposed(),j0(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.equal=function(t){return this.throwIfDisposed(),Hi(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.erf=function(){return this.throwIfDisposed(),A_(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),PZ(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.exp=function(){return this.throwIfDisposed(),Ki(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.expandDims=function(t){return this.throwIfDisposed(),js(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.expm1=function(){return this.throwIfDisposed(),LZ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.fft=function(){return this.throwIfDisposed(),q_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.flatten=function(){return this.throwIfDisposed(),ie(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.floor=function(){return this.throwIfDisposed(),q0(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.floorDiv=function(t){return this.throwIfDisposed(),T_(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.gather=function(t,e,n){return this.throwIfDisposed(),Hv(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.greaterEqual=function(t){return this.throwIfDisposed(),Pl(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.greater=function(t){return this.throwIfDisposed(),_r(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.ifft=function(){return this.throwIfDisposed(),X1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.irfft=function(){return this.throwIfDisposed(),EJ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.isFinite=function(){return this.throwIfDisposed(),HZ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.isInf=function(){return this.throwIfDisposed(),jZ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.isNaN=function(){return this.throwIfDisposed(),qZ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.leakyRelu=function(t){return this.throwIfDisposed(),jv(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.lessEqual=function(t){return this.throwIfDisposed(),Jc(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.less=function(t){return this.throwIfDisposed(),Jm(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.localResponseNormalization=function(t,e,n,s){return this.throwIfDisposed(),eQ(this,t,e,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.logSigmoid=function(){return this.throwIfDisposed(),aQ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.logSoftmax=function(t){return this.throwIfDisposed(),M_(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),L_(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.log=function(){return this.throwIfDisposed(),ji(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.log1p=function(){return this.throwIfDisposed(),N_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.logicalAnd=function(t){return this.throwIfDisposed(),_o(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.logicalNot=function(){return this.throwIfDisposed(),Xv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.logicalOr=function(t){return this.throwIfDisposed(),O_(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.logicalXor=function(t){return this.throwIfDisposed(),mQ(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),Lt(this,t,e,n)};be().prototype.maxPool=function(t,e,n,s){return this.throwIfDisposed(),qv(this,t,e,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.max=function(t,e){return this.throwIfDisposed(),si(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.maximum=function(t){return this.throwIfDisposed(),xa(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.mean=function(t,e){return this.throwIfDisposed(),Hn(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.min=function(t,e){return this.throwIfDisposed(),Qm(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.minimum=function(t){return this.throwIfDisposed(),kd(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),CQ(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.mod=function(t){return this.throwIfDisposed(),IQ(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.mul=function(t){return this.throwIfDisposed(),te(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.neg=function(){return this.throwIfDisposed(),Un(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.norm=function(t,e,n){return this.throwIfDisposed(),X0(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.notEqual=function(t){return this.throwIfDisposed(),eg(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),F_(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.onesLike=function(){return this.throwIfDisposed(),jr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.pad=function(t,e){return this.throwIfDisposed(),Zv(this,t,e)};be().prototype.pool=function(t,e,n,s,r,i){return this.throwIfDisposed(),MQ(this,t,e,n,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.pow=function(t){return this.throwIfDisposed(),gl(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.prelu=function(t){return this.throwIfDisposed(),Jv(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.prod=function(t,e){return this.throwIfDisposed(),FQ(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.reciprocal=function(){return this.throwIfDisposed(),aJ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.relu=function(){return this.throwIfDisposed(),Nl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.relu6=function(){return this.throwIfDisposed(),z_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.reshapeAs=function(t){return this.throwIfDisposed(),ie(this,t.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.reshape=function(t){return this.throwIfDisposed(),ie(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),e$(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),t$(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.reverse=function(t){return this.throwIfDisposed(),xl(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.rfft=function(){return this.throwIfDisposed(),RJ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.round=function(){return this.throwIfDisposed(),G_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.rsqrt=function(){return this.throwIfDisposed(),V_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.selu=function(){return this.throwIfDisposed(),W_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.separableConv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),H_(this,t,e,n,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.sigmoid=function(){return this.throwIfDisposed(),Qc(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.sign=function(){return this.throwIfDisposed(),gJ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.sin=function(){return this.throwIfDisposed(),K_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.sinh=function(){return this.throwIfDisposed(),j_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.slice=function(t,e){return this.throwIfDisposed(),sn(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.softmax=function(t){return this.throwIfDisposed(),u2(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.softplus=function(){return this.throwIfDisposed(),Yf(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),Qv(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.split=function(t,e){return this.throwIfDisposed(),Cr(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.sqrt=function(){return this.throwIfDisposed(),Is(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.square=function(){return this.throwIfDisposed(),dn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.squaredDifference=function(t){return this.throwIfDisposed(),PJ(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.squeeze=function(t){return this.throwIfDisposed(),Qf(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof Qn?[this,t]:[this,...t];return $o(n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.step=function(t){return this.throwIfDisposed(),Jf(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.stridedSlice=function(t,e,n,s,r,i,o,a){return this.throwIfDisposed(),OJ(this,t,e,n,s,r,i,o,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.sub=function(t){return this.throwIfDisposed(),mt(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.sum=function(t,e){return this.throwIfDisposed(),ut(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.tan=function(){return this.throwIfDisposed(),UJ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.tanh=function(){return this.throwIfDisposed(),W0(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.tile=function(t){return this.throwIfDisposed(),ei(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.toBool=function(){return this.throwIfDisposed(),Ze(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.toFloat=function(){return this.throwIfDisposed(),Ze(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.toInt=function(){return this.throwIfDisposed(),Ze(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.topk=function(t,e){return this.throwIfDisposed(),GJ(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.transpose=function(t){return this.throwIfDisposed(),Ot(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.unique=function(t){return this.throwIfDisposed(),HJ(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),Q_(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.unstack=function(t){return this.throwIfDisposed(),bl(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.where=function(t,e){return this.throwIfDisposed(),Fs(t,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */be().prototype.zerosLike=function(){return this.throwIfDisposed(),Ft(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ai extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ai.prototype)}}class Gr extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Gr.prototype)}}class ee extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ee.prototype)}}class Et extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Et.prototype)}}class C2 extends Error{constructor(e){super(e),Object.setPrototypeOf(this,C2.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class G${constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let n;return this.cache.has(e)&&(n=this.cache.get(e),this.cache.delete(e),this.cache.set(e,n)),n}put(e,n){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let n=0;n<this.maxEntries-e;n++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yl(t,e){if(Array.isArray(t)){let n=[];for(let s=0;s<e;s++)n=n.concat(t);return n}else{const n=new Array(e);return n.fill(t),n}}function Pi(t,e){if(!t)throw new C2(e)}function BC(t,e){let n=0;for(const s of t)s===e&&n++;return n}function Xs(t){return t.length===1?t[0]:t}function Xt(t){return Array.isArray(t)?t:[t]}function fo(t){const n=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function Ha(t){return t.length<=1||t.indexOf("_")===-1?t:t.replace(/[_]+(\w|$)/g,(e,n)=>n.toUpperCase())}let Dr={};function T2(t){if(t==null)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function Z1(t){if(!(t==null||typeof t!="object"))if(Array.isArray(t))t.forEach(e=>Z1(e));else{const e=Object.keys(t);for(const n of e){const s=t[n];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?t[n]=s.value:Z1(s))}}}function sp(t,e={},n={},s="object",r=!1){if(typeof t=="string"){const i=t;let o;if(i in n)o=n[i];else if(i in Dr)o=Dr[i];else if(o=e[i],o==null)throw new ee(`Unknown ${s}: ${t}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=t;if(i.className==null||i.config==null)throw new ee(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,l;if(o in n?[a,l]=n[o]:o in Dr?[a,l]=Dr.className:o in e&&([a,l]=e[o]),a==null)throw new ee(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const f of Object.keys(Dr))u[f]=Dr[f];for(const f of Object.keys(n))u[f]=n[f];const c=i.config;c.customObjects=u;const h=Object.assign({},Dr);for(const f of Object.keys(n))Dr[f]=n[f];Z1(i.config);const d=l(a,i.config,n,r);return Dr=Object.assign({},h),d}else{const u=Object.assign({},Dr);for(const h of Object.keys(n))Dr[h]=n[h];const c=new a(i.config);return Dr=Object.assign({},u),c}}}function pse(t,e){return t<e?-1:t>e?1:0}function Vp(t,e){return-1*pse(t,e)}function sa(t){if(t==null)return t;const e=[];for(const n of t)e.indexOf(n)===-1&&e.push(n);return e}function mse(t){if(t==null)throw new ee(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function Fl(t,e,n){if(n!=null&&t.indexOf(n)<0)throw new ee(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function I2(t,e,n=0,s=1/0){return Pi(n>=0),Pi(s>=n),Array.isArray(t)&&t.length>=n&&t.length<=s&&t.every(r=>typeof r===e)}function us(t,e){Array.isArray(t)?(G(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((n,s)=>us(n,`element ${s+1} of ${e}`))):G(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${V$(t)}.`)}function V$(t){return t===null?"null":Array.isArray(t)?"["+t.map(e=>V$(e)).join(",")+"]":typeof t=="string"?`"${t}"`:`${t}`}function gse(t,e,n){let s=n!=null?n():Hs(),r;return(...o)=>{const a=n!=null?n():Hs();return a-s<e||(s=a,r=t(...o)),r}}function W$(t){return t==="relu"?"relu":t==="linear"?"linear":t==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let xse=0;function H$(){return xse++}const Wp={};function vx(t=""){return t in Wp||(Wp[t]=0),Wp[t]+=1,t+Wp[t].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const bse=["channelsFirst","channelsLast"],yse=["nearest","bilinear"],vse=["valid","same","causal"],wse=["max","avg"],Sse=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const au=new Map;function Vn(t){Fl(bse,"DataFormat",t)}function Cse(t){Fl(yse,"InterpolationFormat",t)}function $r(t){Fl(vse,"PaddingMode",t)}function K$(t){Fl(wse,"PoolMode",t)}const rd=[],zC="/";function ol(t,e){rd.push(t);try{const n=e();return rd.pop(),n}catch(n){throw rd.pop(),n}}function Tse(){return rd.length===0?"":rd.join(zC)+zC}function j$(t){if(!q$(t))throw new Error("Not a valid tensor name: '"+t+"'");return Tse()+t}function X$(t){if(!q$(t))throw new Error("Not a valid tensor name: '"+t+"'");au.has(t)||au.set(t,0);const e=au.get(t);if(au.set(t,au.get(t)+1),e>0){const n=`${t}_${e}`;return au.set(n,1),n}else return t}const Ise=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function q$(t){return!!t.match(Ise)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function kse(t){return t===parseInt(t.toString(),10)}function ra(t,e,n){e==null&&(e=0),n==null&&(n=t.length);let s=1;for(let r=e;r<n;++r)s*=t[r];return s}function Vu(t){if(t.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s<e&&(e=s)}return e}function aa(t){if(t.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s>e&&(e=s)}return e}function hi(t,e){if(e<t)throw new ee(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let s=t;s<e;++s)n.push(s);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Nb;function es(){return Nb==null&&(Nb=yq().epsilon()),Nb}function di(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Vi(t,e){return Ze(t,e)}function rp(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),ie(t,n)}function Ese(t,e){return de(()=>{if(t.shape.length!==2)throw new ee(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);const n=rp(t,1);return Q1(n,[1,e,1])})}function _se(t){const e=[ra(t.shape)];return ie(t,e)}function $se(t){if(t.rank<=1)throw new ee(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],ra(t.shape,1)];return ie(t,e)}function al(t,e,n){return de(()=>{switch(t.rank){case 1:return a2(t,e,n);case 2:return X_(t,[e,0],[n,t.shape[1]]);case 3:return l2(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return ng(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return sn(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return sn(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new ee(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function Mb(t,e,n){return de(()=>{switch(t.rank){case 1:return a2(t,e,n);case 2:return X_(t,[0,e],[t.shape[0],n]);case 3:return l2(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return ng(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new ee(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function Hp(t,e,n,s){return de(()=>{switch(t.rank){case 1:return a2(t,e,n);case 2:switch(s){case 1:return al(t,e,n);case 2:return Mb(t,e,n);default:throw new ee(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return al(t,e,n);case 2:return l2(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return Mb(t,e,n);default:throw new ee(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return al(t,e,n);case 2:return ng(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return ng(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return Mb(t,e,n);default:throw new ee(`The axis is not within the rank of the tensor ${s}`)}default:throw new ee(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function k2(t,e=-1){let n;return e<0&&(n=t[0].rank,n!==0?e=n:e=0),e===t[0].rank&&(e=-1),Ys(t,e)}function GC(t,e){switch(t.rank){case 1:return GY([t,e]);case 2:return WY([t,e],0);case 3:return KY([t,e],0);case 4:return XY([t,e],0);default:throw new ee(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function Q1(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new ee(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return ei(t,e)}function wx(t,e=0,n=1,s,r){return sJ(t,e,n,s,r)}function Wi(t,e,n,s){if(t.rank<2||e.rank<2)throw new Et(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=t.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(r!==i)throw new Et(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`)}if(t.rank===2&&e.rank===2)return _C({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?J1(t.rank,s,di()):null,activation:n});{const r=t.shape.slice(),i=r.pop();t=ie(t,[-1,i]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),u=[...o,a],c=Array.from({length:e.rank},(p,g)=>g===0?e.rank-2:g<=e.rank-2?g-1:g);e=ie(Ot(e,c),[l,-1]);const h=[...r,...u];return ie(_C({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?J1(t.rank,s,di()):null,activation:n}),h)}}function Y$(t,e,n){return de(()=>(Array.isArray(e)?e=cr(e,"int32"):e=Ze(e,"int32"),Hv(t,e,n)))}function ip(t){return te(t,t)}function J1(t,e,n){const s=e.shape;if(e.rank!==1&&e.rank!==t)throw new ee(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(t===5){if(n==="channelsFirst")return s.length===1?ie(e,[1,s[0],1,1,1]):ie(e,[1,s[3],s[0],s[1],s[2]]);if(n==="channelsLast")return s.length===1?ie(e,[1,1,1,1,s[0]]):ie(e,[1].concat(s))}else if(t===4){if(n==="channelsFirst")return s.length===1?ie(e,[1,s[0],1,1]):ie(e,[1,s[2],s[0],s[1]]);if(n==="channelsLast")return s.length===1?ie(e,[1,1,1,s[0]]):ie(e,[1].concat(s))}else if(t===3){if(n==="channelsFirst")return s.length===1?ie(e,[1,s[0],1]):ie(e,[1,s[1],s[0]]);if(n==="channelsLast")return s.length===1?ie(e,[1,1,s[0]]):ie(e,[1].concat(s))}else if(t<3)return e;throw new ee(`Unsupported input rank by biasAdd: ${e.rank}`)}function xi(t,e,n){return de(()=>(n==null&&(n=di()),Vn(n),Me(t,J1(t.rank,e,n))))}function Rse(t,e=1){if(e!==1)throw new Et(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return j0(t)}function Ase(t){return de(()=>ct(t,Me(As(t),1)))}function Z$(t,e,n,s){return de(()=>QJ(t,e,n,s))}function Pse(t){return de(()=>{const e=Me(.5,te(.2,t));return Ir(e,0,1)})}function op(t,e,n=!1){return n?t():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Dse=["fanIn","fanOut","fanAvg"],Nse=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Mse(t){Fl(Dse,"FanMode",t)}function Lse(t){Fl(Nse,"Distribution",t)}class Xr extends th{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Q$ extends Xr{apply(e,n){return Jn(e,n)}}Q$.className="Zeros";$e(Q$);class E2 extends Xr{apply(e,n){return ba(e,n)}}E2.className="Ones";$e(E2);class J$ extends Xr{constructor(e){if(super(),typeof e!="object")throw new ee(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new ee(`config must have value set but got ${e}`);this.value=e.value}apply(e,n){return de(()=>te(Ht(this.value),ba(e,n)))}getConfig(){return{value:this.value}}}J$.className="Constant";$e(J$);class eR extends Xr{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,n){return Zf(e,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}eR.className="RandomUniform";$e(eR);class tR extends Xr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Et(`randomNormal does not support dType ${n}.`);return wx(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}tR.className="RandomNormal";$e(tR);class nR extends Xr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Et(`truncatedNormal does not support dType ${n}.`);return Z_(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}nR.className="TruncatedNormal";$e(nR);class sR extends Xr{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,n){return de(()=>{if(e.length!==2||e[0]!==e[1])throw new ee("Identity matrix initializer can only be used for 2D square matrices.");return te(this.gain,Wv(e[0]))})}getConfig(){return{gain:this.gain}}}sR.className="Identity";$e(sR);function Ose(t,e="channelsLast"){let n,s;if(Vn(e),t.length===2)n=t[0],s=t[1];else if([3,4,5].indexOf(t.length)!==-1){if(e==="channelsFirst"){const r=ra(t,2);n=t[1]*r,s=t[0]*r}else if(e==="channelsLast"){const r=ra(t,0,t.length-2);n=t[t.length-2]*r,s=t[t.length-1]*r}}else{const r=ra(t);n=Math.sqrt(r),s=Math.sqrt(r)}return[n,s]}class dr extends Xr{constructor(e){if(super(),e.scale<0)throw new ee(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Mse(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Lse(this.distribution),this.seed=e.seed}apply(e,n){const s=Ose(e),r=s[0],i=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(r+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Et(`${this.getClassName()} does not support dType ${n}.`);return Z_(e,0,a,n,this.seed)}else{const a=Math.sqrt(3*o);return Zf(e,-a,a,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}dr.className="VarianceScaling";$e(dr);class _2 extends dr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return dr.className}}_2.className="GlorotUniform";$e(_2);class $2 extends dr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return dr.className}}$2.className="GlorotNormal";$e($2);class R2 extends dr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return dr.className}}R2.className="HeNormal";$e(R2);class A2 extends dr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return dr.className}}A2.className="HeUniform";$e(A2);class P2 extends dr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return dr.className}}P2.className="LeCunNormal";$e(P2);class D2 extends dr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return dr.className}}D2.className="LeCunUniform";$e(D2);class rR extends Xr{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,n){return de(()=>{if(e.length<2)throw new Et("Shape must be at least 2D.");if(n!=="int32"&&n!=="float32"&&n!==void 0)throw new TypeError(`Unsupported data type ${n}.`);n=n;const s=oe(e.slice(0,-1)),r=e[e.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(r,s),Math.min(r,s)],a=wx(o,0,1,n,this.seed),l=Xee.qr(a,!1);let u=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return u=te(u,h.sign()),s<r&&(u=u.transpose()),te(Ht(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}rR.className="Orthogonal";$e(rR);const VC={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function WC(t,e={}){return sp(t,Or.getMap().classNameMap,e,"initializer")}function Cn(t){return T2(t)}function yn(t){if(typeof t=="string"){const e=t in VC?VC[t]:t;if(e==="GlorotNormal")return new $2;if(e==="GlorotUniform")return new _2;if(e==="HeNormal")return new R2;if(e==="HeUniform")return new A2;if(e==="LeCunNormal")return new P2;if(e==="LeCunUniform")return new D2;{const n={};return n.className=e,n.config={},WC(n)}}else return t instanceof Xr?t:WC(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ey(t){return Array.isArray(t)&&Array.isArray(t[0])}function sg(t){return t.length===0?[]:Array.isArray(t[0])?t:[t]}function bt(t){let e;if(Array.isArray(t)){if(t.length!==1)throw new ee(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function Vt(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(t.length===1)return t=t,t[0];throw new ee(`Expected exactly 1 Shape; got ${t.length}`)}else return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function rg(t){let e=0;for(const n of t)n.shape.length===0?e+=1:e+=n.shape.reduce((s,r)=>s*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const HC="Variable";class Fse{constructor(e,n="float32",s=HC,r=!0,i=null){this.dtype=n??"float32",this.shape=e.shape,this.id=H$(),s=s??HC,this.originalName=j$(s),this.name=X$(this.originalName),this.trainable_=r,this.constraint=i,this.val=XJ(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Use(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Use(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}function ty(t){return t.map(e=>e.read())}function N2(t){t.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ts{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Xi{constructor(e,n,s,r,i,o,a){this.dtype=e,this.shape=n,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=a,this.id=H$(),o!=null&&(this.originalName=j$(o),this.name=X$(this.originalName)),this.rank=n.length}}let Bse=0,Sx=class{constructor(e,n){this.callArgs=n,this.id=Bse++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const n of this.inboundLayers)n!=null?e.push(n.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},zse=0,Rt=class extends th{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=zse++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=e.name;if(!n){const s=this.getClassName();n=fo(s)+"_"+vx(s)}if(this.name=n,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),s=[i].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,n){return e.name+"_ib-"+n.toString()}getNodeAtIndex(e,n){if(this.inboundNodes.length===0)throw new Gr(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=e)throw new ee(`Asked to get ${n} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Xs(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Xs(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ai(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ai(`Layer ${this.name} is not connected, no input to return.`);return Xs(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ai(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ai(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Xs(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(n=>n.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const n=Xt(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Xt(this.inputSpec);if(n.length!==s.length)throw new ee(`Layer ${this.name} expects ${s.length} inputs, but it received ${n.length} input tensors. Input received: ${e}`);for(let r=0;r<n.length;r++){const i=n[r],o=s[r];if(o==null)continue;const a=i.rank;if(o.ndim!=null&&a!==o.ndim)throw new ee(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new ee(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new ee(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new ee(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const l=i.shape;for(const u in o.axes){const c=Number(u),h=o.axes[u],d=c>=0?l[c]:l[l.length+c];if(h!=null&&[h,null].indexOf(d)===-1)throw new ee(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const u=o.shape[l],c=i.shape[l];if(u!=null&&c!=null&&u!==c)throw new ee(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(e,n){return e}invokeCallHook(e,n){this._callHook!=null&&this._callHook(e,n)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,n){n=n||{},this.assertNotDisposed();const s=Xt(e),r=Wse(e),i=Hse(e);if(r===i)throw new ee("Arguments to apply() must be all SymbolicTensors or all Tensors");return ol(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of Xt(e))o.push(a.shape);this.build(Xs(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let o=this.call(e,n);this.supportsMasking&&this.setMaskMetadata(e,o);const a=Xt(o),l=[];for(let u of a)s.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(o=Xs(l),this.activityRegularizer!=null)throw new Et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=Gse(e),a=this.computeOutputShape(o);let l;const u=Vse(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((c,h)=>new Xi(u,c,this,Xt(e),n,this.name,h)):l=new Xi(u,a,this,Xt(e),n,this.name),this.addInboundNode(e,l,null,null,o,a,n),this._refCount++,this.activityRegularizer!=null)throw new Et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ai(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const n of this.inboundNodes){const s=JSON.stringify(n.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new Ai(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Gr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return rg(this.weights)}build(e){this.built=!0}getWeights(e=!1){return ty(e?this.trainableWeights:this.weights)}setWeights(e){de(()=>{const n=this.weights;if(n.length!==e.length)throw new ee(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${n.length} weights. Provided weights: ${e}...`);if(n.length===0)return;const s=[],r=ty(n);for(let i=0;i<r.length;++i){const o=r[i],a=n[i],l=e[i];if(!Pt(o.shape,l.shape))throw new ee(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}N2(s)})}addWeight(e,n,s,r,i,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new ee(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():yn("zeros"));const u=r.apply(n,s),c=new Fse(u,s,e,o,a);return u.dispose(),i!=null&&this.addLoss(()=>i.apply(c.read())),o==null&&(o=!0),o?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Xt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}setMaskMetadata(e,n,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),i=Xt(n),o=Xt(r);if(i.length!==o.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let a=0;a<i.length;a++)i[a].kerasMask=o[a]}addInboundNode(e,n,s,r,i,o,a=null){const l=Xt(e);n=Xt(n),s=Xt(s),r=Xt(r),i=sg(i),o=sg(o);const u=[],c=[],h=[];for(const d of l)u.push(d.sourceLayer),c.push(d.nodeIndex),h.push(d.tensorIndex);new Sx({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:h,inputTensors:l,outputTensors:n,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:o},a);for(let d=0;d<n.length;d++)n[d].sourceLayer=this,n[d].nodeIndex=this.inboundNodes.length-1,n[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function Gse(t){t=Xt(t);const e=[];for(const n of t)e.push(n.shape);return Xs(e)}function Vse(t){return"float32"}function iR(t,e,n){if((e==null||n!=null&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),e.inboundNodes.length===0)return[t];{const s=e.inboundNodes[n];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const o=s.inputTensors[i],a=s.inboundLayers[i],l=s.nodeIndices[i],u=iR(o,a,l);for(const c of u)r.indexOf(c)===-1&&r.push(c)}return r}}}function Wse(t){let e=!0;for(const n of Xt(t))if(!(n instanceof Xi)){e=!1;break}return e}function Hse(t){let e=!0;for(const n of Xt(t))if(n instanceof Xi){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ap extends Rt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:vx("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new ee("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=e.batchInputShape;if(n==null){if(e.inputShape==null)throw new ee("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new ee("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=n,this.dtype=s,this.inputSpec=[{shape:n}];const r=new Xi(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Sx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(e,n){throw new ee(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}ap.className="InputLayer";$e(ap);function Kse(t){if(t.batchShape==null&&t.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(t.batchShape!=null&&t.shape!=null)throw new ee("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;t.shape!=null&&e==null&&(e=[null].concat(t.shape));let n=t.dtype;return n==null&&(n="float32"),new ap({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function jse(t,e){if(t.dtype==null||t.dtype===e.dtype)return e;try{return Ze(e,t.dtype)}catch{throw new ee(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}class Zo{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Zo)for(const n in e.id2Value)this.id2Value[n]=e.id2Value[n],n in e.id2Mask&&(this.id2Mask[n]=e.id2Mask[n]);else{if(e==null)return;for(const n of e)this.add(n.key,n.value)}}add(e,n,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=jse(e,n),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new ee(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Xi){if(this.id2Value[e.id]==null)throw new ee(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const n=this.name2Id[e];if(n==null)throw new ee(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[n]}}getMask(e){if(e instanceof Xi){if(this.id2Value[e.id]==null)throw new ee(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const n=this.name2Id[e];if(n==null)throw new ee(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&At(this.id2Mask)}}const ig=new G$,og=new G$;function Xse(t){ig!=null&&ig.setMaxEntries(t),og!=null&&og.setMaxEntries(t)}function Lh(t,e,n,s){const r=n==null?!1:n.training,i=Array.isArray(t),o=i?t:[t],a=o.map(p=>p.name),l=[],u=e.names();for(const p of a)u.indexOf(p)!==-1?l.push(e.getValue(p)):l.push(null);const c=a.join(",")+"|"+e.names().sort().join(",");let h=ig.get(c),d;if(h==null){const p=qse(o,e);h=p.sorted,d=p.recipientCounts,ig.put(c,h),og.put(c,d)}d={},r||Object.assign(d,og.get(c));const f=new Zo(e);for(let p=0;p<h.length;++p){const g=h[p],m=g.sourceLayer;if(m instanceof ap)continue;const x=[],b=[],v=[];let y=!1;for(const S of g.inputs){const E=f.getValue(S),_=f.getMask(S);x.push(E),b.push(_),_!=null&&(y=!0),r||(d[S.name]--,d[S.name]===0&&!e.hasKey(S)&&a.indexOf(S.name)===-1&&!E.isDisposed&&S.sourceLayer.stateful!==!0&&v.push(E))}y&&(n=n||{},n.mask=b[0]);const C=Xt(m.apply(x,n));let I=null;m.supportsMasking&&(I=m.computeMask(x,b));const $=Zse(g),T=Array.isArray($)?$:[$];for(let S=0;S<T.length;++S){f.hasKey(T[S])||f.add(T[S],C[S],Array.isArray(I)?I[0]:I);const E=a.indexOf(T[S].name);E!==-1&&(l[E]=C[S])}r||At(v)}return f.disposeMasks(),i?l:l[0]}function qse(t,e){G(t!=null&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(t.length===1){const r=KC(t[0],e);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of t){const{sorted:o,recipientMap:a}=KC(i,e);for(const l of o)r.has(l.name)||(n.push(l),r.add(l.name));for(const l in a)s[l]==null&&(s[l]=new Set),a[l].forEach(u=>s[l].add(u))}}return{sorted:n,recipientCounts:Yse(s)}}function Yse(t){const e={};for(const n in t)e[n]=t[n].size;return e}function KC(t,e){const n=new Set,s=[],r={};for(const a of e.names())n.add(a);const i=[],o=[];for(i.push(t);i.length>0;){const a=i[i.length-1];if(n.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(a.inputs.length===0||l)i.pop(),s.push(a),n.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const u of a.inputs)r[u.name]==null&&(r[u.name]=new Set),r[u.name].add(a.name),!n.has(u.name)&&i.push(u)}}return{sorted:s,recipientMap:r}}function Zse(t){let e;if(t.sourceLayer.inboundNodes.length===1)e=t.sourceLayer.output;else{let n=null;for(let s=0;s<t.sourceLayer.inboundNodes.length;++s)for(const r of t.sourceLayer.inboundNodes[s].outputTensors)if(r.id===t.id){n=s;break}e=t.sourceLayer.getOutputAt(n)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qse=ue();Qse.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Xse);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function M2(t,e){return de(()=>Is(ut(te(t,t),e,!0)))}class lp extends th{getConfig(){return{}}}class oR extends lp{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return de(()=>{const n=M2(e,this.axis),s=Ir(n,0,this.maxValue);return te(e,ct(s,Me(es(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}oR.className="MaxNorm";$e(oR);class aR extends lp{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return de(()=>ct(e,Me(es(),M2(e,this.axis))))}getConfig(){return{axis:this.axis}}}aR.className="UnitNorm";$e(aR);class lR extends lp{apply(e){return Nl(e)}}lR.className="NonNeg";$e(lR);class uR extends lp{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return de(()=>{const n=M2(e,this.axis),s=Me(te(this.rate,Ir(n,this.minValue,this.maxValue)),te(1-this.rate,n));return te(e,ct(s,Me(es(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}uR.className="MinMaxNorm";$e(uR);const jC={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ns(t){return T2(t)}function XC(t,e={}){return sp(t,Or.getMap().classNameMap,e,"constraint")}function ss(t){if(t==null)return null;if(typeof t=="string"){const n={className:t in jC?jC[t]:t,config:{}};return XC(n)}else return t instanceof lp?t:XC(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function La(t){if(t==null)return;const e=[],n=[],s=[];for(const r in t){const i=t[r];if(typeof i!="number"){const o=i;e.push(o.data()),n.push(r),s.push(o)}}if(e.length>0){const r=await Promise.all(e);for(let i=0;i<r.length;++i)t[n[i]]=r[i][0];At(s)}}function cR(t){if(t!=null)for(const e in t){const n=t[e];typeof n!="number"&&n.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var qC;(function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"})(qC||(qC={}));const Jse=125;class _d{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,n){}async onEpochEnd(e,n){}async onBatchBegin(e,n){}async onBatchEnd(e,n){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class ere{constructor(e,n=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=n}append(e){this.callbacks.push(e)}setParams(e){for(const n of this.callbacks)n.setParams(e)}setModel(e){for(const n of this.callbacks)n.setModel(e)}async onEpochBegin(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onEpochBegin(e,n)}async onEpochEnd(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onEpochEnd(e,n)}async onBatchBegin(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onBatchBegin(e,n)}async onBatchEnd(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onBatchEnd(e,n)}async onTrainBegin(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainEnd(e)}}class tre extends _d{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,n){n==null&&(n={});const s=n.size==null?0:n.size;this.seen+=s;for(const r in n){const i=n[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const a=de(()=>Me(this.totals[r],te(i,s)));this.totals[r]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,n){if(n!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?n[s]=this.totals[s]/this.seen:de(()=>{const r=te(ct(1,this.seen),this.totals[s]);n[s]=r,this.totals[s].dispose(),Gi(n[s])}))}}class nre extends _d{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,n){n==null&&(n={}),this.epoch.push(e);for(const s in n)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(n[s])}async syncData(){const e=[],n=[],s=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),n.push(i),s.push(a)}}const r=await Promise.all(e);for(let i=0;i<r.length;++i)this.history[n[i]][s[i]].dispose(),this.history[n[i]][s[i]]=r[i][0]}}class sre extends _d{constructor(e,n){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||g$,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Jse),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");P1(this.yieldEvery)&&(this.maybeWait=gse(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,n,s){const r=[];this.yield!=null&&(await La(s),r.push(this.yield(e,n,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,n){this.currentEpoch=e,this.epochBegin!=null&&(await La(n),await this.epochBegin(e,n))}async onEpochEnd(e,n){const s=[];this.epochEnd!=null&&(await La(n),s.push(this.epochEnd(e,n))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,n){this.batchBegin!=null&&(await La(n),await this.batchBegin(e,n))}async onBatchEnd(e,n){const s=[];this.batchEnd!=null&&(await La(n),s.push(this.batchEnd(e,n))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):P1(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,n)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await La(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await La(e),await this.trainEnd(e))}}function hR(t,e){return t==null&&(t={}),t instanceof _d?[t]:Array.isArray(t)&&t[0]instanceof _d?t:Xt(t).map(s=>new sre(s,e))}class Mr{constructor(){}static registerCallbackConstructor(e,n){G(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Mr.checkForDuplicate(n),Mr.constructors[e]==null&&(Mr.constructors[e]=[]),Mr.constructors[e].push(n)}static checkForDuplicate(e){for(const n in Mr.constructors)Mr.constructors[+n].forEach(r=>{if(r===e)throw new ee("Duplicate callback constructor.")})}static clear(){Mr.constructors={}}static createCallbacks(e){const n=[];for(const s in Mr.constructors){const r=+s;e>=r&&n.push(...Mr.constructors[r])}return n.map(s=>new s)}}Mr.constructors={};function dR(t,e,n,s,r,i,o,a,l){const u=new nre,c=[new tre,...Mr.createCallbacks(e)];t!=null&&c.push(...t),c.push(u);const h=new ere(c);return h.setParams({epochs:n,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:u}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wo(t,e={},n=!1){return sp(t,Or.getMap().classNameMap,e,"layer",n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ag(t,e){return de(()=>{t.dtype!=="float32"&&(t=Ze(t,"float32"));const n=ut(ip(t),e,!0),s=K0(n.shape,es()),r=Is(xa(n,s));return ct(t,r)})}function Cx(t,e){return de(()=>Hn(ip(mt(e,t)),-1))}function L2(t,e){return de(()=>Hn(As(mt(e,t)),-1))}function O2(t,e){return de(()=>{const n=mt(t,e),s=Ir(As(t),es(),Number.MAX_VALUE),r=As(ct(n,s));return te(100,Hn(r,-1))})}function rre(t,e){return de(()=>{const n=Ir(e,es(),Number.MAX_VALUE),s=ji(Me(1,n)),r=Ir(t,es(),Number.MAX_VALUE),i=ji(Me(1,r));return Hn(ip(mt(s,i)),-1)})}function ire(t,e){return de(()=>{const n=xa(0,mt(1,te(t,e)));return Hn(ip(n),-1)})}function ore(t,e){return de(()=>{const n=xa(0,mt(1,te(t,e)));return Hn(n,-1)})}function are(t,e){return de(()=>{const n=ut(te(t,e),-1),s=si(te(mt(1,t),e),-1);return xa(0,Me(1,mt(s,n)))})}function lre(t,e){return de(()=>{const n=Math.log(2),s=mt(e,t),r=mt(Me(s,Yf(te(-2,s))),n);return Hn(r,-1)})}function $d(t,e,n=!1){return de(()=>{if(n)e=u2(e);else{const s=ut(e,e.shape.length-1,!0);e=ct(e,s)}return e=Ir(e,es(),1-es()),Un(ut(te(Ze(t,"float32"),ji(e)),e.shape.length-1))})}function lg(t,e,n=!1){return de(()=>{const s=Ze(q0(_se(t)),"int32");e=Ir(e,es(),1-es());const r=e.shape,i=ie(F_(s,r[r.length-1]),r);return $d(i,e,n)})}function ure(t,e){if(!Pt(t.shape,e.shape))throw new ee(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return de(()=>{const n=Nl(e),s=Un(As(e));return Me(mt(n,te(e,t)),N_(Ki(s)))})}function Tx(t,e){return de(()=>{let n;return n=Ir(e,es(),1-es()),n=ji(ct(n,mt(1,n))),Hn(ure(t,n),-1)})}function cre(t,e){return de(()=>{const n=Ir(t,es(),1),s=Ir(e,es(),1);return ut(te(t,ji(ct(n,s))),-1)})}function hre(t,e){return de(()=>{const n=ji(Me(es(),e));return Hn(mt(e,te(t,n)),-1)})}function fR(t,e){return de(()=>{const n=ag(t,-1),s=ag(e,-1),r=te(n,s);return Un(ut(r,-1))})}const ug={meanSquaredError:Cx,meanAbsoluteError:L2,meanAbsolutePercentageError:O2,meanSquaredLogarithmicError:rre,squaredHinge:ire,hinge:ore,categoricalHinge:are,logcosh:lre,categoricalCrossentropy:$d,sparseCategoricalCrossentropy:lg,binaryCrossentropy:Tx,kullbackLeiblerDivergence:cre,poisson:hre,cosineProximity:fR};function Lb(t){if(typeof t=="string"){if(t in ug)return ug[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ee(e)}else return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pR(t,e){return de(()=>{const n=te(.5,jr(e)),s=Vi(_r(e,n),t.dtype);return Hn(Hi(t,s),-1)})}function mR(t,e){return de(()=>Vi(Hi(Cd(t,-1),Cd(e,-1)),"float32"))}function dre(t,e){return de(()=>Ze(ut(_o(Hi(t,1),Hi(e,1))),"float32"))}function fre(t,e){return de(()=>Ze(ut(_o(Hi(t,0),Hi(e,1))),"float32"))}function pre(t,e){return de(()=>{const n=dre(t,e),s=fre(t,e),r=Me(n,s);return Ze(Fs(_r(r,0),ct(n,r),0),"float32")})}function mre(t,e){return Tx(t,e)}function gre(t,e){return t.rank===e.rank&&(t=Qf(t,[t.rank-1])),e=Cd(e,-1),e.dtype!==t.dtype&&(e=Ze(e,t.dtype)),Ze(Hi(t,e),"float32")}const xre=Cx,bre=Cx,yre=L2,vre=L2,wre=O2,Sre=O2,gR=$d,Cre=fR,xR=lg,cg={binaryAccuracy:pR,categoricalAccuracy:mR,precision:pre,categoricalCrossentropy:gR,sparseCategoricalCrossentropy:xR,mse:xre,MSE:bre,mae:yre,MAE:vre,mape:wre,MAPE:Sre,cosine:Cre};function Tre(t){if(typeof t=="string"&&t in cg)return cg[t];if(typeof t!="string"&&t!=null)return t;throw new ee(`Unknown metric ${t}`)}function Kp(t){if(Pi(t!==null,`Unknown LossOrMetricFn ${t}`),typeof t=="string")return t;{let e;for(const n of Object.keys(ug))if(ug[n]===t){e=n;break}if(e!==void 0)return e;for(const n of Object.keys(cg))if(cg[n]===t){e=n;break}return e!==void 0?e:t.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ire(t){const e={Adagrad:()=>ou.adagrad(.01),Adadelta:()=>ou.adadelta(1,.95,es()),Adam:()=>ou.adam(.001,.9,.999,es()),Adamax:()=>ou.adamax(.002,.9,.999,es(),0),RMSProp:()=>ou.rmsprop(.001,.9,0,es()),SGD:()=>ou.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new ee(`Unknown Optimizer ${t}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const YC=1*1024*1024;function ZC(t,e,n=!1){if(t==null||typeof t!="object"||Object.getPrototypeOf(t)!==Object.prototype||!ny(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const s=JSON.stringify(t);s.length>YC&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${YC}.`)}}function ny(t){if(t===null)return!0;if(typeof t=="object")if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e)if(typeof n!="string"||!ny(t[n]))return!1;return!0}else if(Array.isArray(t)){for(const e of t)if(!ny(e))return!1;return!0}else return!1;else{const e=typeof t;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function kre(t,e,n,s=console.log){const r=_re(t),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(e*c)));let o;if(!r){i.push("Receives inputs"),o=[];for(const c in t.nodesByDepth)o.push(...t.nodesByDepth[c])}s("_".repeat(e)),hg(i,n,s),s("=".repeat(e));const a=t.layers;for(let c=0;c<a.length;++c)r?$re(a[c],n,s):Rre(a[c],n,o,s),s((c===a.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=Ere(t),u=rg(t.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(e))}function Ere(t){let e;return t.collectedTrainableWeights!=null?e=rg(t.collectedTrainableWeights):e=rg(t.trainableWeights),e}function _re(t){let e=!0;const n=[],s=[];for(const r in t.nodesByDepth)n.push(t.nodesByDepth[r]);for(const r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of t.layers){let i=!1;for(const o of r.inboundNodes)if(s.indexOf(o)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function hg(t,e,n=console.log){let s="";for(let r=0;r<t.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=t[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);n(s)}function $re(t,e,n){let s,r;try{r=t.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(t.outputShape)}catch{s="multiple"}const i=t.name,o=t.getClassName(),a=[`${i} (${o})`,r,s,t.countParams().toString()];hg(a,e,n)}function Rre(t,e,n,s){let r,i;try{i=t.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}const o=[];for(const h of t.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){const f=h.inboundLayers[d].name,p=h.nodeIndices[d],g=h.tensorIndices[d];o.push(`${f}[${p}][${g}]`)}const a=t.name,l=t.getClassName(),u=o.length===0?"":o[0],c=[`${a} (${l})`,i,r,t.countParams().toString(),u];hg(c,e,s);for(let h=1;h<o.length;++h)hg(["","","","",o[h]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bR(t,e,n){return(t==="inboundNodes"||t==="outputLayers"||t==="inputLayers")&&e===0&&typeof n=="string"}function sy(t,e){if(t===null)return null;if(typeof t=="string")return Ha(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const i=t[r];bR(e,r,i)?n.push(i):n.push(sy(i,e))}return n}else{const n={};for(const s of Object.keys(t)){const r=t[s];if(s==="name"&&typeof r=="string")n[s]=r;else{const i=Ha(s);n[i]=sy(r,i)}}return n}}function ry(t,e){if(t==null)return null;if(typeof t=="string")return fo(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const i=t[r];bR(e,r,i)?n.push(i):n.push(ry(i,e))}return n}else{const n={};for(const s of Object.keys(t)){const r=t[s],i=fo(s);(s==="name"||s==="className")&&typeof r=="string"?n[i]=r:n[i]=ry(r,s)}return n}}/** @license See the LICENSE file. */const yR="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Are=t=>{const e=Object.keys(t);if(e.length===0)return!1;const n=e[0].split("/");return!isNaN(parseInt(n[n.length-1],10))};let Pre=class Ti extends Rt{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=vx(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],sa(this.inputs).length!==this.inputs.length)throw new ee(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);sa(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const v=b.sourceLayer,y=b.nodeIndex,C=b.tensorIndex;this.outputLayers.push(v),this.outputLayersNodeIndices.push(y),this.outputLayersTensorIndices.push(C)}for(const b of this.inputs){const v=b.sourceLayer,y=b.nodeIndex,C=b.tensorIndex;Pi(y===0,"input layer has >1 nodes"),Pi(C===0,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(y),this.inputLayersTensorIndices.push(C)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const v=this.inputLayers[b];if(!(v instanceof ap))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const n={},s={},r={},i={},o={},a=[],l=(b,v,y,C,I,$)=>{(C==null||I==null||$==null)&&(C=b.sourceLayer,I=b.nodeIndex,$=b.tensorIndex);const T=C.inboundNodes[I];if(y.indexOf(T)!==-1)throw new Gr(`The tensor ${b.name} at layer "${C.name}" is part of a cycle.`);if(v.indexOf(T)!==-1)return;this.containerNodes.add(Ti.nodeKey(C,I)),C.id in o||(o[C.id]=Object.keys(o).length),y.indexOf(T)===-1&&y.push(T);const S=T.inboundLayers.length;for(let E=0;E<S;E++){const _=T.inputTensors[E],N=T.inboundLayers[E],P=T.nodeIndices[E],M=T.tensorIndices[E];l(_,v,y,N,P,M)}for(v.push(T);y.indexOf(T)>=0;)y.splice(y.indexOf(T),1);a.push(T)},u=[],c=[];for(const b of this.outputs)l(b,u,c);const h=a.slice().reverse();for(const b of h){s[b.id]=b,b.id in n||(n[b.id]=0);let v=n[b.id];const y=r[b.outboundLayer.id]==null?0:r[b.outboundLayer.id];v=Math.max(v,y),r[b.outboundLayer.id]=v,i[b.outboundLayer.id]=b.outboundLayer,n[b.id]=v;for(let C=0;C<b.inboundLayers.length;C++){const I=b.inboundLayers[C],$=b.nodeIndices[C],T=I.inboundNodes[$],S=n[T.id]==null?0:n[T.id];n[T.id]=Math.max(v+1,S),s[T.id]=T}}const d={};for(const b in n){const v=n[b];v in d||(d[v]=[]),d[v].push(s[b])}const f={};for(const b in r){const v=r[b];v in f||(f[v]=[]),f[v].push(i[b])}let p=Object.keys(f).map(b=>parseInt(b,10)).sort(Vp);this.layers=[];for(const b of p){const v=f[b];v.sort((y,C)=>{const I=o[y.id],$=o[C.id];return I<$?-1:I>$?1:0});for(const y of v)y instanceof Ti&&this.internalContainerRefs.push(y),this.layers.push(y)}this.layersByDepth=f,p=Object.keys(d).map(b=>parseInt(b,10)).sort(Vp);const g=this.inputs.slice(),m=[];for(const b of p)for(const v of d[b]){const y=v.outboundLayer;if(y!=null){for(const C of v.inputTensors)if(g.indexOf(C)===-1)throw new Gr(`Graph disconnected: cannot obtain value for tensor ${C} at layer "${y.name}". The following previous layers were accessed without issue: ${m}`);for(const C of v.outputTensors)g.push(C);m.push(y.name)}}this.nodesByDepth=d;const x=this.layers.map(b=>b.name);for(const b of x){const v=x.filter(y=>y===b).length;if(v!==1)throw new Gr(`The name "${b}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(x))}this.outboundNodes=[],this.inboundNodes=[],new Sx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers)e.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)e.numDisposedVariables+=n.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(n=>{n._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new ee("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const n of this.layers)e=e.concat(n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.layers)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const s of this.layers)n.push(...s.trainableWeights);return n.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,n=!0){const s={};let r=0;const i=Are(e);i&&this.parseWeights(e);for(const a of this.layers)for(const[l,u]of a.weights.entries()){const c=i?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(s[c]!=null)throw new ee(`Duplicate weight name: ${c}`);s[c]=u,r++}const o=[];for(const a in e){let l=a;if(s[a]==null){const u=a.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(s[l]!=null)o.push([s[l],e[a]]);else if(n)throw new ee(`Provided weight data has no target variable: ${a}`);delete s[l]}if(n){const a=[];for(const l in s)a.push(l);if(a.length>0)throw new ee(`${a.length} of ${r} weights are not set: ${a}`)}N2(o)}parseWeights(e){for(const n in Object.keys(e)){const s=n.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!r.includes(o)).join("/");i!==n&&(e[i]=e[n],delete e[n])}}updatedConfig(){const e=this.getConfig(),n={};return n.className=this.getClassName(),n.config=e,n.kerasVersion=`tfjs-layers ${yR}`,n.backend="TensorFlow.js",n}toJSON(e,n=!0){const s=ry(this.updatedConfig());return n?JSON.stringify(s):s}call(e,n){return de(()=>{e=Xt(e);const s=new Zo;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return Lh(this.outputs,s,n)})}computeMask(e,n){return de(()=>{e=Xt(e);let s;return n==null?s=yl(null,e.length):s=Xt(n),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const n=sg(e);if(n.length!==this.inputLayers.length)throw new ee(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<n.length;a++){const l=this.inputLayers[a],u=n[a],c=l.name+"_0_0";s[c]=u}const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Vp);if(r.length>1)for(const a of r){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(c.id)!==-1)continue;const h=[];for(let g=0;g<u.inboundLayers.length;g++){const m=u.inboundLayers[g],x=u.nodeIndices[g],b=u.tensorIndices[g],v=`${m.name}_${x}_${b}`,y=s[v];h.push(y)}const d=c.computeOutputShape(Xs(h)),f=sg(d),p=c.inboundNodes.indexOf(u);for(let g=0;g<f.length;g++){const m=`${c.name}_${p}_${g}`;s[m]=f[g]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],h=`${l.name}_${u}_${c}`;o.push(h)}for(let a=0;a<o.length;a++){const l=o[a];Pi(l in s),i.push(s[l])}return Xs(i)}runInternalGraph(e,n){n==null&&(n=yl(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=e[l],h=n[l];s[u.id]=[c,h]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Vp);for(const l of r){const u=this.nodesByDepth[l];for(const c of u){const h=c.outboundLayer,d=c.inputTensors,f=c.outputTensors,p=new Array;for(const g of d)g.id in s&&p.push(s[g.id]);if(p.length===d.length){let g={},m,x,b,v;if(c.callArgs!=null&&(g=c.callArgs),p.length===1){const[y,C]=p[0];g.mask==null&&(g.mask=C),b=Xt(h.call(y,g)),v=Xt(h.computeMask(y,C)),m=[y],x=[C]}else m=p.map(y=>y[0]),x=p.map(y=>y[1]),g.mask==null&&(g.mask=x),b=Xt(h.call(m,g)),v=Xt(h.computeMask(m,x));if(h.activityRegularizer)throw new Et("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let y=0;y<f.length;++y){const C=f[y],I=b[y],$=v[y];s[C.id]=[I,$]}}}}const i=[],o=[],a=[];for(const l of this.outputs){Pi(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=s[l.id];a.push(u.shape),i.push(u),o.push(c)}return[i,o,a]}buildNodeConversionMap(e){const n={};let s;for(const r of this.layers){s=r instanceof Ti?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=Ti.nodeKey(r,i);this.containerNodes.has(o)&&(n[o]=s,s+=1)}}return n}getLayer(e,n){if(n!=null)return this.findLayer(n);if(e==null)throw new ee("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new ee(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new ee(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return de(()=>{const e=[];for(const n of this.layers)for(let s=0;s<n.inboundNodes.length;++s){const r=Ti.nodeKey(n,s);this.containerNodes.has(r)&&e.push(...n.calculateLosses())}return e})}getConfig(){const e={name:this.name},n=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),u=[];for(let h=0;h<o.inboundNodes.length;h++){const d=o.inboundNodes[h],f=Ti.nodeKey(o,h);let p={};if(this.containerNodes.has(f)){if(d.callArgs)try{JSON.stringify(d.callArgs),p=d.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(d.inboundLayers.length>0){const g=[];for(let m=0;m<d.inboundLayers.length;m++){const x=d.inboundLayers[m],b=d.nodeIndices[m],v=d.tensorIndices[m],y=Ti.nodeKey(x,b);let C=n[y];C==null&&(C=0),g.push([x.name,C,v,p])}u.push(g)}}}const c={};c.name=o.name,c.className=a,c.config=l,c.inboundNodes=u,s.push(c)}e.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],u=Ti.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const h=this.inputLayersTensorIndices[o];r.push([a.name,c,h])}e.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],u=Ti.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const h=this.outputLayersTensorIndices[o];i.push([a.name,c,h])}return e.outputLayers=i,e}static fromConfig(e,n,s={},r=!1){const i={},o={};function a(m,x){m.name in o?o[m.name].push(x):o[m.name]=[x]}function l(m,x){const b=[];let v;for(const y of x){const C=y[0],I=y[1],$=y[2];if(v=y[3]==null?{}:y[3],!(C in i)){a(m,x);return}const T=i[C];if(T.inboundNodes.length<=I){a(m,x);return}const S=T.inboundNodes[I];b.push(S.outputTensors[$])}b.length>0&&m.apply(Xs(b),v)}function u(m){const x=m.name,b=wo(m,n.customObjects!=null?n.customObjects:{});b.setFastWeightInitDuringBuild(r),i[x]=b,m.inboundNodes.forEach(y=>{if(!(y instanceof Array))throw new ee(`Corrupted configuration, expected array for nodeData: ${y}`);a(b,y)})}const c=n.name,h=n.layers;for(const m of h)u(m);for(;!mse(o);)for(const m of h){const x=i[m.name];if(x.name in o){const b=o[x.name];delete o[x.name];for(const v of b)l(x,v)}}const d=[],f=[],p=n.inputLayers;for(const m of p){const x=m[0],b=m[1],v=m[2];Pi(x in i);const C=i[x].inboundNodes[b].outputTensors;d.push(C[v])}const g=n.outputLayers;for(const m of g){const x=m[0],b=m[1],v=m[2];Pi(x in i);const C=i[x].inboundNodes[b].outputTensors;f.push(C[v])}return new e({inputs:d,outputs:f,name:c})}get stateful(){if(this._stateful)throw new ee("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){de(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Dre(t,e,n){const s=e.length;if(t==null||Array.isArray(t)&&t.length===0)return e.map(r=>null);if(s===1)return Array.isArray(t)&&t.length===1?t:typeof t=="object"&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==s)throw new Error(`Provided ${n} is an array of ${t.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return t}else if(typeof t=="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]=="object"){const r=[];return e.forEach(i=>{i in t?r.push(t[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${n} must be either an array with ${s} elements or an object with ${e} keys. Provided ${n} not understood: ${JSON.stringify(t)}`)}function vR(t,e){return Dre(t,e,"classWeight")}async function wR(t,e,n,s){if(n!=null){const r=de(()=>{if(t.shape.length===1)return il(t);if(t.shape.length===2){if(t.shape[1]>1)return Cd(t,1);if(t.shape[1]===1)return ie(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());At(r);const o=[];return i.forEach(a=>{if(n[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(n[a])}),cr(o,"float32")}else return null}function Nre(t,e){return te(t,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Mre=32;function SR(t,e){let n,s;const r=e;n=r.xs,s=r.ys,G(n!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=QC("input",t.inputNames,n),o=QC("output",t.outputNames,s),a=i[0].shape[0];G(i.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),G(o.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<i.length;l++)G(i[l].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let l=0;l<o.length;l++)G(o[l].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:i,ys:o}}function QC(t,e,n){if(n instanceof Qn)return[n];if(Array.isArray(n))return G(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const s=[];for(const r of e){if(n[r]==null)throw new ee(`The feature data generated by the dataset lacks the required ${t} key '${r}'.`);s.push(n[r])}return s}}function Lre(t){if(t.length===3)throw new Et("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}async function Ore(t,e,n){const s=n.batchesPerEpoch!=null;if(G(t.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),G(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),G(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),G(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),G(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const r=n.validationData!=null;let i,o;if(r)if(JC(n.validationData))G(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const m=Lre(n.validationData);i=m.xs,o=m.ys}const a=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;r?u=l.slice().concat(l.map(m=>"val_"+m)):u=l.slice();const c=hR(n.callbacks,n.yieldEvery),h=n.verbose==null?1:n.verbose,{callbackList:d,history:f}=dR(c,h,n.epochs,null,null,Fre(e,n),null,r,u);d.setModel(t),t.history=f,await d.onTrainBegin(),t.stopTraining_=!1;let p=n.initialEpoch==null?0:n.initialEpoch,g=await e.iterator();for(;p<n.epochs;){const m={};await d.onEpochBegin(p);let x=0,b=0;for(s||(g=await e.iterator());!s||x<n.batchesPerEpoch;){const v=await g.next();if(s&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${x} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(v.value!=null){const{xs:y,ys:C}=SR(t,v.value),I={};I.batch=b,I.size=y[0].shape[0],await d.onBatchBegin(b,I);const $=[];if(n.classWeight!=null){const E=vR(n.classWeight,t.outputNames);for(let _=0;_<E.length;++_)$.push(await wR(C[_],null,E[_]))}const T=y.concat(C).concat($),S=a(T);At(T);for(let E=0;E<l.length;++E){const _=l[E],N=S[E];I[_]=N,Gi(N)}await d.onBatchEnd(b,I),cR(I),b++,x++}if(s?x>=n.batchesPerEpoch:v.done){if(r){let y;JC(n.validationData)?y=Xt(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):y=Xt(t.evaluate(i,o,{batchSize:n.validationBatchSize==null?Mre:n.validationBatchSize,verbose:0}));for(let C=0;C<t.metricsNames.length;++C)m[`val_${t.metricsNames[C]}`]=y[C]}break}if(t.stopTraining_)break}if(await d.onEpochEnd(p,m),p++,t.stopTraining_)break}return await d.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function Fre(t,e){let n=null;return e.batchesPerEpoch!=null?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}function JC(t){return typeof t.iterator=="function"}function Ure(t){return typeof t.next=="function"}async function Bre(t,e,n){n=n||{};const s=n.batches!=null,r=t.testFunction;let i=[];if(n.verbose>0)throw new Et("Verbose mode is not implemented yet.");G(!s||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const o=Ure(e)?e:await e.iterator();let a=0,l=0;for(;!s||l<n.batches;){const u=await o.next();if(i=de(()=>{if(u.value){const{xs:c,ys:h}=SR(t,u.value),d=c.concat(h),f=de(()=>r(d));if(At(d),l===0)for(let g=0;g<f.length;++g)i.push(Ht(0));const p=d[0].shape[0];for(let g=0;g<f.length;++g){const m=f[g],x=i[g];i[g]=de(()=>Me(i[g],te(p,m))),l>0&&At(x)}At(f),a+=p,++l}return i}),u.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<i.length;++u){const c=i[u];i[u]=ct(i[u],a),At(c)}return Xs(i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ob(t){G(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function wh(t,e,n){return t==null?[null]:Array.isArray(t)?t.map(s=>al(s,e,n-e)):al(t,e,n-e)}function iy(t,e){return de(()=>t==null?null:Array.isArray(t)?t.map(n=>iy(n,e)):Y$(t,e.dtype==="int32"?e:Ze(e,"int32")))}function Fb(t,e){const n=[];let s=0,r=null;for(;s<t;)r=s+e,r>=t&&(r=t),n.push([s,r]),s=r;return n}function CR(t){const e=[];t instanceof Qn&&(t=[t]);for(let n=0;n<t.length;++n){const s=t[n];if(s.rank===1)e.push(rp(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function Zr(t,e){if(t==null)return;const n=[];if(e instanceof Qn)n.push(e.id);else if(Array.isArray(e))e.forEach(r=>n.push(r.id));else if(e!=null)for(const r in e){const i=e[r];n.push(i.id)}const s=[];if(t instanceof Qn)n.indexOf(t.id)===-1&&s.push(t);else if(Array.isArray(t))t.forEach(r=>{n.indexOf(r.id)===-1&&s.push(r)});else if(t!=null)for(const r in t){const i=t[r];n.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zre(t){return t instanceof Qn}function oy(t){return Array.isArray(t)}function e3(t){return!zre(t)&&!oy(t)}function t3(t,e,n,s=!0,r=""){if(e==null||e.length===0){if(t!=null){let o=!1;if(oy(t)&&t.length>0)o=!0;else if(e3(t)){for(const a in t)if(t.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new ee(`Error when checking model ${r} expected no data, but got ${t}`)}return[]}if(t==null)return e.map(o=>null);let i;if(e3(t)){t=t,i=[];for(const o of e){if(t[o]==null)throw new ee(`No data provided for "${o}". Need data for each key in: ${e}`);i.push(t[o])}}else if(oy(t)){if(t=t,t.length!==e.length)throw new ee(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);i=t}else{if(t=t,e.length>1)throw new ee(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);i=[t]}if(i=CR(i),n!=null)for(let o=0;o<e.length;++o){if(n[o]==null)continue;const a=i[o];if(a.shape.length!==n[o].length)throw new ee(`Error when checking ${r}: expected ${e[o]} to have ${n[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<n[o].length;++l){if(l===0&&!s)continue;const u=a.shape[l],c=n[o][l];if(c!=null&&c>=0&&u!==c)throw new ee(`${r} expected a batch of elements where each example has shape [${n[o].slice(1,n[o].length)}] (i.e.,tensor shape [*,${n[o].slice(1,n[o].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function Gre(t,e,n){const s=sa(t.map(i=>i.shape[0]));s.sort();const r=sa(e.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new ee(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(r.length>1)throw new ee(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!Pt(s,r))throw new ee(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function Vre(t,e,n){const s=[Cx,Tx,$d];for(let r=0;r<t.length;++r){const i=t[r],o=e[r],a=n[r];if(o!=null){if(o===$d&&i.shape[i.shape.length-1]===1)throw new ee(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const l=i.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const h=l[c],d=u[c];if(d!=null&&h!==d)throw new ee(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function n3(t,e,n,s=!0,r=""){let i;if(Array.isArray(t)){if(t.length!==e.length)throw new ee(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);i=t}else{if(e.length>1)throw new ee(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);i=[t]}if(n!=null)for(let o=0;o<e.length;++o){if(n[o]==null)continue;const a=i[o];if(a.shape.length!==n[o].length)throw new ee(`Error when checking ${r}: expected ${e[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<n[o].length;++l){if(l===0&&!s)continue;const u=a.shape[l],c=n[o][l];if(c!=null&&c!==u)throw new ee(`Error when checking ${r}: expected ${e[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function Wre(t,e){if(t==null||Array.isArray(t)&&t.length===0)return e.map(s=>[]);let n;if(typeof t=="string"||typeof t=="function")n=[t];else if(Array.isArray(t)||typeof t=="object")n=t;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);if(Array.isArray(n))return e.map(s=>n);{const s=[];for(const r of e){let i=n.hasOwnProperty(r)?n[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const Hre="layers-model";class Pu extends Pre{constructor(e){super(e),this.isTraining=!1}summary(e,n,s=console.log){if(!this.built)throw new ee("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");kre(this,e,n,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Ire(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof ya))throw new ee("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new ee(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),n.push(Lb(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ee(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);n=e.loss.map(a=>Lb(a))}else{const o=Lb(e.loss);this.outputs.forEach(a=>{n.push(o)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ol("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=Wre(e.metrics,this.outputNames),i=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};ol("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=r[o];(u=>{const c="";let h,d,f;for(const p of u){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){const m=this.internalOutputShapes[o];m[m.length-1]===1||this.lossFunctions[o]===Tx?["accuracy","acc"].indexOf(p)!==-1?d=pR:["crossentropy","ce"].indexOf(p)!==-1&&(d=mre):this.lossFunctions[o]===lg?["accuracy","acc"].indexOf(p)!==-1?d=gre:["crossentropy","ce"].indexOf(p)!==-1&&(d=xR):["accuracy","acc"].indexOf(p)!==-1?d=mR:["crossentropy","ce"].indexOf(p)!==-1&&(d=gR);let x;["accuracy","acc"].indexOf(p)!==-1?x="acc":["crossentropy","ce"].indexOf(p)!==-1&&(x="ce"),f=d,h=c+x}else f=Tre(p),h=c+Kp(p);let g;ol(h,()=>{g=f}),i(o,h,g)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,n,s={}){const r=s.batchSize==null?32:s.batchSize;Ob(r);const o=this.standardizeUserDataXY(e,n,!0,r);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,a,r,s.verbose,s.steps);return Xs(u)}finally{Zr(o[0],e),Zr(o[1],n)}}async evaluateDataset(e,n){return this.makeTestFunction(),Bre(this,e,n)}checkNumSamples(e,n,s,r="steps"){let i;if(s!=null){if(i=null,n!=null)throw new ee(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new ee(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(e,n){if(Array.isArray(n)&&n.length===0)throw new ee("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(n),r=s?n:[n],i=this.retrieveSymbolicTensors(r),o=new Zo;if(e instanceof Qn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ee(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const u=e[l.name];if(u==null)throw new ee(`No value is provided for the model's input ${l.name}`);o.add(l,u)}const a=Lh(i,o);return s?a:a[0]}retrieveSymbolicTensors(e){const n=yl(null,e.length);let s=e.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],o=i.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(n[a]=i[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw n.forEach((i,o)=>{i==null&&r.push(e[o])}),new ee(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return n}predictLoop(e,n=32,s=!1){return de(()=>{const r=this.checkNumSamples(e);if(s)throw new Et("Verbose predictLoop() is not implemented yet.");const i=Fb(r,n),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)de(()=>{const u=i[a][0],c=i[a][1],h=wh(e,u,c),d=[];if(Array.isArray(h))for(let p=0;p<h.length;++p)d.push({key:this.inputs[p],value:h[p]});else d.push({key:this.inputs[0],value:h});const f=new Zo(d);return Lh(this.outputs,f)}).forEach((u,c)=>o[c].push(u));return Xs(o.map(a=>Ys(a,0)))})}predict(e,n={}){const s=CR(e);n3(s,this.inputNames,this.feedInputShapes,!1);try{const r=n.batchSize==null?32:n.batchSize;return Ob(r),this.predictLoop(s,r)}finally{Zr(s,e)}}predictOnBatch(e){n3(e,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,n)}standardizeUserDataXY(e,n,s=!0,r){if(this.optimizer_==null)throw new Gr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===lg?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(e=t3(e,this.feedInputNames,this.feedInputShapes,!1,"input"),n=t3(n,this.feedOutputNames,i,!1,"target"),Gre(e,n),Vre(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new ee(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,n]}async standardizeUserData(e,n,s,r,i=!0,o){const[a,l]=this.standardizeUserDataXY(e,n,i,o);if(s!=null)throw new Error("sample weight is not supported yet.");let u=null;if(r!=null){const c=vR(r,this.outputNames);u=[];for(let h=0;h<c.length;++h)u.push(await wR(l[h],null,c[h]))}return[a,l,u]}testLoop(e,n,s,r=0,i){return de(()=>{const o=this.checkNumSamples(n,s,i,"steps"),a=[];if(r>0)throw new Et("Verbose mode is not implemented yet.");if(i!=null)throw new Et("steps mode in testLoop() is not implemented yet");{const l=Fb(o,s),u=cr(hi(0,o));for(let c=0;c<l.length;++c){const h=l[c][0],d=l[c][1],f=al(u,h,d-h),p=iy(n,f),g=e(p);if(c===0)for(let m=0;m<g.length;++m)a.push(Ht(0));for(let m=0;m<g.length;++m){const x=g[m];a[m]=Me(a[m],te(d-h,x))}}for(let c=0;c<a.length;++c)a[c]=ct(a[c],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,n=[];for(let s=0;s<e.length;++s){const r=e[s];let i=r;if(BC(e,r)>1){const o=BC(e.slice(0,s),r);i+=`_${o}`}n.push(i)}return n}makeTrainFunction(){return e=>{const n=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const d=new Zo(h),f=Lh(this.outputs,d,{training:!0});let p;for(let g=0;g<this.lossFunctions.length;++g){const m=this.lossFunctions[g];let x=m(r[g],f[g]);i[g]!=null&&(x=Nre(x,i[g]));const b=Hn(x);n.push(b),g===0?p=x:p=Me(p,x)}for(let g=0;g<this.metricsTensors.length;++g){let m;if(this.outputs.length>1&&g<this.outputs.length)m=n[g];else{const x=this.metricsTensors[g][0],b=this.metricsTensors[g][1];m=Hn(x(r[b],f[b]))}Gi(m),o.push(m)}return p=Hn(p),this.calculateLosses().forEach(g=>{p=Me(p,g)}),p},l=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(a,!0,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>de(()=>{const n=[];let s;const r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let u=0;u<this.inputs.length;++u)o.push({key:this.inputs[u],value:r[u]});const a=new Zo(o),l=Lh(this.outputs,a);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],h=Hn(c(i[u],l[u]));u===0?s=h:s=Me(s,h),n.push(s)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],h=this.metricsTensors[u][1],d=Hn(c(i[h],l[h]));n.push(d)}return n})}async fit(e,n,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,o,a,l,u,c,h,d;try{const f=s.batchSize==null?32:s.batchSize;Ob(f);const g=await this.standardizeUserData(e,n,s.sampleWeight,s.classWeight,!1,f);r=g[0],i=g[1],d=g[2];let m=!1,x;if(s.validationData!=null&&s.validationData.length>0){if(m=!0,s.validationData.length===2)l=s.validationData[0],u=s.validationData[1];else throw s.validationData.length===3?new Et("validationData including sample weights is not supported yet."):new ee(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const E=await this.standardizeUserData(l,u,null,null,!0,f);c=E[0],h=E[1],x=c.concat(h)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){m=!0;const S=Math.floor(r[0].shape[0]*(1-s.validationSplit)),E=r[0].shape[0];c=wh(r,S,E),o=r,r=wh(r,0,S),h=wh(i,S,E),a=i,i=wh(i,0,S),x=c.concat(h)}else s.validationSteps!=null&&(m=!0);const b=r.concat(i).concat(d);this.checkTrainableWeightsConsistency();const v=this.makeTrainFunction(),y=this.getDedupedMetricsNames();let C,I;m?(this.makeTestFunction(),C=this.testFunction,I=y.slice().concat(y.map(S=>"val_"+S))):(C=null,x=[],I=y.slice());const $=hR(s.callbacks,s.yieldEvery);return await this.fitLoop(v,b,y,f,s.epochs,s.verbose,$,C,x,s.shuffle,I,s.initialEpoch,null,null)}finally{this.isTraining=!1,Zr(r,e),Zr(i,n),Zr(o,e),Zr(a,n),Zr(c,l),Zr(h,u),d!=null&&At(d)}}async fitLoop(e,n,s,r,i,o,a,l,u,c,h,d,f,p){r==null&&(r=32),i==null&&(i=1),c==null&&(c=!0),d==null&&(d=0);let g=!1;if(l!=null&&u!=null&&(g=!0),p!=null&&(g=!0,f==null))throw new ee("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(n,r,f,"steps_per_epoch");let x;m!=null&&(x=hi(0,m)),o==null&&(o=1);const{callbackList:b,history:v}=dR(a,o,i,d,m,f,r,g,h);b.setModel(this),this.history=v,await b.onTrainBegin(),this.stopTraining_=!1;for(let y=d;y<i;++y){await b.onEpochBegin(y);const C={};if(f!=null)throw new Et("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Et("batch shuffling is not implemneted yet");c&&PX(x);const I=cr(x),$=Fb(m,r);for(let T=0;T<$.length;++T){const S={};if(await b.onBatchBegin(T,S),de(()=>{const E=$[T][0],_=$[T][1],N=al(I,E,_-E);S.batch=T,S.size=_-E;const P=iy(n,N),M=e(P);for(let z=0;z<s.length;++z){const A=s[z],B=M[z];S[A]=B,Gi(B)}if(T===$.length-1&&g){const z=this.testLoop(l,u,r);for(let A=0;A<s.length;++A){const B=s[A],L=z[A];Gi(L),C["val_"+B]=L}}}),await b.onBatchEnd(T,S),cR(S),this.stopTraining_)break}I.dispose()}if(await b.onEpochEnd(y,C),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,n){return Ore(this,e,n)}async trainOnBatch(e,n){const s=await this.standardizeUserData(e,n),r=s[0],i=s[1],a=this.makeTrainFunction()(r.concat(i)),l=[];for(const u of a){const c=await u.data();l.push(c[0])}return At(a),Zr(s[0],e),Zr(s[1],n),Xs(l)}getNamedWeights(e){const n=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let o=0;o<r.length;++o)s&&!r[o].trainable||n.push({name:r[o].originalName,tensor:i[o]});return n}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=SC().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=n-SC().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=fo(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(n=>fo(n))}else{const n=Object.keys(this.loss);e={};const s=this.loss;for(const r of n)if(typeof s[r]=="string")e[r]=fo(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[fo(Kp(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>fo(Kp(e)));{const e={};for(const n in this.metrics)e[n]=fo(Kp(this.metrics[n]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=sy(e.optimizer_config),s=wo(n);let r;if(typeof e.loss=="string")r=Ha(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(o=>Ha(o));else if(e.loss!=null){r={};for(const o in e.loss)r[o]=Ha(e.loss[o])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(o=>Ha(o));else if(e.metrics!=null){i={};for(const o in e.metrics)i[o]=Ha(e.metrics[o])}this.compile({loss:r,metrics:i,optimizer:s})}async save(e,n){if(typeof e=="string"){const u=Tq(e);if(u.length===0)throw new ee(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new ee(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new ee("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await TC(this.getNamedWeights(n)),a={modelTopology:this.toJSON(null,!1),format:Hre,generatedBy:`TensorFlow.js tfjs-layers v${yR}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:h}=await TC(await this.optimizer.getWeights(),u);s.specs.push(...h),s.data=Cq([s.data,c])}return this.userDefinedMetadata!=null&&(ZC(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,e.save(a)}setUserDefinedMetadata(e){ZC(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Pu.className="Model";$e(Pu);class TR extends Pu{}TR.className="Functional";$e(TR);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Rd extends Pu{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:vx("sequential_"),e.layers!=null)for(const n of e.layers)this.add(n)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new ee(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const n=e instanceof Rd||e instanceof Pu;let s;if(n){if(s=e,s.outputs.length!==1)throw new ee("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new ee("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new ee("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=Kse({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(n)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new ee(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new ee("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=iR(this.outputs[0])}this.inboundNodes=[],new Sx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:yl(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,n){return this.model==null&&this.build(),this.model.call(e,n)}build(e){if(Vt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Pu({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,n,s=console.log){this.built||this.build(),super.summary(e,n,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,n,s={}){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.evaluate(e,n,s)}async evaluateDataset(e,n){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,n)}predict(e,n={}){return this.model==null&&this.build(),this.model.predict(e,n)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,n,s={}){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.fit(e,n,s)}async fitDataset(e,n){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.fitDataset(e,n)}async trainOnBatch(e,n){return this.model.trainOnBatch(e,n)}static fromConfig(e,n,s={},r=!1){let i,o={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new ee("Legacy serialization format not supported yet.");i=n}else G(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=n.layers,delete n.layers,o=n;const a=new e(o);if(!(a instanceof Rd))throw new Et(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of i){const c=wo(l,void 0,r);r&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(e){if(this.model==null)throw new ee("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new ee("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const n of this.layers){const s={};s.className=n.getClassName(),s.config=n.getConfig(),e.push(s)}return{name:this.name,layers:e}}}Rd.className="Sequential";$e(Rd);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Es=class extends th{getConfig(){return{}}};class IR extends Es{apply(e,n=1){return Rse(e,n)}}IR.className="elu";$e(IR);class kR extends Es{apply(e){return W_(e)}}kR.className="selu";$e(kR);class ER extends Es{apply(e){return Nl(e)}}ER.className="relu";$e(ER);class _R extends Es{apply(e){return de(()=>kd(6,Nl(e)))}}_R.className="relu6";$e(_R);class $R extends Es{apply(e){return e}}$R.className="linear";$e($R);class RR extends Es{apply(e){return Qc(e)}}RR.className="sigmoid";$e(RR);class AR extends Es{apply(e){return Pse(e)}}AR.className="hardSigmoid";$e(AR);class PR extends Es{apply(e){return Yf(e)}}PR.className="softplus";$e(PR);class DR extends Es{apply(e){return Ase(e)}}DR.className="softsign";$e(DR);class NR extends Es{apply(e){return W0(e)}}NR.className="tanh";$e(NR);let F2=class extends Es{apply(e,n=-1){return u2(e,n)}};F2.className="softmax";$e(F2);class MR extends Es{apply(e,n=-1){return M_(e,n)}}MR.className="logSoftmax";$e(MR);class LR extends Es{apply(e){return de(()=>de(()=>{const n=Math.sqrt(2),s=te(.5,Me(1,A_(ct(e,n))));return te(e,s)}))}}LR.className="gelu";$e(LR);class OR extends Es{apply(e){return de(()=>te(.5,te(e,Me(1,W0(te(Is(ct(2,Math.PI)),Me(e,te(.044715,gl(e,3)))))))))}}OR.className="gelu_new";$e(OR);class FR extends Es{apply(e){return de(()=>te(e,W0(Yf(e))))}}FR.className="mish";$e(FR);class UR extends Es{apply(e,n=1){return de(()=>te(Qc(te(e,n)),e))}}UR.className="swish";$e(UR);function la(t){return t.getClassName()}function Ub(t,e={}){return sp(t,Or.getMap().classNameMap,e,"activation")}function ua(t){if(t==null){const e={};return e.className="linear",e.config={},Ub(e)}if(typeof t=="string"){const e={};return e.className=t,e.config={},Ub(e)}else return t instanceof Es?t:Ub(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Kre(t){if(t!=null&&typeof t!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}class BR extends th{}class zR extends BR{constructor(e){super(),Kre(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return de(()=>{let n=Jn([1]);return this.hasL1&&(n=Me(n,ut(te(this.l1,As(e))))),this.hasL2&&(n=Me(n,ut(te(this.l2,ip(e))))),ie(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,n){return new e({l1:n.l1,l2:n.l2})}}zR.className="L1L2";$e(zR);const s3={l1l2:"L1L2"};function en(t){return T2(t)}function r3(t,e={}){return sp(t,Or.getMap().classNameMap,e,"regularizer")}function vn(t){if(t==null)return null;if(typeof t=="string"){const n={className:t in s3?s3[t]:t,config:{}};return r3(n)}else return t instanceof BR?t:r3(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class GR extends Rt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,n){e=bt(e);let s=Nl(e);return this.maxValue!=null&&(s=Ir(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},n=super.getConfig();return Object.assign(e,n),e}}GR.className="ReLU";$e(GR);class VR extends Rt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const s=bt(e);return jv(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}}VR.className="LeakyReLU";$e(VR);class WR extends Rt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=yn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=vn(e.alphaRegularizer),this.alphaConstraint=ss(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new ee(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Vt(e);const n=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)n[r-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new ts({ndim:e.length,axes:s})],this.built=!0}call(e,n){return e=bt(e),Jv(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Cn(this.alphaInitializer),alphaRegularizer:en(this.alphaRegularizer),alphaConstraint:ns(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(e,n),e}}WR.className="PReLU";$e(WR);let HR=class extends Rt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Et(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const s=bt(e);return j0(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}};HR.className="ELU";$e(HR);class KR extends Rt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,n){const s=bt(e);return te(s,Ze(_r(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},n=super.getConfig();return Object.assign(e,n),e}}KR.className="ThresholdedReLU";$e(KR);class jR extends Rt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new F2().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,n){return de(()=>{let s=bt(e);const r=n.mask;if(r!=null){const i=te(mt(ba(s.shape),Ze(r,s.dtype)),Ht(-1e9));s=Me(s,i)}return this.axis instanceof Array?this.axis.length>1?Ki(mt(s,L_(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}jR.className="Softmax";$e(jR);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Du(t,e,n){if(typeof t=="number")return yl(t,e);if(t.length!==e)throw new ee(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let s=0;s<e;++s){const r=t[s];if(!kse(r))throw new ee(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${r}`)}return t}function ri(t,e,n,s,r=1){if(t==null)return t;const i=e+(e-1)*(r-1);let o;return n==="same"?o=t:o=t-i+1,Math.floor((o+s-1)/s)}function Di(t,e,n,s){if(t==null)return null;if(s==="valid")t=t*e+aa([n-e,0]);else if(s==="same")t=t*e;else throw new ee(`Unsupport padding mode: ${s}.`);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function U2(t,e){return de(()=>(Vn(e),e==="channelsFirst"?Ot(t,[0,2,3,1]):t))}function XR(t,e){return de(()=>(Vn(e),e==="channelsFirst"?Ot(t,[0,2,3,4,1]):t))}function jre(t,e,n,s=1,r="valid",i,o=1){return de(()=>{if(i==null&&(i=di()),Vn(i),t.shape.length!==3)throw new ee(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(e.shape.length!==3)throw new ee(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new ee(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(i==="channelsFirst"&&(t=Ot(t,[0,2,1])),r==="causal")throw new Et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=k_(t,e,s,r==="same"?"same":"valid","NWC",o);return n!=null&&(a=xi(a,n)),a})}function i3(t,e,n,s=[1,1],r="valid",i,o,a=null){return de(()=>{if(i==null&&(i=di()),Vn(i),t.rank!==3&&t.rank!==4)throw new ee(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(e.rank!==3&&e.rank!==4)throw new ee(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=U2(t,i);if(r==="causal")throw new Et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=tee({x:l,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:a}),i==="channelsFirst"&&(l=Ot(l,[0,3,1,2])),l})}function Xre(t,e,n,s=[1,1,1],r="valid",i,o){return de(()=>{if(i==null&&(i=di()),Vn(i),t.rank!==4&&t.rank!==5)throw new ee(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(e.rank!==4&&e.rank!==5)throw new ee(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=XR(t,i);if(r==="causal")throw new Et("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=eZ(a,e,s,r==="same"?"same":"valid","NDHWC",o),n!=null&&(a=xi(a,n)),i==="channelsFirst"&&(a=Ot(a,[0,4,1,2,3])),a})}class Ix extends Rt{constructor(e,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Ix.verifyArgs(n),this.rank=e,us(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Et(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Du(n.kernelSize,e,"kernelSize"),this.strides=Du(n.strides==null?1:n.strides,e,"strides"),this.padding=n.padding==null?"valid":n.padding,$r(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Vn(this.dataFormat),this.activation=ua(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=yn(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ss(n.biasConstraint),this.biasRegularizer=vn(n.biasRegularizer),this.activityRegularizer=vn(n.activityRegularizer),this.dilationRate=Du(n.dilationRate==null?1:n.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ee(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ee(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ee(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Pi("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!I2(e.kernelSize,"number",1,3))throw new ee(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:la(this.activation),useBias:this.useBias,biasInitializer:Cn(this.biasInitializer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),biasConstraint:ns(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}class nh extends Ix{constructor(e,n){super(e,n),this.kernel=null,nh.verifyArgs(n),this.filters=n.filters,us(this.filters,"filters"),this.kernelInitializer=yn(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ss(n.kernelConstraint),this.kernelRegularizer=vn(n.kernelRegularizer)}build(e){e=Vt(e);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new ee(`The channel dimension of the input should be defined. Found ${e[n]}`);const s=e[n],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:s}}],this.built=!0}call(e,n){return de(()=>{e=bt(e);let s;const r=this.bias==null?null:this.bias.read(),i=W$(this.activation.getClassName());if(i!=null&&this.rank===2)s=i3(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=jre(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=i3(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=Xre(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Et("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=Vt(e);const n=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<s.length;++i){const o=ri(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);n.push(o)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Cn(this.kernelInitializer),kernelRegularizer:en(this.kernelRegularizer),kernelConstraint:ns(this.kernelConstraint)},n=super.getConfig();return Object.assign(e,n),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new ee(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class up extends nh{constructor(e){super(2,e),up.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!I2(e.kernelSize,"number",1,2))throw new ee(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}up.className="Conv2D";$e(up);class cp extends nh{constructor(e){super(3,e),cp.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new ee(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}cp.className="Conv3D";$e(cp);class qR extends up{constructor(e){if(super(e),this.inputSpec=[new ts({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ee(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Vt(e),e.length!==4)throw new ee("Input should have rank 4; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new ee("The channel dimension of the inputs should be defined. Found `None`.");const s=e[n],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ts({ndim:4,axes:{[n]:s}})],this.built=!0}call(e,n){return de(()=>{let s=bt(e);if(s.shape.length!==4)throw new ee(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=r[o],u=r[a],c=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],f=this.strides[1],p=Di(l,d,c,this.padding),g=Di(u,f,h,this.padding),m=[i,p,g,this.filters];this.dataFormat!=="channelsLast"&&(s=Ot(s,[0,2,3,1]));let x=E_(s,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=Ot(x,[0,3,1,2])),this.bias!=null&&(x=xi(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(e){e=Vt(e);const n=e.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return n[s]=this.filters,n[r]=Di(n[r],l,o,this.padding),n[i]=Di(n[i],u,a,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}qR.className="Conv2DTranspose";$e(qR);class YR extends cp{constructor(e){if(super(e),this.inputSpec=[new ts({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ee(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Vt(e),e.length!==5)throw new ee("Input should have rank 5; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new ee("The channel dimension of the inputs should be defined. Found `None`.");const s=e[n],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ts({ndim:5,axes:{[n]:s}})],this.built=!0}call(e,n){return de(()=>{let s=bt(e);if(s.shape.length!==5)throw new ee(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const u=r[l],c=r[o],h=r[a],d=this.kernelSize[0],f=this.kernelSize[1],p=this.kernelSize[2],g=this.strides[0],m=this.strides[1],x=this.strides[2],b=Di(u,g,d,this.padding),v=Di(c,m,f,this.padding),y=Di(h,x,p,this.padding),C=[i,b,v,y,this.filters];this.dataFormat!=="channelsLast"&&(s=Ot(s,[0,2,3,4,1]));let I=sZ(s,this.kernel.read(),C,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(I=Ot(I,[0,4,1,2,3])),this.bias!==null&&(I=xi(I,this.bias.read(),this.dataFormat)),this.activation!==null&&(I=this.activation.apply(I)),I})}computeOutputShape(e){e=Vt(e);const n=e.slice();let s,r,i,o;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,o=4):(s=4,r=1,i=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],h=this.strides[1],d=this.strides[2];return n[s]=this.filters,n[r]=Di(n[r],c,a,this.padding),n[i]=Di(n[i],h,l,this.padding),n[o]=Di(n[o],d,u,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}YR.className="Conv3DTranspose";$e(YR);class ZR extends nh{constructor(e,n){if(super(e,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new ee("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new ee("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new ee(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=yn(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=vn(n.depthwiseRegularizer),this.depthwiseConstraint=ss(n.depthwiseConstraint),this.pointwiseInitializer=yn(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=vn(n.pointwiseRegularizer),this.pointwiseConstraint=ss(n.pointwiseConstraint)}build(e){if(e=Vt(e),e.length<this.rank+2)throw new ee(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null||e[n]<0)throw new ee(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[n])}`);const s=e[n],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new ts({ndim:this.rank+2,axes:{[n]:s}})],this.built=!0}call(e,n){return de(()=>{e=bt(e);let s;if(this.rank===1)throw new Et("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Ot(e,[0,2,3,1])),s=H_(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=xi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Ot(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Cn(this.depthwiseInitializer),e.pointwiseInitializer=Cn(this.pointwiseInitializer),e.depthwiseRegularizer=en(this.depthwiseRegularizer),e.pointwiseRegularizer=en(this.pointwiseRegularizer),e.depthwiseConstraint=ns(this.depthwiseConstraint),e.pointwiseConstraint=ns(this.pointwiseConstraint),e}}ZR.className="SeparableConv";class QR extends ZR{constructor(e){super(2,e)}}QR.className="SeparableConv2D";$e(QR);class kx extends nh{constructor(e){super(1,e),kx.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!I2(e.kernelSize,"number",1,1))throw new ee(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}kx.className="Conv1D";$e(kx);class JR extends Rt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,n){return de(()=>{if(e=bt(e),this.dataFormat==="channelsLast"){const s=Hp(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Hp(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Hp(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Hp(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}JR.className="Cropping2D";$e(JR);class eA extends Rt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,Cse(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const n=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],n,s]}else{const n=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],n,s,e[3]]}}call(e,n){return de(()=>{let s=bt(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=Ot(s,[0,2,3,1]);const i=this.size[0]*r[2],o=this.size[1]*r[3],a=this.interpolation==="nearest"?xo.resizeNearestNeighbor(s,[i,o]):xo.resizeBilinear(s,[i,o]);return Ot(a,[0,3,1,2])}else{const i=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?xo.resizeNearestNeighbor(s,[i,o]):xo.resizeBilinear(s,[i,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}}eA.className="UpSampling2D";$e(eA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qre(t,e,n=[1,1],s="valid",r,i){return de(()=>{r==null&&(r=di()),Vn(r);let o=U2(t,r);if(t.rank!==4)throw new ee(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(e.rank!==4)throw new ee(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=Gv(o,e,n,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(o=Ot(o,[0,3,1,2])),o})}class tA extends Ix{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=yn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ss(e.depthwiseConstraint),this.depthwiseRegularizer=vn(e.depthwiseRegularizer)}build(e){if(e=Vt(e),e.length<4)throw new ee(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(e[n]==null||e[n]<0)throw new ee(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[n]}).`);const s=e[n],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return de(()=>{e=bt(e);let s=qre(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=xi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Vt(e);const n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=ri(n,this.kernelSize[0],this.padding,this.strides[0]),o=ri(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,i,o]:[e[0],i,o,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Cn(this.depthwiseInitializer),e.depthwiseRegularizer=en(this.depthwiseRegularizer),e.depthwiseConstraint=ns(this.depthwiseRegularizer),e}}tA.className="DepthwiseConv2D";$e(tA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nA(t,e,n,s){if(Array.isArray(t)){if(e!=null||n!=null)throw new ee("When inputs is an array, neither initialState or constants should be provided");s!=null&&(n=t.slice(t.length-s,t.length),t=t.slice(0,t.length-s)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return e=r(e),n=r(n),{inputs:t,initialState:e,constants:n}}function sA(t,e,n,s=!1,r,i,o=!1,a=!1){return de(()=>{const l=e.shape.length;if(l<3)throw new ee(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(hi(2,l));e=Ot(e,u),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Ze(Ze(r,"bool"),"float32"),r.rank===l-1&&(r=js(r,-1)),r=Ot(r,u)),s&&(e=xl(e,0),r!=null&&(r=xl(r,0)));const c=[];let h,d=n;const f=e.shape[0],p=bl(e);let g;r!=null&&(g=bl(r));for(let x=0;x<f;++x){const b=p[x],v=de(()=>t(b,d));if(r==null)h=v[0],d=v[1];else{const y=de(()=>{const C=g[x],I=mt(jr(C),C),$=Me(te(v[0],C),te(d[0],I)),T=d.map((S,E)=>Me(te(v[1][E],C),te(S,I)));return{output:$,newStates:T}});h=y.output,d=y.newStates}a&&c.push(h)}let m;return a&&(m=$o(c,1)),[h,m,d]})}class va extends Rt{constructor(e){super(e);let n;if(e.cell==null)throw new ee("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?n=new G2({cells:e.cell}):n=e.cell,n.stateSize==null)throw new ee("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new ts({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return hi(0,e).map(n=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){ey(e)&&(e=e[0]),e=e;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const s=n[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const i=[];for(const o of n)i.push([e[0],o]);return[r].concat(i)}else return r}computeMask(e,n){return de(()=>{Array.isArray(n)&&(n=n[0]);const s=this.returnSequences?n:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let s=0;s<e;++s)n.push(null);return n}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Et("Constants support is not implemented in RNN yet.");ey(e)&&(e=e[0]),e=e;const n=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new ts({shape:[n,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!Pt(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new ee(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new ts({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,n=!1){de(()=>{if(!this.stateful)throw new Ai("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new ee("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Jn([s,r])):this.states_=[Jn([s,this.cell.stateSize])];else if(e==null)At(this.states_),this.keptStates!=null&&(At(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Jn([s,r])):this.states_[0]=Jn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ee(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n===!0?this.keptStates.push(this.states_.slice()):At(this.states_);for(let r=0;r<this.states_.length;++r){const i=e[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[s,o];if(!Pt(i.shape,a))throw new ee(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>Gi(r.clone()))})}apply(e,n){let s=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const i=nA(e,s,r,this.numConstants);e=i.inputs,s=i.initialState,r=i.constants;let o=[],a=[];if(s!=null){n.initialState=s,o=o.concat(s),this.stateSpec=[];for(const u of s)this.stateSpec.push(new ts({shape:u.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(n.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof Xi){const u=[e].concat(o),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const d=super.apply(u,n);return this.inputSpec=h,d}else return super.apply(e,n)}call(e,n){return de(()=>{const s=n==null?null:n.mask,r=n==null?null:n.training;let i=n==null?null:n.initialState;e=bt(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new ee(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},u=sA((p,g)=>{const m=this.cell.call([p].concat(g),a);return[m[0],m.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),c=u[0],h=u[1],d=u[2];this.stateful&&this.resetStates(d,r);const f=this.returnSequences?h:c;return this.returnState?[f].concat(d):f})}getInitialState(e){return de(()=>{let n=Jn(e.shape);return n=ut(n,[1,2]),n=rp(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?Q1(n,[1,s]):n):this.cell.stateSize>1?[Q1(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===va.className&&(n.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),n)}static fromConfig(e,n,s={}){const r=n.cell,i=wo(r,s);return new e(Object.assign(n,{cell:i}))}}va.className="RNN";$e(va);class Ex extends Rt{}class B2 extends Ex{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,us(this.units,"units"),this.activation=ua(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=yn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=yn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=yn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vn(e.kernelRegularizer),this.recurrentRegularizer=vn(e.recurrentRegularizer),this.biasRegularizer=vn(e.biasRegularizer),this.kernelConstraint=ss(e.kernelConstraint),this.recurrentConstraint=ss(e.recurrentConstraint),this.biasConstraint=ss(e.biasConstraint),this.dropout=Vu([1,aa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Vu([1,aa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Vt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return de(()=>{if(e=e,e.length!==2)throw new ee(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ca({ones:()=>jr(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ca({ones:()=>jr(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=Wi(te(e,o),this.kernel.read()):i=Wi(e,this.kernel.read()),this.bias!=null&&(i=xi(i,this.bias.read())),a!=null&&(s=te(s,a));let l=Me(i,Wi(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:la(this.activation),useBias:this.useBias,kernelInitializer:Cn(this.kernelInitializer),recurrentInitializer:Cn(this.recurrentInitializer),biasInitializer:Cn(this.biasInitializer),kernelRegularizer:en(this.kernelRegularizer),recurrentRegularizer:en(this.recurrentRegularizer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),kernelConstraint:ns(this.kernelConstraint),recurrentConstraint:ns(this.recurrentConstraint),biasConstraint:ns(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),n)}}B2.className="SimpleRNNCell";$e(B2);class rA extends va{constructor(e){e.cell=new B2(e),super(e)}call(e,n){return de(()=>{this.cell.dropoutMask!=null&&(At(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(At(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,n){return new e(n)}}rA.className="SimpleRNN";$e(rA);class z2 extends Ex{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ee("GRUCell does not support reset_after parameter set to true.");this.units=e.units,us(this.units,"units"),this.activation=ua(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ua(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=yn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=yn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=yn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vn(e.kernelRegularizer),this.recurrentRegularizer=vn(e.recurrentRegularizer),this.biasRegularizer=vn(e.biasRegularizer),this.kernelConstraint=ss(e.kernelConstraint),this.recurrentConstraint=ss(e.recurrentConstraint),this.biasConstraint=ss(e.biasConstraint),this.dropout=Vu([1,aa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Vu([1,aa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Vt(e);const n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return de(()=>{if(e=e,e.length!==2)throw new ee(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=n.training==null?!1:n.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ca({ones:()=>jr(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ca({ones:()=>jr(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,u;0<this.dropout&&this.dropout<1&&(e=te(e,i[0]));let c=Wi(e,this.kernel.read());this.useBias&&(c=xi(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=te(r,o[0]));const h=this.recurrentKernel.read(),[d,f]=Cr(h,[2*this.units,this.units],h.rank-1),p=Wi(r,d),[g,m,x]=Cr(c,3,c.rank-1),[b,v]=Cr(p,2,p.rank-1);a=this.recurrentActivation.apply(Me(g,b)),l=this.recurrentActivation.apply(Me(m,v));const y=Wi(te(l,r),f);u=this.activation.apply(Me(x,y));const C=Me(te(a,r),te(Me(1,Un(a)),u));return[C,C]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:la(this.activation),recurrentActivation:la(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Cn(this.kernelInitializer),recurrentInitializer:Cn(this.recurrentInitializer),biasInitializer:Cn(this.biasInitializer),kernelRegularizer:en(this.kernelRegularizer),recurrentRegularizer:en(this.recurrentRegularizer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),kernelConstraint:ns(this.kernelConstraint),recurrentConstraint:ns(this.recurrentConstraint),biasConstraint:ns(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),n)}}z2.className="GRUCell";$e(z2);class iA extends va{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new z2(e),super(e)}call(e,n){return de(()=>{this.cell.dropoutMask!=null&&(At(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(At(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}iA.className="GRU";$e(iA);class _x extends Ex{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,us(this.units,"units"),this.activation=ua(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ua(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=yn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=yn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=yn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=vn(e.kernelRegularizer),this.recurrentRegularizer=vn(e.recurrentRegularizer),this.biasRegularizer=vn(e.biasRegularizer),this.kernelConstraint=ss(e.kernelConstraint),this.recurrentConstraint=ss(e.recurrentConstraint),this.biasConstraint=ss(e.biasConstraint),this.dropout=Vu([1,aa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Vu([1,aa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var n;e=Vt(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;r=new(n=class extends Xr{apply(l,u){const c=i.apply([o]),h=new E2().apply([o]),d=i.apply([o*2]);return GC(GC(c,h),d)}},n.className="CustomInit",n)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,n){return de(()=>{const s=n.training==null?!1:n.training;if(e=e,e.length!==3)throw new ee(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ca({ones:()=>jr(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ca({ones:()=>jr(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,u,c,h;0<this.dropout&&this.dropout<1&&(e=te(e,o[0]));let d=Wi(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=te(r,a[0])),d=Me(d,Wi(r,this.recurrentKernel.read())),this.useBias&&(d=xi(d,this.bias.read()));const[f,p,g,m]=Cr(d,4,d.rank-1);l=this.recurrentActivation.apply(f),u=this.recurrentActivation.apply(p),c=Me(te(u,i),te(l,this.activation.apply(g))),h=this.recurrentActivation.apply(m);const x=te(h,this.activation.apply(c));return[x,x,c]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:la(this.activation),recurrentActivation:la(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Cn(this.kernelInitializer),recurrentInitializer:Cn(this.recurrentInitializer),biasInitializer:Cn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:en(this.kernelRegularizer),recurrentRegularizer:en(this.recurrentRegularizer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),kernelConstraint:ns(this.kernelConstraint),recurrentConstraint:ns(this.recurrentConstraint),biasConstraint:ns(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),n)}}_x.className="LSTMCell";$e(_x);class oA extends va{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new _x(e),super(e)}call(e,n){return de(()=>{this.cell.dropoutMask!=null&&(At(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(At(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}oA.className="LSTM";$e(oA);class G2 extends Ex{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?e.push(...n.stateSize):e.push(n.stateSize);return e}call(e,n){return de(()=>{e=e;let s=e.slice(1);const r=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(s.splice(0,a.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];s=r[a],a===0?o=[e[0]].concat(s):o=[o[0]].concat(s),o=l.call(o,n),i.push(o.slice(1))}s=[];for(const a of i.slice().reverse())s.push(...a);return[o[0]].concat(s)})}build(e){ey(e)&&(e=e[0]),e=e;let n;this.cells.forEach((s,r)=>{ol(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?n=s.stateSize[0]:n=s.stateSize,e=[e[0],n]})}),this.built=!0}getConfig(){const e=super.getConfig(),n=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(n)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,n,s={}){const r=[];for(const i of n.cells)r.push(wo(i,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const n of this.cells)e.push(...n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.cells)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const s of this.cells)n.push(...s.trainableWeights);return n.concat(e)}return e}getWeights(){const e=[];for(const n of this.cells)e.push(...n.weights);return ty(e)}setWeights(e){const n=[];for(const s of this.cells){const r=s.weights.length,i=e.splice(r);for(let o=0;o<s.weights.length;++o)n.push([s.weights[o],i[o]])}N2(n)}}G2.className="StackedRNNCells";$e(G2);function ca(t){const{ones:e,rate:n,training:s=!1,count:r=1,dropoutFunc:i}=t,o=()=>i!=null?i(e(),n):Z$(e(),n),a=()=>op(o,e,s);return!r||r<=1?Gi(a().clone()):Array(r).fill(void 0).map(a).map(u=>Gi(u.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Yre=function(t,e){var n={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(t);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(t,s[r])&&(n[s[r]]=t[s[r]]);return n};class aA extends va{constructor(e){if(e.unroll)throw new Et("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Et("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new ts({ndim:5})]}call(e,n){return de(()=>{if(this.cell.dropoutMask!=null&&(At(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(At(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new ee("ConvRNN2D cell does not support constants");const s=n==null?null:n.mask,r=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}computeOutputShape(e){let n=this.computeSingleOutputShape(e);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([e[0],...n.slice(-3)])]),n}getInitialState(e){return de(()=>{const{stateSize:n}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],o=Jn(i);return Array.isArray(n)?Array(n.length).fill(o):[o]})}resetStates(e,n=!1){de(()=>{if(!this.stateful)throw new Ai("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new ee("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Jn(i)):this.states_=[Jn(i)];else if(e==null)At(this.states_),this.keptStates!=null&&(At(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Jn(i)):this.states_[0]=Jn(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ee(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n?this.keptStates.push(this.states_.slice()):At(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],u=i;if(!Pt(l.shape,u))throw new ee(`State ${a} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>Gi(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:n,filters:s,kernelSize:r,padding:i,strides:o,dilationRate:a}=this.cell,l=n==="channelsFirst",u=e[l?3:2],c=e[l?4:3],h=ri(u,r[0],i,o[0],a[0]),d=ri(c,r[1],i,o[1],a[1]);return[...e.slice(0,2),...l?[s,h,d]:[h,d,s]]}}aA.className="ConvRNN2D";class V2 extends _x{constructor(e){const{filters:n,kernelSize:s,strides:r,padding:i,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:n})),this.filters=n,us(this.filters,"filters"),this.kernelSize=Du(s,2,"kernelSize"),this.kernelSize.forEach(l=>us(l,"kernelSize")),this.strides=Du(r||1,2,"strides"),this.strides.forEach(l=>us(l,"strides")),this.padding=i||"valid",$r(this.padding),this.dataFormat=o||"channelsLast",Vn(this.dataFormat),this.dilationRate=Du(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>us(l,"dilationRate"))}build(e){var n;e=Vt(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new ee(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],i=4,o=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(n=class extends Xr{apply(d,f){const p=u.apply([c]),g=ba([c]),m=u.apply([c*2]);return k2([p,g,m])}},n.className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,n){return de(()=>{if(e.length!==3)throw new ee(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=n.training||!1,r=e[0],i=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ca({ones:()=>jr(r),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(j,Z,J)=>!Z||!Z[J]?j:te(Z[J],j);let c=u(r,l,0),h=u(r,l,1),d=u(r,l,2),f=u(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ca({ones:()=>jr(i),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const p=this.recurrentDropoutMask;let g=u(i,p,0),m=u(i,p,1),x=u(i,p,2),b=u(i,p,3);const v=3,[y,C,I,$]=Cr(this.kernel.read(),a,v),[T,S,E,_]=this.useBias?Cr(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,y,T,this.padding),h=this.inputConv(h,C,S,this.padding),d=this.inputConv(d,I,E,this.padding),f=this.inputConv(f,$,_,this.padding);const[N,P,M,z]=Cr(this.recurrentKernel.read(),a,v);g=this.recurrentConv(g,N),m=this.recurrentConv(m,P),x=this.recurrentConv(x,M),b=this.recurrentConv(b,z);const A=this.recurrentActivation.apply(Me(c,g)),B=this.recurrentActivation.apply(Me(h,m)),L=Me(te(B,o),te(A,this.activation.apply(Me(d,x)))),U=te(this.recurrentActivation.apply(Me(f,b)),this.activation.apply(L));return[U,U,L]})}getConfig(){const e=super.getConfig(),{units:n}=e,s=Yre(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,n,s,r){const i=ml(e,n,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?xi(i,s,this.dataFormat):i}recurrentConv(e,n){return ml(e,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}V2.className="ConvLSTM2DCell";$e(V2);class lA extends aA{constructor(e){const n=new V2(e);super(Object.assign(Object.assign({},e),{cell:n}))}static fromConfig(e,n){return new e(n)}}lA.className="ConvLSTM2D";$e(lA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class W2 extends Rt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const n=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?n[r]:this.noiseShape[r]);return s}call(e,n){return de(()=>{this.invokeCallHook(e,n);const s=bt(e);if(0<this.rate&&this.rate<1){const r=n.training==null?!1:n.training,i=this.getNoiseShape(s);return op(()=>Z$(s,this.rate,i,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(e,n),e}dispose(){return super.dispose()}}W2.className="Dropout";$e(W2);class uA extends W2{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const n=e.shape;return[n[0],1,n[2]]}}uA.className="SpatialDropout1D";$e(uA);class cA extends Rt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let n=null;e.batchSize!=null&&(n=e.batchSize),this.batchInputShape=[n,e.inputDim]}this.units=e.units,us(this.units,"units"),this.activation=ua(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=yn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=yn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ss(e.kernelConstraint),this.biasConstraint=ss(e.biasConstraint),this.kernelRegularizer=vn(e.kernelRegularizer),this.biasRegularizer=vn(e.biasRegularizer),this.activityRegularizer=vn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Vt(e);const n=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(e){e=Vt(e);const n=e.slice();return n[n.length-1]=this.units,n}call(e,n){return de(()=>{this.invokeCallHook(e,n);const s=bt(e),r=W$(this.activation.getClassName());let i;return r!=null?i=Wi(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=Wi(s,this.kernel.read()),this.bias!=null&&(i=xi(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:la(this.activation),useBias:this.useBias,kernelInitializer:Cn(this.kernelInitializer),biasInitializer:Cn(this.biasInitializer),kernelRegularizer:en(this.kernelRegularizer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),kernelConstraint:ns(this.kernelConstraint),biasConstraint:ns(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}cA.className="Dense";$e(cA);class hA extends Rt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Vt(e);for(const n of e.slice(1))if(n==null)throw new ee(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],ra(e,1)]}call(e,n){return de(()=>{this.invokeCallHook(e,n);let s=bt(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=Ot(s,r)}return $se(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(e,n),e}}hA.className="Flatten";$e(hA);class dA extends Rt{constructor(e){super(e),this.supportsMasking=!0,this.activation=ua(e.activation)}call(e,n){return de(()=>{this.invokeCallHook(e,n);const s=bt(e);return this.activation.apply(s)})}getConfig(){const e={activation:la(this.activation)},n=super.getConfig();return Object.assign(e,n),e}}dA.className="Activation";$e(dA);class fA extends Rt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,n){return de(()=>(e=bt(e),Ese(e,this.n)))}getConfig(){const e={n:this.n},n=super.getConfig();return Object.assign(e,n),e}}fA.className="RepeatVector";$e(fA);class pA extends Rt{constructor(e){super(e),this.targetShape=e.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,n){const s="Total size of new array must be unchanged.",r=n.slice();let i=1,o=null;for(let l=0;l<r.length;++l){const u=r[l];if(this.isUnknown(u))if(o===null)o=l;else throw new ee("Can only specifiy one unknown dimension.");else i*=u}const a=ra(e);if(o!==null){if(i===0||a%i!==0)throw new ee(s);r[o]=a/i}else if(a!==i)throw new ee(s);return r}computeOutputShape(e){let n=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){n=!0;break}return n?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,n){return de(()=>{this.invokeCallHook(e,n);const s=bt(e),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return ie(s,i)})}getConfig(){const e={targetShape:this.targetShape},n=super.getConfig();return Object.assign(e,n),e}}pA.className="Reshape";$e(pA);class mA extends Rt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const n=hi(1,e.dims.length+1);if(!Pt(e.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ts({ndim:this.dims.length+1})]}computeOutputShape(e){e=Vt(e);const n=e.slice();return this.dims.forEach((s,r)=>{n[r+1]=e[s]}),n}call(e,n){return Ot(bt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},n=super.getConfig();return Object.assign(e,n),e}}mA.className="Permute";$e(mA);class gA extends Rt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,e),n}computeMask(e,n){const s=bt(e);return H1(eg(s,this.maskValue),-1)}call(e,n){return de(()=>{this.invokeCallHook(e,n);const s=bt(e),o=H1(eg(s,this.maskValue),-1,!0);return te(s,Ze(o,s.dtype))})}}gA.className="Masking";$e(gA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class xA extends Rt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let n=null;e.batchSize!=null&&(n=e.batchSize),e.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(Xt(e.inputLength))}this.inputDim=e.inputDim,us(this.inputDim,"inputDim"),this.outputDim=e.outputDim,us(this.outputDim,"outputDim"),this.embeddingsInitializer=yn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=vn(e.embeddingsRegularizer),this.activityRegularizer=vn(e.activityRegularizer),this.embeddingsConstraint=ss(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,n){return de(()=>this.maskZero?(e=bt(e),eg(e,Ft(e))):null)}computeOutputShape(e){if(e=Vt(e),this.inputLength==null)return[...e,this.outputDim];const n=Xt(this.inputLength);if(n.length!==e.length-1)throw new ee(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<n.length;++r){const i=n[r],o=e[r+1];if(i!=null&&o!=null&&i!==o)throw new ee(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(n[s]=o),s++}}return[e[0],...n,this.outputDim]}call(e,n){return de(()=>{this.invokeCallHook(e,n);let s=bt(e);s.dtype!=="int32"&&(s=Vi(s,"int32"));const r=Y$(this.embeddings.read(),ie(s,[s.size]));return ie(r,Vt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Cn(this.embeddingsInitializer),embeddingsRegularizer:en(this.embeddingsRegularizer),activityRegularizer:en(this.activityRegularizer),embeddingsConstraint:ns(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(e,n),e}}xA.className="Embedding";$e(xA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ul extends Rt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Et}computeElementwiseOpOutputShape(e,n){if(e==null||n==null)return null;if(e.length<n.length)return this.computeElementwiseOpOutputShape(n,e);if(n.length===0)return e;const s=e.slice(0,e.length-n.length);for(let r=0;r<n.length;++r){const i=e[e.length-n.length+r],o=n[r];if(i==null||o==null||i<0||o<0)s.push(null);else if(i===1)s.push(o);else if(o===1)s.push(i);else{if(i!==o)throw new ee("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(n));s.push(i)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Vt(e)]),e=e,e.length<2)throw new ee(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let n=[];for(const i of e)i!=null&&i[0]!==null&&n.push(i[0]);if(n=sa(n),n.length>1)throw new ee(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const o=e[i]==null?null:e[i].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=e.map(i=>i.length);e.indexOf(null)===-1&&sa(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,n){return de(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(i=>i.rank);if(r.indexOf(null)===-1){const i=aa(r);for(let o of e){const a=o.rank;for(let l=0;l<i-a;++l)o=rp(o,1);s.push(o)}return this.mergeFunction(s)}else{let i=!1;for(const l of e){const u=l.rank;if(u==null){const c=l.shape,h=c[0],d=c.slice(1).concat([h]);let f=ie(l,[h].concat(ra(c.slice(1))));f=Ot(f,[1,0]),f=ie(f,d),s.push(f),i=!0}else if(u>1){const c=hi(1,u).concat([0]);s.push(Ot(l,c)),i=!0}else s.push(l)}let o=this.mergeFunction(s);const a=o.rank;if(i){if(a==null){const l=o.shape,u=l.length,c=l[u-1],h=[c].concat(l.slice(0,l.length-1));o=ie(Ot(ie(o,[-1,c]),[1,0]),h)}else if(a>1){const l=[a-1].concat(hi(0,a-1));o=Ot(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let n;e[0]==null?n=null:n=e[0].slice(1);for(let r=1;r<e.length;++r){const i=e[r]==null?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=sa(s),s.length===1?n=s.concat(n):n=[null].concat(n),n}computeMask(e,n){return de(()=>{if(n==null)return null;if(!Array.isArray(n))throw new ee("`mask` should be an Array");if(!Array.isArray(e))throw new ee("`inputs` should be an Array");if(n.length!==e.length)throw new ee(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${n.length})`);if(n.every(r=>r==null))return null;n=n.map(r=>r==null?r:js(r,0));let s=n[0];for(let r=1;r<n.length-1;++r)s=_o(s,n[r]);return s})}}class bA extends Ul{constructor(e){super(e)}mergeFunction(e){return de(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=Me(n,e[s]);return n})}}bA.className="Add";$e(bA);class yA extends Ul{constructor(e){super(e)}mergeFunction(e){return de(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=te(n,e[s]);return n})}}yA.className="Multiply";$e(yA);class vA extends Ul{constructor(e){super(e)}mergeFunction(e){return de(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=Me(n,e[s]);return te(1/e.length,n)})}}vA.className="Average";$e(vA);class wA extends Ul{constructor(e){super(e)}mergeFunction(e){return de(()=>{let n=e[0];for(let s=1;s<e.length;++s)n=xa(n,e[s]);return n})}}wA.className="Maximum";$e(wA);class SA extends Ul{constructor(e){super(e)}mergeFunction(e){return de(()=>{let n=e[0];for(let s=1;s<e.length;++s)n=kd(n,e[s]);return n})}}SA.className="Minimum";$e(SA);class CA extends Ul{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new ee("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let n=!0;for(const r of e)if(r!=null){n=!1;break}if(n)return;const s=[];for(let r=0;r<e.length;++r){const i=e[r].slice();i.splice(this.axis,1);let o=!1;for(const a of s)if(Pt(a,i)){o=!0;break}o||s.push(i)}if(s.length>1)throw new ee("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return de(()=>k2(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new ee("A `Concatenate` layer should be called on a list of inputs.");const n=e,s=n[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of n.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(e,n){if(n==null)return null;if(!Array.isArray(n))throw new ee("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ee("`inputs` should be an array for Concatenate");if(n.length!==e.length)throw new ee(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${e.length})`);return de(()=>{let s=!0;if(n.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const r=[];for(let o=0;o<e.length;++o)n[o]==null?r.push(Ze(jr(e[o]),"bool")):n[o].rank<e[o].rank?r.push(js(n[o],-1)):r.push(n[o]);const i=Ys(r,this.axis);return I_(i,-1,!1)})}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}CA.className="Concatenate";$e(CA);function Sh(t,e){for(;t<0;)t+=e;return t}function Zre(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new Et("batchDot is not implemented for tensors of 4D or higher rank yet");if(G(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),G(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof n=="number"&&(n=[n,n]),t.dtype==="complex64"||e.dtype==="complex64")throw new Et("batchDot is not implemented for complex64-type Tensors yet.");const s=t.shape.length,r=e.shape.length;n==null&&(n=[s-1,r-2]);const i=n;return de(()=>{let o;if(s>r){o=s-r;const l=[];for(let u=0;u<o;++u)l.push(1);e=ie(e,e.shape.concat(l))}else if(r>s){o=r-s;const l=[];for(let u=0;u<o;++u)l.push(1);t=ie(t,t.shape.concat(l))}else o=0;let a;if(t.shape.length===2&&e.shape.length===2)i[0]===i[1]?a=ut(te(t,e),i[0]):a=ut(te(Ot(t,[1,0]),e),i[1]);else{const l=i[0]!==t.shape.length-1,u=i[1]===e.shape.length-1;a=Lt(t,e,l,u)}if(o>0){let l;s>r?l=s+r-3:l=s-1;const u=[];for(let c=l;c<l+o;++c)u.push(c);a=Qf(a,u)}return a.shape.length===1&&(a=js(a,1)),a})}class TA extends Ul{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){G(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0],s=e[1];if(n.length>3||s.length>3)throw new Et("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,s);if(n[r[0]]!==s[r[1]])throw new ee(`Dimension incompatibility: ${n[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new ee(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let n=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,o)=>Sh(i,e[o].shape.length)):r=[Sh(this.axes,n.shape.length),Sh(this.axes,s.shape.length)],this.normalize&&(n=ag(n,r[0]),s=ag(s,r[1])),Zre(n,s,r)}interpretAxes(e,n){let s;return Array.isArray(this.axes)?s=this.axes:s=[Sh(this.axes,e.length),Sh(this.axes,n.length)],s}computeOutputShape(e){G(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0].slice(),s=e[1].slice();if(n.length>3||s.length>3)throw new Et("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,s);n.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=n.concat(s);return i.length===1&&i.push(1),i}computeMask(e,n){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(e,n),e}}TA.className="Dot";$e(TA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class IA extends Rt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,e),n}call(e,n){return de(()=>{this.invokeCallHook(e,n);const s=bt(e);return op(()=>Me(wx(s.shape,0,this.stddev),s),()=>s,n.training||!1)})}}IA.className="GaussianNoise";$e(IA);class kA extends Rt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return de(()=>{this.invokeCallHook(e,n);const s=bt(e);return this.rate>0&&this.rate<1?op(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return te(s,wx(s.shape,1,i))},()=>s,n.training||!1):s})}}kA.className="GaussianDropout";$e(kA);class EA extends Rt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||bt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return de(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return op(()=>{const i=bt(e),a=-1.6732632423543772*1.0507009873554805;let l=Pl(Zf(s),this.rate);l=Vi(l,"float32");const u=((1-this.rate)*(1+this.rate*a**2))**-.5,c=-u*a*this.rate,h=Me(te(i,l),te(Me(l,-1),a));return Me(te(h,u),c)},()=>bt(e),n.training||!1)}return e})}}EA.className="AlphaDropout";$e(EA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ad(t,e,n,s,r,i=.001){let o;if(t.rank===2)o=RY(t,e,n,s,r,i);else if(t.rank===3)o=PY(t,e,n,s,r,i);else if(t.rank===4)o=NY(t,e,n,s,r,i);else throw new Et(`batchNormalization is not implemented for array of rank ${t.rank} yet`);return o}function Qre(t,e,n,s,r=.001){return de(()=>{const i=Yv(t,s),o=i.mean,a=i.variance;return[Ad(t,o,a,n,e,r),o,a]})}function Jre(t,e,n,s,r=.001){return de(()=>{const i=Yv(t,s),o=i.mean,a=i.variance,l=[];for(const p of hi(0,t.rank))s.indexOf(p)!==-1?l.push(1):l.push(t.shape[p]);const u=ie(o,l),c=ie(a,l),h=e==null?null:ie(e,l),d=n==null?null:ie(n,l);return[Ad(t,u,c,d,h,r),o,a]})}function eie(t,e,n,s,r=.001){return Pt(s.slice().sort(),hi(0,t.rank-1))?Qre(t,e,n,s,r):Jre(t,e,n,s,r)}class _A extends Rt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=yn(e.betaInitializer||"zeros"),this.gammaInitializer=yn(e.gammaInitializer||"ones"),this.movingMeanInitializer=yn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=yn(e.movingVarianceInitializer||"ones"),this.betaConstraint=ss(e.betaConstraint),this.gammaConstraint=ss(e.gammaConstraint),this.betaRegularizer=vn(e.betaRegularizer),this.gammaRegularizer=vn(e.gammaRegularizer)}build(e){e=Vt(e);const n=this.axis>=0?this.axis:this.axis+e.length,s=e[n];if(s==null)throw new ee(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new ts({ndim:e.length,axes:{[n]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,n){return de(()=>{const s=n.training==null?!1:n.training,r=bt(e),i=r.shape,o=i.length,a=hi(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const u=yl(1,o);u[l]=i[l];const c=a.slice();c.sort();const h=!Pt(c,hi(0,o).slice(0,o-1)),d=()=>{if(h){const b=ie(this.movingMean.read(),u),v=ie(this.movingVariance.read(),u),y=this.center?ie(this.beta.read(),u):null,C=this.scale?ie(this.gamma.read(),u):null;return Ad(r,b,v,y,C,this.epsilon)}else return Ad(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return d();const[f,p,g]=eie(r,this.gamma.read(),this.beta.read(),a,this.epsilon),m=(b,v,y)=>{de(()=>{const C=1-y,I=b.read(),$=te(mt(I,v),C);b.write(mt(I,$))})};return(()=>{m(this.movingMean,p,this.momentum),m(this.movingVariance,g,this.momentum)})(),f})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Cn(this.betaInitializer),gammaInitializer:Cn(this.gammaInitializer),movingMeanInitializer:Cn(this.movingMeanInitializer),movingVarianceInitializer:Cn(this.movingVarianceInitializer),betaRegularizer:en(this.betaRegularizer),gammaRegularizer:en(this.gammaRegularizer),betaConstraint:ns(this.betaConstraint),gammaConstraint:ns(this.gammaConstraint)},n=super.getConfig();return Object.assign(e,n),e}}_A.className="BatchNormalization";$e(_A);class $A extends Rt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=yn(e.betaInitializer||"zeros"),this.gammaInitializer=yn(e.gammaInitializer||"ones"),this.betaRegularizer=vn(e.betaRegularizer),this.gammaRegularizer=vn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Vt(e);const n=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=n);for(const i of this.axis)if(i<0||i>=n)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==sa(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,n){const s=bt(e),r=s.shape,i=r.length;return de(()=>{let{mean:a,variance:l}=Yv(s,this.axis,!0);const u=yl(1,i);for(const g of this.axis)u[g]=r[g];const c=g=>g!=null&&g.shape.length!==i?ie(g,u):g;let h=this.scale?c(this.gamma.read()):null,d=this.center?c(this.beta.read()):null;const f=[],p=[];for(let g=0;g<i;++g)this.axis.indexOf(g)!==-1?(f.push(r[g]),p.push(1)):(f.push(1),p.push(r[g]));return a=ei(a,f),l=ei(l,f),h!=null&&(h=ei(h,p)),d!=null&&(d=ei(d,p)),Ad(s,a,l,d,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Cn(this.betaInitializer),gammaInitializer:Cn(this.gammaInitializer),betaRegularizer:en(this.betaRegularizer),gammaRegularizer:en(this.gammaRegularizer)},n=super.getConfig();return Object.assign(e,n),e}}$A.className="LayerNormalization";$e($A);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tie(t,e,n){return de(()=>{if(t.rank!==4)throw new ee(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new ee("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=di()),n!=="channelsLast"&&n!=="channelsFirst")throw new ee(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return n==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],Zv(t,s)})}class RA extends Rt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?di():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new ee(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let n,s;if(typeof e.padding[0]=="number")n=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new ee(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(n=e.padding[0],e.padding[1].length!==2)throw new ee(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[n,s]}this.inputSpec=[new ts({ndim:4})]}computeOutputShape(e){e=Vt(e);let n,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?n=e[2]+this.padding[0][0]+this.padding[0][1]:n=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],n,s]):(e[1]!=null&&e[1]>=0?n=e[1]+this.padding[0][0]+this.padding[0][1]:n=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],n,s,e[3]])}call(e,n){return de(()=>tie(bt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}RA.className="ZeroPadding2D";$e(RA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $x(t,e,n,s,r,i){return de(()=>{Vn(r),K$(i),$r(s),n==null&&(n=[1,1]),s==null&&(s="valid"),r==null&&(r=di()),i==null&&(i="max"),t=U2(t,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=qv(t,e,n,a):o=Fv(t,e,n,a),r==="channelsFirst"&&(o=Ot(o,[0,3,1,2])),o})}function AA(t,e,n,s,r,i){return de(()=>{Vn(r),K$(i),$r(s),n==null&&(n=[1,1,1]),s==null&&(s="valid"),r==null&&(r=di()),i==null&&(i="max"),t=XR(t,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=bQ(t,e,n,a):o=vY(t,e,n,a),r==="channelsFirst"&&(o=Ot(o,[0,4,1,2,3])),o})}class PA extends Rt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new ee(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(us(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new ee(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);us(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,$r(this.padding),this.inputSpec=[new ts({ndim:3})]}computeOutputShape(e){e=Vt(e);const n=ri(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],n,e[2]]}call(e,n){return de(()=>{this.invokeCallHook(e,n),e=rp(bt(e),2);const s=this.poolingFunction(bt(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Qf(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(e,n),e}}class DA extends PA{constructor(e){super(e)}poolingFunction(e,n,s,r,i){return Vn(i),$r(r),$x(e,n,s,r,i,"max")}}DA.className="MaxPooling1D";$e(DA);class NA extends PA{constructor(e){super(e)}poolingFunction(e,n,s,r,i){return Vn(i),$r(r),$x(e,n,s,r,i,"avg")}}NA.className="AveragePooling1D";$e(NA);class MA extends Rt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new ee(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];us(this.poolSize,"poolSize"),us(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vn(this.dataFormat),$r(this.padding),this.inputSpec=[new ts({ndim:4})]}computeOutputShape(e){e=Vt(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return n=ri(n,this.poolSize[0],this.padding,this.strides[0]),s=ri(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,s]:[e[0],n,s,e[3]]}call(e,n){return de(()=>(this.invokeCallHook(e,n),this.poolingFunction(bt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class LA extends MA{constructor(e){super(e)}poolingFunction(e,n,s,r,i){return Vn(i),$r(r),$x(e,n,s,r,i,"max")}}LA.className="MaxPooling2D";$e(LA);class OA extends MA{constructor(e){super(e)}poolingFunction(e,n,s,r,i){return Vn(i),$r(r),$x(e,n,s,r,i,"avg")}}OA.className="AveragePooling2D";$e(OA);class FA extends Rt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new ee(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];us(this.poolSize,"poolSize"),us(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vn(this.dataFormat),$r(this.padding),this.inputSpec=[new ts({ndim:5})]}computeOutputShape(e){e=Vt(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return n=ri(n,this.poolSize[0],this.padding,this.strides[0]),s=ri(s,this.poolSize[1],this.padding,this.strides[1]),r=ri(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,s,r]:[e[0],n,s,r,e[4]]}call(e,n){return de(()=>(this.invokeCallHook(e,n),this.poolingFunction(bt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class UA extends FA{constructor(e){super(e)}poolingFunction(e,n,s,r,i){return Vn(i),$r(r),AA(e,n,s,r,i,"max")}}UA.className="MaxPooling3D";$e(UA);class BA extends FA{constructor(e){super(e)}poolingFunction(e,n,s,r,i){return Vn(i),$r(r),AA(e,n,s,r,i,"avg")}}BA.className="AveragePooling3D";$e(BA);class zA extends Rt{constructor(e){super(e),this.inputSpec=[new ts({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,n){throw new Et}}class GA extends zA{constructor(e){super(e||{})}call(e,n){return de(()=>{const s=bt(e);return Hn(s,1)})}}GA.className="GlobalAveragePooling1D";$e(GA);class VA extends zA{constructor(e){super(e||{})}call(e,n){return de(()=>{const s=bt(e);return si(s,1)})}}VA.className="GlobalMaxPooling1D";$e(VA);class WA extends Rt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vn(this.dataFormat),this.inputSpec=[new ts({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,n){throw new Et}getConfig(){const e={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class HA extends WA{call(e,n){return de(()=>{const s=bt(e);return this.dataFormat==="channelsLast"?Hn(s,[1,2]):Hn(s,[2,3])})}}HA.className="GlobalAveragePooling2D";$e(HA);class KA extends WA{call(e,n){return de(()=>{const s=bt(e);return this.dataFormat==="channelsLast"?si(s,[1,2]):si(s,[2,3])})}}KA.className="GlobalMaxPooling2D";$e(KA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class jA extends Rt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(e,n),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,n,s={}){const r=n.layer,i=wo(r,s);delete n.layer;const o={layer:i};return Object.assign(o,n),new e(o)}}class XA extends jA{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Vt(e),e.length<3)throw new ee(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const n=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Vt(e);const n=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(n),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,n){return de(()=>(e=bt(e),sA((o,a)=>[bt(this.layer.call(o,n)),[]],e,[],!1,null,null,!1,!0)[1]))}}XA.className="TimeDistributed";$e(XA);function nie(t){Fl(Sse,"BidirectionalMergeMode",t)}const sie="concat";class qA extends jA{constructor(e){super(e);const n=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=n,this.forwardLayer=wo(s),n.goBackwards=n.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=n,this.backwardLayer=wo(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?sie:e.mergeMode,nie(this.mergeMode),e.weights)throw new Et("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const n=e.length,s=Math.floor(n/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let n=this.forwardLayer.computeOutputShape(e);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let s,r,i;return this.returnState&&(i=n.slice(1)),s=n[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):Xs(r)}apply(e,n){let s=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const i=nA(e,s,r,this.numConstants);if(e=i.inputs,s=i.initialState,r=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,n);const o=[],a=[];if(s!=null){const u=s.length;if(u%2>0)throw new ee("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=s,o.push(...s);const c=s.map(h=>new ts({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),a.push(...c)}if(r!=null)throw new Et("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof Xi;for(const u of o)if(u instanceof Xi!==l)throw new ee("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[e].concat(o),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const d=super.apply(u,n);return this.inputSpec=h,d}else return super.apply(e,n)}call(e,n){return de(()=>{const s=n.initialState;let r,i;if(s==null)r=this.forwardLayer.call(e,n),i=this.backwardLayer.call(e,n);else{const l=s.slice(0,s.length/2),u=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(n,{initialState:l})),i=this.backwardLayer.call(e,Object.assign(n,{initialState:u}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=xl(i,1));let a;return this.mergeMode==="concat"?a=k2([r,i]):this.mergeMode==="sum"?a=Me(r,i):this.mergeMode==="ave"?a=te(.5,Me(r,i)):this.mergeMode==="mul"?a=te(r,i):this.mergeMode==null&&(a=[r,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){ol(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),ol(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,n){Array.isArray(n)&&(n=n[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[n,n]:s=n:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(e,n),e}static fromConfig(e,n){const s=wo(n.layer);if(delete n.layer,n.numConstants!=null)throw new Et("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=n;return r.layer=s,new e(r)}}qA.className="Bidirectional";$e(qA);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class YA extends Rt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return de(()=>(e=bt(e),e.dtype!=="float32"&&(e=Vi(e,"float32")),Me(te(e,this.scale),this.offset)))}}YA.className="Rescaling";$e(YA);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:rie,cropAndResize:iie}=xo;class ZA extends Rt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,n,s,r,i,o,a,l){return de(()=>{let u,c=!1;const h=n/o,d=s/a,f=(r+n)/o,p=(i+s)/a,g=[h,d,f,p],m=[];e.rank===3?(c=!0,u=$o([e])):u=e;for(let C=0;C<u.shape[0];C++)m.push(g);const x=p_(m,[m.length,4]),b=Ed(0,m.length,1,"int32"),y=iie(u,x,b,[r,i],"nearest");return Vi(c?bt(bl(y)):y,l)})}upsize(e,n,s,r){return de(()=>{const i=rie(e,[n,s]);return Vi(i,r)})}call(e,n){return de(()=>{const s=bt(e),r=s.dtype,i=s.shape,o=i[i.length-3],a=i[i.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let u=0;return a!==this.width&&(u=Math.floor((a-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(s,l,u,this.height,this.width,o,a,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=Vt(e);const n=e.length-3,s=e.length-2;return e[n]=this.height,e[s]=this.width,e}}ZA.className="CenterCrop";$e(ZA);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function oie(t,e,n,s){let r=bt(t);if(r.dtype!=="int32"&&(r=Vi(r,"int32")),e==="int")return r;const i=r.shape;if(r.rank===0&&(r=js(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=js(r,-1)),r.rank>2)throw new ee(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(e),a=r;let l;if(typeof s<"u"&&e==="count"?l=EC(a,s,n,o):l=EC(a,[],n,o),e!=="tfIdf")return l;if(s)return te(l,s);throw new ee("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class QA extends Rt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){return e=Vt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,n){return de(()=>{e=bt(e),e.dtype!=="int32"&&(e=Vi(e,"int32"));let s;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new ee(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);s=bt(n.countWeights)}const r=si(e),i=Qm(e),o=_r(this.numTokens,r).bufferSync().get(0),a=Pl(i,0).bufferSync().get(0);if(!(o&&a))throw new ee(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return oie(e,this.outputMode,this.numTokens,s)})}}QA.className="CategoryEncoding";$e(QA);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const aie=["bilinear","nearest"],o3=new Set(aie);class JA extends Rt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(o3.has(e.interpolation))this.interpolation=e.interpolation;else throw new ee(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Vt(e);const n=e[2];return[this.height,this.width,n]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return de(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return xo.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return xo.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...o3]} are supported`)})}}JA.className="Resizing";$e(JA);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class eP{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}eP.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class tP extends Rt{constructor(e){super(e),this.randomGenerator=new eP(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(e,n),e}}tP.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const lie=["bilinear","nearest"],a3=new Set(lie);class nP extends tP{constructor(e){super(e);const{factor:n,interpolation:s="bilinear"}=e;if(this.factor=n,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ee(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ee(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ee(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(a3.has(s))this.interpolation=s;else throw new ee(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=Vt(e);const n=e[2];return[this.imgHeight,-1,n]}call(e,n){return de(()=>{const s=bt(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=Zf([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return xo.resizeBilinear(e,o);case"nearest":return xo.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...a3]} are supported`)}})}}nP.className="RandomWidth";$e(nP);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uie=ue();uie.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var l3;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(l3||(l3={}));var u3;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(u3||(u3={}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var c3;(function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"})(c3||(c3={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ot(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&G(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cie=J_;class Rx extends t0{nextDataId(){return Rx.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new lv(this,br())}write(e,n,s){this.firstUse&&(this.firstUse=!1,ue().get("IS_NODE")&&yr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&ec(s[0])){const i=s.map(o=>vo(o));r=this.write(i,e,n)}else r=this.write(s,e,n);return{dataId:r,shape:e,dtype:n}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const n=this.data.get(e);n.refCount++}decRef(e){if(this.data.has(e)){const n=this.data.get(e);n.refCount--}}move(e,n,s,r,i){this.data.set(e,{values:n,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:n,complexTensorInfos:s}=this.data.get(e);if(n==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return ui(r,i)}return Tm(this.data.get(e).values,n)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const s=n.map(r=>li(r));return Ct(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ct(e.shape,e.dtype,n)}makeOutput(e,n,s){return br().makeTensorFromTensorInfo(this.makeTensorInfo(n,s,e),this)}disposeData(e,n=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!n&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const n=Hs();return e(),{kernelMs:Hs()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){ot([e],"where");const n=this.readSync(e.dataId);return cie(e.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Rx.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sP(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const hie=t=>{const{x:e}=t.inputs,n=t.backend;ot(e,"abs");let s=new Float32Array(oe(e.shape));const r=n.data.get(e.dataId).values;return s=sP(r),n.makeOutput(s,e.shape,e.dtype)},die={kernelName:qd,backendName:"cpu",kernelFunc:hie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wn(t){return(e,n,s,r,i)=>{const o=pt(e,n),a=o.length,l=lt(o),u=oe(o),c=cs(i,u),h=e.length,d=n.length,f=lt(e),p=lt(n),g=oa(e,o),m=oa(n,o);if(g.length+m.length===0)for(let x=0;x<c.length;++x)c[x]=t(s[x%s.length],r[x%r.length]);else for(let x=0;x<c.length;++x){const b=tc(x,a,l),v=b.slice(-h);g.forEach($=>v[$]=0);const y=zi(v,h,f),C=b.slice(-d);m.forEach($=>C[$]=0);const I=zi(C,d,p);c[x]=t(s[y],r[I])}return[c,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ar(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,a=n.makeTensorInfo(s.shape,"complex64"),l=n.data.get(a.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",i),imag:n.makeTensorInfo(r.shape,"float32",o)},a}const fie={kernelName:u0,backendName:"cpu",kernelFunc:ar};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dg(t,e,n="float32"){if(n==="complex64"){const r=dg(t,e,"float32"),i=dg(t,e,"float32");return ar({inputs:{real:r,imag:i},backend:t})}const s=vs(oe(e),n);return t.makeTensorInfo(e,n,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qi(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const pie={kernelName:Sc,backendName:"cpu",kernelFunc:qi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vl(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.real,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const mie={kernelName:P0,backendName:"cpu",kernelFunc:vl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rP(t,e,n,s){if(s==="int32"){const r=Int32Array.from(t);return[e,"int32",r]}if(s==="bool"){const r=Al([0],n),[i,o]=Wn((a,l)=>a!==l?1:0)(e,[],t,r,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)}function ha(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return qi({inputs:{x:r},backend:n});const c=dg(n,r.shape,r.dtype),h=ha({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),d=ar({inputs:{real:h,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),d}if(r.dtype==="complex64"){const c=vl({inputs:{input:r},backend:n}),h=ha({inputs:{x:c},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(c),h}if(!hv(r.dtype,i)){const c=qi({inputs:{x:r},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:i}}const o=n.data.get(r.dataId).values,[a,l,u]=rP(o,r.shape,r.dtype,i);return n.makeTensorInfo(a,l,u)}const gie={kernelName:uc,backendName:"cpu",kernelFunc:ha};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function os(t,e,n,s){return n==null?({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;ot([o,a],t);const u=l.data.get(o.dataId).values,c=l.data.get(a.dataId).values,h=o.dtype==="string"?ci(u):u,d=o.dtype==="string"?ci(c):c,f=s||o.dtype,[p,g]=e(o.shape,a.shape,h,d,f);return l.makeTensorInfo(g,f,p)}:({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;if(o.dtype==="complex64"||a.dtype==="complex64"){const u=ha({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,f=l.data.get(h.dataId).values,p=l.data.get(d.dataId).values,g=ha({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(g.dataId),x=m.complexTensorInfos.real,b=m.complexTensorInfos.imag,v=l.data.get(x.dataId).values,y=l.data.get(b.dataId).values,[C,I,$]=n(o.shape,a.shape,f,p,v,y),T=l.makeTensorInfo($,"float32",C),S=l.makeTensorInfo($,"float32",I),E=ar({inputs:{real:T,imag:S},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(T),l.disposeIntermediateTensorInfo(S),E}else{const u=l.data.get(o.dataId).values,c=l.data.get(a.dataId).values,h=s||o.dtype,[d,f]=e(o.shape,a.shape,u,c,h);return l.makeTensorInfo(f,h,d)}}}function H2(t){return(e,n,s,r,i,o)=>{const a=pt(e,n),l=oe(a),u=a.length,c=lt(a),h=cs("float32",l),d=cs("float32",l),f=oa(e,a),p=oa(n,a),g=ui(s,r),m=ui(i,o),x=e.length,b=lt(e),v=n.length,y=lt(n);if(f.length+p.length===0)for(let C=0;C<h.length;C++){const I=C%g.length,$=C%m.length,T=t(g[I*2],g[I*2+1],m[$*2],m[$*2+1]);h[C]=T.real,d[C]=T.imag}else for(let C=0;C<h.length;C++){const I=tc(C,u,c),$=I.slice(-x);f.forEach(N=>$[N]=0);const T=zi($,x,b),S=I.slice(-v);p.forEach(N=>S[N]=0);const E=zi(S,v,y),_=t(g[T*2],g[T*2+1],m[E*2],m[E*2+1]);h[C]=_.real,d[C]=_.imag}return[h,d,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iP=Wn((t,e)=>t+e),xie=H2((t,e,n,s)=>({real:t+n,imag:e+s})),Wu=os($l,iP,xie),bie={kernelName:$l,backendName:"cpu",kernelFunc:Wu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K2(t,e,n,s,r){const i=oe(s),o=vs(r,n);for(let a=0;a<t.length;a++){const l=t[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(i>0?o[l]+=e[a]:o[l]+=1)}return o}function oP(t,e,n,s=!1){const r=t.shape[0],i=t.shape[1],o=Ct([r,n],e.dtype);for(let a=0;a<r;a++)for(let l=0;l<i;l++){const u=t.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(s?o.set(1,a,u):e.size>0?o.set(o.get(a,u)+e.get(a,l),a,u):o.set(o.get(a,u)+1,a,u))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aP=Wn((t,e)=>t&e),yie=os(mv,aP),vie={kernelName:mv,backendName:"cpu",kernelFunc:yie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eo(t){return(e,n,s)=>{const r=_n(n,e.length);for(let i=0;i<e.length;++i)r[i]=t(e[i],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zt(t,e,n){const s=eo(e);return wa(t,s,n)}function wa(t,e,n){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;ot(o,t);const a=i,l=a.data.get(o.dataId).values;let u;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=ci(l)}else u=l;const c=n||o.dtype,h=e(u,c,r);return a.makeTensorInfo(o.shape,c,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lP=eo(t=>Math.ceil(t)),wie=wa(cc,lP),Sie={kernelName:cc,backendName:"cpu",kernelFunc:wie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uP(t,e,n,s){const r=_n(n,oe(e));if(s&&n!=="string"){let i=0;t.forEach(o=>{const a=oe(o.shape);r.set(o.vals,i),i+=a})}else{let i=0;t.forEach(o=>{const a=n==="string"?ci(o.vals):o.vals;let l=0;for(let u=0;u<o.shape[0];++u){const c=u*e[1]+i;for(let h=0;h<o.shape[1];++h)r[c+h]=a[l++]}i+=o.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cP=Wn((t,e)=>t===e?1:0),hP=os(hf,cP,null,"bool"),Cie={kernelName:hf,backendName:"cpu",kernelFunc:hP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dP=eo(t=>Math.exp(t)),fP=wa(xc,dP,"float32"),Tie={kernelName:xc,backendName:"cpu",kernelFunc:fP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pP=eo(t=>Math.expm1(t)),Iie=wa(bc,pP),kie={kernelName:bc,backendName:"cpu",kernelFunc:Iie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mP=eo(t=>Math.floor(t)),Eie=wa(yc,mP),_ie={kernelName:yc,backendName:"cpu",kernelFunc:Eie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gP=Wn((t,e)=>Math.floor(t/e)),$ie=os(vc,gP,null,"int32"),Rie={kernelName:vc,backendName:"cpu",kernelFunc:$ie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xP(t,e,n,s,r,i,o,a,l){const u=Ct([s,i],n);for(let c=0;c<s;c++){const h=[];let d=0;for(let f=0;f<r;f++){const p=t[c*r+f];d+=p*o[f],h.push(p)}if(d<0||d>=l/i)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let f=0;f<i;f++)u.values[c*i+f]=e.get(...e.indexToLoc(d*i+f))}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bP(t,e,n){const s=Ct(n,t.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),a=o[0],l=o[2],u=e.locToIndex([a,l]);o[2]=e.values[u];const c=t.locToIndex(o);0<=c&&c<t.values.length&&(s.values[r]=t.values[c])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yP=Wn((t,e)=>t>e?1:0),Aie=os(mf,yP,null,"bool"),Pie={kernelName:mf,backendName:"cpu",kernelFunc:Aie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vP=Wn((t,e)=>t>=e?1:0),Die=os(wc,vP,null,"bool"),Nie={kernelName:wc,backendName:"cpu",kernelFunc:Die};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wP=Wn((t,e)=>t<e?1:0),Mie=os(xf,wP,null,"bool"),Lie={kernelName:xf,backendName:"cpu",kernelFunc:Mie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SP=Wn((t,e)=>t<=e?1:0),Oie=os(bf,SP,null,"bool"),Fie={kernelName:bf,backendName:"cpu",kernelFunc:Oie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CP(t,e,n){const s=(e-t)/(n-1),r=vs(n,"float32");r[0]=t;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TP=eo(t=>Math.log(t)),Uie=wa(kc,TP),Bie={kernelName:kc,backendName:"cpu",kernelFunc:Uie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IP(t,e,n,s){const r=cs(s,oe(n));for(let i=0;i<r.length;++i){const o=i*e;let a=t[o];for(let l=0;l<e;++l){const u=t[o+l];(Number.isNaN(u)||u>a)&&(a=u)}r[i]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kP=Wn((t,e)=>Math.max(t,e)),zie=os(_c,kP),Gie={kernelName:_c,backendName:"cpu",kernelFunc:zie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EP=Wn((t,e)=>Math.min(t,e)),Vie=os($c,EP),Wie={kernelName:$c,backendName:"cpu",kernelFunc:Vie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j2=Wn((t,e)=>t*e),Hie=H2((t,e,n,s)=>({real:t*n-e*s,imag:t*s+e*n})),Ax=os(Ac,j2,Hie),Kie={kernelName:Ac,backendName:"cpu",kernelFunc:Ax};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _P(t,e,n){const s=ma(-1,n);return j2([],e,s,t,n)}function jie(t){const{inputs:e,backend:n}=t,{x:s}=e;ot(s,"neg");const r=n.data.get(s.dataId).values,[i,o]=_P(r,s.shape,s.dtype);return n.makeTensorInfo(o,s.dtype,i)}const Xie={kernelName:$f,backendName:"cpu",kernelFunc:jie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $P=Wn((t,e)=>t!==e?1:0),qie=os(Rf,$P,null,"bool"),Yie={kernelName:Rf,backendName:"cpu",kernelFunc:qie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X2(t,e,n,s,r){const i=e.length,o=oe(e),a=lt(e),l=lt(r),u=cs(n,oe(r));for(let c=0;c<o;++c){const h=tc(c,i,a),d=new Array(h.length);for(let p=0;p<d.length;p++)d[p]=h[s[p]];const f=zi(d,i,l);u[f]=t[c]}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function er(t){const{inputs:e,attrs:n,backend:s}=t,{x:r}=e,{perm:i}=n;ot(r,"transpose");const o=r.shape.length,a=new Array(o);for(let h=0;h<a.length;h++)a[h]=r.shape[i[h]];const l=s.data.get(r.dataId).values,u=X2(l,r.shape,r.dtype,i,a);return{dataId:s.write(u,a,r.dtype),shape:a,dtype:r.dtype}}const Zie={kernelName:rl,backendName:"cpu",kernelFunc:er};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RP(t,e,n,s){const[r,i]=Gn(t,s),o=hs(e,"int32"),a=vs(oe(r),o),l=oe(i);for(let u=0;u<a.length;++u){const c=u*l;let h=1;for(let d=0;d<l;++d)h*=n[c+d];a[u]=h}return{outVals:a,outShape:r,outDtype:o}}function Qie(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;ot(r,"prod");const a=r.shape.length,l=wt(i,r.shape),u=Jt(l,a);let c=l,h=r;const d=[];u!=null&&(h=er({inputs:{x:r},backend:n,attrs:{perm:u}}),d.push(h),c=an(c.length,a));const f=n.data.get(h.dataId).values,{outVals:p,outShape:g,outDtype:m}=RP(h.shape,h.dtype,f,c);let x=g;return o&&(x=zn(g,l)),d.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(x,m,p)}const Jie={kernelName:Lf,backendName:"cpu",kernelFunc:Qie};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eoe(t,e,n){t.forEach((s,r)=>{if(s<0||s>=n){const i=tc(r,e.length,lt(e)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${n})`)}})}function toe(t,e){for(let n=0;n<t.length;++n){const s=t[n],r=n===t.length-1?e:t[n+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function noe(t,e,n,s){const r=[];let i=0;const o=e.length-1+n.length,a=new Array(o).fill(null).map(()=>[0]);toe(n,s);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const c=e[u+1];for(let h=1;h<l+1;++h)a[u].push(h*c)}for(let u=0;u<t.length;++u){let c=t[u],h=t[u]+1;for(let d=0;d<n.length;++d){const f=n[d],p=d+e.length-1;if(p>=0){const g=a[p],m=g[g.length-1]-f[c];for(let x=c;x<h;++x)a[p].push(f[x+1]+m)}c=f[c],h=f[h]}h!==c&&(r.push([c,h]),i+=h-c)}return{outSplits:a,valueSlices:r,numValues:i}}function soe(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n].length,r=_n("int32",s);e.push(r),t[n].forEach((i,o)=>r[o]=i)}return e}function h3(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let s=e;s<t.length;s++)n[e-1]*=t[s];return n}function roe(t,e,n,s,r,i){const o=h3(e,2)[1],a=h3(i,2)[1];let l=0;for(const u of n)for(let c=u[0];c<u[1];++c){for(let h=0;h<s;++h)r[l*a+h]=t[c*o+h];++l}}function ioe(t,e,n,s,r){const i=e.slice();i[0]=r;const o=_n(n,oe(i)),a=t.length,l=a===0?0:a/e[0];return roe(t,e,s,l,o,i),[o,i]}function AP(t,e,n,s,r,i,o,a){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(eoe(i,o,l),s.length===0)throw new Error("params.rank must be nonzero");const u=s[0],{outSplits:c,valueSlices:h,numValues:d}=noe(i,o,t,u),f=soe(c),p=ioe(n,s,r,h,d);return[f,p[0],p[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d3=2147483647;function PP(t,e,n,s,r,i,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=r.length===0,u=o.length===0,c=[];a||c.push(e[0]),l||c.push(r[0]),u||c.push(o[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const h=c.length===0?1:c[0],d=_n("int32",h+1);d[0]=0;for(let m=0;m<h;++m){const x=a?t[0]:t[m],b=l?s[0]:s[m],v=u?i[0]:i[m];if(v===0)throw new Error("Requires delta != 0");let y;if(v>0&&b<x||v<0&&b>x)y=0;else if(y=Math.ceil(Math.abs((b-x)/v)),y>d3)throw new Error(`Requires ((limit - start) / delta) <= ${d3}`);d[m+1]=d[m]+y}const f=d[h],p=_n(n,f);let g=0;for(let m=0;m<h;++m){const x=d[m+1]-d[m];let b=a?t[0]:t[m];const v=u?i[0]:i[m];for(let y=0;y<x;++y)p[g++]=b,b+=v}return[d,p]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Nr=Jr;class fg{constructor(e,n,s,r,i,o,a,l,u,c){this.shape=e,this.shapeShape=n,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=b$(c),this.raggedRank=y$(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Nr.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Nr.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Nr.VALUE_ROWIDS:return fg.getMaxWidthValueRowID(n);case Nr.ROW_SPLITS:return fg.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Nr[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let s=0;for(let r=0;r<n-1;++r){const i=e[r+1]-e[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let s=0,r=e[0],i=0;for(let o=1;o<n;++o){const a=e[o];a!==r&&(r=a,i=Math.max(o-s,i),s=o)}return Math.max(n-s,i)}tensorShapeFromTensor(e,n,s=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return p3(e,s)}calculateOutputSize(e){const n=this.valuesShape,s=this.defaultValueShape;v$(s,n);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=x$(this.raggedRank,r,n);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,n,s){const r=Math.min(e,s),i=[];let o=0;for(let a=0;a<r;++a,o+=n)i.push(o);for(let a=r;a<e;++a)i.push(-1);return G(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,n,s,r){const i=e.length,o=[];for(let a=0;a<i-1;++a){const l=e[a+1]-e[a];let u=Math.min(r,l),c=n[a];c===-1&&(u=0);for(let h=0;h<u;++h)o.push(c),c+=s;for(let h=0;h<l-u;++h)o.push(-1)}if(i>0&&o.length!==e[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,n,s,r){const i=e.length,o=[];if(i===0)return[];let a=0,l=e[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];o.push(u);for(let c=1;c<i;++c){const h=e[c];if(h===l)u>=0&&(++a,a<r?u+=s:u=-1);else{if(a=0,l=h,h>=n.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${n.length}`);u=n[h]}o.push(u)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,n,s,r){const i=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case Nr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,n,s,r);case Nr.ROW_SPLITS:if(i.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(i,n,s,r);default:throw new Error(`Unsupported partition type: ${Nr[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case Nr.FIRST_DIM_SIZE:return e[0];case Nr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Nr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Nr[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),s=this.calculateOutputSize(n),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const i=p3(s,!1),o=_n(this.valuesDType,oe(i));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(n,r[0],s[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,r[u],s[u]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(e,n,s,r){if(s.length===0)return;const i=this.values,o=s;let a=r.slice();a=a.slice(e+1);const l=oe(a),u=n.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const p=this.defaultValueShape;de(()=>{const g=ie(c,p);c=nd(g,a).dataSync()})}let h=0,d=0,f=0;for(let p=0;p<=u;++p){let g=p<u?n[p]:-1;if(g===f){++f;continue}if(d<f){const m=i.subarray(h*l),x=o.subarray(d*l),b=(f-d)*l;f3(x,m,b)}if(p>=u){const m=s.length;g=Math.floor(m/l)}if(g>f)if(this.defaultValue.length===1)o.subarray(f*l,g*l).fill(this.defaultValue[0]),f=g;else for(;g>f;){const m=o.slice(f*l);f3(m,c,l),++f}g<0?(h=p+1,d=f):(h=p,d=f,f=d+1)}}}function f3(t,e,n){for(let s=0;s<n;s++)t[s]=e[s]}function p3(t,e){const n=[];for(let s of t){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}n.push(s)}return n}function DP(t,e,n,s,r,i,o,a,l,u){return new fg(t,e,n,s,r,i,o,a,l,u).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NP(t,e,n,s){const r=t===e,i=t<e&&n<0,o=e<t&&n>1;if(r||i||o)return vs(0,s);const a=Math.abs(Math.ceil((e-t)/n)),l=vs(a,s);e<t&&n===1&&(n=-1),l[0]=t;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MP=eo(t=>1/Math.sqrt(t)),ooe=wa(Oc,MP),aoe={kernelName:Oc,backendName:"cpu",kernelFunc:ooe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ya(t,e,n,s,r,i,o,a,l,u){const c=[s/r,r],h=t.values,d=e.values;if(s===0)return Ct(n,e.dtype);const f=l instanceof bs?l:Ct(c,e.dtype);typeof l=="string"||typeof l=="number"?f.values.fill(l):typeof l=="boolean"&&f.values.fill(+l);for(let p=0;p<i;p++){const g=[];let m=0;for(let x=0;x<o;x++){const b=h[p*o+x];g.push(b),m+=b*a[x]}if(m<0||m>=s/r)throw new Error(`Invalid indices: ${g} does not index into ${n}`);for(let x=0;x<r;x++)u?f.values[m*r+x]+=d[p*r+x]:f.values[m*r+x]=e.rank===0?d[0]:d[p*r+x]}return f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const loe=eo(t=>1/(1+Math.exp(-t))),LP=Zt(Gc,t=>1/(1+Math.exp(-t))),uoe={kernelName:Gc,backendName:"cpu",kernelFunc:LP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OP(t,e,n,s,r){const i=b2(s,e,n),o=oe(n),a=lt(s);if(i){const h=y2(e,a);return r==="string"?t.slice(h,h+o):t.subarray(h,h+o)}const l=r==="string"?ci(t):t,u=Ct(s,r,l),c=Ct(n,r);for(let h=0;h<c.size;++h){const d=c.indexToLoc(h),f=d.map((p,g)=>p+e[g]);c.set(u.get(...f),...d)}return r==="string"?U$(c.values):c.values}function wl(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,size:o}=s;ot(r,"slice");const[a,l]=ep(r,i,o);J0(r,a,l);const u=n.data.get(r.dataId).values,c=OP(u,a,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,c)}const coe={kernelName:Gf,backendName:"cpu",kernelFunc:wl};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FP(t,e,n,s,r,i,o){const a=e[0],l=i[0],u=new Array(l),c=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(E$(a));const m=_n(n,0),x=_n(r,0);return[m,[0,h],x,u,c]}let d=!0,f=0;const p=new Array(l).fill(0);for(let m=0;m<a;++m){const x=t[m*h];if(x<0)throw new Error(_$(m,x));if(x>=l)throw new Error($$(m,x,l));++p[x],d=d&&x>=f,f=x}let g=!0;for(let m=0;m<l;++m){const x=p[m]===0;u[m]=x,g=g&&!x,p[m]=Math.max(p[m],1),m>0&&(p[m]+=p[m-1])}if(g&&d){const m=t,x=s;for(let b=0;b<a;++b)c[b]=b;return[m,[a,h],x,u,c]}else{const m=p[l-1],x=_n(n,m*h),b=_n(r,m),v=new Array(l).fill(0);for(let y=0;y<a;++y){const C=t[y*h],I=v[C],$=(C===0?0:p[C-1])+I;v[C]++;for(let T=0;T<h;++T)x[$*h+T]=t[y*h+T];b[$]=s[y],c[y]=$}for(let y=0;y<l;++y)if(v[y]===0){const I=y===0?0:p[y-1];x[I*h+0]=y;for(let $=1;$<h;++$)x[I*h+$]=0;b[I]=o}return[x,[m,h],b,u,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UP(t,e,n,s,r){const i=oe(s),o=e[0],a=r.length,l=[];let u=1,c=-1;for(let m=0;m<a;++m){const x=r[m];if(x===-1){if(c!==-1)throw new Error(R$(c,m));c=m,l.push(1)}else{if(x<0)throw new Error(A$(m,x));u*=x,l.push(x)}}if(c!==-1){if(u<=0)throw new Error(P$());const m=Math.trunc(i/u);if(u*m!==i)throw new Error(D$(s,l));l[c]=m}if(oe(l)!==i)throw new Error(N$(s,l));const d=s.length,f=[];if(d>0){f[d-1]=1;for(let m=d-2;m>=0;--m)f[m]=f[m+1]*s[m+1]}const p=[];if(a>0){p[a-1]=1;for(let m=a-2;m>=0;--m)p[m]=p[m+1]*l[m+1]}const g=_n(n,o*a);for(let m=0;m<o;++m){let x=0;for(let b=0;b<d;++b)x+=t[m*d+b]*f[b];for(let b=0;b<a;++b)g[m*a+b]=Math.trunc(x/p[b]),x%=p[b]}return[g,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q2(t,e,n,s,r,i=!1,o=0){const a=s.length,l=[e[0],t.length/e[0]],u=l[1],h=a>0?r[a-1]+1:0;if(h<0)throw new Error(Y1());const d=e.slice();d[0]=h;const f=d.reduce((v,y)=>v*y,1),p=_n(n,f);if(a===0)return h>0&&p.fill(o),[p,d];if(h<=0)throw new Error(Y1());let g=0,m=1,x=0,b=r[g];for(;;){let v=0;if(m<a){if(v=r[m],b===v){++m;continue}if(b>=v)throw new Error(M$())}if(b<0||b>=h)throw new Error(L$(b,h));b>x&&p.fill(o,x*u,b*u);for(let y=g;y<m;++y){const C=s[y];if(C<0||C>=l[0])throw new Error(O$(y,s[y],l[0]));for(let I=0;I<u;I++)p[b*u+I]+=t[C*u+I]}if(i)for(let y=0;y<u;y++)p[b*u+y]/=m-g;if(g=m,++m,x=b+1,b=v,m>a)break}return x<h&&p.fill(o,x*u,h*u),[p,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hoe=eo(t=>Math.sqrt(t)),doe=Zt(Wc,t=>Math.sqrt(t)),foe={kernelName:Wc,backendName:"cpu",kernelFunc:doe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BP=Wn((t,e)=>{const n=t-e;return n*n}),poe=os(Hc,BP),moe={kernelName:Hc,backendName:"cpu",kernelFunc:poe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zP=eo((t,e)=>{const{pattern:n,replaceGlobal:s,rewrite:r}=e;return t.replace(new RegExp(n,s?"g":""),r)}),goe=wa($v,zP),xoe={kernelName:$v,backendName:"cpu",kernelFunc:goe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GP(t,e,n,s){const r=Ct(t,e.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*n[l]+s[l];r.set(e.get(...a),...o)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class boe{constructor(e,n,s,r,i,o){this.separator=vo(e),this.nGramWidths=n,this.leftPad=vo(s),this.rightPad=vo(r),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const s=this.getPadWidth(n);return Math.max(0,e+2*s-n+1)}createNGrams(e,n,s,r,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),u=Math.max(0,l-a),c=Math.max(0,l-(i-(a+1))),h=o-(u+c),d=n+(u>0?0:a-l);let f=0;f+=u*this.leftPad.length;for(let b=0;b<h;++b)f+=e[d+b].length;f+=c*this.rightPad.length;const p=u+c+h-1;f+=p*this.separator.length,s[r+a]=new Uint8Array(f);const g=s[r+a];let m=0;const x=b=>b.forEach(v=>g[m++]=v);for(let b=0;b<u;++b)x(this.leftPad),x(this.separator);for(let b=0;b<h-1;++b)x(e[d+b]),x(this.separator);if(h>0){x(e[d+h-1]);for(let b=0;b<c;++b)x(this.separator),x(this.rightPad)}else{for(let b=0;b<c-1;++b)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(e,n){const s=e.length,r=n.length;if(r>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<r;++u){let c=n[u]>=l;if(c=c&&n[u]<=s,!c)throw new Error(`Invalid split value ${n[u]}, must be in [${l}, ${s}]`);l=n[u]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const i=r-1,o=_n("int32",r);if(s===0||r===0){const l=new Array(s);for(let u=0;u<=i;++u)o[u]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const u=n[l]-n[l-1];let c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(u,h)}),this.preserveShort&&u>0&&c===0&&(c=1),o[l]=o[l-1]+c}const a=new Array(o[i]);for(let l=0;l<i;++l){const u=n[l];let c=o[l];if(this.nGramWidths.forEach(h=>{const d=n[l+1]-n[l],f=this.getNumNGrams(d,h);this.createNGrams(e,u,a,c,f,h),c+=f}),this.preserveShort&&c===o[l]){const h=n[l+1]-n[l];if(h===0)continue;const d=h+2*this.padWidth;this.createNGrams(e,u,a,c,1,d)}}return[a,o]}}function VP(t,e,n,s,r,i,o,a){return new boe(n,s,r,i,o,a).compute(t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yoe(t,e,n,s){if(!t.length)return;if(e.length===0){for(let i=0;i<t.length;++i)s.push(t.subarray(i,i+1));return}if(e.length===1){const i=e[0];let o=t.indexOf(i);for(;o!==-1;){const a=t.subarray(0,o);(!n||a.length!==0)&&s.push(a),t=t.subarray(o+1),o=t.indexOf(i)}(!n||t.length!==0)&&s.push(t);return}let r=0;for(let i=0;i<t.length+1;i++)if(i===t.length||e.indexOf(t[i])!==-1){const o=t.subarray(r,i);(!n||o.length!==0)&&s.push(o),r=i+1}}function WP(t,e,n){const s=t.length,r=[];let i=0,o=0;const a=new Array(s);for(let d=0;d<s;++d){const f=r.length;yoe(t[d],e,n,r);const p=r.length-f;a[d]=p,i+=p,o=Math.max(o,p)}const l=_n("int32",i*2),u=new Array(i),c=[s,o];let h=0;for(let d=0;d<s;++d)for(let f=0;f<a[d];++f)l[h*2]=d,l[h*2+1]=f,u[h]=r[h],++h;return[l,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HP(t,e){const n=_n("int32",t.length);for(let s=0;s<t.length;++s)n[s]=JX(t[s]).modulo(e).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KP=Wn((t,e)=>t-e),voe=H2((t,e,n,s)=>({real:t-n,imag:e-s})),Y2=os(Kc,KP,voe),woe={kernelName:Kc,backendName:"cpu",kernelFunc:Y2};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jP(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const s=Ct(n,t.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),o=new Array(t.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%t.shape[l];const a=t.locToIndex(o);s.values[r]=t.values[a]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oh=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function XP(t,e,n=0,s=t.length-1){for(;s>n;){if(s-n>600){const a=s-n+1,l=e-n+1,u=Math.log(a),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2),d=Math.max(n,Math.floor(e-l*c/a+h)),f=Math.min(s,Math.floor(e+(a-l)*c/a+h));XP(t,e,d,f)}const r=t[e];let i=n,o=s;for(gu(t,n,e),Oh(t[s],r)>0&&gu(t,n,s);i<o;){for(gu(t,i,o),i++,o--;Oh(t[i],r)<0;)i=i+1;for(;Oh(t[o],r)>0;)o=o-1}Oh(t[n],r)===0?gu(t,n,o):(o=o+1,gu(t,o,s)),o<=e&&(n=o+1),e<=o&&(s=o-1)}}function qP(t,e,n,s,r){const i=e[e.length-1],[o,a]=[t.length/i,i],l=cs(n,o*s),u=cs("int32",o*s);for(let h=0;h<o;h++){const d=h*a,f=t.subarray(d,d+a);let p=new Array(f.length);f.forEach((b,v)=>p[v]={value:b,index:v}),s<p.length&&(XP(p,s),p=p.slice(0,s)),r&&p.sort(Oh);const g=h*s,m=l.subarray(g,g+s),x=u.subarray(g,g+s);for(let b=0;b<s;b++)m[b]=p[b].value,x[b]=p[b].index}const c=e.slice();return c[c.length-1]=s,[Ct(c,n,l),Ct(c,"int32",u)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YP(t,e,n,s){const r=wt(e,n)[0],i=[1,n[0],1];for(let p=0;p<r;p++)i[0]*=n[p];i[1]=n[r];for(let p=r+1;p<n.length;p++)i[2]*=n[p];const o=new Map,a=new Int32Array(n[r]),l=new bs(i,s,t),u=[],c=i[0]===1&&i[2]===1;for(let p=0;p<n[r];p++){let g;if(c)g=t[p].toString();else{const x=[];for(let b=0;b<i[0];b++)for(let v=0;v<i[2];v++)x.push(l.get(b,p,v));g=x.join(",")}const m=o.get(g);if(m!=null)a[p]=m;else{const x=o.size;o.set(g,x),a[p]=x,u.push(p)}}const h=i.slice();h[1]=o.size;const d=new bs(h,s);u.forEach((p,g)=>{for(let m=0;m<i[0];m++)for(let x=0;x<i[2];x++)d.set(l.get(m,p,x),m,g,x)});const f=n.slice();return f[r]=h[1],{outputValues:d.values,outputShape:f,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZP=Object.freeze(Object.defineProperty({__proto__:null,addImpl:iP,bincountImpl:K2,bincountReduceImpl:oP,bitwiseAndImpl:aP,castImpl:rP,ceilImpl:lP,concatImpl:uP,equalImpl:cP,expImpl:dP,expm1Impl:pP,floorDivImpl:gP,floorImpl:mP,gatherNdImpl:xP,gatherV2Impl:bP,greaterEqualImpl:vP,greaterImpl:yP,lessEqualImpl:SP,lessImpl:wP,linSpaceImpl:CP,logImpl:TP,maxImpl:IP,maximumImpl:kP,minimumImpl:EP,multiplyImpl:j2,negImpl:_P,notEqualImpl:$P,prodImpl:RP,raggedGatherImpl:AP,raggedRangeImpl:PP,raggedTensorToTensorImpl:DP,rangeImpl:NP,rsqrtImpl:MP,scatterImpl:Ya,sigmoidImpl:loe,simpleAbsImpl:sP,sliceImpl:OP,sparseFillEmptyRowsImpl:FP,sparseReshapeImpl:UP,sparseSegmentReductionImpl:q2,sqrtImpl:hoe,squaredDifferenceImpl:BP,staticRegexReplaceImpl:zP,stridedSliceImpl:GP,stringNGramsImpl:VP,stringSplitImpl:WP,stringToHashBucketFastImpl:HP,subImpl:KP,tileImpl:jP,topKImpl:qP,transposeImpl:X2,uniqueImpl:YP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Mv("cpu",()=>new Rx,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QP=Zt(mc,t=>t>=0?t:Math.exp(t)-1),Soe={kernelName:mc,backendName:"cpu",kernelFunc:QP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JP(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:i}=s;ot([r],"leakyRelu");const o=oe(r.shape),a=n.data.get(r.dataId).values,l=cs("float32",o);for(let u=0;u<a.length;u++)l[u]=a[u]<0?i*a[u]:a[u];return n.makeTensorInfo(r.shape,"float32",l)}const Coe={kernelName:gf,backendName:"cpu",kernelFunc:JP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Toe=Wn((t,e)=>t<0?e*t:t);function eD(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e;ot([s,r],"prelu");const i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,[a,l]=Toe(s.shape,r.shape,i,o,"float32");return n.makeTensorInfo(l,"float32",a)}const Ioe={kernelName:Mf,backendName:"cpu",kernelFunc:eD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tD=Zt(Nc,t=>Math.max(0,t)),koe={kernelName:Nc,backendName:"cpu",kernelFunc:tD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nD=Zt(Mc,t=>Math.min(Math.max(0,t),6)),Eoe={kernelName:Mc,backendName:"cpu",kernelFunc:nD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pg(t,e,n,s,r){if(n==="linear")return qi({inputs:{x:e},backend:t});if(n==="relu")return tD({inputs:{x:e},backend:t});if(n==="elu")return QP({inputs:{x:e},backend:t});if(n==="relu6")return nD({inputs:{x:e},backend:t});if(n==="prelu")return eD({inputs:{x:e,alpha:s},backend:t});if(n==="leakyrelu")return JP({inputs:{x:e},backend:t,attrs:{alpha:r}});if(n==="sigmoid")return LP({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function on(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:i}=s,o=oe(r.shape),a=cv(i,o),l=oe(a);G(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);const u=n.data.get(r.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;c.shape=a,h.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const _oe={kernelName:Of,backendName:"cpu",kernelFunc:on};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sD(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;ot([r,i],"matMul");const l=r.shape.length,u=i.shape.length,c=o?r.shape[l-2]:r.shape[l-1],h=a?i.shape[u-1]:i.shape[u-2],d=o?r.shape[l-1]:r.shape[l-2],f=a?i.shape[u-2]:i.shape[u-1],p=r.shape.slice(0,-2),g=i.shape.slice(0,-2),m=oe(p),x=oe(g),v=pt(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([d,f]);G(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const y=o?[m,c,d]:[m,d,c],C=a?[x,f,h]:[x,h,f],I=on({inputs:{x:r},backend:n,attrs:{shape:y}}),$=on({inputs:{x:i},backend:n,attrs:{shape:C}}),T=o?I.shape[1]:I.shape[2],S=o?I.shape[2]:I.shape[1],E=a?$.shape[1]:$.shape[2],_=Math.max(m,x),N=n.data.get(I.dataId).values,P=n.data.get($.dataId).values,M=lt(I.shape),z=lt($.shape),[A,B,L]=o?[M[0],1,M[1]]:[M[0],M[1],1],[U,j,Z]=a?[1,z[1],z[0]]:[z[1],1,z[0]],J=S*E,se=Ct([_,S,E],I.dtype),fe=se.values,he=n.blockSize;for(let ve=0;ve<_;ve++){const Pe=ve%m,Ee=ve%x;for(let Se=0;Se<S;Se+=he){const ze=Math.min(Se+he,S);for(let ke=0;ke<E;ke+=he){const H=Math.min(ke+he,E);for(let K=0;K<T;K+=he){const re=Math.min(K+he,T);for(let pe=Se;pe<ze;pe++)for(let me=ke;me<H;me++){let xe=0;for(let Te=K;Te<re;Te++){const De=N[Pe*A+pe*B+Te*L],Re=P[Te*U+me*j+Ee*Z];xe+=De*Re}fe[ve*J+(pe*E+me)]+=xe}}}}}return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo($),n.makeTensorInfo(v,se.dtype,se.values)}const $oe={kernelName:ef,backendName:"cpu",kernelFunc:sD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Roe(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;let d,f,p;const g=[];d=sD({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:u},backend:n}),o&&(f=Wu({inputs:{a:d,b:o},backend:n}),g.push(d),d=f),c&&(p=pg(n,d,c,a,h),g.push(d),d=p);for(const x of g)n.disposeIntermediateTensorInfo(x);return d}const Aoe={kernelName:wd,backendName:"cpu",kernelFunc:Roe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Poe=Zt(nc,t=>Math.acos(t)),Doe={kernelName:nc,backendName:"cpu",kernelFunc:Poe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Noe=Zt(sc,t=>Math.acosh(t)),Moe={kernelName:sc,backendName:"cpu",kernelFunc:Noe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Loe(t){const{inputs:e,backend:n}=t,s=e;ot(e,"addN");const r=s.map(a=>n.data.get(a.dataId).values),i=Ct(s[0].shape,s[0].dtype),o=i.values;for(let a=0;a<s.length;a++){const l=r[a];for(let u=0;u<o.length;u++)o[u]+=l[u]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}const Ooe={kernelName:s0,backendName:"cpu",kernelFunc:Loe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Foe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;ot(r,"all");const a=wt(i,r.shape);let l=a;const u=Jt(l,r.shape.length);let c=r;u!=null&&(c=er({inputs:{x:r},backend:n,attrs:{perm:u}}),l=an(l.length,r.shape.length)),qn("all",l,c.shape.length);const[h,d]=Gn(c.shape,l),f=oe(d),p=vs(oe(h),c.dtype),g=n.data.get(c.dataId).values;for(let x=0;x<p.length;++x){const b=x*f;let v=g[b];for(let y=0;y<f;++y){const C=g[b+y];v=v&&C}p[x]=v}u!=null&&n.disposeIntermediateTensorInfo(c);const m=n.makeTensorInfo(h,c.dtype,p);if(o){const x=zn(h,a),b=on({inputs:{x:m},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(m),b}return m}const Uoe={kernelName:r0,backendName:"cpu",kernelFunc:Foe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Boe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;ot(r,"any");const a=wt(i,r.shape);let l=a;const u=Jt(l,r.shape.length);let c=r;u!=null&&(c=er({inputs:{x:r},backend:n,attrs:{perm:u}}),l=an(l.length,r.shape.length)),qn("any",l,c.shape.length);const[h,d]=Gn(c.shape,l),f=oe(d),p=vs(oe(h),c.dtype),g=n.data.get(c.dataId).values;for(let x=0;x<p.length;++x){const b=x*f;let v=g[b];for(let y=0;y<f;++y){const C=g[b+y];v=v||C}p[x]=v}u!=null&&n.disposeIntermediateTensorInfo(c);const m=n.makeTensorInfo(h,c.dtype,p);if(o){const x=zn(h,a),b=on({inputs:{x:m},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(m),b}return m}const zoe={kernelName:i0,backendName:"cpu",kernelFunc:Boe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Goe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;ot(r,"argMax");let o=wt(i,r.shape);const a=Jt(o,r.shape.length);let l=r;const u=[];a!=null&&(l=er({inputs:{x:r},backend:n,attrs:{perm:a}}),u.push(l),o=an(o.length,l.shape.length)),o=[o[0]],qn("argMax",o,l.shape.length);const[c,h]=Gn(l.shape,o),d=oe(c),f=vs(d,"int32"),p=oe(h),g=n.data.get(l.dataId).values;for(let m=0;m<f.length;++m){const x=m*p;let b=g[x],v=0;for(let y=0;y<p;++y){const C=g[x+y];C>b&&(b=C,v=y)}f[m]=v}return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),n.makeTensorInfo(c,"int32",f)}const Voe={kernelName:Yd,backendName:"cpu",kernelFunc:Goe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Woe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;ot(r,"argMin");let o=wt(i,r.shape);const a=Jt(o,r.shape.length);let l=r;const u=[];a!=null&&(l=er({inputs:{x:r},backend:n,attrs:{perm:a}}),u.push(l),o=an(o.length,l.shape.length)),o=[o[0]],qn("argMin",o,l.shape.length);const[c,h]=Gn(l.shape,o),d=oe(c),f=vs(d,"int32"),p=oe(h),g=n.data.get(l.dataId).values;for(let m=0;m<f.length;++m){const x=m*p;let b=g[x],v=0;for(let y=0;y<p;++y){const C=g[x+y];C<b&&(b=C,v=y)}f[m]=v}return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),n.makeTensorInfo(c,"int32",f)}const Hoe={kernelName:Zd,backendName:"cpu",kernelFunc:Woe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Koe=Zt(rc,t=>Math.asin(t)),joe={kernelName:rc,backendName:"cpu",kernelFunc:Koe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xoe=Zt(ic,t=>Math.asinh(t)),qoe={kernelName:ic,backendName:"cpu",kernelFunc:Xoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yoe=Zt(oc,t=>Math.atan(t)),Zoe={kernelName:oc,backendName:"cpu",kernelFunc:Yoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qoe=Wn((t,e)=>Math.atan2(t,e)),Joe=os(lc,Qoe),eae={kernelName:lc,backendName:"cpu",kernelFunc:Joe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tae=Zt(ac,t=>Math.atanh(t)),nae={kernelName:ac,backendName:"cpu",kernelFunc:tae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z2(t,e,n,s,r,i){const o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,f=r.padInfo.left,p=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Ct(r.outShape,n),m=g.values,x=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let y=0;y<r.batchSize;++y){const C=y*x,I=y*s[0];for(let $=0;$<r.inChannels;++$)for(let T=0;T<r.outHeight;++T){const S=T*o-d,E=Math.max(0,S),_=Math.min(r.inHeight,c+S),N=C+T*b;for(let P=0;P<r.outWidth;++P){const M=P*a-f,z=Math.max(0,M),A=Math.min(r.inWidth,h+M);let B=p,L=0,U=0;for(let Z=E;Z<_;Z+=l){const J=I+Z*s[1];for(let se=z;se<A;se+=u){const fe=J+se*s[2],he=t[fe+$];i==="max"&&he>B?B=he:i==="avg"&&(L+=he,U++)}if(isNaN(B))break}const j=N+P*v+$;m[j]=i==="avg"?L/U:B}}}return g}function rD(t,e,n,s,r=!1,i=!1){const o=Ct(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,f=s.padInfo.top,p=s.padInfo.left,g=Ct(e,n,t);for(let m=0;m<s.batchSize;++m)for(let x=0;x<s.inChannels;++x)for(let b=0;b<s.outHeight;++b){const v=b*a-f;let y=v;for(;y<0;)y+=u;const C=Math.min(s.inHeight,h+v);for(let I=0;I<s.outWidth;++I){const $=I*l-p;let T=$;for(;T<0;)T+=c;const S=Math.min(s.inWidth,d+$);let E=Number.NEGATIVE_INFINITY,_=-1;for(let N=y;N<C;N+=u){const P=N-v;for(let M=T;M<S;M+=c){const z=M-$,A=g.get(m,N,M,x);A>E&&(E=A,r?_=i?((m*s.inHeight+N)*s.inWidth+M)*s.inChannels+x:(N*s.inWidth+M)*s.inChannels+x:_=P*d+z)}}o.set(_,m,b,I,x)}}return o}function iD(t,e,n,s,r,i){const o=r.strideDepth,a=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,f=r.effectiveFilterHeight,p=r.effectiveFilterWidth,g=r.padInfo.front,m=r.padInfo.top,x=r.padInfo.left,b=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Ct(r.outShape,n),y=v.values,C=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[2]*r.outShape[3]*r.outShape[4],$=r.outShape[3]*r.outShape[4],T=r.outShape[4];for(let S=0;S<r.batchSize;++S){const E=S*C,_=S*s[0];for(let N=0;N<r.inChannels;++N)for(let P=0;P<r.outDepth;++P){const M=P*o-g;let z=M;for(;z<0;)z+=u;const A=Math.min(r.inDepth,d+M),B=E+P*I;for(let L=0;L<r.outHeight;++L){const U=L*a-m;let j=U;for(;j<0;)j+=c;const Z=Math.min(r.inHeight,f+U),J=B+L*$;for(let se=0;se<r.outWidth;++se){const fe=se*l-x;let he=fe;for(;he<0;)he+=h;const ve=Math.min(r.inWidth,p+fe),Pe=J+se*T;let Ee=b,Se=0,ze=0;for(let H=z;H<A;H+=u){const K=_+H*s[1];for(let re=j;re<Z;re+=c){const pe=K+re*s[2];for(let me=he;me<ve;me+=h){const xe=pe+me*s[3],Te=t[xe+N];if(i==="max"&&Te>Ee?Ee=Te:i==="avg"&&(Se+=Te,ze++),isNaN(Ee))break}if(isNaN(Ee))break}if(isNaN(Ee))break}const ke=Pe+N;y[ke]=i==="avg"?Se/Math.max(ze,1):Ee}}}}return v}function sae(t,e){const n=Ct(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,f=e.padInfo.top,p=e.padInfo.left;for(let g=0;g<e.batchSize;++g)for(let m=0;m<e.inChannels;++m)for(let x=0;x<e.outDepth;++x){const b=x*s-d;let v=b;for(;v<0;)v+=o;const y=Math.min(e.inDepth,u+b);for(let C=0;C<e.outHeight;++C){const I=C*r-f;let $=I;for(;$<0;)$+=a;const T=Math.min(e.inHeight,c+I);for(let S=0;S<e.outWidth;++S){const E=S*i-p;let _=E;for(;_<0;)_+=l;const N=Math.min(e.inWidth,h+E);let P=Number.NEGATIVE_INFINITY,M=-1;for(let z=v;z<y;z+=o){const A=z-b;for(let B=$;B<T;B+=a){const L=B-I;for(let U=_;U<N;U+=l){const j=U-E,Z=t.get(g,z,B,U,m);Z>=P&&(P=Z,M=A*c*h+L*c+j)}}}n.set(M,g,x,C,S,m)}}}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;ot(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,u=1;G(ds(o,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=ks(r.shape,i,o,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&Pt(c.inShape,c.outShape))h=qi({inputs:{x:r},backend:n});else{const d=n.data.get(r.dataId).values,f=lt(r.shape),p=Z2(d,r.shape,r.dtype,f,c,"avg");h=n.makeTensorInfo(c.outShape,r.dtype,p.values)}return h}const iae={kernelName:Qd,backendName:"cpu",kernelFunc:rae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=s;ot(r,"avgPool3d");const c=Er(r.shape,i,o,1,a,l,u),h=n.data.get(r.dataId).values,d=iD(h,r.shape,r.dtype,lt(r.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}const aae={kernelName:Jd,backendName:"cpu",kernelFunc:oae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lae(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=s;ot([r,i],"avgPool3DGrad");const c=Er(i.shape,o,a,1,l,u),h=c.strideDepth,d=c.strideHeight,f=c.strideWidth,p=c.filterDepth,g=c.filterHeight,m=c.filterWidth,x=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,y=c.effectiveFilterDepth,C=c.effectiveFilterHeight,I=c.effectiveFilterWidth,$=y-1-c.padInfo.front,T=I-1-c.padInfo.left,S=C-1-c.padInfo.top,E=Ct(i.shape,"float32"),_=1/(p*g*m),N=n.bufferSync(r);for(let P=0;P<c.batchSize;++P)for(let M=0;M<c.inChannels;++M)for(let z=0;z<c.inDepth;++z)for(let A=0;A<c.inHeight;++A)for(let B=0;B<c.inWidth;++B){const L=z-$,U=A-S,j=B-T;let Z=0;for(let J=0;J<y;J+=x){const se=(L+J)/h;if(!(se<0||se>=c.outDepth||Math.floor(se)!==se))for(let fe=0;fe<C;fe+=b){const he=(U+fe)/d;if(!(he<0||he>=c.outHeight||Math.floor(he)!==he))for(let ve=0;ve<I;ve+=v){const Pe=(j+ve)/f;if(Pe<0||Pe>=c.outWidth||Math.floor(Pe)!==Pe)continue;const Ee=N.get(P,se,he,Pe,M);Z+=Ee}}}E.set(Z*_,P,z,A,B,M)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}const uae={kernelName:a0,backendName:"cpu",kernelFunc:lae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cae(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,o=i;ot([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=ks(o.shape,a,l,1,u),h=c.strideHeight,d=c.strideWidth,f=c.filterHeight,p=c.filterWidth,g=c.dilationHeight,m=c.dilationWidth,x=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,y=x-1-c.padInfo.top,C=Ct(o.shape,"float32"),I=1/(f*p),$=n.data.get(r.dataId).values,T=Ct(r.shape,"float32",$);for(let S=0;S<c.batchSize;++S)for(let E=0;E<c.inChannels;++E)for(let _=0;_<c.inHeight;++_)for(let N=0;N<c.inWidth;++N){const P=_-y,M=N-v;let z=0;for(let A=0;A<x;A+=g){const B=(P+A)/h;if(!(B<0||B>=c.outHeight||Math.floor(B)!==B))for(let L=0;L<b;L+=m){const U=(M+L)/d;if(U<0||U>=c.outWidth||Math.floor(U)!==U)continue;const j=T.get(S,B,U,E);z+=j}}C.set(z*I,S,_,N,E)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}const hae={kernelName:o0,backendName:"cpu",kernelFunc:cae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,scale:i,offset:o,mean:a,variance:l}=e;G(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),G(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),G(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ot([r,a,l,i,o],"batchNorm");let{varianceEpsilon:u}=s;u==null&&(u=.001);const c=n.data.get(r.dataId).values,h=n.data.get(a.dataId).values,d=n.data.get(l.dataId).values,f=i?n.data.get(i.dataId).values:new Float32Array([1]),p=o?n.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),m=p.length,x=f.length,b=d.length,v=h.length;let y=0,C=0,I=0,$=0;for(let T=0;T<c.length;++T)g[T]=p[y++]+(c[T]-h[C++])*f[I++]/Math.sqrt(d[$++]+u),y>=m&&(y=0),C>=v&&(C=0),I>=x&&(I=0),$>=b&&($=0);return n.makeTensorInfo(r.shape,r.dtype,g)}const fae={kernelName:ff,backendName:"cpu",kernelFunc:dae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,crops:o}=s;ot([r],"batchToSpaceND");const a=i.reduce((x,b)=>x*b),l=Ml(r.shape,i,a),u=Ll(l.length,i.length),c=Ol(r.shape,i,a),h=ix(o,i.length),d=ox(c,o,i.length),f=on({inputs:{x:r},backend:n,attrs:{shape:l}}),p=er({inputs:{x:f},backend:n,attrs:{perm:u}}),g=on({inputs:{x:p},backend:n,attrs:{shape:c}}),m=wl({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),m}const mae={kernelName:tf,backendName:"cpu",kernelFunc:pae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:o}=s,a=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,u=K2(a,l,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,u)}const xae={kernelName:l0,backendName:"cpu",kernelFunc:gae};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bae(t){const{inputs:e,backend:n}=t,{s0:s,s1:r}=e,i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,a=pt(Array.from(i),Array.from(o));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const yae={kernelName:gv,backendName:"cpu",kernelFunc:bae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vae=Zt(hc,(t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t}),wae={kernelName:hc,backendName:"cpu",kernelFunc:vae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sae=t=>{const{x:e}=t.inputs,n=t.backend,s=new Float32Array(oe(e.shape)),r=n.data.get(e.dataId),i=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,a=n.data.get(i.dataId).values,l=n.data.get(o.dataId).values;for(let u=0;u<a.length;u++){const c=a[u],h=l[u];s[u]=Math.hypot(c,h)}return n.makeOutput(s,e.shape,"float32")},Cae={kernelName:nf,backendName:"cpu",kernelFunc:Sae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hu(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.imag,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const Tae={kernelName:I0,backendName:"cpu",kernelFunc:Hu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ku(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,i=wt(r,e[0].shape)[0],o=e.map(g=>g.shape);nx(o,i);let a=Zs(e.map(g=>g.shape),i);if(oe(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(g=>oe(g.shape)>0);if(l.length===1)return qi({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){const g=l.map(y=>vl({inputs:{input:y},backend:n})),m=l.map(y=>Hu({inputs:{input:y},backend:n})),x=Ku({inputs:g,backend:n,attrs:{axis:i}}),b=Ku({inputs:m,backend:n,attrs:{axis:i}}),v=ar({inputs:{real:x,imag:b},backend:n});return g.forEach(y=>n.disposeIntermediateTensorInfo(y)),m.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(b),v}const u=l.map(g=>{const x=[-1,oe(g.shape.slice(i))];return on({inputs:{x:g},backend:n,attrs:{shape:x}})}),c=u.map(g=>({vals:n.data.get(g.dataId).values,shape:g.shape}));a=Zs(u.map(g=>g.shape),1);const h=u[0].shape[0]===1,d=uP(c,a,e[0].dtype,h),f=Zs(l.map(g=>g.shape),i),p=n.makeTensorInfo(f,e[0].dtype,d);return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),p}const Iae={kernelName:sf,backendName:"cpu",kernelFunc:Ku};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oD(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s;ot([r,i],"conv2d");const h=gr(l),d=gn(r.shape,i.shape,o,u,a,c,!1,h),f=d.filterHeight,p=d.filterWidth,g=d.dilationHeight,m=d.dilationWidth,x=d.padInfo.left,b=d.padInfo.top,v=d.dataFormat==="channelsLast",y=new bs(d.outShape,r.dtype),C=lt(r.shape),I=lt(i.shape),$=C[0],T=v?C[1]:C[2],S=v?C[2]:1,E=v?1:C[1],_=y.strides[0],N=v?y.strides[1]:y.strides[2],P=v?y.strides[2]:1,M=v?1:y.strides[1],z=n.data.get(r.dataId).values,A=n.data.get(i.dataId).values,B=y.values;for(let L=0;L<d.batchSize;++L){const U=L*$,j=L*_;for(let Z=0;Z<d.outHeight;++Z){const J=j+Z*N,se=Z*d.strideHeight-b;for(let fe=0;fe<f;++fe){const he=se+fe*g;if(he<0||he>=d.inHeight)continue;const ve=fe*I[0],Pe=U+he*T;for(let Ee=0;Ee<d.outWidth;++Ee){const Se=J+Ee*P,ze=Ee*d.strideWidth-x;for(let ke=0;ke<p;++ke){const H=ze+ke*m;if(H<0||H>=d.inWidth)continue;const K=ve+ke*I[1],re=Pe+H*S;let pe=K;for(let me=0;me<d.inChannels;++me){const xe=z[re+me*E];for(let Te=0;Te<d.outChannels;++Te)B[Se+Te*M]+=xe*A[pe+Te];pe+=d.outChannels}}}}}}return n.makeTensorInfo(y.shape,y.dtype,B)}const kae={kernelName:rf,backendName:"cpu",kernelFunc:oD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;ot([r,i],"conv2dBackpropFilter");const h=gr(l),d=gn(r.shape,c,o,1,a,u,!1,h),{strideHeight:f,strideWidth:p,filterHeight:g,filterWidth:m}=d,x=d.dataFormat==="channelsLast",b=new bs(d.filterShape,"float32"),v=d.padInfo.left,y=d.padInfo.top,C=n.data.get(r.dataId).values,I=n.data.get(i.dataId).values,$=new bs(r.shape,r.dtype,C),T=new bs(i.shape,i.dtype,I);for(let S=0;S<g;++S){const E=Math.max(0,Math.ceil((y-S)/f)),_=Math.min(d.outHeight,(d.inHeight+y-S)/f);for(let N=0;N<m;++N){const P=Math.max(0,Math.ceil((v-N)/p)),M=Math.min(d.outWidth,(d.inWidth+v-N)/p);for(let z=0;z<d.inChannels;++z)for(let A=0;A<d.outChannels;++A){let B=0;for(let L=0;L<d.batchSize;++L)for(let U=E;U<_;++U){const j=S+U*f-y;for(let Z=P;Z<M;++Z){const J=N+Z*p-v;x?B+=$.get(L,j,J,z)*T.get(L,U,Z,A):B+=$.get(L,z,j,J)*T.get(L,A,U,Z)}}b.set(B,S,N,z,A)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const _ae={kernelName:c0,backendName:"cpu",kernelFunc:Eae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ae(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s;ot([r,i],"conv2dBackpropInput");const h=lt(i.shape),d=lt(r.shape);let f=gr(u);const p=gn(o,i.shape,a,1,l,c,!1,f),g=new bs(p.inShape,"float32"),m=g.values,x=n.data.get(r.dataId).values,b=n.data.get(i.dataId).values,[v,y,C]=h,{batchSize:I,filterHeight:$,filterWidth:T,inChannels:S,inHeight:E,inWidth:_,outChannels:N,outHeight:P,outWidth:M,strideHeight:z,strideWidth:A}=p;f=p.dataFormat;const B=$-1-p.padInfo.top,L=T-1-p.padInfo.left,U=f==="channelsLast",j=g.strides[0],Z=U?g.strides[1]:g.strides[2],J=U?g.strides[2]:1,se=U?1:g.strides[1],fe=d[0],he=U?d[1]:d[2],ve=U?d[2]:1,Pe=U?1:d[1];for(let Ee=0;Ee<I;++Ee)for(let Se=0;Se<S;++Se)for(let ze=0;ze<E;++ze){const ke=ze-B,H=Math.max(0,Math.ceil(ke/z)),K=Math.min(P,($+ke)/z);for(let re=0;re<_;++re){const pe=re-L,me=Math.max(0,Math.ceil(pe/A)),xe=Math.min(M,(T+pe)/A);let Te=0;for(let Re=H;Re<K;++Re){const _e=Re*z-ke;for(let nt=me;nt<xe;++nt){const Ae=nt*A-pe,Je=fe*Ee+he*Re+ve*nt,tt=v*($-1-_e)+y*(T-1-Ae)+C*Se;for(let Tt=0;Tt<N;++Tt){const $t=x[Je+Pe*Tt],Ke=b[tt+Tt];Te+=$t*Ke}}}const De=j*Ee+Z*ze+J*re+se*Se;m[De]=Te}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const Rae={kernelName:of,backendName:"cpu",kernelFunc:$ae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s;ot([r,i],"conv3d");const u=gi(r.shape,i.shape,o,l,a),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:f,dilationHeight:p,dilationWidth:g,padInfo:m}=u,x=m.front,b=m.left,v=m.top,y=new bs(u.outShape,r.dtype),C=n.data.get(r.dataId).values,I=n.data.get(i.dataId).values,$=y.values,T=lt(r.shape),S=lt(i.shape);for(let E=0;E<u.batchSize;++E){const _=E*T[0],N=E*y.strides[0];for(let P=0;P<u.outDepth;++P){const M=N+P*y.strides[1],z=P*u.strideDepth-x;for(let A=0;A<c;++A){const B=z+A*f;if(B<0||B>=u.inDepth)continue;const L=A*S[0],U=_+B*T[1];for(let j=0;j<u.outHeight;++j){const Z=M+j*y.strides[2],J=j*u.strideHeight-v;for(let se=0;se<h;++se){const fe=J+se*p;if(fe<0||fe>=u.inHeight)continue;const he=L+se*S[1],ve=U+fe*T[2];for(let Pe=0;Pe<u.outWidth;++Pe){const Ee=Z+Pe*u.outChannels,Se=Pe*u.strideWidth-b;for(let ze=0;ze<d;++ze){const ke=Se+ze*g;if(ke<0||ke>=u.inWidth)continue;const H=he+ze*S[2],K=ve+ke*u.inChannels;let re=H;for(let pe=0;pe<u.inChannels;++pe){const me=C[K+pe];for(let xe=0;xe<u.outChannels;++xe)$[Ee+xe]+=me*I[re+xe];re+=u.outChannels}}}}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const Pae={kernelName:af,backendName:"cpu",kernelFunc:Aae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:l}=s;ot([r,i],"conv3dBackpropFilterV2");const u=lt(r.shape),c=lt(i.shape),h=gi(r.shape,l,o,1,a),d=h.strideDepth,f=h.strideHeight,p=h.strideWidth,g=h.filterDepth,m=h.filterHeight,x=h.filterWidth,b=new bs(h.filterShape,"float32"),v=b.values,[y,C,I,$]=b.strides,T=n.data.get(i.dataId).values,[S,E,_,N]=c,P=n.data.get(r.dataId).values,[M,z,A,B]=u,L=h.padInfo.front,U=h.padInfo.left,j=h.padInfo.top;for(let Z=0;Z<g;++Z){const J=Math.max(0,Math.ceil((L-Z)/d)),se=Math.min(h.outDepth,(h.inDepth+L-Z)/d),fe=Z*y;for(let he=0;he<m;++he){const ve=Math.max(0,Math.ceil((j-he)/f)),Pe=Math.min(h.outHeight,(h.inHeight+j-he)/f),Ee=he*C+fe;for(let Se=0;Se<x;++Se){const ze=Math.max(0,Math.ceil((U-Se)/p)),ke=Math.min(h.outWidth,(h.inWidth+U-Se)/p),H=Se*I+Ee;for(let K=0;K<h.inChannels;++K){const re=K*$+H;for(let pe=0;pe<h.outChannels;++pe){let me=0;for(let xe=0;xe<h.batchSize;++xe){const Te=xe*M,De=xe*S;for(let Re=J;Re<se;++Re){const nt=(Z+Re*d-L)*z+Te,Ae=Re*E+De;for(let Je=ve;Je<Pe;++Je){const Tt=(he+Je*f-j)*A+nt,$t=Je*_+Ae;for(let Ke=ze;Ke<ke;++Ke){const Zn=(Se+Ke*p-U)*B+Tt,$s=Ke*N+$t;me+=P[Zn+K]*T[$s+pe]}}}}v[re+pe]=me}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const Nae={kernelName:h0,backendName:"cpu",kernelFunc:Dae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mae(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{pad:o,strides:a,inputShape:l}=s;ot([r],"conv3dBackpropInputV2");const u=lt(r.shape),c=lt(i.shape),h=gi(l,i.shape,a,1,o),d=new bs(h.inShape,"float32"),f=d.values,[p,g,m,x]=d.strides,b=n.data.get(r.dataId).values,[v,y,C,I]=u,$=n.data.get(i.dataId).values,[T,S,E,_]=c,{batchSize:N,filterDepth:P,filterHeight:M,filterWidth:z,inChannels:A,inDepth:B,inHeight:L,inWidth:U,outChannels:j,outDepth:Z,outHeight:J,outWidth:se,strideDepth:fe,strideHeight:he,strideWidth:ve}=h,Pe=P-1-h.padInfo.front,Ee=M-1-h.padInfo.top,Se=z-1-h.padInfo.left;for(let ze=0;ze<N;++ze)for(let ke=0;ke<A;++ke)for(let H=0;H<B;++H){const K=H-Pe,re=Math.max(0,Math.ceil(K/fe)),pe=Math.min(Z,(P+K)/fe);for(let me=0;me<L;++me){const xe=me-Ee,Te=Math.max(0,Math.ceil(xe/he)),De=Math.min(J,(M+xe)/he);for(let Re=0;Re<U;++Re){const _e=Re-Se,nt=Math.max(0,Math.ceil(_e/ve)),Ae=Math.min(se,(z+_e)/ve);let Je=0;for(let tt=re;tt<pe;++tt){const Tt=tt*fe-K;for(let $t=Te;$t<De;++$t){const Ke=$t*he-xe;for(let Sn=nt;Sn<Ae;++Sn){const Zn=Sn*ve-_e,$s=v*ze+y*tt+C*$t+I*Sn,ms=T*(P-1-Tt)+S*(M-1-Ke)+E*(z-1-Zn)+_*ke;for(let nr=0;nr<j;++nr){const $a=b[$s+nr],xn=$[ms+nr];Je+=$a*xn}}}}f[p*ze+g*H+m*me+x*Re+ke]=Je}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}const Lae={kernelName:d0,backendName:"cpu",kernelFunc:Mae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oae=Zt(dc,t=>Math.cos(t)),Fae={kernelName:dc,backendName:"cpu",kernelFunc:Oae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uae=Zt(fc,t=>Math.cosh(t)),Bae={kernelName:fc,backendName:"cpu",kernelFunc:Uae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zae(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=s,[c,h,d,f]=r.shape,p=i.shape[0],[g,m]=a,x=Ct([p,g,m,f],"float32"),b=n.data.get(i.dataId).values,v=n.data.get(o.dataId).values,y=n.data.get(r.dataId).values,C=lt(r.shape),I=lt(x.shape);for(let $=0;$<p;$++){const T=$*4,S=b[T],E=b[T+1],_=b[T+2],N=b[T+3],P=v[$];if(P>=c)continue;const M=g>1?(_-S)*(h-1)/(g-1):0,z=m>1?(N-E)*(d-1)/(m-1):0;for(let A=0;A<g;A++){const B=g>1?S*(h-1)+A*M:.5*(S+_)*(h-1);if(B<0||B>h-1){for(let L=0;L<m;L++)for(let U=0;U<f;U++){const j=U+L*I[2]+A*I[1]+$*I[0];x.values[j]=u}continue}if(l==="bilinear"){const L=Math.floor(B),U=Math.ceil(B),j=B-L;for(let Z=0;Z<m;Z++){const J=m>1?E*(d-1)+Z*z:.5*(E+N)*(d-1);if(J<0||J>d-1){for(let ve=0;ve<f;ve++){const Pe=ve+Z*I[2]+A*I[1]+$*I[0];x.values[Pe]=u}continue}const se=Math.floor(J),fe=Math.ceil(J),he=J-se;for(let ve=0;ve<f;ve++){let Pe=ve+se*C[2]+L*C[1]+P*C[0];const Ee=y[Pe];Pe=ve+fe*C[2]+L*C[1]+P*C[0];const Se=y[Pe];Pe=ve+se*C[2]+U*C[1]+P*C[0];const ze=y[Pe];Pe=ve+fe*C[2]+U*C[1]+P*C[0];const ke=y[Pe],H=Ee+(Se-Ee)*he,K=ze+(ke-ze)*he;Pe=ve+Z*I[2]+A*I[1]+$*I[0],x.values[Pe]=H+(K-H)*j}}}else for(let L=0;L<m;++L){const U=m>1?E*(d-1)+L*z:.5*(E+N)*(d-1);if(U<0||U>d-1){for(let J=0;J<f;J++){const se=J+L*I[2]+A*I[1]+$*I[0];x.values[se]=u}continue}const j=Math.round(U),Z=Math.round(B);for(let J=0;J<f;J++){const se=J+j*C[2]+Z*C[1]+P*C[0],fe=J+L*I[2]+A*I[1]+$*I[0];x.values[fe]=y[se]}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}const Gae={kernelName:p0,backendName:"cpu",kernelFunc:zae};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;ot(r,"cumprod");const l=Jt([i],r.shape.length);let u=r;l!=null&&(u=er({inputs:{x:r},backend:n,attrs:{perm:l}}));const c=an(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=hs(u.dtype,"int32"),d=dv(oe(u.shape),h),f=n.data.get(u.dataId).values,p=u.shape[u.shape.length-1],g=a?(x,b)=>x+p-b-1:(x,b)=>x+b;for(let x=0;x<f.length;x+=p)for(let b=0;b<p;b++){const v=g(x,b);if(b===0)d[v]=o?1:f[v];else{const y=g(x,b-1);d[v]=o?f[y]*d[y]:f[v]*d[y]}}const m=n.makeTensorInfo(u.shape,h,d);if(l!=null){const x=Qi(l),b=er({inputs:{x:m},backend:n,attrs:{perm:x}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(u),b}return m}const Wae={kernelName:f0,backendName:"cpu",kernelFunc:Vae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;ot(r,"cumsum");const l=Jt([i],r.shape.length);let u=r;l!=null&&(u=er({inputs:{x:r},backend:n,attrs:{perm:l}}));const c=an(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=hs(u.dtype,"int32"),d=vs(oe(u.shape),h),f=n.data.get(u.dataId).values,p=u.shape[u.shape.length-1],g=a?(x,b)=>x+p-b-1:(x,b)=>x+b;for(let x=0;x<f.length;x+=p)for(let b=0;b<p;b++){const v=g(x,b);if(b===0)d[v]=o?0:f[v];else{const y=g(x,b-1);d[v]=o?f[y]+d[y]:f[v]+d[y]}}const m=n.makeTensorInfo(u.shape,h,d);if(l!=null){const x=Qi(l),b=er({inputs:{x:m},backend:n,attrs:{perm:x}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(u),b}return m}const Kae={kernelName:lf,backendName:"cpu",kernelFunc:Hae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,c=K2(l,u,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,c)}else if(r.shape.length===2){const l=n.bufferSync(r),u=n.bufferSync(i),c=oP(l,u,o,a);return n.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Xae={kernelName:m0,backendName:"cpu",kernelFunc:jae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:i,dataFormat:o}=s;G(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],h=l*i,d=u*i,f=c/(i*i),p=n.data.get(r.dataId).values,g=new Float32Array(a*h*d*f);let m=0;for(let x=0;x<a;++x)for(let b=0;b<h;++b){const v=Math.floor(b/i),y=b%i;for(let C=0;C<d;++C){const I=Math.floor(C/i),$=C%i,T=(y*i+$)*f;for(let S=0;S<f;++S){const _=S+T+c*(I+u*(v+l*x));g[m++]=p[_]}}}return n.makeTensorInfo([a,h,d,f],r.dtype,g)}const Yae={kernelName:g0,backendName:"cpu",kernelFunc:qae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aD(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=s;ot([r,i],"depthwiseConv2DNative");const c=lt(r.shape),h=lt(i.shape);let d=l;d==null&&(d=[1,1]),G(ds(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const f=gn(r.shape,i.shape,o,d,a,u,!0),{filterHeight:p,filterWidth:g,dilationHeight:m,dilationWidth:x,padInfo:b}=f,v=b.left,y=b.top,C=f.outChannels/f.inChannels,I=new bs(f.outShape,r.dtype),$=n.data.get(r.dataId).values,T=n.data.get(i.dataId).values,S=I.values;for(let E=0;E<f.batchSize;++E){const _=E*c[0],N=E*I.strides[0];for(let P=0;P<f.outHeight;++P){const M=N+P*I.strides[1],z=P*f.strideHeight-y;for(let A=0;A<p;++A){const B=z+A*m;if(B<0||B>=f.inHeight)continue;const L=A*h[0],U=_+B*c[1];for(let j=0;j<f.outWidth;++j){const Z=M+j*I.strides[2],J=j*f.strideWidth-v;for(let se=0;se<g;++se){const fe=J+se*x;if(fe<0||fe>=f.inWidth)continue;const he=L+se*h[1],ve=U+fe*f.inChannels;let Pe=Z,Ee=he;for(let Se=0;Se<f.inChannels;++Se){const ze=$[ve+Se];for(let ke=0;ke<C;++ke)S[Pe+ke]+=ze*T[Ee+ke];Pe+=C,Ee+=C}}}}}}return n.makeTensorInfo(I.shape,I.dtype,I.values)}const Zae={kernelName:uf,backendName:"cpu",kernelFunc:aD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s;ot([r,i],"depthwiseConv2dNativeBackpropFilter");const h=gn(r.shape,c,o,a,l,u,!0),{strideHeight:d,strideWidth:f,filterHeight:p,filterWidth:g}=h,m=new bs(h.filterShape,"float32"),x=h.padInfo.left,b=h.padInfo.top,v=h.outChannels/h.inChannels,y=n.data.get(r.dataId).values,C=new bs(r.shape,r.dtype,y),I=n.data.get(i.dataId).values,$=new bs(i.shape,i.dtype,I);for(let T=0;T<p;++T){const S=Math.max(0,Math.ceil((b-T)/d)),E=Math.min(h.outHeight,(h.inHeight+b-T)/d);for(let _=0;_<g;++_){const N=Math.max(0,Math.ceil((x-_)/f)),P=Math.min(h.outWidth,(h.inWidth+x-_)/f);for(let M=0;M<h.outChannels;++M){const z=Math.trunc(M/v),A=M%v;let B=0;for(let L=0;L<h.batchSize;++L)for(let U=S;U<E;++U){const j=T+U*d-b;for(let Z=N;Z<P;++Z){const J=_+Z*f-x;B+=C.get(L,j,J,z)*$.get(L,U,Z,M)}}m.set(B,T,_,z,A)}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const Jae={kernelName:x0,backendName:"cpu",kernelFunc:Qae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ele(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s;ot([r,i],"depthwiseConv2DNativeBackpropInput");const h=lt(r.shape),d=lt(i.shape),f=gn(c,i.shape,o,a,l,u,!0),p=new bs(f.inShape,"float32"),g=p.values,[m,x,b]=p.strides,v=n.data.get(r.dataId).values,[y,C,I]=h,$=n.data.get(i.dataId).values,[T,S,E]=d,{batchSize:_,filterHeight:N,filterWidth:P,inChannels:M,inHeight:z,inWidth:A,outChannels:B,outHeight:L,outWidth:U,strideHeight:j,strideWidth:Z}=f,J=N-1-f.padInfo.top,se=P-1-f.padInfo.left,fe=B/M;for(let he=0;he<_;++he)for(let ve=0;ve<M;++ve)for(let Pe=0;Pe<z;++Pe){const Ee=Pe-J,Se=Math.max(0,Math.ceil(Ee/j)),ze=Math.min(L,(N+Ee)/j);for(let ke=0;ke<A;++ke){const H=ke-se,K=Math.max(0,Math.ceil(H/Z)),re=Math.min(U,(P+H)/Z);let pe=0;for(let me=Se;me<ze;++me){const xe=me*j-Ee;for(let Te=K;Te<re;++Te){const De=Te*Z-H,Re=y*he+C*me+I*Te,_e=T*(N-1-xe)+S*(P-1-De)+E*ve;for(let nt=0;nt<fe;++nt){const Ae=ve*fe+nt,Je=v[Re+Ae],tt=$[_e+nt];pe+=Je*tt}}}g[m*he+x*Pe+b*ke+ve]=pe}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}const tle={kernelName:b0,backendName:"cpu",kernelFunc:ele};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nle(t){const{inputs:e,backend:n}=t,{x:s}=e,r=oe(s.shape),i=n.data.get(s.dataId).values,o=Ct([r,r],s.dtype),a=o.values;for(let u=0;u<i.length;u++)a[u*r+u]=i[u];const l=[...s.shape,...s.shape];return n.makeTensorInfo(l,o.dtype,o.values)}const sle={kernelName:xv,backendName:"cpu",kernelFunc:nle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rle={kernelName:cf,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r}=t,{strides:i,pad:o,dilations:a}=n,l=e,u=l.data.get(s.dataId).values,c=s.shape.length,h=l.data.get(r.dataId).values,d=r.shape.length,{batchSize:f,inHeight:p,inWidth:g,inChannels:m,outHeight:x,outWidth:b,padInfo:v,strideHeight:y,strideWidth:C,filterHeight:I,filterWidth:$,dilationHeight:T,dilationWidth:S,outShape:E}=ga(s.shape,r.shape,i,o,"NHWC",a),_=oe(E),N=E.length,P=_n(s.dtype,_);for(let z=0;z<f;++z)for(let A=0;A<x;++A){const B=A*y-v.top;for(let L=0;L<b;++L){const U=L*C-v.left;for(let j=0;j<m;++j){let Z=Number.MIN_SAFE_INTEGER;for(let se=0;se<I;++se){const fe=B+se*T;if(fe>=0&&fe<p)for(let he=0;he<$;++he){const ve=U+he*S;if(ve>=0&&ve<g){const Pe=zi([z,fe,ve,j],c,lt(s.shape)),Ee=zi([se,he,j],d,lt(r.shape)),Se=u[Pe]+h[Ee];Se>Z&&(Z=Se)}}}const J=zi([z,A,L,j],N,lt(E));P[J]=Z}}}return{dataId:l.write(Al(P,s.dtype),E,s.dtype),shape:E,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ile={kernelName:Xm,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:i}=t,{strides:o,pad:a,dilations:l}=n,u=e,c=ni(s.shape,u.data.get(s.dataId).values),h=ni(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:f,inWidth:p,inChannels:g,outHeight:m,outWidth:x,padInfo:b,strideHeight:v,strideWidth:y,filterHeight:C,filterWidth:I,dilationHeight:$,dilationWidth:T,outShape:S}=ga(s.shape,r.shape,o,a,"NHWC",l);G(i.rank===S.length,()=>`Error in ${Xm}, dy must have the same rank as output ${S.length}, but got ${i.rank}`);const E=ni(S,u.data.get(i.dataId).values),_=LE(r.shape,r.dtype);for(let P=0;P<d;++P)for(let M=0;M<m;++M){const z=M*v-b.top;for(let A=0;A<x;++A){const B=A*y-b.left;for(let L=0;L<g;++L){let U=Number.MIN_SAFE_INTEGER,j=0,Z=0;for(let J=0;J<C;++J){const se=z+J*$;if(se>=0&&se<f)for(let fe=0;fe<I;++fe){const he=B+fe*T;if(he>=0&&he<p){const ve=c[P][se][he][L]+h[J][fe][L];ve>U&&(U=ve,j=J,Z=fe)}}}_[j][Z][L]+=E[P][M][A][L]}}}return{dataId:u.write(Al(_,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ole={kernelName:jm,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:i}=t,{strides:o,pad:a,dilations:l}=n,u=e,c=ni(s.shape,u.data.get(s.dataId).values),h=ni(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:f,inWidth:p,inChannels:g,outHeight:m,outWidth:x,padInfo:b,strideHeight:v,strideWidth:y,filterHeight:C,filterWidth:I,dilationHeight:$,dilationWidth:T,outShape:S}=ga(s.shape,r.shape,o,a,"NHWC",l);G(i.rank===S.length,()=>`Error in ${jm}, dy must have the same rank as output ${S.length}, but got ${i.rank}`);const E=ni(S,u.data.get(i.dataId).values),_=LE(s.shape,s.dtype);for(let P=0;P<d;++P)for(let M=0;M<m;++M){const z=M*v-b.top;for(let A=0;A<x;++A){const B=A*y-b.left;for(let L=0;L<g;++L){let U=Number.MIN_SAFE_INTEGER,j=z<0?0:z,Z=B<0?0:B;for(let J=0;J<C;++J){const se=z+J*$;if(se>=0&&se<f)for(let fe=0;fe<I;++fe){const he=B+fe*T;if(he>=0&&he<p){const ve=c[P][se][he][L]+h[J][fe][L];ve>U&&(U=ve,j=se,Z=he)}}}_[P][j][Z][L]+=E[P][M][A][L]}}}return{dataId:u.write(Al(_,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ale(t){const{inputs:e,backend:n,attrs:s}=t,{image:r}=e,{canvas:i,options:o}=s,{contextOptions:a,imageOptions:l}=o||{},u=(l==null?void 0:l.alpha)||1,c=(a==null?void 0:a.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=i.getContext(c,(a==null?void 0:a.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);const[d,f]=r.shape.slice(0,2),p=r.shape.length===2?1:r.shape[2],g=n.data.get(r.dataId).values,m=r.dtype==="float32"?255:1,x=new Uint8ClampedArray(f*d*4);for(let v=0;v<d*f;++v){const y=[0,0,0,255*u];for(let I=0;I<p;I++){const $=g[v*p+I];if(r.dtype==="float32"){if($<0||$>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${$}.`)}else if(r.dtype==="int32"&&($<0||$>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${$}.`);p===1?(y[0]=$*m,y[1]=$*m,y[2]=$*m):y[I]=$*m}const C=v*4;x[C+0]=Math.round(y[0]),x[C+1]=Math.round(y[1]),x[C+2]=Math.round(y[2]),x[C+3]=Math.round(y[3])}i.width=f,i.height=d;const b=new ImageData(x,f,d);return h.putImageData(b,0,0),r}const lle={kernelName:UE,backendName:"cpu",kernelFunc:ale};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hp(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;ot(r,"sum");let a;r.dtype==="bool"?a=ha({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):a=qi({inputs:{x:r},backend:n});const l=a.shape.length,u=wt(i,a.shape),c=Jt(u,l);let h=u,d=a;c!=null&&(d=er({inputs:{x:a},backend:n,attrs:{perm:c}}),h=an(h.length,l)),qn("sum",h,d.shape.length);const[f,p]=Gn(d.shape,h),g=hs(d.dtype,"int32");let m=dg(n,f,g);const x=oe(p),b=n.data.get(m.dataId).values,v=n.data.get(d.dataId).values;for(let y=0;y<b.length;++y){const C=y*x;let I=0;for(let $=0;$<x;++$)I+=v[C+$];b[y]=I}if(o){const y=zn(m.shape,u),C=m;m=on({inputs:{x:m},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(C)}return n.disposeIntermediateTensorInfo(a),c!=null&&n.disposeIntermediateTensorInfo(d),m}const ule={kernelName:Vf,backendName:"cpu",kernelFunc:hp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cle(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:l}=fx(r,i.length);mx(o.length,l,i);const{path:u,steps:c}=gx(a,l),h=c.length;let d=null,f=o.length;const p=[];for(let g=0;g<h;++g){for(const m of c[g]){const{permutationIndices:x,expandDims:b}=px(f,l[m]);let v;xx(x)?v=i[m]:(v=er({inputs:{x:i[m]},backend:n,attrs:{perm:x}}),p.push(v));const y=v.shape.slice();for(let C=0;C<b.length;++C)y.splice(b[C],0,1);Pt(v.shape,y)||(v=on({inputs:{x:v},backend:n,attrs:{shape:y}}),p.push(v)),d===null?d=v:(d=Ax({inputs:{a:v,b:d},backend:n}),p.push(d))}g<h-1&&(u[g]>=0&&(d=hp({inputs:{x:d},backend:n,attrs:{axis:u[g]-(o.length-f),keepDims:!1}}),p.push(d)),f--)}for(const g of p)g!==d&&n.disposeIntermediateTensorInfo(g);return d}const hle={kernelName:y0,backendName:"cpu",kernelFunc:cle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dle(t){const{inputs:e,backend:n}=t,{dy:s,y:r}=e;ot([s,r],"eluGrad");const i=new Float32Array(oe(r.shape)),o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values;for(let l=0;l<o.length;++l){const u=o[l];u>=0?i[l]=a[l]:i[l]=a[l]*(u+1)}return n.makeTensorInfo(r.shape,"float32",i)}const fle={kernelName:v0,backendName:"cpu",kernelFunc:dle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ple=ax,mle=lx,gle=ux,xle=cx,ble=hx,yle=dx,vle=Zt(gc,t=>{const e=Math.sign(t),n=Math.abs(t),s=1/(1+ple*n);return e*(1-((((yle*s+ble)*s+xle)*s+gle)*s+mle)*s*Math.exp(-n*n))}),wle={kernelName:gc,backendName:"cpu",kernelFunc:vle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mg(t){const{inputs:e,backend:n,attrs:s}=t,{input:r}=e,{dim:i}=s,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&(G(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),on({inputs:{x:r},backend:n,attrs:{shape:a}})}const Sle={kernelName:df,backendName:"cpu",kernelFunc:mg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cle=Wn((t,e)=>t/e),Q2=os(pc,Cle),ay={kernelName:pc,backendName:"cpu",kernelFunc:Q2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lD(t,e,n){const s=t.shape,r=s[0],i=s[1],o=n.data.get(t.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=[r,i],c=oe(u),h=cs("float32",c),d=cs("float32",c);for(let m=0;m<r;m++){const x=wl({inputs:{x:a},backend:n,attrs:{begin:[m,0],size:[1,i]}}),b=wl({inputs:{x:l},backend:n,attrs:{begin:[m,0],size:[1,i]}}),v=ar({inputs:{real:x,imag:b},backend:n}),{real:y,imag:C}=Tle(v,e,n),I=ui(y,C);for(let $=0;$<i;$++){const T=w2(I,$);h[m*i+$]=T.real,d[m*i+$]=T.imag}n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v)}const f=n.makeTensorInfo(u,"float32",h),p=n.makeTensorInfo(u,"float32",d),g=ar({inputs:{real:f,imag:p},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),g}function Tle(t,e,n){const s=oe(t.shape),r=n.data.get(t.dataId),i=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(r.complexTensorInfos.imag.dataId).values;if(Ile(s)){const a=ly(i,o,s,e,n),l=[t.shape[0],t.shape[1]];if(e){const u=n.makeTensorInfo(l,"float32",a.real),c=n.makeTensorInfo(l,"float32",a.imag),h=n.makeTensorInfo([],"float32",ma(s,"float32")),d=qi({inputs:{x:h},backend:n}),f=ay.kernelFunc({inputs:{a:u,b:h},backend:n}),p=ay.kernelFunc({inputs:{a:c,b:d},backend:n}),g=n.data.get(f.dataId).values,m=n.data.get(p.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),{real:g,imag:m}}return a}else{const a=ui(i,o),l=kle(a,s,e);return w$(l)}}function Ile(t){return(t&t-1)===0}function ly(t,e,n,s,r){if(n===1)return{real:t,imag:e};const i=ui(t,e),o=n/2,a=S$(i),l=a.real,u=a.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),d=r.makeTensorInfo(c,"float32",u),f=ar({inputs:{real:h,imag:d},backend:r}),p=C$(i),g=p.real,m=p.imag,x=[g.length],b=r.makeTensorInfo(x,"float32",g),v=r.makeTensorInfo(x,"float32",m),y=ar({inputs:{real:b,imag:v},backend:r}),C=ly(l,u,o,s,r),I=C.real,$=C.imag,T=[I.length],S=r.makeTensorInfo(T,"float32",I),E=r.makeTensorInfo(T,"float32",$),_=ar({inputs:{real:S,imag:E},backend:r}),N=ly(g,m,o,s,r),P=N.real,M=N.imag,z=[P.length],A=r.makeTensorInfo(z,"float32",P),B=r.makeTensorInfo(z,"float32",M),L=ar({inputs:{real:A,imag:B},backend:r}),U=I$(n,s),j=[U.real.length],Z=r.makeTensorInfo(j,"float32",U.real),J=r.makeTensorInfo(j,"float32",U.imag),se=ar({inputs:{real:Z,imag:J},backend:r}),fe=Ax({inputs:{a:se,b:L},backend:r}),he=Wu({inputs:{a:_,b:fe},backend:r}),ve=Y2({inputs:{a:_,b:fe},backend:r}),Pe=vl({inputs:{input:he},backend:r}),Ee=vl({inputs:{input:ve},backend:r}),Se=Hu({inputs:{input:he},backend:r}),ze=Hu({inputs:{input:ve},backend:r}),ke=Ku({inputs:[Pe,Ee],backend:r,attrs:{axis:0}}),H=Ku({inputs:[Se,ze],backend:r,attrs:{axis:0}}),K=r.data.get(ke.dataId).values,re=r.data.get(H.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(Z),r.disposeIntermediateTensorInfo(J),r.disposeIntermediateTensorInfo(se),r.disposeIntermediateTensorInfo(fe),r.disposeIntermediateTensorInfo(he),r.disposeIntermediateTensorInfo(ve),r.disposeIntermediateTensorInfo(Pe),r.disposeIntermediateTensorInfo(Se),r.disposeIntermediateTensorInfo(Ee),r.disposeIntermediateTensorInfo(ze),r.disposeIntermediateTensorInfo(ke),r.disposeIntermediateTensorInfo(H),{real:K,imag:re}}function kle(t,e,n){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let i=0,o=0;for(let a=0;a<e;a++){const l=k$(r*a,e,n),u=w2(t,a);i+=u.real*l.real-u.imag*l.imag,o+=u.real*l.imag+u.imag*l.real}n&&(i/=e,o/=e),T$(s,i,o,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ele(t){const{inputs:e,backend:n}=t,{input:s}=e,r=oe(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=on({inputs:{x:s},backend:n,attrs:{shape:[o,i]}}),l=lD(a,!1,n),u=on({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}const _le={kernelName:w0,backendName:"cpu",kernelFunc:Ele};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J2(t){const{backend:e,attrs:n}=t,{shape:s,value:r,dtype:i}=n,o=i||_l(r),a=_n(o,oe(s));return Rle(a,r,o),e.makeTensorInfo(s,o,a)}const $le={kernelName:S0,backendName:"cpu",kernelFunc:J2};function Rle(t,e,n){t.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ale={kernelName:C0,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,r=n,i=cs(s.dtype,oe(s.shape)),[o,a,l,u]=s.shape,c=r.data.get(s.dataId).values;for(let d=0;d<o;d++){const f=d*l*a*u;for(let p=0;p<a;p++){const g=p*(l*u);for(let m=0;m<l;m++){const x=m*u;for(let b=0;b<u;b++){const v=Math.round(l-m-1),y=f+g+x+b;let C=c[y];if(v>=0&&v<l){const I=v*u,$=f+g+I+b;C=c[$]}i[y]=C}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ple(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:p}=s;let g=oD({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(o){const m=g;if(c==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const x=on({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});g=Wu({inputs:{a:g,b:x},backend:n}),n.disposeIntermediateTensorInfo(x)}else g=Wu({inputs:{a:g,b:o},backend:n});n.disposeIntermediateTensorInfo(m)}if(f){const m=g;if(c==="NCHW"&&f==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const x=on({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}});g=pg(n,g,f,x,p),n.disposeIntermediateTensorInfo(x)}else g=pg(n,g,f,a,p);n.disposeIntermediateTensorInfo(m)}return g}const Dle={kernelName:Sd,backendName:"cpu",kernelFunc:Ple};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nle(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:p}=s;let g=aD({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(o){const m=g;g=Wu({inputs:{a:g,b:o},backend:n}),n.disposeIntermediateTensorInfo(m)}if(f){const m=g;g=pg(n,g,f,a,p),n.disposeIntermediateTensorInfo(m)}return g}const Mle={kernelName:Pv,backendName:"cpu",kernelFunc:Nle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lle(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,i=oe(s.shape),o=r.shape,a=o[o.length-1],[l,u,c,h]=Q0(s,r);if(u===0)return n.makeTensorInfo(l,s.dtype,[]);const d=n.data.get(r.dataId).values,f=n.bufferSync(s),p=xP(d,f,s.dtype,u,a,c,h,s.shape,i);return n.makeTensorInfo(l,s.dtype,p.values)}const Ole={kernelName:bv,backendName:"cpu",kernelFunc:Lle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fle(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:i}=e,{axis:o,batchDims:a}=s;ot([r,i],"gatherV2");const l=wt(o,r.shape)[0],u=n.data.get(i.dataId).values,c=r.shape[l];for(let y=0;y<u.length;++y){const C=u[y];G(C<=c-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${c-1}]`)}let h=a;a==null&&(h=0);const d=oe(i.shape),f=yx(r,i,l,h),p=on({inputs:{x:r},backend:n,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),g=on({inputs:{x:i},backend:n,attrs:{shape:[f.batchSize,d/f.batchSize]}}),m=[f.batchSize,f.outerSize,d/f.batchSize,f.sliceSize],x=n.bufferSync(g),b=n.bufferSync(p),v=bP(b,x,m);return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(f.outputShape,v.dtype,v.values)}const Ule={kernelName:pf,backendName:"cpu",kernelFunc:Fle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ble(t){const{inputs:e,backend:n}=t,{input:s}=e,r=oe(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=on({inputs:{x:s},backend:n,attrs:{shape:[o,i]}}),l=lD(a,!0,n),u=on({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}const zle={kernelName:T0,backendName:"cpu",kernelFunc:Ble};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gle=Zt(Cc,t=>Number.isFinite(t)?1:0,"bool"),Vle={kernelName:Cc,backendName:"cpu",kernelFunc:Gle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wle=Zt(Tc,t=>Math.abs(t)===1/0?1:0,"bool"),Hle={kernelName:Tc,backendName:"cpu",kernelFunc:Wle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kle=Zt(Ic,t=>Number.isNaN(t)?1:0,"bool"),jle={kernelName:Ic,backendName:"cpu",kernelFunc:Kle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xle(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:i}=n,o=CP(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const qle={kernelName:yv,backendName:"cpu",kernelFunc:Xle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yle=Zt(Ec,t=>Math.log1p(t)),Zle={kernelName:Ec,backendName:"cpu",kernelFunc:Yle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qle=Wn((t,e)=>t&&e),Jle=os(yf,Qle,null,"bool"),eue={kernelName:yf,backendName:"cpu",kernelFunc:Jle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tue=Zt(vf,t=>t?0:1,"bool"),nue={kernelName:vf,backendName:"cpu",kernelFunc:tue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sue=Wn((t,e)=>t||e),rue=os(wf,sue,null,"bool"),iue={kernelName:wf,backendName:"cpu",kernelFunc:rue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oue(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=s;ot(r,"LRN");const u=r.shape[3],c=u-1,h=n.data.get(r.dataId).values,d=oe(r.shape),f=new Float32Array(d);function p(g){const m=g%u;let x=g-m+Math.max(0,m-i);const b=g-m+Math.min(m+i,c);let v=0;for(;x<=b;x++){const y=h[x];v+=y*y}return v}for(let g=0;g<d;g++){const m=p(g),x=h[g]*Math.pow(o+a*m,-l);f[g]=x}return n.makeTensorInfo(r.shape,r.dtype,f)}const aue={kernelName:Sf,backendName:"cpu",kernelFunc:oue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lue(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=s;ot(o,"LRNGrad");const h=oe(o.shape),d=o.shape[3],f=n.data.get(o.dataId).values,p=n.data.get(r.dataId).values,g=n.data.get(i.dataId).values,m=new Float32Array(h),x=h;for(let b=0;b<x;b++){const v=b%d,y=b-v+Math.max(0,v-a),C=b-v+Math.min(d,v+a+1);let I=0;for(let $=y;$<C;$++)I+=Math.pow(p[$],2);I=u*I+l;for(let $=y;$<C;$++){let T=-2*u*c*p[$]*g[b]/I;b===$&&(T+=Math.pow(I,-c)),T*=f[b],m[$]+=T}}return n.makeTensorInfo(o.shape,r.dtype,m)}const uue={kernelName:k0,backendName:"cpu",kernelFunc:lue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uD(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:i,keepDims:o}=s,a=n;let l=r.shape;const u=l.length,c=wt(i,l);let h=c;const d=Jt(h,u);let f=a.data.get(r.dataId).values;if(d!=null){const y=new Array(u);for(let C=0;C<y.length;C++)y[C]=l[d[C]];f=X2(f,l,r.dtype,d,y),h=an(h.length,u),l=y}ot(r,"max"),qn("max",h,u);const[p,g]=Gn(l,h),m=oe(g),x=IP(f,m,p,r.dtype),b=a.write(x,p,r.dtype);let v=p;return o&&(v=zn(p,c)),{dataId:b,shape:v,dtype:r.dtype}}const cue={kernelName:Cf,backendName:"cpu",kernelFunc:uD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hue(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;ot(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,u=1;G(ds(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=ks(r.shape,i,o,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&Pt(c.inShape,c.outShape))h=qi({inputs:{x:r},backend:n});else{const d=n.data.get(r.dataId).values,f=lt(r.shape),p=Z2(d,r.shape,r.dtype,f,c,"max");h=n.makeTensorInfo(c.outShape,r.dtype,p.values)}return h}const due={kernelName:Tf,backendName:"cpu",kernelFunc:hue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fue(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=s;ot(r,"maxPool3d");const c=Er(r.shape,i,o,1,a,l,u),h=n.data.get(r.dataId).values,d=iD(h,r.shape,r.dtype,lt(r.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}const pue={kernelName:If,backendName:"cpu",kernelFunc:fue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mue(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=s;ot([r,i],"maxPool3DGrad");const c=Er(i.shape,o,a,1,l,u),h=n.bufferSync(i),d=sae(h,c),f=c.strideDepth,p=c.strideHeight,g=c.strideWidth,m=c.dilationDepth,x=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterDepth,y=c.effectiveFilterHeight,C=c.effectiveFilterWidth,I=v-1-c.padInfo.front,$=C-1-c.padInfo.left,T=y-1-c.padInfo.top,S=Ct(i.shape,"float32"),E=n.bufferSync(r);for(let _=0;_<c.batchSize;++_)for(let N=0;N<c.inChannels;++N)for(let P=0;P<c.inDepth;++P)for(let M=0;M<c.inHeight;++M)for(let z=0;z<c.inWidth;++z){const A=P-I,B=M-T,L=z-$;let U=0;for(let j=0;j<v;j+=m){const Z=(A+j)/f;if(!(Z<0||Z>=c.outDepth||Math.floor(Z)!==Z))for(let J=0;J<y;J+=x){const se=(B+J)/p;if(!(se<0||se>=c.outHeight||Math.floor(se)!==se))for(let fe=0;fe<C;fe+=b){const he=(L+fe)/g;if(he<0||he>=c.outWidth||Math.floor(he)!==he)continue;const ve=v*y*C-1-d.get(_,Z,se,he,N),Pe=j*y*C+J*C+fe,Ee=ve===Pe?1:0;if(Ee===0)continue;const Se=E.get(_,Z,se,he,N);U+=Se*Ee}}}S.set(U,_,P,M,z,N)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const gue={kernelName:_0,backendName:"cpu",kernelFunc:mue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xue(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i,output:o}=e,a=i;ot([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=ks(a.shape,l,u,1,c,h),f=n.data.get(a.dataId).values,p=Ct(d.outShape,a.dtype,rD(f,a.shape,a.dtype,d).values),g=d.strideHeight,m=d.strideWidth,x=d.dilationHeight,b=d.dilationWidth,v=d.effectiveFilterHeight,y=d.effectiveFilterWidth,C=y-1-d.padInfo.left,I=v-1-d.padInfo.top,$=Ct(a.shape,"float32"),T=n.data.get(r.dataId).values,S=Ct(r.shape,"float32",T);for(let E=0;E<d.batchSize;++E)for(let _=0;_<d.inChannels;++_)for(let N=0;N<d.inHeight;++N)for(let P=0;P<d.inWidth;++P){const M=N-I,z=P-C;let A=0;for(let B=0;B<v;B+=x){const L=(M+B)/g;if(!(L<0||L>=d.outHeight||Math.floor(L)!==L))for(let U=0;U<y;U+=b){const j=(z+U)/m;if(j<0||j>=d.outWidth||Math.floor(j)!==j)continue;const Z=v*y-1-p.get(E,L,j,_),J=B*y+U,se=Z===J?1:0;if(se===0)continue;const fe=S.get(E,L,j,_);A+=fe*se}}$.set(A,E,N,P,_)}return n.makeTensorInfo($.shape,$.dtype,$.values)}const bue={kernelName:E0,backendName:"cpu",kernelFunc:xue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yue(t,e,n,s,r){const i=lt(e),o=Z2(t,e,n,i,r,"max"),a=rD(t,e,n,r,!0,s);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vue={kernelName:vv,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=e,l=n;ot(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,c=ks(s.shape,r,i,[1,1],o),[h,d]=yue(u,s.shape,s.dtype,a,c),f=l.write(h,c.outShape,s.dtype),p=l.write(d,c.outShape,s.dtype);return[{dataId:f,shape:c.outShape,dtype:s.dtype},{dataId:p,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wue(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s,a=wt(i,r.shape),u=Gn(r.shape,a)[1],c=oe(u),h=[],d=n.makeTensorInfo([],"float32",new Float32Array([c]));h.push(d);const f=ha({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});h.push(f);const p=Q2({inputs:{a:f,b:d},backend:n});h.push(p);const g=hp({inputs:{x:p},backend:n,attrs:{axis:i,keepDims:o}});return h.forEach(m=>n.disposeIntermediateTensorInfo(m)),g}const Sue={kernelName:kf,backendName:"cpu",kernelFunc:wue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cue(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;ot(r,"min");const a=wt(i,r.shape);let l=a;const u=Jt(l,r.shape.length);let c=r;u!=null&&(c=er({inputs:{x:r},backend:n,attrs:{perm:u}}),l=an(l.length,r.shape.length)),qn("min",l,c.shape.length);const[h,d]=Gn(c.shape,l),f=oe(d),p=vs(oe(h),c.dtype),g=n.data.get(c.dataId).values;for(let x=0;x<p.length;++x){const b=x*f;let v=g[b];for(let y=0;y<f;++y){const C=g[b+y];(Number.isNaN(C)||C<v)&&(v=C)}p[x]=v}u!=null&&n.disposeIntermediateTensorInfo(c);const m=n.makeTensorInfo(h,c.dtype,p);if(o){const x=zn(h,a),b=on({inputs:{x:m},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(m),b}return m}const Tue={kernelName:Ef,backendName:"cpu",kernelFunc:Cue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iue(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:i,mode:o}=s;ot(r,"mirrorPad");const a=i.map((v,y)=>v[0]+r.shape[y]+v[1]),l=i.map(v=>v[0]),u=i.map((v,y)=>v[0]+r.shape[y]),c=o==="reflect"?0:1,h=n.data.get(r.dataId).values,d=r.shape.length,f=lt(r.shape),p=oe(a),g=a.length,m=lt(a),x=cs(r.dtype,p);for(let v=0;v<p;v++){let y=tc(v,g,m);for(let I=0;I<g;I++)y[I]<l[I]?y[I]=l[I]*2-y[I]-c:y[I]>=u[I]&&(y[I]=(u[I]-1)*2-y[I]+c);y=y.map((I,$)=>I-l[$]);const C=zi(y,d,f);x[v]=h[C]}return{dataId:n.write(x,a,r.dtype),shape:a,dtype:r.dtype}}const kue={kernelName:_f,backendName:"cpu",kernelFunc:Iue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eue=Wn((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}),_ue=os(Rc,Eue),$ue={kernelName:Rc,backendName:"cpu",kernelFunc:_ue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cD(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:i}=s,o=r.shape.length;let a=i;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=wt([a],r.shape),u=uD({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=zn(u.shape,l),h=on({inputs:{x:u},backend:n,attrs:{shape:c}}),d=Y2({inputs:{a:r,b:h},backend:n}),f=fP({inputs:{x:d},backend:n}),p=hp({inputs:{x:f},backend:n,attrs:{axis:l,keepDims:!1}}),g=on({inputs:{x:p},backend:n,attrs:{shape:c}}),m=Q2({inputs:{a:f,b:g},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),m}const Rue={kernelName:Kf,backendName:"cpu",kernelFunc:cD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aue(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s;ot(r,"multinomial");const l=a?r:cD({inputs:{logits:r},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,d=[u,i],f=vs(oe(d),"int32");for(let p=0;p<u;++p){const g=p*c,m=new Float32Array(c-1);m[0]=h[g];for(let v=1;v<m.length;++v)m[v]=m[v-1]+h[g+v];const x=o2.alea(o.toString()),b=p*i;for(let v=0;v<i;++v){const y=x();f[b+v]=m.length;for(let C=0;C<m.length;C++)if(y<m[C]){f[b+v]=C;break}}}return a||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",f)}const Pue={kernelName:wv,backendName:"cpu",kernelFunc:Aue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Due=Y0;function Nue(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s;ot(r,"NonMaxSuppression");const u=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:h}=Due(u,c,o,a,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const Mue={kernelName:$0,backendName:"cpu",kernelFunc:Nue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lue=m2;function Oue(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s;ot(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:d,validOutputs:f}=Lue(c,h,o,a,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}const Fue={kernelName:Sv,backendName:"cpu",kernelFunc:Oue};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uue=Z0;function Bue(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s;ot(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,d=o,f=a,p=l,g=u,{selectedIndices:m,selectedScores:x}=Uue(c,h,d,f,p,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}const zue={kernelName:R0,backendName:"cpu",kernelFunc:Bue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gue(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{dtype:i,depth:o,onValue:a,offValue:l}=s;ot(r,"oneHot");const u=oe(r.shape),c=new Float32Array(u*o);c.fill(l);const h=n.data.get(r.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<o&&(c[d*o+h[d]]=a);return n.makeTensorInfo([...r.shape,o],i,c)}const Vue={kernelName:Pf,backendName:"cpu",kernelFunc:Gue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gg(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=vl({inputs:{input:s},backend:n}),i=gg({inputs:{x:r},backend:n}),o=Hu({inputs:{input:s},backend:n}),a=gg({inputs:{x:o},backend:n}),l=ar({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return J2({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const Wue={kernelName:qf,backendName:"cpu",kernelFunc:gg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hD(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=vl({inputs:{input:s},backend:n}),i=hD({inputs:{x:r},backend:n}),o=Hu({inputs:{input:s},backend:n}),a=gg({inputs:{x:o},backend:n}),l=ar({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return J2({backend:n,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const Hue={kernelName:Af,backendName:"cpu",kernelFunc:hD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dD(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(e.length===1)return mg({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(c=>{n0(i,c.shape,"All tensors passed to stack must have matching shapes"),G(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=mg({inputs:{input:c},backend:n,attrs:{dim:r}});return a.push(h),h}),u=Ku({inputs:l,backend:n,attrs:{axis:r}});return a.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const Kue={kernelName:Df,backendName:"cpu",kernelFunc:dD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jue(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:i,constantValue:o}=s;ot(r,"pad");const a=i.map((b,v)=>b[0]+r.shape[v]+b[1]),l=i.map(b=>b[0]),u=n.data.get(r.dataId).values,c=oe(r.shape),h=r.shape.length,d=lt(r.shape),f=oe(a),p=a.length,g=lt(a),m=cs(r.dtype,f);o!==0&&m.fill(o);for(let b=0;b<c;b++){const y=tc(b,h,d).map((I,$)=>I+l[$]),C=zi(y,p,g);m[C]=u[b]}return{dataId:n.write(m,a,r.dtype),shape:a,dtype:r.dtype}}const fD={kernelName:Nf,backendName:"cpu",kernelFunc:jue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xue=Wn((t,e)=>Math.pow(t,e)),que=os(Pc,Xue),Yue={kernelName:Pc,backendName:"cpu",kernelFunc:que};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zue(t){const{inputs:e,backend:n,attrs:s}=t,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=s,l=r.map(x=>n.data.get(x.dataId).values),u=r.map(x=>x.shape),c=n.data.get(i.dataId).values,h=n.data.get(o.dataId).values,[d,f,p]=AP(l,u,c,i.shape,i.dtype,h,o.shape),g=d.map(x=>n.makeTensorInfo([x.length],"int32",x)),m=n.makeTensorInfo(p,i.dtype,f);return g.concat([m])}const Que={kernelName:BE,backendName:"cpu",kernelFunc:Zue};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jue(t){const{inputs:e,backend:n}=t,{starts:s,limits:r,deltas:i}=e,o=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[u,c]=PP(o,s.shape,s.dtype,a,r.shape,l,i.shape),h=n.makeTensorInfo([u.length],"int32",u),d=n.makeTensorInfo([c.length],s.dtype,c);return[h,d]}const ece={kernelName:zE,backendName:"cpu",kernelFunc:Jue};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tce(t){const{inputs:e,backend:n,attrs:s}=t,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,u=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,h=n.data.get(o.dataId).values,d=a.map(m=>n.data.get(m.dataId).values),f=a.map(m=>m.shape),[p,g]=DP(u,r.shape,c,i.shape,i.dtype,h,o.shape,d,f,l);return n.makeTensorInfo(p,i.dtype,g)}const nce={kernelName:GE,backendName:"cpu",kernelFunc:tce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sce(t){const{backend:e,attrs:n}=t,{start:s,stop:r,dtype:i,step:o}=n,a=NP(s,r,o,i);return e.makeTensorInfo([a.length],i,a)}const rce={kernelName:A0,backendName:"cpu",kernelFunc:sce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ice=Zt(Dc,t=>1/t),oce={kernelName:Dc,backendName:"cpu",kernelFunc:ice};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ace(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s;ot(r,"resizeBilinear");const l=lt(r.shape),[u,c]=a,[h,d,f,p]=r.shape,g=n.data.get(r.dataId).values,m=new Float32Array(oe([h,u,c,p])),x=[i&&u>1?d-1:d,i&&c>1?f-1:f],b=[i&&u>1?u-1:u,i&&c>1?c-1:c];let v=0;const y=x[0]/b[0],C=x[1]/b[1];for(let I=0;I<h;I++)for(let $=0;$<u;$++){let T;o?T=y*($+.5)-.5:T=y*$;const S=Math.max(0,Math.floor(T)),E=T-S,_=Math.min(d-1,Math.ceil(T)),N=I*l[0]+S*l[1],P=I*l[0]+_*l[1];for(let M=0;M<c;M++){let z;o?z=C*(M+.5)-.5:z=C*M;const A=Math.max(0,Math.floor(z)),B=z-A,L=Math.min(f-1,Math.ceil(z)),U=N+A*l[2],j=P+A*l[2],Z=N+L*l[2],J=P+L*l[2];for(let se=0;se<p;se++){const fe=g[U+se],he=g[j+se],ve=g[Z+se],Pe=g[J+se],Ee=fe+(ve-fe)*B,Se=he+(Pe-he)*B,ze=Ee+(Se-Ee)*E;m[v++]=ze}}}return n.makeTensorInfo([h,u,c,p],"float32",m)}const lce={kernelName:Uf,backendName:"cpu",kernelFunc:ace};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uce(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:o}=s;ot([i,r],"resizeBilinearGrad");const a=lt(r.shape),[l,u,c,h]=r.shape,[,d,f]=i.shape,p=new Float32Array(l*u*c*h),g=[o&&d>1?u-1:u,o&&f>1?c-1:c],m=[o&&d>1?d-1:d,o&&f>1?f-1:f],x=g[0]/m[0],b=g[1]/m[1],v=n.data.get(i.dataId).values;let y=0;for(let C=0;C<l;C++){const I=C*a[0];for(let $=0;$<d;$++){const T=$*x,S=Math.floor(T),E=Math.min(Math.ceil(T),u-1),_=I+S*a[1],N=I+E*a[1],P=T-S,M=1-P;for(let z=0;z<f;z++){const A=z*b,B=Math.floor(A),L=Math.min(Math.ceil(A),c-1),U=A-B,j=1-U,Z=_+B*a[2],J=_+L*a[2],se=N+B*a[2],fe=N+L*a[2],he=M*j,ve=M*U,Pe=P*j,Ee=P*U;for(let Se=0;Se<h;Se++){const ze=v[y++];p[Z+Se]+=ze*he,p[J+Se]+=ze*ve,p[se+Se]+=ze*Pe,p[fe+Se]+=ze*Ee}}}}return n.makeTensorInfo([l,c,u,h],"float32",p)}const cce={kernelName:N0,backendName:"cpu",kernelFunc:uce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hce(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s;ot(r,"resizeNearestNeighbor");const l=lt(r.shape),[u,c]=a,[h,d,f,p]=r.shape,g=n.data.get(r.dataId).values,m=new Float32Array(h*u*c*p),x=[i&&u>1?d-1:d,i&&c>1?f-1:f],b=[i&&u>1?u-1:u,i&&c>1?c-1:c],v=x[0]/b[0],y=x[1]/b[1];let C=0;for(let I=0;I<h;I++){const $=I*l[0];for(let T=0;T<u;T++){const S=o?v*(T+.5):v*T;let E=Math.min(d-1,i?Math.round(S):Math.floor(S));o&&(E=Math.max(0,E));const _=$+E*l[1];for(let N=0;N<c;N++){const P=o?y*(N+.5):y*N;let M=Math.min(f-1,i?Math.round(P):Math.floor(P));o&&(M=Math.max(0,M));const z=_+M*l[2];for(let A=0;A<p;A++){const B=g[z+A];m[C++]=B}}}}return n.makeTensorInfo([h,u,c,p],r.dtype,m)}const dce={kernelName:Ff,backendName:"cpu",kernelFunc:hce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fce(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:o}=s;ot([i,r],"resizeNearestNeighborGrad");const a=lt(r.shape),l=lt(i.shape),[u,c,h,d]=r.shape,[,f,p]=i.shape,g=new Float32Array(u*c*h*d),m=n.data.get(i.dataId).values,x=[o&&f>1?c-1:c,o&&p>1?h-1:h],b=[o&&f>1?f-1:f,o&&p>1?p-1:p],v=x[0]/b[0],y=x[1]/b[1],C=1/v,I=1/y,$=Math.ceil(C)*2+2,T=Math.ceil(I)*2+2;for(let S=0;S<u;S++){const E=S*a[0];for(let _=0;_<c;_++){const N=E+_*a[1],P=Math.floor(_*C),M=Math.floor(P-$/2);for(let z=0;z<h;z++){const A=N+z*a[2],B=Math.floor(z*I),L=Math.floor(B-T/2);for(let U=0;U<d;U++){let j=0;for(let Z=0;Z<$;Z++){const J=Z+M;if(J<0||J>=f)continue;const se=E+J*l[1],fe=J*v,he=Math.min(c-1,o?Math.round(fe):Math.floor(fe));if(_===he)for(let ve=0;ve<T;ve++){const Pe=ve+L;if(Pe<0||Pe>=p)continue;const Ee=se+Pe*l[2],Se=Pe*y,ze=Math.min(h-1,o?Math.round(Se):Math.floor(Se));z===ze&&(j+=m[Ee+U])}}g[A+U]=j}}}}return n.makeTensorInfo(r.shape,r.dtype,g)}const pce={kernelName:D0,backendName:"cpu",kernelFunc:fce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mce(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:i}=s;ot(r,"reverse");const o=r.shape.length,a=wt(i,r.shape);if(o===0)return qi({inputs:{x:r},backend:n});const l=new bs(r.shape,r.dtype),u=n.bufferSync(r);for(let c=0;c<l.size;c++){const h=l.indexToLoc(c),d=h.slice();a.forEach(f=>d[f]=r.shape[f]-1-d[f]),l.set(u.get(...d),...h)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}const gce={kernelName:Bf,backendName:"cpu",kernelFunc:mce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xce={kernelName:U0,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:i,center:o}=e,a=n,l=cs(s.dtype,oe(s.shape)),[u,c,h,d]=s.shape,[f,p]=rx(o,c,h),g=255,m=Math.sin(r),x=Math.cos(r),b=a.data.get(s.dataId).values;for(let y=0;y<u;y++){const C=y*h*c*d;for(let I=0;I<c;I++){const $=I*(h*d);for(let T=0;T<h;T++){const S=T*d;for(let E=0;E<d;E++){const _=[u,I,T,E],N=_[2],P=_[1];let M=(N-f)*x-(P-p)*m,z=(N-f)*m+(P-p)*x;M=Math.round(M+f),z=Math.round(z+p);let A=i;if(typeof i!="number"&&(E===3?A=g:A=i[E]),M>=0&&M<h&&z>=0&&z<c){const L=z*(h*d),U=M*d,j=C+L+U+E;A=b[j]}const B=C+$+S+E;l[B]=A}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bce=Zt(Lc,t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2===0?e:e+1}),yce={kernelName:Lc,backendName:"cpu",kernelFunc:bce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vce(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Ji(i,r,o),d=!0,f=n.bufferSync(r),p=n.bufferSync(i),g=Ya(f,p,o,h,u,l,a,c,0,d);return n.makeTensorInfo(o,g.dtype,g.values)}const wce={kernelName:Cv,backendName:"cpu",kernelFunc:vce};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sce(t,e){let n=0,s=t.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),t[r]<e?n=r+1:s=r;return s}function Cce(t,e){let n=0,s=t.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),t[r]<=e?n=r+1:s=r;return s}function Tce(t,e,n,s,r,i){const o=_n("int32",n*r);for(let a=0;a<n;++a){const l=t.slice(a*s,(a+1)*s),u=a*r;for(let c=0;c<r;++c)o[u+c]=i==="left"?Sce(l,e[c+u]):Cce(l,e[c+u])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ice(t){const{inputs:e,backend:n,attrs:s}=t,{sortedSequence:r,values:i}=e,{side:o}=s,a=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,u=Tce(a,l,r.shape[0],r.shape[1],i.shape[1],o);return n.makeTensorInfo(i.shape,"int32",u)}const kce={kernelName:Iv,backendName:"cpu",kernelFunc:Ice};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ece(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:i}=e;ot([s,r,i],"select");const o=s.shape.length,a=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,c=hs(r.dtype,i.dtype),h=vs(oe(r.shape),c);let d=0;const f=o===0||o>1||r.shape.length===1?1:oe(r.shape.slice(1));for(let p=0;p<a.length;p++)for(let g=0;g<f;g++)a[p]===1?h[d++]=l[p]:h[d++]=u[p];return n.makeTensorInfo(r.shape,c,h)}const _ce={kernelName:zf,backendName:"cpu",kernelFunc:Ece};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ce=tp,Rce=np,Ace=Zt(Fc,t=>t>=0?Rce*t:$ce*(Math.exp(t)-1)),Pce={kernelName:Fc,backendName:"cpu",kernelFunc:Ace};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dce=Zt(zc,t=>t<0?-1:t>0?1:0),Nce={kernelName:zc,backendName:"cpu",kernelFunc:Dce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mce=Zt(Uc,t=>Math.sin(t)),Lce={kernelName:Uc,backendName:"cpu",kernelFunc:Mce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oce=Zt(Bc,t=>Math.sinh(t)),Fce={kernelName:Bc,backendName:"cpu",kernelFunc:Oce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uce=11920928955078125e-23,m3=Math.log(Uce)+2,Bce=Zt(Vc,t=>{const e=t>-m3,n=t<m3,s=Math.exp(t);let r;return n?r=s:e?r=t:r=Math.log(1+s),r}),zce={kernelName:Vc,backendName:"cpu",kernelFunc:Bce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gce(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,paddings:o}=s;ot([r],"spaceToBatchND");const a=oe(i),l=[[0,0]];l.push(...o);for(let I=1+i.length;I<r.shape.length;++I)l.push([0,0]);const u=fD.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),c=Ml(u.shape,i,a,!1),h=Ll(c.length,i.length,!1),d=Ol(u.shape,i,a,!1),g=on({inputs:{x:u},backend:n,attrs:{shape:c}}),b=er({inputs:{x:g},backend:n,attrs:{perm:h}}),C=on({inputs:{x:b},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),C}const Vce={kernelName:Wf,backendName:"cpu",kernelFunc:Gce};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wce(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,c=n.data.get(o.dataId).values[0],[h,d,f,p,g]=FP(a,s.shape,s.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(d,s.dtype,h),n.makeTensorInfo([d[0]],r.dtype,f),n.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(m=>Number(m)))),n.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const Hce={kernelName:VE,backendName:"cpu",kernelFunc:Wce};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kce(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(n.data.get(r.dataId).values),a=n.data.get(s.dataId).values,l=Array.from(n.data.get(i.dataId).values),[u,c,h]=UP(a,s.shape,s.dtype,o,l);return[n.makeTensorInfo(c,s.dtype,u),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const jce={kernelName:WE,backendName:"cpu",kernelFunc:Kce};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xce(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[u,c]=q2(o,s.shape,s.dtype,a,l,!0);return n.makeTensorInfo(c,s.dtype,u)}const qce={kernelName:kv,backendName:"cpu",kernelFunc:Xce};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yce(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[u,c]=q2(o,s.shape,s.dtype,a,l);return n.makeTensorInfo(c,s.dtype,u)}const Zce={kernelName:Ev,backendName:"cpu",kernelFunc:Yce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qce(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=Ji(i,r,a),f=!1,p=n.bufferSync(r);let g;switch(i.dtype){case"bool":{const m=n.bufferSync(i),x=!!n.data.get(o.dataId).values[0];g=Ya(p,m,a,d,c,u,l,h,x,f);break}case"float32":{const m=n.bufferSync(i),x=n.data.get(o.dataId).values[0];g=Ya(p,m,a,d,c,u,l,h,x,f);break}case"int32":{const m=n.bufferSync(i),x=n.data.get(o.dataId).values[0];g=Ya(p,m,a,d,c,u,l,h,x,f);break}case"string":{const m=n.bufferSync(i),x=li(n.data.get(o.dataId).values[0]);g=Ya(p,m,a,d,c,u,l,h,x,f);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return n.makeTensorInfo(a,g.dtype,g.values)}const Jce={kernelName:_v,backendName:"cpu",kernelFunc:Qce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ehe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=wt(o,r.shape)[0],l=bx(r,i,a),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(h=>{const d=[...c];d[a]=h;const f=wl({inputs:{x:r},backend:n,attrs:{begin:u,size:d}});return u[a]+=h,f})}const the={kernelName:Hf,backendName:"cpu",kernelFunc:ehe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nhe={kernelName:M0,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,s=e;ot(n,"square");const r=s.data.get(n.dataId).values,i=new Float32Array(r.length);for(let a=0;a<r.length;++a){const l=r[a];i[a]=l*l}return{dataId:s.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const she=Zt(Yc,(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha}),rhe={kernelName:Yc,backendName:"cpu",kernelFunc:she};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ihe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s;ot(r,"stridedSlice");const{finalShapeSparse:f,finalShape:p,isIdentity:g,sliceDim0:m,isSimpleSlice:x,begin:b,end:v,strides:y}=tx(r.shape,i,o,a,l,u,c,h,d);let C;if(g)C=on({inputs:{x:r},backend:n,attrs:{shape:p}});else if(m||x){G(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const I=ex(b,v,y),$=wl({inputs:{x:r},backend:n,attrs:{begin:b,size:I}});C=on({inputs:{x:$},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo($)}else{const I=n.bufferSync(r),$=GP(f,I,y,b);C=n.makeTensorInfo(p,$.dtype,$.values)}return C}const ohe={kernelName:L0,backendName:"cpu",kernelFunc:ihe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ahe(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=n.data.get(c.dataId).values,f=n.data.get(h.dataId).values,[p,g]=VP(d,f,r,i,o,a,l,u);return[n.makeTensorInfo([p.length],"string",p),n.makeTensorInfo(h.shape,"int32",g)]}const lhe={kernelName:Rv,backendName:"cpu",kernelFunc:ahe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uhe(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.data.get(i.dataId).values,l=n.data.get(o.dataId).values[0],[u,c,h]=WP(a,l,r),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}const che={kernelName:HE,backendName:"cpu",kernelFunc:uhe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hhe(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=n.data.get(i.dataId).values,a=HP(o,r);return n.makeTensorInfo(i.shape,"int32",a)}const dhe={kernelName:KE,backendName:"cpu",kernelFunc:hhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fhe=Zt(jc,t=>Math.tan(t)),phe={kernelName:jc,backendName:"cpu",kernelFunc:fhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mhe=Zt(Xc,t=>Math.tanh(t)),ghe={kernelName:Xc,backendName:"cpu",kernelFunc:mhe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xhe(t){const{inputs:e,backend:n}=t,{tensor:s,indices:r,updates:i}=e,{sliceRank:o,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=Ji(i,r,s.shape),h=!1,d=n.bufferSync(r),f=n.bufferSync(i),p=n.bufferSync(s),g=Ya(d,f,s.shape,c,l,a,o,u,p,h);return n.makeTensorInfo(s.shape,g.dtype,g.values)}const bhe={kernelName:Tv,backendName:"cpu",kernelFunc:xhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yhe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:i}=s;ot(r,"tile");const o=jP(n.bufferSync(r),i);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const vhe={kernelName:qc,backendName:"cpu",kernelFunc:yhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function whe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:i,sorted:o}=s;ot(r,"topk");const a=n.data.get(r.dataId).values,[l,u]=qP(a,r.shape,r.dtype,i,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}const She={kernelName:O0,backendName:"cpu",kernelFunc:whe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Che(t){const{inputs:e,attrs:n,backend:s}=t,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=n,[c,h,d,f]=r.shape,[p,g]=u??[h,d],m=[c,p,g,f],x=lt(r.shape),b=x[0],v=x[1],y=x[2],C=lt(m),I=C[0],$=C[1],T=C[2],S=cs(r.dtype,oe(m));S.fill(l);const E=s.data.get(r.dataId).values,_=s.data.get(i.dataId).values;for(let P=0;P<c;++P){const M=i.shape[0]===1?_:_.subarray(P*8,P*8+8);for(let z=0;z<p;++z)for(let A=0;A<g;++A)for(let B=0;B<f;++B){let L;const U=M[6]*A+M[7]*z+1;if(U===0)continue;const j=(M[0]*A+M[1]*z+M[2])/U,Z=(M[3]*A+M[4]*z+M[5])/U,J=g3(j,d,a),se=g3(Z,h,a);switch(o){case"nearest":L=$he(E,h,d,b,v,y,P,se,J,B,l);break;case"bilinear":L=Rhe(E,h,d,b,v,y,P,se,J,B,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const fe=P*I+z*$+A*T+B;S[fe]=L}return s.makeTensorInfo(m,r.dtype,S)}return{dataId:s.write(S,m,r.dtype),shape:r.shape,dtype:r.dtype}}const The={kernelName:F0,backendName:"cpu",kernelFunc:Che};function g3(t,e,n){switch(n){case"reflect":return Ihe(t,e);case"wrap":return khe(t,e);case"nearest":return _he(t,e);case"constant":default:return Ehe(t)}}function Ihe(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const s=2*e;n<s&&(n=s*Math.trunc(-n/s)+n),n=n<-e?n+s:-n-1}else if(n>e-1)if(e<=1)n=0;else{const s=2*e;n-=s*Math.trunc(n/s),n>=e&&(n=s-n-1)}return cl(0,n,e-1)}function khe(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const s=e-1;n+=e*(Math.trunc(-n/s)+1)}else if(n>e-1)if(e<=1)n=0;else{const s=e-1;n-=e*Math.trunc(n/s)}return cl(0,n,e-1)}function Ehe(t,e){return t}function _he(t,e){return cl(0,t,e-1)}function Fh(t,e,n,s,r,i,o,a,l,u,c){const h=o*s+a*r+l*i+u;return 0<=a&&a<e&&0<=l&&l<n?t[h]:c}function $he(t,e,n,s,r,i,o,a,l,u,c){const h=Math.round(a),d=Math.round(l);return Fh(t,e,n,s,r,i,o,h,d,u,c)}function Rhe(t,e,n,s,r,i,o,a,l,u,c){const h=Math.floor(a),d=Math.floor(l),f=h+1,p=d+1,g=(p-l)*Fh(t,e,n,s,r,i,o,h,d,u,c)+(l-d)*Fh(t,e,n,s,r,i,o,h,p,u,c),m=(p-l)*Fh(t,e,n,s,r,i,o,f,d,u,c)+(l-d)*Fh(t,e,n,s,r,i,o,f,p,u,c);return(f-a)*g+(a-h)*m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ahe(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:i}=e;ot(i,"unique");const o=s.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:u}=YP(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}const Phe={kernelName:Av,backendName:"cpu",kernelFunc:Ahe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dhe(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r.shape.length,a=r.shape[i],l=new Array(o-1);let u=0;for(let f=0;f<o;f++)f!==i&&(l[u++]=r.shape[f]);const c=new Array(o).fill(0),h=r.shape.slice();h[i]=1;const d=new Array(a);for(let f=0;f<d.length;f++){c[i]=f;const p=wl({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});d[f]=on({inputs:{x:p},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(p)}return d}const Nhe={kernelName:jf,backendName:"cpu",kernelFunc:Dhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mhe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:i}=e,{numSegments:o}=s;ot(r,"unsortedSegmentSum");const a=r.shape.length,l=i.shape.length,u=[],c=[],h=a-l;let d=i;for(let p=0;p<h;++p){const g=mg({inputs:{input:d},backend:n,attrs:{dim:p+1}});d=g,c.push(g)}for(let p=0;p<o;++p){const g=ma(p,"int32"),m=n.makeTensorInfo([],"int32",g),x=hP({inputs:{a:m,b:d},backend:n}),b=ha({inputs:{x},backend:n,attrs:{dtype:"float32"}}),v=Ax({inputs:{a:b,b:r},backend:n}),y=hp({inputs:{x:v},backend:n,attrs:{axis:0,keepDims:!1}});u.push(y),c.push(m),c.push(x),c.push(b),c.push(v),c.push(y)}const f=dD({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(p=>n.disposeIntermediateTensorInfo(p)),f}const Lhe={kernelName:Xf,backendName:"cpu",kernelFunc:Mhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ohe=[Aoe,die,Doe,Moe,bie,Ooe,Uoe,zoe,Voe,Hoe,joe,qoe,Zoe,eae,nae,iae,aae,uae,hae,$oe,fae,mae,xae,vie,yae,gie,Sie,wae,fie,Cae,Iae,kae,_ae,Rae,Pae,Nae,Lae,Fae,Bae,Gae,Wae,Kae,Xae,Yae,Zae,Jae,tle,sle,rle,ile,ole,lle,hle,Soe,fle,Cie,wle,Tie,Sle,kie,_le,$le,Ale,_ie,Rie,Dle,Mle,Ole,Ule,Pie,Nie,pie,zle,Tae,Vle,Hle,jle,Coe,Lie,Fie,qle,Bie,Zle,eue,nue,iue,aue,uue,cue,Gie,due,pue,gue,bue,vue,Sue,Tue,Wie,kue,$ue,Pue,Kie,Xie,Mue,Fue,zue,Yie,Vue,Hue,Kue,fD,Yue,Ioe,Jie,Que,ece,nce,rce,mie,ay,oce,koe,Eoe,_oe,lce,cce,dce,pce,gce,xce,yce,aoe,wce,kce,_ce,Pce,uoe,Nce,Lce,Fce,coe,Rue,zce,Vce,Hce,jce,qce,Zce,Jce,the,foe,nhe,moe,xoe,rhe,ohe,lhe,che,dhe,woe,ule,phe,ghe,bhe,vhe,She,The,Zie,Phe,Nhe,Lhe,Wue];for(const t of Ohe)Dv(t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ka={},jp={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Fhe(t,e){Ka[t]=e}function fi(t,e){if(!(t in Ka)||e!=null){const s=Bhe(t,e);if(s!==null)Ka[t]=s;else return console.log("Could not get context for WebGL version",t),null}const n=Ka[t];return n==null||n.isContextLost()?(delete Ka[t],fi(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Ka[t])}function Uhe(t){if(!ue().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Bhe(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??Uhe(t);return n.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Ka[t]},!1),ue().getBool("SOFTWARE_WEBGL_ENABLED")&&(jp.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",jp)||n.getContext("experimental-webgl",jp):n.getContext("webgl2",jp)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Pd;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(Pd||(Pd={}));var Sr;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(Sr||(Sr={}));var xs;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(xs||(xs={}));function dp(t,e){return[e,t]}function zhe(t,e){return t*e}function Xp(t){const e=oe(t),n=Math.ceil(e/4);return A1(n)}function sh(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function Ghe(t,e){const[n,s]=sh(t,e);return n*s*4}function ew(t,e){const n=t;let s,r,i,o,a,l,u,c,h,d;return ue().getNumber("WEBGL_VERSION")===2?(s=n.R32F,r=n.R16F,i=n.RGBA16F,o=n.RGBA32F,a=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(s=t.RGBA,r=t.RGBA,i=t.RGBA,o=n.RGBA,a=t.RGBA,u=4,c=4,h=e!=null?e.HALF_FLOAT_OES:null,d=t.FLOAT,l=t.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ye(t,e){const n=e();return ue().getBool("DEBUG")&&Vhe(t),n}function Vhe(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+jhe(t,e))}const Whe=596e-10,Hhe=65504;function Khe(t){return!!(ue().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||Whe<Math.abs(t)&&Math.abs(t)<Hhe)}function jhe(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function qp(t,e){return Po(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Xhe(t,e){const n=Po(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ye(t,()=>t.shaderSource(n,e)),Ye(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function qhe(t,e){const n=Po(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ye(t,()=>t.shaderSource(n,e)),Ye(t,()=>t.compileShader(n)),ue().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw pD(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const Yhe=/ERROR: [0-9]+:([0-9]+):/g;function pD(t,e){const n=Yhe.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const s=+n[1],r=t.split(`
`),i=r.length.toString().length+2,o=r.map((h,d)=>Ru((d+1).toString(),i)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,s-1),u=o.slice(s-1,s),c=o.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Ru(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function Zhe(t){return Po(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function Qhe(t,e){if(Ye(t,()=>t.linkProgram(e)),!ue().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Bb(t,e){if(Ye(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Jhe(t,e){const n=Po(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Ye(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),Ye(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function ede(t,e){const n=Po(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Ye(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),Ye(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function tde(t){return Po(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function nde(t,e){const n=ue().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const s=`[${t}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(t>n||e>n){const s=`[${t}x${e}]`,r=`[${n}x${n}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function sde(t){return Po(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function x3(t,e,n,s,r,i,o){const a=t.getAttribLocation(e,n);return a===-1?!1:(Ye(t,()=>t.bindBuffer(t.ARRAY_BUFFER,s)),Ye(t,()=>t.vertexAttribPointer(a,r,t.FLOAT,!1,i,o)),Ye(t,()=>t.enableVertexAttribArray(a)),!0)}function rde(t,e,n){ude(t,n),Ye(t,()=>t.activeTexture(t.TEXTURE0+n)),Ye(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function ide(t,e,n){return Po(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function ode(t,e,n){return t.getUniformLocation(e,n)}function ade(t,e,n,s){Ye(t,()=>rde(t,e,s)),Ye(t,()=>t.uniform1i(n,s))}function zb(t,e,n){Ye(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),Ye(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function b3(t,e){Ye(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),Ye(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function Yp(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+lde(t,e))}function lde(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Po(t,e,n){const s=Ye(t,()=>e());if(s==null)throw new Error(n);return s}function ude(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+t.TEXTURE0;if(s<t.TEXTURE0||s>n){const r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function ju(t,e=2){return oe(t.slice(0,t.length-e))}function Xu(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Zp(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[ju(t),...Xu(t)]),e}function cde(t,e=!1){let n=ue().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ue().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ue().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=n/2),e&&(n=n*2,s=s*2,t=t.map((a,l)=>l>=t.length-2?uv(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=pa(t).newShape);let r=oe(t),i=null;t.length<=1&&r<=n?i=[1,r]:t.length===2&&t[0]<=n&&t[1]<=n?i=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?i=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?i=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?i=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(i=[t[0],t[1]*t[2]*t[3]]);const o=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||o)if(e){const a=ju(t);let l=2,u=2;t.length&&([l,u]=Xu(t)),r=a*(l/2)*(u/2),i=A1(r).map(c=>c*2)}else i=A1(r);return i}function Qp(t){return t%2===0}function xg(t,e){if(t=t.slice(-2),e=e.slice(-2),Pt(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t[t.length-1],s=e[e.length-1];if(n===s||Qp(n)&&Qp(s)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&Qp(t[0])&&Qp(e[0])}let Gb,Vb;function hde(t){if(Gb==null){const e=fi(t);Gb=e.getParameter(e.MAX_TEXTURE_SIZE)}return Gb}function dde(t){if(Vb==null){const e=fi(t);Vb=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Vb)}function fde(t){if(t===0)return 0;let e;const n=fi(t);return Vr(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:Vr(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function Vr(t,e){return t.getExtension(e)!=null}function y3(t){try{if(fi(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function pde(t){if(t===0)return!1;const e=fi(t);if(t===1){if(!Vr(e,"OES_texture_float"))return!1}else if(!Vr(e,"EXT_color_buffer_float"))return!1;return uy(e)}function mde(t){if(t===0)return!1;const e=fi(t);if(t===1){if(!Vr(e,"OES_texture_float")||!Vr(e,"WEBGL_color_buffer_float"))return!1}else{if(Vr(e,"EXT_color_buffer_float"))return uy(e);const s="EXT_color_buffer_half_float";if(Vr(e,s)){const r=e.getExtension(s);return gde(e,r)}return!1}return uy(e)}function uy(t){const e=ew(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const o=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(i),o}function gde(t,e){const n=ew(t,e),s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(s),t.deleteFramebuffer(o),a}function xde(t){return t!==2?!1:fi(t).fenceSync!=null}function fp(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&G(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const at=ue();at.registerFlag("HAS_WEBGL",()=>at.getNumber("WEBGL_VERSION")>0);at.registerFlag("WEBGL_VERSION",()=>y3(2)?2:y3(1)?1:0);at.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);at.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>at.get("WEBGL_VERSION")===2);at.registerFlag("WEBGL_CPU_FORWARD",()=>!0);at.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);at.registerFlag("WEBGL_PACK",()=>at.getBool("HAS_WEBGL"));at.registerFlag("WEBGL_PACK_NORMALIZATION",()=>at.getBool("WEBGL_PACK"));at.registerFlag("WEBGL_PACK_CLIP",()=>at.getBool("WEBGL_PACK"));at.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>at.getBool("WEBGL_PACK"));at.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>at.getBool("WEBGL_PACK"));at.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>at.getBool("WEBGL_PACK"));at.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>at.getBool("WEBGL_PACK"));at.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>at.getBool("WEBGL_PACK"));at.registerFlag("WEBGL_PACK_REDUCE",()=>at.getBool("WEBGL_PACK"));at.registerFlag("WEBGL_LAZILY_UNPACK",()=>at.getBool("WEBGL_PACK"));at.registerFlag("WEBGL_CONV_IM2COL",()=>at.getBool("WEBGL_PACK"));at.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>at.getBool("WEBGL_PACK"));at.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>hde(at.getNumber("WEBGL_VERSION")));at.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>dde(at.getNumber("WEBGL_VERSION")));at.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=at.getNumber("WEBGL_VERSION");return t===0?0:fde(t)});at.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>at.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!c_());at.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>pde(at.getNumber("WEBGL_VERSION")));at.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>at.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:at.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));at.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>mde(at.getNumber("WEBGL_VERSION")));at.registerFlag("WEBGL_FENCE_API_ENABLED",()=>xde(at.getNumber("WEBGL_VERSION")));at.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>at.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);at.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});at.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>c_()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});at.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);at.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);at.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);at.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);at.registerFlag("WEBGL_EXP_CONV",()=>!1);at.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>at.getBool("IS_TEST"));at.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);at.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);at.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);at.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bs(){let t,e,n,s,r,i,o,a,l,u;return ue().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",a=ue().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",s="varying",r="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bl(t,e,n="index"){const s=lt(e);return s.map((r,i)=>{const o=`int ${t[i]} = ${n} / ${r}`,a=i===s.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${r}`:`index -= ${t[i]} * ${r}`;return`${o}; ${a};`}).join("")}function Px(t,e,n="index"){const s=lt(e);return s.map((r,i)=>{const o=`int ${t[i]} = ${n} / outShapeStrides[${i}]`,a=i===s.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * outShapeStrides[${i}]`:`index -= ${t[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function bde(t,e){const n=t.length,s=t.map(i=>`${e}[${i}]`),r=new Array(n-1);r[n-2]=s[n-1];for(let i=n-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function yde(t,e,n="index"){const s=t.map((i,o)=>o),r=bde(s,e);return r.map((i,o)=>{const a=`int ${t[o]} = ${n} / ${r[o]}`,l=o===r.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * ${r[o]}`:`index -= ${t[o]} * ${r[o]}`;return`${a}; ${l};`}).join("")}function tw(t){const e=lt(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function nw(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const mD=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:gD}=ute;function vde(t,e,n){const s=[];if(t.forEach(f=>{const p=oe(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?s.push(`uniform float ${f.name}${p>1?`[${p}]`:""};`):(s.push(`uniform sampler2D ${f.name};`),s.push(`uniform int offset${f.name};`)),n.enableShapeUniforms){const{uniformShape:g}=sw(n.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(g.length){case 1:s.push(`uniform int ${f.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${f.name}Shape;`);break}s.push(`uniform ivec2 ${f.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(f=>{s.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const r=s.join(`
`),i=t.map(f=>wde(f,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),o=e.texShape,a=Bs(),l=Tde(a);let u,c,h=Ede(a);return e.isPacked?(u=Sde(e.logicalShape,o,n.enableShapeUniforms),c=kde(a)):(u=Cde(e.logicalShape,o,n.enableShapeUniforms),c=Ide(a)),n.packedInputs&&(h+=Ade),[h,l,c,r,u,i,n.userCode].join(`
`)}function rh(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return Vde(t,e);case 1:return Hde(t,e);case 2:return jde(t,e);case 3:return qde(t,e);case 4:return Zde(t,e);case 5:return Qde(t);case 6:return Jde(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function xD(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return Gde(t);case 1:return Wde(t,e);case 2:return Kde(t,e);case 3:return Xde(t,e);default:return Yde(t,e)}}function wde(t,e,n=!1,s){let r="";n?r+=xD(t,s):r+=rh(t,s);const i=t.shapeInfo.logicalShape,o=e.logicalShape;return i.length<=o.length&&(n?r+=efe(t,e):r+=tfe(t,e)),r}function Sde(t,e,n){switch(t.length){case 0:return bD();case 1:return Pde(t,e,n);case 2:return Bde(t,e,n);case 3:return Nde(t,e,n);default:return Lde(t,e,n)}}function Cde(t,e,n){switch(t.length){case 0:return bD();case 1:return Dde(t,e,n);case 2:return zde(t,e,n);case 3:return Mde(t,e,n);case 4:return Ode(t,e,n);case 5:return Fde(t,e);case 6:return Ude(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function Tde(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function Ide(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function kde(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function Ede(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${_de}
    ${$de}
    ${Rde}
  `}const _de=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,$de=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Rde=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Ade=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function bD(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Pde(t,e,n){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function Dde(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function Nde(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),i=r*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function Mde(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Px(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const s=Bl(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function Lde(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),i=r*Math.ceil(t[t.length-2]/2);let o=i,a="",l="b, r, c";for(let u=2;u<t.length-1;u++)o*=t[t.length-u-1],a=`
      int b${u} = index / ${o};
      index -= b${u} * ${o};
    `+a,l=`b${u}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${t.length}(${l});
    }
  `}function Ode(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Px(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Bl(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function Fde(t,e){const n=Bl(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Ude(t,e){const n=Bl(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Bde(t,e,n){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Pt(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function zde(t,e,n){return Pt(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function zl(t){return`offset${t}`}function Gde(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Bs();return`
    vec4 ${n}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function Vde(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${s}() {return ${n};}`;const[r,i]=t.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=zl(n);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});
      return sampleTexture(${n}, uv);
    }
  `;const[a,l]=t.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${n}, uv);
    }
  `}function Wde(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,i=Bs();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${n}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${n}, uv);
    }
  `}function Hde(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${ih(t)}
      }
    `;const r=t.shapeInfo.texShape,i=r[0],o=r[1];if(o===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const a=zl(n);return o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${n}, uv);
      }
    `:i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${a});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${n}, uv);
    }
  `}function Kde(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t.shapeInfo.texShape,o=i[0],a=i[1],l=Bs();if(i!=null&&Pt(n,i))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function jde(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t.shapeInfo.texShape;if(i!=null&&Pt(n,i)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const d=i[0],f=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:a}=pa(n),l=o;if(l.length<n.length){const d=oh(t,l),f=["row","col"];return`
      ${rh(d,e)}
      float ${r}(int row, int col) {
        return ${r}(${ah(f,a)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${ih(t)}
      }
    `;const u=i[0],c=i[1],h=zl(s);return c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${s}, uv);
    }
  `:u===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${s}, uv);
  }
`}function Xde(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(n[0]===1){const d=n.slice(1),f=[1,2],p=oh(t,d),g=["b","row","col"];return`
        ${xD(p,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${ah(g,f)});
        }
      `}const a=Bs();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const l=o[0],u=o[1],c=Math.ceil(n[2]/2),h=c*Math.ceil(n[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${c}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function qde(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n[1]*n[2],o=n[2],{newShape:a,keptDims:l}=pa(n),u=a;if(u.length<n.length){const g=oh(t,u),m=["row","col","depth"];return`
        ${rh(g,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${ah(m,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${ih(t)}
      }
    `;const c=t.shapeInfo.texShape,h=c[0],d=c[1],f=t.shapeInfo.flatOffset;if(d===i&&f==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(d===o&&f==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `;const p=zl(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${p};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${p};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${s}, uv);
      }
  `}function Yde(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=Bs();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);
    }
  `;const i=t.shapeInfo.logicalShape,o=i.length,a=t.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],h=Math.ceil(i[o-1]/2);let d=h*Math.ceil(i[o-2]/2),f="int b, int row, int col",p=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let g=2;g<o-1;g++)f=`int b${g}, `+f,d*=i[o-g-1],p=`b${g} * ${d} + `+p;return`
    vec4 ${s}(${f}) {
      int index = ${p};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${r.texture2D}(${n}, uv);
    }
  `}function Zde(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n[3],o=n[2]*i,a=n[1]*o,{newShape:l,keptDims:u}=pa(n);if(l.length<n.length){const b=oh(t,l),v=["row","col","depth","depth2"];return`
      ${rh(b,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${ah(v,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${ih(t)}
      }
    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],f=h[1],p=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,m=`int stride0 = ${s}Shape[1] * stride1;`;if(f===a&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${p}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(f===i&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;const x=zl(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${g}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${x});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${d}, ${f}, index + ${x});
      return sampleTexture(${s}, uv);
    }
  `}function Qde(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e[4],i=e[3]*r,o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:u}=pa(e);if(l.length<e.length){const g=oh(t,l),m=["row","col","depth","depth2","depth3"];return`
      ${rh(g)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${ah(m,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${r})) +
          depth3;
        ${ih(t)}
      }
    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],f=h[1];if(f===a&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===r&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;const p=zl(n);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${r} + depth3 + ${p};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Jde(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:i}=pa(e);if(r.length<e.length){const m=oh(t,r),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${rh(m)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${ah(x,i)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,u=e[2]*l,c=e[1]*u;if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${ih(t)}
      }
    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,f=d[0],p=d[1];if(p===c&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===o&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;const g=zl(n);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${g};
      vec2 uv = uvFromFlat(${f}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function ih(t){const e=t.name,n=oe(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function efe(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",i=t.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=gD(t.shapeInfo.logicalShape,e.logicalShape),l=Qt(o),u=o-i;let c;const h=["x","y","z","w","u","v"];i===0?c="":o<2&&a.length>=1?c="coords = 0;":c=a.map(b=>`coords.${h[b+u]} = 0;`).join(`
`);let d="";o<2&&i>0?d="coords":d=t.shapeInfo.logicalShape.map((b,v)=>`coords.${h[v+u]}`).join(", ");let f="return outputValue;";const g=oe(t.shapeInfo.logicalShape)===1,x=oe(e.logicalShape)===1;if(i===1&&!g&&!x)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!x)o===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){const b=i-2,v=i-1;a.indexOf(b)>-1&&a.indexOf(v)>-1?f="return vec4(outputValue.x);":a.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(v)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${s}(${d});
      ${f}
    }
  `}function tfe(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",i=e.texShape,o=t.shapeInfo.texShape,a=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&t.shapeInfo.flatOffset==null&&Pt(o,i))return`
      float ${r}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const u=Qt(l),c=gD(t.shapeInfo.logicalShape,e.logicalShape),h=l-a;let d;const f=["x","y","z","w","u","v"];a===0?d="":l<2&&c.length>=1?d="coords = 0;":d=c.map(g=>`coords.${f[g+h]} = 0;`).join(`
`);let p="";return l<2&&a>0?p="coords":p=t.shapeInfo.logicalShape.map((g,m)=>`coords.${f[m+h]}`).join(", "),`
    float ${r}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${s}(${p});
    }
  `}function Qt(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function sw(t,e,n){const{newShape:s,keptDims:r}=pa(e),i=e.length,o=t&&i===3&&e[0]===1,a=o?e.slice(1):s,l=!t&&i>1&&!Pt(e,n)&&s.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:r}}function oh(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function ah(t,e){return e.map(n=>t[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nfe(t,e,n,s){const r=n.map((c,h)=>{const d={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(d.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:d}}),i=r.map(c=>c.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=vde(r,o,e),l=qhe(t.gl,a),u=t.createProgram(l);return ue().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(u),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:i,outShapeInfo:o},yD(t,e,u)))}function yD(t,e,n){const s=[],r=[];let i,o,a,l=null,u=null;u=t.getUniformLocation(n,"NAN",!1),ue().getNumber("WEBGL_VERSION")===1&&(l=t.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const h of e.variableNames){const d={name:h,uniform:t.getUniformLocation(n,h,c),offset:t.getUniformLocation(n,`offset${h}`,c)};e.enableShapeUniforms&&(d.shape=t.getUniformLocation(n,`${h}Shape`,c),d.texShape=t.getUniformLocation(n,`${h}TexShape`,c)),s.push(d)}if(e.enableShapeUniforms&&(i=t.getUniformLocation(n,"outShape",c),a=t.getUniformLocation(n,"outShapeStrides",c),o=t.getUniformLocation(n,"outTexShape",c)),e.customUniforms)for(const h of e.customUniforms)r.push(t.getUniformLocation(n,h.name,c));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function v3(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,s)=>{const r=n.logicalShape,i=e[s],o=i.shape;if(!Pt(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(n.isUniform&&i.isUniform)return;const a=n.texShape,l=i.isUniform?null:i.texData.texShape;if(!Pt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function sfe(t,e,n,s,r){e.program.enableShapeUniforms||(v3(e.inShapeInfos,n),v3([e.outShapeInfo],[s]));const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?t.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):t.setOutputMatrixTexture(i.texture,o[0],o[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),ue().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<n.length;++l){const u=n[l],{uniform:c,offset:h,shape:d,texShape:f}=e.variablesLocations[l];if(d){const{uniformShape:p}=sw(e.program.packedInputs,u.shape,u.texData.texShape);switch(p.length){case 1:t.gl.uniform1iv(d,new Int32Array(p));break;case 2:t.gl.uniform2iv(d,new Int32Array(p));break;case 3:t.gl.uniform3iv(d,new Int32Array(p));break;case 4:t.gl.uniform4iv(d,new Int32Array(p));break}}if(f&&t.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(oe(u.shape)<2)t.gl.uniform1f(c,u.uniformValues[0]);else{let p=u.uniformValues;p instanceof Float32Array||(p=new Float32Array(p)),t.gl.uniform1fv(c,p)}continue}u.texData.slice!=null&&h!=null&&t.gl.uniform1i(h,u.texData.slice.flatOffset),t.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const a=e.outShapeLocation;if(a)switch(s.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=lt(s.shape);switch(s.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let l=0;l<e.program.customUniforms.length;++l){const u=e.program.customUniforms[l],c=e.customUniformLocations[l],h=r[l];if(u.type==="float")t.gl.uniform1fv(c,h);else if(u.type==="vec2")t.gl.uniform2fv(c,h);else if(u.type==="vec3")t.gl.uniform3fv(c,h);else if(u.type==="vec4")t.gl.uniform4fv(c,h);else if(u.type==="int")t.gl.uniform1iv(c,h);else if(u.type==="ivec2")t.gl.uniform2iv(c,h);else if(u.type==="ivec3")t.gl.uniform3iv(c,h);else if(u.type==="ivec4")t.gl.uniform4iv(c,h);else throw Error(`uniform type ${u.type} is not supported yet.`)}t.executeProgram()}function rfe(t,e,n){let s="";e.concat(n).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:h}=sw(t.packedInputs,o.shape,l);let d="",f="",p="";if(c.length===1&&t.packedInputs){const C=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${C[0]>1}_${C[1]>1}`}else if(c.length===2&&!t.packedInputs)f=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!t.packedInputs){const C=lt(c);p=`${C[0]===l[1]}_${C[C.length-1]===l[1]}`}const g=o.shape.length,m=c.length===2&&Pt(o.shape,l),x=oe(o.shape)===1,b=oa(o.shape,n.shape),v=!t.packedInputs&&g===n.shape.length&&Pt(l,n.texData.texShape),y=t.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${g}_${v}_${u?h:""}_${c.length}_${x}_${b}_${m}_${d}_${f}_${p}_${y}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${l}_${a}`}});const r=t.userCode;let i=t.constructor.name;return i+="_"+s+"_"+r+`${ue().getNumber("WEBGL_VERSION")}`,i}function _s(t){return ue().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ife{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Pd.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Bs();this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Px(["r","c","d"],e):Bl(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ofe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Pd.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Bs();this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Px(["r","c","d"],e):Bl(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class afe{constructor(e){this.variableNames=["A"],this.outTexUsage=Sr.DOWNLOAD;const n=Bs();this.outputShape=e,this.userCode=`
      ${mD}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lfe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Sr.DOWNLOAD;const n=Bs();this.outputShape=e,this.userCode=`
      ${mD}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ufe={R:0,G:1,B:2,A:3};class w3{constructor(e,n=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Bs();this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length);let i="result";n&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<s.length;a++){const l=s[a];o+=`
          if(offset == ${a}) {
            result = values[${ufe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?nw():tw(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cfe{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Bs();this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length);let r="",i="result";n&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?nw():tw(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hfe(t){const e=Bs(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Xhe(t,n)}function dfe(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Jhe(t,e)}function ffe(t){const e=new Uint16Array([0,1,2,2,1,3]);return ede(t,e)}function pp(t,e,n,s,r,i){nde(e,n);const o=tde(t),a=t.TEXTURE_2D;return Ye(t,()=>t.bindTexture(a,o)),Ye(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),Ye(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),Ye(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),Ye(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),ue().getNumber("WEBGL_VERSION")===1?Ye(t,()=>t.texImage2D(a,0,s,e,n,0,r,i,null)):Ye(t,()=>t.texStorage2D(a,1,s,e,n)),Ye(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:o,texShape:[n,e]}}function vD(t){return t.internalFormatFloat}function pfe(t,e,n,s){const[r,i]=dp(e,n);return pp(t,r,i,vD(s),s.textureFormatFloat,t.FLOAT)}function wD(t){return t.internalFormatHalfFloat}function mfe(t,e,n,s){const[r,i]=dp(e,n);return pp(t,r,i,wD(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function SD(t){return t.downloadTextureFormat}function gfe(t,e,n,s){const[r,i]=dp(e,n);return pp(t,r,i,SD(s),t.RGBA,t.UNSIGNED_BYTE)}function CD(t){return t.internalFormatPackedFloat}function xfe(t,e,n,s){const[r,i]=sh(e,n);return pp(t,r,i,CD(s),t.RGBA,t.FLOAT)}function TD(t){return t.internalFormatPackedHalfFloat}function bfe(t,e,n,s){const[r,i]=sh(e,n);return pp(t,r,i,TD(s),t.RGBA,s.textureTypeHalfFloat)}function yfe(t,e,n){return Ye(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),x3(t,e,"clipSpacePos",n,3,20,0)&&x3(t,e,"uv",n,2,20,12)}function vfe(t,e,n,s,r,i){Ye(t,()=>t.bindTexture(t.TEXTURE_2D,e));let o,a,l;r instanceof Uint8Array?(o=new Uint8Array(n*s*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(o=new Float32Array(n*s*4),a=t.FLOAT,l=i.internalFormatPackedFloat),o.set(r),ue().getNumber("WEBGL_VERSION")===2?Ye(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,s,t.RGBA,a,o)):Ye(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,s,0,t.RGBA,a,o)),Ye(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function wfe(t,e,n){Ye(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?ue().getNumber("WEBGL_VERSION")===2?Ye(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):Ye(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):ue().getNumber("WEBGL_VERSION")===2?Ye(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):Ye(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),Ye(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function Sfe(t,e,n,s){const r=t.createBuffer();Ye(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,r));const a=4*4*e*n;return Ye(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),Ye(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),Ye(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),r}function Cfe(t,e,n){const s=t,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function Tfe(t,e,n,s){const[r,i]=dp(e,n),o=4,a=new Uint8Array(zhe(e*n,o));return Ye(t,()=>t.readPixels(0,0,r,i,s.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function Ife(t,e,n,s,r,i,o,a){const l=t,u=new Float32Array(Ghe(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function kfe(t,e,n){const s=new Float32Array(e*n*4);return Ye(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wb{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=ue().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,Fhe(n,e)):this.gl=fi(n),e=this.gl,ue().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>Ye(i,()=>i.createVertexArray()),this.bindVertexArray=o=>Ye(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>Ye(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>Ye(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ye(e,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>Ye(e,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Ye(e,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>Ye(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ue().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=qp(this.gl,i),Vr(this.gl,o))this.textureHalfFloatExtension=qp(this.gl,o);else if(ue().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),Vr(this.gl,r))this.colorBufferHalfFloatExtension=qp(this.gl,r);else if(ue().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",Vr(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(Vr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=dfe(this.gl),this.indexBuffer=ffe(this.gl),this.framebuffer=sde(this.gl),this.textureConfig=ew(this.gl,this.textureHalfFloatExtension)}get debug(){return ue().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Ye(e,()=>e.finish()),Ye(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ye(e,()=>e.deleteFramebuffer(this.framebuffer)),Ye(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Ye(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Ye(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),pfe(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),mfe(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),gfe(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),wfe(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,s,r){this.throwIfDisposed(),vfe(this.gl,e,n,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),bfe(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),xfe(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(b3(this.gl,this.framebuffer),this.outputTexture=null),Ye(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,s){return this.downloadMatrixDriver(e,()=>Tfe(this.gl,n,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,s,r,i,o){return Ife(this.gl,e,n,s,r,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return Cfe(this.gl,e,n)}createBufferFromTexture(e,n,s){this.bindTextureToFrameBuffer(e);const r=Sfe(this.gl,n,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,s;if(ue().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},n=i}else ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(n,ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:n,isFencePassed:s}}downloadMatrixFromPackedTexture(e,n,s){return this.downloadMatrixDriver(e,()=>kfe(this.gl,n,s))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=hfe(n));const s=Zhe(n);Ye(n,()=>n.attachShader(s,this.vertexShader)),Ye(n,()=>n.attachShader(s,e)),Qhe(n,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Bb(n,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const n=this.gl;Ye(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),yfe(n,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Ye(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Bb(this.gl,this.program),Ye(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,s=!0){return this.throwIfDisposed(),s?ide(this.gl,e,n):ode(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),Ye(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,s){this.throwIfDisposed(),this.throwIfNoProgram(),ade(this.gl,e,n,s)}setOutputMatrixTexture(e,n,s){this.setOutputMatrixTextureDriver(e,s,n)}setOutputPackedMatrixTexture(e,n,s){this.throwIfDisposed();const[r,i]=sh(n,s);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,n,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,n)}setOutputPackedMatrixWriteRegion(e,n,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Bb(this.gl,this.program),Yp(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ye(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ye(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=qp(this.gl,ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,s=this.getQueryTimerExtensionWebGL2();n.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await aC(()=>this.disposed||this.isQueryAvailable(e,ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=Efe(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:s}=this.itemsToPoll[n];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ue().platform&&(s=ue().platform.setTimeoutCustom.bind(ue().platform)),aC(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),zb(this.gl,e,this.framebuffer),this.debug&&Yp(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(zb(this.gl,this.outputTexture,this.framebuffer),this.debug&&Yp(this.gl)):b3(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const s=n();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,n,s){this.throwIfDisposed();const r=this.gl;zb(r,e,this.framebuffer),this.debug&&Yp(r),this.outputTexture=e,Ye(r,()=>r.viewport(0,0,n,s)),Ye(r,()=>r.scissor(0,0,n,s))}setOutputMatrixWriteRegionDriver(e,n,s,r){this.throwIfDisposed(),Ye(this.gl,()=>this.gl.scissor(e,n,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function Efe(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:_fe,bincountImpl:ID,bincountReduceImpl:$fe,bitwiseAndImpl:Rfe,castImpl:Afe,ceilImpl:Pfe,concatImpl:Dfe,equalImpl:Nfe,expImpl:Mfe,expm1Impl:Lfe,floorImpl:Ofe,gatherNdImpl:Ffe,gatherV2Impl:Ufe,greaterImpl:Bfe,greaterEqualImpl:zfe,lessImpl:Gfe,lessEqualImpl:Vfe,linSpaceImpl:Wfe,logImpl:Hfe,maxImpl:Kfe,maximumImpl:jfe,minimumImpl:Xfe,multiplyImpl:qfe,negImpl:Yfe,notEqualImpl:Zfe,prodImpl:Qfe,raggedGatherImpl:Jfe,raggedRangeImpl:epe,raggedTensorToTensorImpl:tpe,rangeImpl:npe,rsqrtImpl:spe,scatterImpl:rpe,sigmoidImpl:ipe,simpleAbsImpl:kD,sliceImpl:ope,sparseFillEmptyRowsImpl:ape,sparseReshapeImpl:lpe,sparseSegmentReductionImpl:ED,sqrtImpl:upe,staticRegexReplaceImpl:cpe,stridedSliceImpl:hpe,stringNGramsImpl:dpe,stringSplitImpl:fpe,stringToHashBucketFastImpl:ppe,subImpl:mpe,tileImpl:gpe,topKImpl:xpe,transposeImpl:rw,uniqueImpl:bpe}=ZP;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _D(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function Os(t,e){return e===1?[t]:_D(t,e)}function ype(t,e){if(t===1)return"rc";let n="";for(let s=0;s<t;s++)n+=e[s],s<t-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vpe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=_s(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=Os("rc",this.rank),s=Qt(this.rank),r=this.getOutOfBoundsCondition(n),i=this.getSetup(n),o=this.getOutput(n);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${e[e.length-1-o]},`+i;n.push(i)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let s=this.rank-2;s<this.rank;s++)n+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $D{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${wpe(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?nw():tw(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function wpe(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?yde(["r","c","d"],"inputShape"):Bl(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Spe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,n,s){const r=C3(n,s),i=T3(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=S3(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let a;return r===xs.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===xs.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===xs.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===xs.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===xs.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,n,s,r){if(this.freeTextures==null)return;const i=C3(s,r),o=T3(n,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const a=S3(n,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=ue().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[o],c=u&&u.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Cpe(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function S3(t,e,n,s,r){const i=Tpe(e,s);let o;if(r){const[l,u]=sh(t[0],t[1]);o=l*u}else{const[l,u]=dp(t[0],t[1]);o=l*u}const a=Cpe(n,i);return o*a}function Tpe(t,e){switch(t){case xs.PACKED_2X2_FLOAT32:return CD(e);case xs.PACKED_2X2_FLOAT16:return TD(e);case xs.UNPACKED_FLOAT32:return vD(e);case xs.UNPACKED_FLOAT16:return wD(e);case xs.PACKED_4X1_UNSIGNED_BYTE:return SD(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function Ipe(t){return ue().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?xs.PACKED_2X2_FLOAT32:xs.UNPACKED_FLOAT32:t?xs.PACKED_2X2_FLOAT16:xs.UNPACKED_FLOAT16}function C3(t,e){if(t===Sr.UPLOAD)return xs.PACKED_2X2_FLOAT32;if(t===Sr.RENDER||t==null)return Ipe(e);if(t===Sr.DOWNLOAD||t===Sr.PIXELS)return xs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function T3(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Oi=class{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const qr="if (isnan(x)) return x;",kpe="return x;",I3="return abs(x);",Epe="return (x >= 0.0) ? x : (exp(x) - 1.0);",_pe=qr+`
  return (x < 0.0) ? 0.0 : x;
`,$pe=qr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ho="return x;",Rpe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ape="return x;",Ppe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Dpe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Npe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Mpe="return 1.0 / (1.0 + exp(-1.0 * x));";class Qo{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lpe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length);const n=e.length,s=Os("rc",n),r=Qt(n),i=ype(n,s),o=s.slice(-2),a=n<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ope=J_,Fpe=1e-7,Upe=1e-4,Jp={};function Bpe(t){return t in Jp||(Jp[t]={}),Jp[t]}const zpe=ue().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Gpe=600;function Vpe(){return ue().global.screen==null?1024:ue().global.screen.height*ue().global.screen.width*window.devicePixelRatio*Gpe/1024/1024}class Dx extends t0{nextDataId(){return Dx.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ue().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof Wb)n=e;else{const s=fi(ue().getNumber("WEBGL_VERSION"),e);n=new Wb(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=fi(ue().getNumber("WEBGL_VERSION"));n=new Wb(s),this.binaryCache=Bpe(ue().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Spe(this.gpgpu),this.numMBBeforeWarning=Vpe(),this.texData=new lv(this,br())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,s,r,i,o){const a=this.makeTensorInfo(n,s),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[r,i]},l.texShape=[r,i];const u=Zp(n),c=new w3(u,!1,o),h=this.runWebGLProgram(c,[a],s,[[r,i]]);return h.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,n,s){if((ue().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ue().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:s,values:e,usage:Sr.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,s,r,i){if(ue().getBool("DEBUG")&&this.checkNumericalProblems(n),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:n,usage:Sr.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:i,slice:o,shape:a,isPacked:l}=n;if(o!=null){let d;l?d=new Qo(a,Ho):d=new Oi(a,Ho);const f=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:r}],r),p=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),p}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const u=this.activeTimers!=null;let c;u&&(c=Hs());let h;if(r==="complex64"){const d=this.readSync(i.real.dataId),f=this.readSync(i.imag.dataId);h=ui(d,f)}else h=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=Hs()-c),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const p=this.pendingRead.get(e);return new Promise(g=>p.push(g))}const n=this.texData.get(e),{values:s,shape:r,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=n;if(i!=null){let p;l?p=new Qo(r,Ho):p=new Oi(r,Ho);const g=this.runWebGLProgram(p,[{dataId:e,shape:r,dtype:o}],o),m=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),m}if(s!=null)return this.convertAndCacheOnCPU(e);if(ue().getBool("DEBUG")&&!ue().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ue().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(o!=="complex64"&&ue().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const p=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(p.texture.texture,...Xp(r))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const p=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),g=p[0],m=p[1];h=ui(g,m)}else if(u==null)h=this.getValuesFromTexture(e);else{const p=oe(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,p)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const p=this.gpgpu.gl;Ye(p,()=>p.deleteBuffer(u))}const d=this.convertAndCacheOnCPU(e,h),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach(p=>p(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&br().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,n={}){const s=this.texData.get(e),{values:r,shape:i,slice:o,dtype:a,isPacked:l,texture:u}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let f;l?f=new Qo(i,Ho):f=new Oi(i,Ho);const p=this.runWebGLProgram(f,[{dataId:e,shape:i,dtype:a}],a),g=this.readToGPU(p,n);return this.disposeIntermediateTensorInfo(p),g}if(u==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,n.customTexShape),h=br().makeTensorFromTensorInfo(c),d=this.texData.get(c.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const s=n.map(r=>li(r));return Ct(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ct(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const s=e[n];if(!Khe(s))throw ue().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:s,isPacked:r}=this.texData.get(e),i=oe(n);if(ue().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),f=this.texData.get(d.dataId),p=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...Xp(n)).subarray(0,i);return this.disposeIntermediateTensorInfo(d),p}const o=ue().getBool("WEBGL_PACK")&&r===!0,a=o?Zp(n):n,l=o?new lfe(a):new afe(a),u=this.runWebGLProgram(l,[{shape:a,dtype:s,dataId:e}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=Eo(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=Eo(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);a.kernelMs=DE(l),a.getExtraProfileInfo=()=>l.map((u,c)=>({name:o[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Hs(),endMs:null}}endTimer(e){return ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Hs(),e)}async getQueryTime(e){if(ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,n),this.disposeData(s.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:s,texShape:r,usage:i,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(n,r,i,o)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=zpe){return ue().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&oe(s.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){yr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return Ope(e.shape,n)}packedUnaryOp(e,n,s){const r=new Qo(e.shape,n),i=this.compileAndRun(r,[e],s);return br().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=kD(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(ue().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,I3,e.dtype);const n=new Oi(e.shape,I3),s=this.compileAndRun(n,[e]);return br().makeTensorFromTensorInfo(s)}makeTensorInfo(e,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&ec(s[0])){const i=s.map(o=>vo(o));r=this.write(i,e,n)}else r=this.write(s,e,n);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:n}}makeOutput(e,n,s){return br().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,s),this)}unpackTensor(e){const n=new Lpe(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new vpe(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){const s=[ju(e.shape),...Xu(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[ju(n),...Xu(n)],o=new $D(i,s),a=!0,l=[s],u=this.runWebGLProgram(o,[r],e.dtype,l,a);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(e,n){const s=this.texData.get(e),{isPacked:r,shape:i,dtype:o}=s;if(n!=null){const d=oe(i),f=n[0]*n[1]*4;G(d<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Zp(i);let l;r?l=new ofe(a):l=new ife(a);const u=!0,c=[n??Xp(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,c,u,n);return{dtype:o,shape:i,dataId:h.dataId}}runWebGLProgram(e,n,s,r,i=!1,o){const a=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Pd.DENSE){const x=o??Xp(e.outputShape);l.texShape=x.map(b=>b*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),oe(a.shape)===0)return l.values=cs(a.dtype,0),a;const u=[],c=n.map(x=>{if(x.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(x.dataId);if(b.texture==null){if(!e.packedInputs&&oe(x.shape)<=ue().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:x.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=x.shape)}if(this.uploadToGPU(x.dataId),!!b.isPacked!=!!e.packedInputs)x=b.isPacked?this.unpackTensor(x):this.packTensor(x),u.push(x),b=this.texData.get(x.dataId);else if(b.isPacked&&!xg(b.shape,x.shape)){const v=x,y=x.shape;x.shape=b.shape,x=this.packedReshape(x,y),u.push(x),b=this.texData.get(x.dataId),v.shape=y}return{shape:x.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},d=rfe(e,c,h),f=this.getAndSaveBinary(d,()=>nfe(this.gpgpu,e,c,h)),p=this.activeTimers!=null;let g;p&&(g=this.startTimer()),ue().get("ENGINE_COMPILE_ONLY")||sfe(this.gpgpu,f,c,h,r),u.forEach(x=>this.disposeIntermediateTensorInfo(x)),p&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const m=ue().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const x=Hs();x-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=x)}if(!ue().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const x=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),x}return a}compileAndRun(e,n,s,r,i=!1){return s=s||n[0].dtype,this.runWebGLProgram(e,n,s,r,i)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ue().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=de(()=>{if(!ue().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ue().getBool("DEBUG");ue().set("DEBUG",!1);const n=this.abs(Ht(1e-8)).dataSync()[0];if(ue().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Fpe:Upe}uploadToGPU(e){const n=this.texData.get(e),{shape:s,dtype:r,values:i,texture:o,usage:a,isPacked:l}=n;if(o!=null)return;const u=this.activeTimers!=null;let c;u&&(c=Hs());let h=n.texShape;if(h==null&&(h=cde(s,l),n.texShape=h),i!=null){const d=Zp(s);let f,p=h[1],g=h[0];const m=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!m)&&([p,g]=sh(h[0],h[1])),l?f=new cfe(d,m):f=new w3(d,m);const x=m?[g,p]:h,b=this.makeTensorInfo(x,r),v=this.texData.get(b.dataId);m?v.usage=Sr.PIXELS:v.usage=Sr.UPLOAD,v.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),p,g,i);const y=[[g,p]],I=this.runWebGLProgram(f,[b],r,y,!0),$=this.texData.get(I.dataId);n.texShape=$.texShape,n.isPacked=$.isPacked,n.usage=$.usage,ue().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(n.texture=$.texture,n.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(b),u&&(this.uploadWaitMs+=Hs()-c)}else{const d=this.acquireTexture(h,a,r,l);n.texture=d}}convertAndCacheOnCPU(e,n){const s=this.texData.get(e),{dtype:r}=s;return n!=null&&(s.values=Wpe(n,r)),s.values}acquireTexture(e,n,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,r)}computeBytes(e,n){return e[0]*e[1]*Km(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(i){throw i}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await g$(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(pD(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:n,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=yD(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=o,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,n,s){e.channels=e.channels||"RGBA";const{texture:r,height:i,width:o,channels:a}=e,l=br().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(r,n,s,i,o,a);return br().makeTensorFromDataId(u,n,s,l)}}Dx.nextDataId=0;function Wpe(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let s=0;s<n.length;++s)n[s]=Math.round(t[s]);return n}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */h_()&&Mv("webgl",()=>new Dx,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iw=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let Sl=class{constructor(e,n,s){this.variableNames=["A","B"],this.outputShape=pt(n,s),this.enableShapeUniforms=_s(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gl=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class lh{constructor(e,n,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=pt(n,s);const i=this.outputShape.length;this.enableShapeUniforms=_s(i);let o="";if(r)if(i===0||oe(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Qt(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Os("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fr(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Hpe={kernelName:Sc,backendName:"webgl",kernelFunc:fr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sa(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,i=n.makeTensorInfo(s.shape,"complex64"),o=n.texData.get(i.dataId),a=fr({inputs:{x:s},backend:n}),l=fr({inputs:{x:r},backend:n});return o.complexTensorInfos={real:a,imag:l},i}const Kpe={kernelName:u0,backendName:"webgl",kernelFunc:Sa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RD="return (a < 0.) ? b * a : a;",AD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function jpe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:i}=s,o=n.makeTensorInfo([],"float32",ma(i,"float32")),a=ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new lh(AD,r.shape,o.shape):new Sl(RD,r.shape,o.shape),l=n.runWebGLProgram(a,[r,o],"float32");return n.disposeIntermediateTensorInfo(o),l}const Xpe={kernelName:gf,backendName:"webgl",kernelFunc:jpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PD="return (a < 0.) ? b * a : a;",DD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function qpe(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e,i=ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new lh(DD,s.shape,r.shape):new Sl(PD,s.shape,r.shape);return n.runWebGLProgram(i,[s,r],"float32")}const Ype={kernelName:Mf,backendName:"webgl",kernelFunc:qpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uh="if (isnan(x)) return x;";function Ut({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,a=i,l=s||o.dtype;if(a.shouldExecuteOnCPU([o])&&n!=null){const h=a.texData.get(o.dataId),d=n(h.values,l);return a.makeTensorInfo(o.shape,l,d)}const u=ue().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return u?c=new Qo(o.shape,e):c=new Oi(o.shape,t),a.runWebGLProgram(c,[o],l)}}function ws({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:u}=o,c=a;if(s&&l.dtype==="complex64"){const p=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[m,x]=[[p.complexTensorInfos.real,g.complexTensorInfos.real],[p.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(v=>{const[y,C]=v,I={dataId:y.dataId,dtype:y.dtype,shape:l.shape},$={dataId:C.dataId,dtype:C.dtype,shape:u.shape},T=new Sl(t,l.shape,u.shape);return c.runWebGLProgram(T,[I,$],hs(y.dtype,C.dtype))}),b=Sa({inputs:{real:m,imag:x},backend:c});return c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(x),b}const h=i||hs(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&r!=null){const p=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,m=l.dtype==="string"?ci(p):p,x=l.dtype==="string"?ci(g):g,[b,v]=r(l.shape,u.shape,m,x,h),y=c.makeTensorInfo(v,h),C=c.texData.get(y.dataId);return C.values=b,y}const d=ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let f;return d?f=new lh(e,l.shape,u.shape,n):f=new Sl(t,l.shape,u.shape),c.runWebGLProgram(f,[l,u],h)}}function Dd(t,e=!1){if(t==="linear")return e?Ape:kpe;if(t==="relu")return e?Dpe:_pe;if(t==="elu")return e?Ppe:Epe;if(t==="relu6")return e?Npe:$pe;if(t==="prelu")return e?DD:PD;if(t==="leakyrelu")return e?AD:RD;if(t==="sigmoid")return e?Mpe:Rpe;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ND=class{constructor(e,n,s,r=!1,i=!1,o=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=_s(this.outputShape.length);const c=r?e[1]:e[2],h=Math.ceil(c/2),d=r?"i * 2, rc.y":"rc.y, i * 2",f=i?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",x="";a&&(l?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:m=`vec4 activation(vec4 x) {
          ${a}
        }`,x="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let v="rc.x",y="rc.x";e[0]<n[0]?v=`imod(rc.x, ${e[0]})`:n[0]<e[0]&&(y=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${v};
        int batchB = ${y};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${g[0]});
          result += (${p[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${x}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k3={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let E3=class{constructor(e,n,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=pt(n,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _3="return a * b;";function ow(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,i=hs(s.dtype,r.dtype);if(s.dtype==="complex64"){const a=n.texData.get(s.dataId),l=n.texData.get(r.dataId),u=new E3(k3.REAL,s.shape,r.shape),c=new E3(k3.IMAG,s.shape,r.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],d=n.runWebGLProgram(u,h,"float32"),f=n.runWebGLProgram(c,h,"float32"),p=Sa({inputs:{real:d,imag:f},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),p}if(n.shouldExecuteOnCPU([s,r])){const a=n.texData.get(s.dataId),l=n.texData.get(r.dataId),[u,c]=qfe(s.shape,r.shape,a.values,l.values,i),h=n.makeTensorInfo(c,i),d=n.texData.get(h.dataId);return d.values=u,h}let o;return ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new lh(_3,s.shape,r.shape):o=new Sl(_3,s.shape,r.shape),n.runWebGLProgram(o,[s,r],i)}const Zpe={kernelName:Ac,backendName:"webgl",kernelFunc:ow};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qpe(t,e,n){const s=[ju(t.shape),...Xu(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},i=[ju(e),...Xu(e)],o=new $D(i,s),a=!0,l=[s],u=n.runWebGLProgram(o,[r],t.dtype,l,a);return{dataId:u.dataId,shape:e,dtype:u.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function je(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:i}=s,o=n,a=oe(r.shape),l=cv(i,a),u=oe(l);G(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=o.texData.get(r.dataId);return c.isPacked&&!xg(r.shape,l)&&!(c.texture!==null&&xg(c.shape,l))?Qpe(r,l,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const Jpe={kernelName:Of,backendName:"webgl",kernelFunc:je};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $3{constructor(e,n){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];const a=Math.floor(s/4)*4,l=s%4;let u="sumValue += dot(values, ones);";if(n!=null){const h=1/n;u=`sumValue += dot(values * ${Fu(h)?h.toPrecision(2):h}, ones);`}let c="";i%s>0&&(c=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eme=class{constructor(e,n){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];let a="0.0",l="";n==="prod"?a="1.0":n==="min"?(a="1.0 / 1e-20",l="min"):n==="max"&&(a="-1.0 / 1e-20",l="max");let u=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?u="sumValue":n==="prod"?u="prodValue":n==="all"?u="allValue":n==="any"&&(u="anyValue");const c=Math.floor(s/4)*4,h=s%4;let d=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";n==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):n==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let p="";i%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${u});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tme(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],s=sx(n);e.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return e}function Vl(t,e,n,s){const r=tme(t.shape);let i=t;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:u}=r[o];let c,h;n==="mean"?c=o===0?new $3({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},a):new $3({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u}):c=new eme({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},n),h=i,i=s.runWebGLProgram(c,[i],e),h.dataId!==t.dataId&&s.disposeIntermediateTensorInfo(h)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nme=class{constructor(e,n){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[n[o]];this.outputShape=s,this.rank=s.length;const r=Qt(this.rank),i=sme(n);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}};function sme(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<t.length;r++)s[t[r]]=n[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rme{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let c=0;c<s.length;c++)s[c]=e[n[c]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Qt(this.rank),i=_D("rc",this.rank),o=new Array(this.rank);for(let c=0;c<n.length;c++)o[n[c]]=i[c];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${s[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nx(t,e,n){const s=ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rme(t.shape,e):new nme(t.shape,e);return n.runWebGLProgram(s,[t],t.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ime(t,e,n,s){const r=e,i=t.shape.length,o=wt(r,t.shape);let a=o;const l=Jt(a,i),u=l!=null;let c=t;u&&(c=Nx(t,l,s),a=an(a.length,i)),qn("sum",a,i);const[h,d]=Gn(c.shape,a);let f=h;n&&(f=zn(h,o));const p=oe(d),m=oe(t.shape)/p,x=je({inputs:{x:c},attrs:{shape:[m,p]},backend:s}),b=z0(t.dtype),v=Vl(x,b,"sum",s),y=je({inputs:{x:v},attrs:{shape:f},backend:s});return s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(v),u&&s.disposeIntermediateTensorInfo(c),y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mx(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;return ime(r,i,o,n)}const ome={kernelName:Vf,backendName:"webgl",kernelFunc:Mx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Us(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{perm:i}=s,o=n,a=r.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=r.shape[i[c]];let u;if(o.shouldExecuteOnCPU([r])){const h=o.texData.get(r.dataId).values,d=rw(h,r.shape,r.dtype,i,l);u=o.makeTensorInfo(l,r.dtype);const f=o.texData.get(u.dataId);f.values=d}else u=Nx(r,i,o);return u}const ame={kernelName:rl,backendName:"webgl",kernelFunc:Us};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MD=1e3;function bg({a:t,b:e,transposeA:n,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const u=t.shape.length,c=e.shape.length,h=n?t.shape[u-2]:t.shape[u-1],d=s?e.shape[c-1]:e.shape[c-2],f=n?t.shape[u-1]:t.shape[u-2],p=s?e.shape[c-2]:e.shape[c-1],g=t.shape.slice(0,-2),m=e.shape.slice(0,-2),x=oe(g),b=oe(m),y=pt(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([f,p]);G(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${s} must match.`);const C=n?[x,h,f]:[x,f,h],I=s?[b,p,d]:[b,d,p],$=je({inputs:{x:t},backend:r,attrs:{shape:C}}),T=je({inputs:{x:e},backend:r,attrs:{shape:I}}),S=[$,T],E=Math.max(x,b),_=n?$.shape[1]:$.shape[2],N=i!=null,P=o!=null,M=l==="leakyrelu",z=l!=null?Dd(l,!0):null,A=N||P||M||z!=null;let B;if((f===1||p===1)&&_>MD&&A===!1){let U=$,j=T;n&&(U=Us({inputs:{x:$},backend:r,attrs:{perm:[0,2,1]}}),S.push(U)),s&&(j=Us({inputs:{x:T},backend:r,attrs:{perm:[0,2,1]}}),S.push(j));const Z=p!==1,J=p===1;let se=U;Z&&(se=je({inputs:{x:U},backend:r,attrs:{shape:[E,_,1]}}),S.push(se));const fe=p===1?2:1;let he=j;J&&(he=je({inputs:{x:j},backend:r,attrs:{shape:[E,1,_]}}),S.push(he));const ve=ow({inputs:{a:se,b:he},backend:r});B=Mx({inputs:{x:ve},backend:r,attrs:{axis:fe,keepDims:!0}}),S.push(ve)}else{const U=hs(t.dtype,e.dtype),j=new ND(C,I,[E,f,p],n,s,N,z,P,M),Z=[$,T];if(i!=null&&Z.push(i),P&&Z.push(o),M){const J=r.makeTensorInfo([],"float32",ma(a,"float32"));Z.push(J),S.push(J)}B=r.runWebGLProgram(j,Z,U)}const L=je({inputs:{x:B},backend:r,attrs:{shape:y}});S.push(B);for(const U of S)r.disposeIntermediateTensorInfo(U);return L}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lme(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;return bg({a:r,b:i,transposeA:l,transposeB:u,backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}const ume={kernelName:wd,backendName:"webgl",kernelFunc:lme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R3="return abs(x);";function cme(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=n.texData.get(s.dataId),o=kD(i.values);return n.makeTensorInfo(s.shape,s.dtype,o)}let r;return ue().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Qo(s.shape,R3):r=new Oi(s.shape,R3),n.runWebGLProgram(r,[s],s.dtype)}const hme={kernelName:qd,backendName:"webgl",kernelFunc:cme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dme=qr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,fme=Ut({opSnippet:dme}),pme={kernelName:nc,backendName:"webgl",kernelFunc:fme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mme=qr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,gme=Ut({opSnippet:mme}),xme={kernelName:sc,backendName:"webgl",kernelFunc:gme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A3="return a + b;",bme=ws({opSnippet:A3,packedOpSnippet:A3,supportsComplex:!0,cpuKernelImpl:_fe}),yme={kernelName:$l,backendName:"webgl",kernelFunc:bme};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vme{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let wme=class{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function km(t){const{inputs:e,backend:n}=t,s=e;if(s.length===1)return fr({inputs:{x:s[0]},backend:n});if(s.length>ue().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),u=km({inputs:s.slice(0,l),backend:n}),c=km({inputs:s.slice(l),backend:n});return km({inputs:[u,c],backend:n})}const r=s.map(l=>l.dtype).reduce((l,u)=>hs(l,u)),i=s.map(l=>l.shape),a=ue().getBool("WEBGL_PACK")?new wme(s[0].shape,i):new vme(s[0].shape,i);return n.runWebGLProgram(a,s,r)}const Sme={kernelName:s0,backendName:"webgl",kernelFunc:km};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cme(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=wt(i,r.shape);let u=l;const c=Jt(u,a);let h=r;c!=null&&(h=Us({inputs:{x:r},backend:n,attrs:{perm:c}}),u=an(u.length,a)),qn("all",u,a);const[d,f]=Gn(h.shape,u),p=oe(f),g=je({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}}),m=Vl(g,g.dtype,"all",n);let x;if(o){const b=zn(d,l);x=je({inputs:{x:m},backend:n,attrs:{shape:b}})}else x=je({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),c!=null&&n.disposeIntermediateTensorInfo(h),x}const Tme={kernelName:r0,backendName:"webgl",kernelFunc:Cme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ime(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=wt(i,r.shape);let u=l;const c=Jt(u,a);let h=r;c!=null&&(h=Us({inputs:{x:r},backend:n,attrs:{perm:c}}),u=an(u.length,a)),qn("any",u,a);const[d,f]=Gn(h.shape,u),p=oe(f),g=je({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}}),m=Vl(g,g.dtype,"any",n);let x;if(o){const b=zn(d,l);x=je({inputs:{x:m},backend:n,attrs:{shape:b}})}else x=je({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),c!=null&&n.disposeIntermediateTensorInfo(h),x}const kme={kernelName:i0,backendName:"webgl",kernelFunc:Ime};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Eme=class{constructor(e,n,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=n==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _me{constructor(e,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,G(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],o=Math.ceil(i/n);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=Qt(l),c=Os("coords",l);let h,d;if(o===1){d=l+1;const T=Qt(d);h=`
        ${T} sourceLocR = ${T}(${c.join()}, 0);
        ++${c[l-1]};
        ${T} sourceLocG = ${T}(${c.join()}, 0);
        ++${c[l-2]};
        ${T} sourceLocA = ${T}(${c.join()}, 0);
        --${c[l-1]};
        ${T} sourceLocB = ${T}(${c.join()}, 0);
        --${c[l-2]};`}else d=l,h=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,d),p="."+f[d-1],g=f.map(T=>"int "+T),m=Os("sourceLocR",d-1).concat("inIdx.r"),x=Os("sourceLocG",d-1).concat("inIdx.g"),b=Os("sourceLocB",d-1).concat("inIdx.b"),v=Os("sourceLocA",d-1).concat("inIdx.a"),y=s==="max"?"greaterThan":"lessThan",C=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${v.join()})));`,I=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,$=r?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${$}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${I};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${C}
          vec4 candidate = ${I};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${y}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LD(t,e,n,s=null){let r=e.shape[0],i=e.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const o=sx(i),a={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},l=new Eme(a,n,s==null),u=[e];s!=null&&u.push(s);const c=t.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const h=LD(t,e,n,c);return t.disposeIntermediateTensorInfo(c),h}function OD(t,e,n,s=null){const r=s!=null?s.shape:e.shape,i=r[r.length-1],o=sx(i),a=new _me(r,o,n,s==null),l=s==null?[e]:[e,s],u=t.runWebGLProgram(a,l,"int32");if(u.shape.length===e.shape.length){const c=OD(t,e,n,u);return t.disposeIntermediateTensorInfo(u),c}return u}function FD(t,e,n,s){const r=[n];if(qn("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!ue().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],o=t.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=t.unpackTensor(e),i.push(l));const[u,c]=Gn(l.shape,r),h=oe(c),d=je({inputs:{x:l},backend:t,attrs:{shape:[-1,h]}});i.push(d);const f=LD(t,d,s);i.push(f);const p=je({inputs:{x:f},backend:t,attrs:{shape:u}});return i.forEach(g=>t.disposeIntermediateTensorInfo(g)),p}return OD(t,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $me(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;let o=wt(i,r.shape);const a=Jt(o,r.shape.length);let l=r;const u=[];a!=null&&(l=Us({inputs:{x:r},backend:n,attrs:{perm:a}}),u.push(l),o=an(o.length,l.shape.length)),qn("argMax",[o[0]],l.shape.length);const c=FD(n,l,o[0],"max");return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const Rme={kernelName:Yd,backendName:"webgl",kernelFunc:$me};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ame(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;let o=wt(i,r.shape);const a=Jt(o,r.shape.length);let l=r;const u=[];a!=null&&(l=Us({inputs:{x:r},backend:n,attrs:{perm:a}}),u.push(l),o=an(o.length,l.shape.length)),qn("argMin",[o[0]],l.shape.length);const c=FD(n,l,o[0],"min");return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const Pme={kernelName:Zd,backendName:"webgl",kernelFunc:Ame};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dme=qr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Nme=Ut({opSnippet:Dme}),Mme={kernelName:rc,backendName:"webgl",kernelFunc:Nme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lme=qr+"return log(x + sqrt(x * x + 1.0));",Ome=Ut({opSnippet:Lme}),Fme={kernelName:ic,backendName:"webgl",kernelFunc:Ome};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ume=qr+`
  return atan(x);
`,Bme=Ut({opSnippet:Ume}),zme={kernelName:oc,backendName:"webgl",kernelFunc:Bme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gme=iw+`
  return atan(a, b);
`,Vme=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Gl+`
  return result;
`,Wme=ws({opSnippet:Gme,packedOpSnippet:Vme}),Hme={kernelName:lc,backendName:"webgl",kernelFunc:Wme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kme=qr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,jme=Ut({opSnippet:Kme}),Xme={kernelName:ac,backendName:"webgl",kernelFunc:jme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Nd=class{constructor(e,n,s,r=!1,i=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const g=n==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,x=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(g||(b="-1.0 / 1e-20"),s){const T=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${f}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${T} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?m:x:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const v="max";let y=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(y="avgValue / max(count, 1.0)");const C=Math.floor(o/4)*4,I=o%4,$=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${f}, ${p});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${C}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${$}
          }

          int xC = xCCorner + ${C};
          if (${I===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${I===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${I===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${$}
          }
        }
        setOutput(${y});
      }
    `}},aw=class{constructor(e,n,s,r=!1,i=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterDepth,p=e.effectiveFilterHeight,g=e.effectiveFilterWidth,m=e.padInfo.front,x=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const v=n==="avg";let y="0.0";if(v||(y="-1.0 / 1e-20"),s){const E=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${u});
        const ivec3 pads = ivec3(${m}, ${x}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${E} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const C="max";let I=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(I="avgValue / max(count, 1.0)");const $=Math.floor(o/4)*4,T=o%4,S=`
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${u});
      const ivec3 pads = ivec3(${m}, ${x}, ${b});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${$}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${S}
            }

            int xC = xCCorner + ${$};
            if (${T===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${S}
            } else if (${T===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${S}
            } else if (${T===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${S}
            }
          }
        }
        setOutput(${I});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qme(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;fp(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,u=1;G(ds(o,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=ks(r.shape,i,o,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&Pt(c.inShape,c.outShape))return fr({inputs:{x:r},backend:n});const h=new Nd(c,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}const Yme={kernelName:Qd,backendName:"webgl",kernelFunc:qme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zme(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=s,c=[1,1,1],h=Er(r.shape,i,o,c,a,l,u),d=new aw(h,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}const Qme={kernelName:Jd,backendName:"webgl",kernelFunc:Zme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Jme=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=l-1-e.padInfo.top,h=u-1-e.padInfo.left,d=1/(n*s);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},ege=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,p=h-1-e.padInfo.front,g=d-1-e.padInfo.top,m=f-1-e.padInfo.left,x=1/(n*s*r);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${g}, ${m});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tge(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=[1,1,1],d=Er(o.shape,a,l,h,u,c),f=new ege(d);return n.runWebGLProgram(f,[r],o.dtype)}const nge={kernelName:a0,backendName:"webgl",kernelFunc:tge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sge(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,o=i;fp([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=ks(o.shape,a,l,1,u),h=new Jme(c);return n.runWebGLProgram(h,[r],o.dtype)}const rge={kernelName:o0,backendName:"webgl",kernelFunc:sge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ige(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;return bg({a:r,b:i,transposeA:o,transposeB:a,backend:n})}const oge={kernelName:ef,backendName:"webgl",kernelFunc:ige};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let age=class{constructor(e,n,s,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],pt(e,n),pt(e,s);let a="0.0";r!=null&&(pt(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";i!=null&&(pt(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lge{constructor(e,n,s,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],pt(e,n),pt(e,s);let a="vec4(0.0)";r!=null&&(pt(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(pt(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uge=({inputs:t,backend:e,attrs:n})=>{const{x:s,mean:r,variance:i,offset:o,scale:a}=t;G(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),G(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),G(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const u=[s,r,i];let c=null;o!=null&&(c=o.shape,u.push(o));let h=null;a!=null&&(h=a.shape,u.push(a));const d=ue().getBool("WEBGL_PACK_NORMALIZATION")?new lge(s.shape,r.shape,i.shape,c,h,l):new age(s.shape,r.shape,i.shape,c,h,l);return e.runWebGLProgram(d,u,u[0].dtype)},cge={kernelName:ff,backendName:"webgl",kernelFunc:uge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hge=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=Qt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=dge(this.rank);let r;const i=e.map((o,a)=>`sourceLoc.${cy[a]} = start[${a}] + coords.${cy[a]};`);r=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}};const cy=["x","y","z","w","u","v"];function dge(t){if(t===1)return"sourceLoc";if(t<=6)return cy.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fge{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Qt(this.rank),s=Os("coords",this.rank),r=Os("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((c,h)=>`start[${h}]`).join()});`:e.map((c,h)=>`${r[h]} = ${s[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pge(t,e,n,s){const r=s.texData.get(t.dataId),i=s.makeTensorInfo(n,t.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=n,o.dtype=t.dtype;let a=y2(e,lt(t.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||t.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),i}function ch(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,size:o}=s,[a,l]=ep(r,i,o);if(J0(r,a,l),oe(l)===0)return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=n.texData.get(r.dataId),d=ope(h.values,a,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,d)}const{isPacked:u}=n.texData.get(r.dataId),c=b2(r.shape,a,l);if(u||!c){const h=ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fge(l):new hge(l),d=[a];return n.runWebGLProgram(h,[r],r.dtype,d)}return n.uploadToGPU(r.dataId),pge(r,a,l,n)}const mge={kernelName:Gf,backendName:"webgl",kernelFunc:ch};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gge=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,crops:o}=s;G(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((b,v)=>b*v),l=Ml(r.shape,i,a),u=Ll(l.length,i.length),c=Ol(r.shape,i,a),h=ix(o,i.length),d=ox(c,o,i.length),f=[],p=je({inputs:{x:r},backend:n,attrs:{shape:l}}),g=Us({inputs:{x:p},backend:n,attrs:{perm:u}}),m=je({inputs:{x:g},backend:n,attrs:{shape:c}}),x=ch({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return f.push(p),f.push(g),f.push(m),f.forEach(b=>n.disposeIntermediateTensorInfo(b)),x},xge={kernelName:tf,backendName:"webgl",kernelFunc:gge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bge(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:o}=s,a=n.readSync(r.dataId),l=n.readSync(i.dataId),u=ID(a,l,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,u)}const yge={kernelName:l0,backendName:"webgl",kernelFunc:bge};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vge=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,wge=`
  return float(int(a.r) & int(b.r));
`;function Sge(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,i=ue().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=ue().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([s,r])||o===1){const l=n.texData.get(s.dataId).values,u=n.texData.get(r.dataId).values,[c,h]=Rfe(s.shape,r.shape,l,u,s.dtype),d=n.makeTensorInfo(h,s.dtype),f=n.texData.get(d.dataId);return f.values=c,d}let a;return i?a=new lh(vge,s.shape,r.shape,!1):a=new Sl(wge,s.shape,r.shape),n.runWebGLProgram(a,[s,r],s.dtype)}const Cge={kernelName:mv,backendName:"webgl",kernelFunc:Sge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tge(t){const{inputs:e,backend:n}=t,{s0:s,s1:r}=e,i=n.readSync(s.dataId),o=n.readSync(r.dataId),a=pt(Array.from(i),Array.from(o));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const Ige={kernelName:gv,backendName:"webgl",kernelFunc:Tge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kge="return float(a != b);",UD=ws({opSnippet:kge,cpuKernelImpl:Zfe,dtype:"bool"}),Ege={kernelName:Rf,backendName:"webgl",kernelFunc:UD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mp(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.texData.get(s.dataId);return fr({inputs:{x:r.complexTensorInfos.real},backend:n})}const _ge={kernelName:P0,backendName:"webgl",kernelFunc:mp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ge="return float(int(x));";function Rge(t,e){const n=new Oi(t.shape,$ge),s=e.runWebGLProgram(n,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hy(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return fr({inputs:{x:r},backend:n});const o=Jn(r.shape),a=hy({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),l=Sa({inputs:{real:a,imag:o},backend:n});return o.dispose(),n.disposeIntermediateTensorInfo(a),l}if(r.dtype==="complex64"){const o=mp({inputs:{input:r},backend:n}),a=hy({inputs:{x:o},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(o),a}if(!hv(r.dtype,i)){const o=fr({inputs:{x:r},backend:n});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(n.shouldExecuteOnCPU([r])){const o=n.texData.get(r.dataId).values,[a,l,u]=Afe(o,r.shape,r.dtype,i);return n.makeTensorInfo(a,l,u)}if(i==="int32")return Rge(r,n);if(i==="bool"){const o=n.makeTensorInfo([],"bool",cs("bool",1)),l=UD({inputs:{a:r,b:o},backend:n});return n.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const Age={kernelName:uc,backendName:"webgl",kernelFunc:hy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P3="return ceil(x);",Pge=Ut({opSnippet:P3,packedOpSnippet:P3,cpuKernelImpl:Pfe}),Dge={kernelName:cc,backendName:"webgl",kernelFunc:Pge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Nge=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mge{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lge(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{clipValueMin:i,clipValueMax:o}=s;let a;ue().getBool("WEBGL_PACK_CLIP")?a=new Mge(r.shape):a=new Nge(r.shape);const l=[[i],[o]];return n.runWebGLProgram(a,[r],r.dtype,l)}const Oge={kernelName:hc,backendName:"webgl",kernelFunc:Lge};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Fge=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D3(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function Uge(t){const{inputs:e,backend:n}=t,{x:s}=e,r=n.texData.get(s.dataId),i=new Fge(s.shape),o=[D3(s,r.complexTensorInfos.real),D3(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(i,o,o[0].dtype)}const Bge={kernelName:nf,backendName:"webgl",kernelFunc:Uge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zge=class{constructor(e){this.outputShape=[],this.outputShape=Zs(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let o=1;o<n.length;o++)n[o]=n[o-1]+e[o][1];const s=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<n.length;o++){const a=n[o-1];s.push(`else if (yC < ${n[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const r=n.length,i=n[n.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gge{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Zs(e,n);const s=this.outputShape,r=s.length,i=Qt(r),o=Os("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((g,m)=>`T${m}`);const l=new Array(e.length-1);l[0]=e[0][n];for(let g=1;g<l.length;g++)l[g]=l[g-1]+e[g][n];const u=a[n],c=a.slice(-2),h=a.join();let d=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;for(let g=1;g<l.length;g++){const m=l[g-1];d+=`
        if (${u} < ${l[g]}  && ${u} >= ${l[g-1]}) {
          return getChannel(
            getT${g}(${em(a,u,m)}),
            vec2(${em(c,u,m)}));
        }`}const f=l.length,p=l[l.length-1];d+=`
        return getChannel(
          getT${f}(${em(a,u,p)}),
          vec2(${em(c,u,p)}));`,this.userCode=`
      float getValue(${a.map(g=>"int "+g)}) {
        ${d}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${s[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${s[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${s[r-2]} &&
            ${o[r-1]} < ${s[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function em(t,e,n){const s=t.indexOf(e);return t.map((i,o)=>o===s?`${i} - ${n}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lx(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.texData.get(s.dataId);return fr({inputs:{x:r.complexTensorInfos.imag},backend:n})}const Vge={kernelName:I0,backendName:"webgl",kernelFunc:Lx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uh(t,e,n){const s=t[0].dtype;if(s==="complex64"){const f=t.map(b=>mp({inputs:{input:b},backend:n})),p=t.map(b=>Lx({inputs:{input:b},backend:n})),g=Uh(f,e,n),m=Uh(p,e,n),x=Sa({inputs:{real:g,imag:m},backend:n});return f.forEach(b=>n.disposeIntermediateTensorInfo(b)),p.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),x}let r=n.shouldExecuteOnCPU(t);if(s==="string"&&(r=!0),r){const f=t.map(y=>{const I=[-1,oe(y.shape.slice(e))];return je({inputs:{x:y},backend:n,attrs:{shape:I}})}),p=f.map(y=>({vals:n.readSync(y.dataId),shape:y.shape})),g=Zs(f.map(y=>y.shape),1),m=f[0].shape[0]===1,x=Dfe(p,g,s,m),b=Zs(t.map(y=>y.shape),e),v=n.makeTensorInfo(b,s,x);return f.forEach(y=>n.disposeIntermediateTensorInfo(y)),v}const i=t.filter(f=>oe(f.shape)>0),o=ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const f=o?new Oi(t[0].shape,Ho):new Qo(t[0].shape,Ho);return n.runWebGLProgram(f,t,s)}const a=ue().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const f=[];for(let g=0;g<i.length;g+=a){const m=i.slice(g,g+a);f.push(Uh(m,e,n))}const p=Uh(f,e,n);for(const g of f)n.disposeIntermediateTensorInfo(g);return p}if(o){const f=new Gge(i.map(p=>p.shape),e);return n.runWebGLProgram(f,i,s)}const{tensors2D:l,outShape:u}=Wge(i,e,n),c=new zge(l.map(f=>f.shape)),h=n.runWebGLProgram(c,l,s);l.forEach(f=>n.disposeIntermediateTensorInfo(f));const d=je({inputs:{x:h},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(h),d}function Wge(t,e,n){const s=Zs(t.map(i=>i.shape),e);return{tensors2D:t.map(i=>je({inputs:{x:i},attrs:{shape:[-1,oe(i.shape.slice(e))]},backend:n})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BD(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,i=wt(r,e[0].shape)[0],o=e.map(u=>u.shape);nx(o,i);const a=Zs(e.map(u=>u.shape),i);if(oe(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(u=>oe(u.shape)>0);return l.length===1?fr({inputs:{x:l[0]},backend:n}):Uh(l,i,n)}const Hge={kernelName:sf,backendName:"webgl",kernelFunc:BD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zD{constructor(e,n=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,p=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,m=e.dataFormat==="channelsLast",x=m?1:2,b=m?2:3,v=m?3:1;let y="",C="";s&&(r?y=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?y=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:y=`
          float activation(float x) {
            ${s}
          }
        `,C="result = activation(result);");const I=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${y}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${v}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${I}
        ${C}
        setOutput(result);
      }
    `}}class Kge{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,f=e.filterWidth,p=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${n}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GD{constructor(e,n=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_s(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<c;m++)d+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;d+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<c;m++)d+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(h+1)/2;m++){const x=m*2;if(d+=`
           xC = xCCorner + ${x*l};
           `,a===1){if(x<c&&(o%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }
               `,l===1&&x>0?d+=`
                 xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                   } else {
                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xC${x} = xTexelC${x};
                 `,x+1<c)){const b=o%2===0?uv(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                     xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${x+1}.zw = vec2(0.0);
                     }
                     xTexelC${x+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                     } else {
                      xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                     }
                     `:d+=`
                     xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                     `):b===1?d+=`
                     xC${x+1} = xTexelC${x};
                     `:d+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                       xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${x+1}.zw = vec2(0.0);
                       }
                       xTexelC${x+1}Ready = 1;
                     }

                     xC${x+1} = xTexelC${x+1};
                     `}}else x<c&&(o%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.0);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
               `,x+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(
                   xTexelC${x}.xy, xTexelC${x+1}.xy);
               `,x+1<c&&(d+=`
                   xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                 `)));x<c&&(d+=`
             wTexel = getW(r, ${x}, d1, d2);
             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,x+1<c&&(d+=`
               wTexel = getW(r, ${x+1}, d1, d2);
               dotProd += xC${x+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${x+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let f="",p="";s&&(r?f=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?f=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:f=`vec4 activation(vec4 x) {
           ${s}
         }`,p="result = activation(result);");const g=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${p}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jge{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length);const{dataFormat:s}=n,r=Bs(),i=s==="channelsLast",o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)u+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yg(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function VD({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=t.shape,u=s.texData.get(t.dataId),c=n.inChannels,h=l[0]*l[1]*l[2],d=n.outChannels,f=n.dataFormat==="channelsLast",p=!1,g=!1;let m;const x=[];if(i!=null){const y=yg(i.shape,f);y!=null&&(i=je({inputs:{x:i},backend:s,attrs:{shape:y}}),x.push(i))}if(r!=null){const y=yg(r.shape,f);y!=null&&(r=je({inputs:{x:r},backend:s,attrs:{shape:y}}),x.push(r))}if(!((h===1||d===1)&&c>MD)&&u.isPacked&&f&&u.texture!=null&&l[2]%2!==0&&Pt(u.shape.slice(-3),l.slice(-3))){const y=l[0]*l[1]*(l[2]+1),C={dataId:t.dataId,shape:[1,y,n.inChannels],dtype:t.dtype},I=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,G(xg(u.shape,C.shape),()=>`packed reshape ${u.shape} to ${C.shape} isn't free`);const $=je({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});x.push($);const T=bg({a:C,b:$,backend:s,transposeA:p,transposeB:g,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),S=s.texData.get(T.dataId);G(S.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=I,S.shape=n.outShape,m=fr({inputs:{x:T},backend:s}),m.shape=n.outShape,x.push(T)}else{const y=n.outHeight*n.outWidth,C=je({inputs:{x:t},backend:s,attrs:{shape:f?[n.batchSize,y,n.inChannels]:[n.batchSize,n.inChannels,y]}}),I=je({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}}),$=bg({a:f?C:I,b:f?I:C,transposeA:!f,transposeB:g,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o});m=je({inputs:{x:$},backend:s,attrs:{shape:n.outShape}}),x.push(C),x.push(I),x.push($)}for(const y of x)s.disposeIntermediateTensorInfo(y);return m}function WD({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:f}=n,p=f==="channelsLast",g=l*u*c,m=d*h,x=[n.batchSize,g,m],b=!0,v=!1,y=[];if(i!=null){const L=yg(i.shape,p);L!=null&&(i=je({inputs:{x:i},backend:s,attrs:{shape:L}}),y.push(i))}if(r!=null){const L=yg(r.shape,p);L!=null&&(r=je({inputs:{x:r},backend:s,attrs:{shape:L}}),y.push(r))}const C=je({inputs:{x:e},backend:s,attrs:{shape:[1,g,oe(e.shape)/g]}});y.push(C);const I=new jge(x,n),$=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],T=s.runWebGLProgram(I,[t],"float32",$),S=je({inputs:{x:T},backend:s,attrs:{shape:x}});y.push(T),y.push(S);const E=r!=null,_=i!=null,N=a==="leakyrelu",P=a?Dd(a,!0):null,M=new ND(p?S.shape:C.shape,p?C.shape:S.shape,p?[n.batchSize,m,n.outChannels]:[n.batchSize,n.outChannels,m],b,v,E,P,_,N),z=p?[S,C]:[C,S];if(r&&z.push(r),_&&z.push(i),N){const L=s.makeTensorInfo([],"float32",ma(o,"float32"));z.push(L),y.push(L)}const A=s.runWebGLProgram(M,z,"float32"),B=je({inputs:{x:A},backend:s,attrs:{shape:n.outShape}});y.push(A);for(const L of y)s.disposeIntermediateTensorInfo(L);return B}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xge(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s,h=gr(l),d=gn(r.shape,i.shape,o,u,a,c,!1,h);let f;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))f=VD({x:r,filter:i,convInfo:d,backend:n});else if(d.strideWidth<=2&&h==="channelsLast"&&ue().getBool("WEBGL_EXP_CONV")){const g=new GD(d),m=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];f=n.runWebGLProgram(g,[r,i],"float32",m)}else if(ue().getBool("WEBGL_CONV_IM2COL"))f=WD({x:r,filter:i,convInfo:d,backend:n});else{const g=new zD(d);f=n.runWebGLProgram(g,[r,i],"float32")}const p=je({inputs:{x:f},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(f),p}const qge={kernelName:rf,backendName:"webgl",kernelFunc:Xge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Yge=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Zge=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dataFormat==="channelsLast",a=n-1-e.padInfo.top,l=s-1-e.padInfo.left,u=o?1:2,c=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Qge=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Jge=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=n-1-e.padInfo.front,u=s-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,h=gr(l),d=gn(r.shape,c,o,1,a,u,!1,h),f=new Yge(d);return n.runWebGLProgram(f,[r,i],"float32")}const t0e={kernelName:c0,backendName:"webgl",kernelFunc:e0e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n0e{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=_s(this.outputShape.length);const n=e.filterHeight,s=e.filterWidth,r=n-1-e.padInfo.top,i=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s0e(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s,h=gr(u),d=gn(o,i.shape,a,1,l,c,!1,h);if(ue().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const f=[[d.strideHeight,d.strideWidth]],p=new n0e(d);return n.runWebGLProgram(p,[r,i],"float32",f)}else{const f=new Zge(d);return n.runWebGLProgram(f,[r,i],"float32")}}const r0e={kernelName:of,backendName:"webgl",kernelFunc:s0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s,u=gi(r.shape,i.shape,o,l,a),c=new Kge(u);return n.runWebGLProgram(c,[r,i],"float32")}const o0e={kernelName:af,backendName:"webgl",kernelFunc:i0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:l}=s,u=gi(r.shape,l,o,1,a),c=new Qge(u);return n.runWebGLProgram(c,[r,i],"float32")}const l0e={kernelName:h0,backendName:"webgl",kernelFunc:a0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u0e(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{pad:o,strides:a,inputShape:l}=s,u=gi(l,i.shape,a,1,o),c=new Jge(u);return n.runWebGLProgram(c,[r,i],"float32")}const c0e={kernelName:d0,backendName:"webgl",kernelFunc:u0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h0e=uh+`
  return cos(x);
`,d0e=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Gl}
  return result;
`,f0e=Ut({opSnippet:h0e,packedOpSnippet:d0e}),p0e={kernelName:dc,backendName:"webgl",kernelFunc:f0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m0e=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,g0e=Ut({opSnippet:m0e}),x0e={kernelName:fc,backendName:"webgl",kernelFunc:g0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let b0e=class{constructor(e,n,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,u]=e,[c]=n,[h,d]=s;this.outputShape=[c,h,d,u];const f=r==="bilinear"?1:0,[p,g]=[`${a-1}.0`,`${l-1}.0`],[m,x,b]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[v,y,C]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${v});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${y};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${C};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y0e=t=>{const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=s,c=new b0e(r.shape,i.shape,a,l,u);return n.runWebGLProgram(c,[r,i,o],"float32")},v0e={kernelName:p0,backendName:"webgl",kernelFunc:y0e};var Md;(function(t){t.Prod="*",t.Sum="+"})(Md||(Md={}));let N3=class{constructor(e,n,s,r){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===Md.Prod?"1.0":"0.0",a=s?o:`getX(${M3(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";s?(u=r?`end != ${l-1}`:"end != 0",c=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${l}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Qt(i)} coords = getOutputCoords();
        int end = ${L3(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${L3(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${M3(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function M3(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function L3(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HD(t,e,n,s,r,i){const o=e.shape.length,a=Jt([s],o);let l=e;a!=null&&(l=Us({inputs:{x:e},backend:n,attrs:{perm:a}}));const u=an(1,o)[0];if(u!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const c=l.shape[u];let h=fr({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const f=new N3(t,l.shape,!1,i),p=[[d]],g=h;h=n.runWebGLProgram(f,[h],h.dtype,p),n.disposeIntermediateTensorInfo(g)}if(r){const d=new N3(t,l.shape,r,i),f=h;h=n.runWebGLProgram(d,[h],h.dtype),n.disposeIntermediateTensorInfo(f)}if(a!=null){const d=Qi(a),f=Us({inputs:{x:h},backend:n,attrs:{perm:d}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),f}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;return HD(Md.Prod,r,n,i,o,a)}const S0e={kernelName:f0,backendName:"webgl",kernelFunc:w0e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;return HD(Md.Sum,r,n,i,o,a)}const T0e={kernelName:lf,backendName:"webgl",kernelFunc:C0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const l=n.readSync(r.dataId),u=n.readSync(i.dataId),c=ID(l,u,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,c)}else if(r.shape.length===2){const l=n.bufferSync(r),u=n.bufferSync(i),c=$fe(l,u,o,a);return n.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const k0e={kernelName:m0,backendName:"webgl",kernelFunc:I0e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let E0e=class{constructor(e,n,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:i,dataFormat:o}=s,a=r.shape[0],l=o==="NHWC"?r.shape[1]:r.shape[2],u=o==="NHWC"?r.shape[2]:r.shape[3],c=o==="NHWC"?r.shape[3]:r.shape[1],h=l*i,d=u*i,f=c/(i*i),p=o==="NHWC"?[a,h,d,f]:[a,f,h,d],g=new E0e(p,i,o);return n.runWebGLProgram(g,[r],r.dtype)}const $0e={kernelName:g0,backendName:"webgl",kernelFunc:_0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let KD=class{constructor(e,n=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_s(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let u="",c="";s&&(r?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:u=`
          float activation(float x) {
            ${s}
          }
        `,c="result = activation(result);");const h=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jD{constructor(e,n=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_s(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,d=h;let f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<h;x++)f+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;f+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let x=0;x<h;x++)f+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(d+1)/2;x++){const b=x*2;if(f+=`
          xC = xCCorner + ${b*u};
          `,l===1){if(b<h&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,u===1&&b>0?f+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<h)){const v=a%2===0?uv(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${v};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,u>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:f+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):v===1?f+=`
                    xC${b+1} = xTexelC${b};
                    `:f+=`
                    xCOffset = xC + ${v};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<h&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<h&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<h&&(f+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<h&&(f+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<h&&(f+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let p="",g="";s&&(r?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:p=`vec4 activation(vec4 x) {
          ${s}
        }`,g="result = activation(result);");const m=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=s;let c=l;c==null&&(c=[1,1]),G(ds(o,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=gn(r.shape,i.shape,o,c,a,u,!0);let d;ue().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new jD(h):d=new KD(h);const f=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[r,i],"float32",f)}const A0e={kernelName:uf,backendName:"webgl",kernelFunc:R0e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let P0e=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},D0e=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=n-1-e.padInfo.top,a=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s,h=gn(r.shape,c,o,a,l,u,!0),d=new P0e(h);return n.runWebGLProgram(d,[r,i],"float32")}const M0e={kernelName:x0,backendName:"webgl",kernelFunc:N0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L0e(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s,h=gn(c,i.shape,o,a,l,u,!0),d=new D0e(h);return n.runWebGLProgram(d,[r,i],"float32")}const O0e={kernelName:b0,backendName:"webgl",kernelFunc:L0e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let F0e=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U0e(t){const{inputs:e,backend:n}=t,{x:s}=e,r=[...s.shape,...s.shape],i=oe(s.shape),o=je({inputs:{x:s},backend:n,attrs:{shape:[i]}}),a=new F0e(i),l=n.runWebGLProgram(a,[o],o.dtype),u=je({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}const B0e={kernelName:xv,backendName:"webgl",kernelFunc:U0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let z0e=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:s,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=e,{top:h,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s,u=ga(r.shape,i.shape,o,a,"NHWC",l);let c;const h=new z0e(u);c=n.runWebGLProgram(h,[r,i],"float32");const d=je({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}const V0e={kernelName:cf,backendName:"webgl",kernelFunc:G0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0e(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:l}=fx(r,i.length);mx(o.length,l,i);const{path:u,steps:c}=gx(a,l),h=c.length;let d=null,f=o.length;const p=[];for(let g=0;g<h;++g){for(const m of c[g]){const{permutationIndices:x,expandDims:b}=px(f,l[m]);let v;xx(x)?v=i[m]:(v=Us({inputs:{x:i[m]},backend:n,attrs:{perm:x}}),p.push(v));const y=v.shape.slice();for(let C=0;C<b.length;++C)y.splice(b[C],0,1);Pt(v.shape,y)||(v=je({inputs:{x:v},backend:n,attrs:{shape:y}}),p.push(v)),d===null?d=v:(d=ow({inputs:{a:v,b:d},backend:n}),p.push(d))}g<h-1&&(u[g]>=0&&(d=Mx({inputs:{x:d},backend:n,attrs:{axis:u[g]-(o.length-f),keepDims:!1}}),p.push(d)),f--)}for(const g of p)g!==d&&n.disposeIntermediateTensorInfo(g);return d}const H0e={kernelName:y0,backendName:"webgl",kernelFunc:W0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K0e="return (x >= 0.0) ? x : (exp(x) - 1.0);",j0e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,X0e=Ut({opSnippet:K0e,packedOpSnippet:j0e}),q0e={kernelName:mc,backendName:"webgl",kernelFunc:X0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y0e="return (b >= 0.0) ? a : a * (b + 1.0);",Z0e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Q0e=t=>{const{inputs:e,backend:n}=t,{dy:s,y:r}=e,i=ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new lh(Z0e,s.shape,r.shape):new Sl(Y0e,s.shape,r.shape);return n.runWebGLProgram(i,[s,r],s.dtype)},J0e={kernelName:v0,backendName:"webgl",kernelFunc:Q0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const exe=`
  return vec4(equal(a, b));
`,txe="return float(a == b);",nxe=ws({opSnippet:txe,packedOpSnippet:exe,dtype:"bool",cpuKernelImpl:Nfe}),sxe={kernelName:hf,backendName:"webgl",kernelFunc:nxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rxe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${ax};
  float a1 = ${lx};
  float a2 = ${ux};
  float a3 = ${cx};
  float a4 = ${hx};
  float a5 = ${dx};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,ixe=Ut({opSnippet:rxe}),oxe={kernelName:gc,backendName:"webgl",kernelFunc:ixe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const axe=uh+`
  return exp(x);
`,lxe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,XD=Ut({opSnippet:axe,packedOpSnippet:lxe,cpuKernelImpl:Mfe,dtype:"float32"}),uxe={kernelName:xc,backendName:"webgl",kernelFunc:XD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dy(t){const{inputs:e,attrs:n,backend:s}=t,{dim:r}=n,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&(G(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),je({inputs:{x:i},backend:s,attrs:{shape:a}})}const cxe={kernelName:df,backendName:"webgl",kernelFunc:dy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O3="return exp(x) - 1.0;",hxe=Ut({opSnippet:O3,packedOpSnippet:O3,cpuKernelImpl:Lfe}),dxe={kernelName:bc,backendName:"webgl",kernelFunc:hxe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let F3=class{constructor(e,n,s){this.variableNames=["real","imag"];const r=n[1];this.outputShape=n;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qD(t,e,n){const s=n.texData.get(t.dataId),r=oe(t.shape),i=t.shape[t.shape.length-1],o=r/i,a=je({inputs:{x:t},backend:n,attrs:{shape:[o,i]}}),l=a.shape,u=new F3("real",l,e),c=new F3("imag",l,e),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(u,h,"float32"),f=n.runWebGLProgram(c,h,"float32"),p=Sa({inputs:{real:d,imag:f},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f);const g=je({inputs:{x:p},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(p),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fxe(t){const{inputs:e,backend:n}=t,{input:s}=e;return qD(s,!1,n)}const pxe={kernelName:w0,backendName:"webgl",kernelFunc:fxe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mxe=class{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gp(t){const{backend:e,attrs:n}=t,{shape:s,value:r}=n;let{dtype:i}=n;if(i=i||_l(r),i==="string"){const o=_n(i,oe(s));return o.fill(r),e.makeTensorInfo(s,i,o)}else{const o=new mxe(s,r),a=[[r]];return e.runWebGLProgram(o,[],i,a)}}const gxe={kernelName:S0,backendName:"webgl",kernelFunc:gp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xxe=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bxe={kernelName:C0,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=new xxe(n.shape);return s.runWebGLProgram(r,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U3="return floor(x);",yxe=Ut({opSnippet:U3,packedOpSnippet:U3,cpuKernelImpl:Ofe}),vxe={kernelName:yc,backendName:"webgl",kernelFunc:yxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wxe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Sxe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Cxe=ws({opSnippet:wxe,packedOpSnippet:Sxe,dtype:"int32"}),Txe={kernelName:vc,backendName:"webgl",kernelFunc:Cxe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ixe=class{constructor(e){this.variableNames=["A"];const n=Bs(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kxe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Bs(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Exe={kernelName:jE,backendName:"webgl",kernelFunc:_xe};let lu,Hb=ue().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function _xe(t){const{inputs:e,backend:n,attrs:s}=t;let{pixels:r}=e;const{numChannels:i}=s,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,u]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,i];if(a||o){const g=ue().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(lu==null||g!==Hb)&&(Hb=g,lu=document.createElement("canvas").getContext("2d",{willReadFrequently:Hb})),lu.canvas.width=l,lu.canvas.height=u,lu.drawImage(r,0,0,l,u),r=lu.canvas}const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=Sr.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const f=ue().getBool("WEBGL_PACK")?new kxe(h):new Ixe(h),p=n.runWebGLProgram(f,[d],"int32");return n.disposeData(d.dataId),p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $xe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:p}=s,g=gr(c),m=gn(r.shape,i.shape,l,h,u,d,!1,g);let x;const b=[],v=o!=null,y=a!=null,C=f==="leakyrelu",I=()=>{const T=[r,i],S=(E,_)=>{if(_==="NCHW"&&E.shape.length===1&&E.shape[0]!==1){const N=je({inputs:{x:E},backend:n,attrs:{shape:[E.shape[0],1,1]}});return b.push(N),N}return E};if(v&&T.push(S(o,c)),y&&T.push(S(a,c)),C){const E=n.makeTensorInfo([],"float32",ma(p,"float32"));T.push(E),b.push(E)}return T};if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))x=VD({x:r,filter:i,convInfo:m,backend:n,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else if(m.strideWidth<=2&&g==="channelsLast"&&ue().getBool("WEBGL_EXP_CONV")){const T=f?Dd(f,!0):null,S=new GD(m,v,T,y,C),E=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],_=I();x=n.runWebGLProgram(S,_,"float32",E)}else if(ue().getBool("WEBGL_CONV_IM2COL"))x=WD({x:r,filter:i,convInfo:m,backend:n,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else{const T=f?Dd(f,!1):null,S=new zD(m,v,T,y,C),E=I();x=n.runWebGLProgram(S,E,"float32")}const $=je({inputs:{x},backend:n,attrs:{shape:m.outShape}});return b.push(x),b.forEach(T=>n.disposeIntermediateTensorInfo(T)),$}const Rxe={kernelName:Sd,backendName:"webgl",kernelFunc:$xe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Axe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:f}=s,p=[];let g=c;g==null&&(g=[1,1]),G(ds(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const m=gn(r.shape,i.shape,l,g,u,h,!0),x=ue().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,b=d?Dd(d,x):null,v=[r,i],y=o!=null,C=a!=null,I=d==="leakyrelu";if(y&&v.push(o),C&&v.push(a),I){const E=n.makeTensorInfo([],"float32",ma(f,"float32"));v.push(E),p.push(E)}let $;x?$=new jD(m,y,b,C,I):$=new KD(m,y,b,C,I);const T=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],S=n.runWebGLProgram($,v,"float32",T);return p.forEach(E=>n.disposeIntermediateTensorInfo(E)),S}const Pxe={kernelName:Pv,backendName:"webgl",kernelFunc:Axe};let Dxe=class{constructor(e,n,s,r){this.sliceDim=e,this.strides=n,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=Qt(s.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxe(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,i=r.shape,o=i[i.length-1],a=oe(s.shape),[l,u,c,h]=Q0(s,r),d=je({inputs:{x:r},backend:n,attrs:{shape:[u,o]}}),f=je({inputs:{x:s},backend:n,attrs:{shape:[oe(s.shape)/c,c]}});if(n.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const x=n.readSync(r.dataId),b=n.bufferSync(s),v=Ffe(x,b,s.dtype,u,o,c,h,s.shape,a);return n.makeTensorInfo(l,s.dtype,v.values)}const p=new Dxe(o,h,[u,c],s.shape),g=n.runWebGLProgram(p,[f,d],f.dtype),m=je({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}const Mxe={kernelName:bv,backendName:"webgl",kernelFunc:Nxe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Lxe=class{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const s=Qt(this.rank),r=Oxe(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function Oxe(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<t.length;r++)r===2?s.push("index"):s.push(`${n[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YD(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:i}=e,{axis:o,batchDims:a}=s,l=wt(o,r.shape)[0];if(ue().get("DEBUG")){const b=n.readSync(i.dataId),v=r.shape[l];for(let y=0;y<b.length;++y){const C=b[y];G(C<=v-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${v-1}]`)}}const u=yx(r,i,l,a),c=oe(i.shape),h=[],d=je({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=je({inputs:{x:i},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(f);const p=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const b=n.bufferSync(f),v=n.bufferSync(d),y=Ufe(v,b,p);return h.forEach(C=>n.disposeIntermediateTensorInfo(C)),n.makeTensorInfo(u.outputShape,y.dtype,y.values)}const g=new Lxe(d.shape,p),m=n.runWebGLProgram(g,[d,f],d.dtype);h.push(m);const x=je({inputs:{x:m},backend:n,attrs:{shape:u.outputShape}});return h.forEach(b=>n.disposeIntermediateTensorInfo(b)),x}const Fxe={kernelName:pf,backendName:"webgl",kernelFunc:YD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uxe="return float(a > b);",Bxe=`
  return vec4(greaterThan(a, b));
`,zxe=ws({opSnippet:Uxe,packedOpSnippet:Bxe,cpuKernelImpl:Bfe,dtype:"bool"}),Gxe={kernelName:mf,backendName:"webgl",kernelFunc:zxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vxe="return float(a >= b);",Wxe=`
  return vec4(greaterThanEqual(a, b));
`,Hxe=ws({opSnippet:Vxe,packedOpSnippet:Wxe,dtype:"bool",cpuKernelImpl:zfe}),Kxe={kernelName:wc,backendName:"webgl",kernelFunc:Hxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jxe(t){const{inputs:e,backend:n}=t,{input:s}=e;return qD(s,!0,n)}const Xxe={kernelName:T0,backendName:"webgl",kernelFunc:jxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qxe="return float(!isnan(x) && !isinf(x));",Yxe=Ut({opSnippet:qxe,dtype:"bool"}),Zxe={kernelName:Cc,backendName:"webgl",kernelFunc:Yxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qxe="return float(isinf(x));",Jxe=Ut({opSnippet:Qxe,dtype:"bool"}),ebe={kernelName:Tc,backendName:"webgl",kernelFunc:Jxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tbe="return float(isnan(x));",nbe=Ut({opSnippet:tbe,dtype:"bool"}),sbe={kernelName:Ic,backendName:"webgl",kernelFunc:nbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rbe="return float(a < b);",ibe=`
  return vec4(lessThan(a, b));
`,obe=ws({opSnippet:rbe,packedOpSnippet:ibe,cpuKernelImpl:Gfe,dtype:"bool"}),abe={kernelName:xf,backendName:"webgl",kernelFunc:obe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lbe="return float(a <= b);",ube=`
  return vec4(lessThanEqual(a, b));
`,cbe=ws({opSnippet:lbe,packedOpSnippet:ube,cpuKernelImpl:Vfe,dtype:"bool"}),hbe={kernelName:bf,backendName:"webgl",kernelFunc:cbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dbe(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:i}=n,o=Wfe(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const fbe={kernelName:yv,backendName:"webgl",kernelFunc:dbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pbe=uh+`
  return x < 0.0 ? 0./0. : log(x);
`,mbe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,gbe=Ut({opSnippet:pbe,packedOpSnippet:mbe,cpuKernelImpl:Hfe}),xbe={kernelName:kc,backendName:"webgl",kernelFunc:gbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bbe=uh+`
  return log(1.0 + x);
`,ybe=Ut({opSnippet:bbe}),vbe={kernelName:Ec,backendName:"webgl",kernelFunc:ybe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wbe="return float(a >= 1.0 && b >= 1.0);",Sbe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Cbe=ws({opSnippet:wbe,packedOpSnippet:Sbe,dtype:"bool"}),Tbe={kernelName:yf,backendName:"webgl",kernelFunc:Cbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ibe="return float(!(x >= 1.0));",kbe=Ut({opSnippet:Ibe}),Ebe={kernelName:vf,backendName:"webgl",kernelFunc:kbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _be="return float(a >= 1.0 || b >= 1.0);",$be=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Rbe=ws({opSnippet:_be,packedOpSnippet:$be,dtype:"bool"}),Abe={kernelName:wf,backendName:"webgl",kernelFunc:Rbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pbe=class{constructor(e,n,s,r,i){this.variableNames=["x"],this.outputShape=[];const o=n,a=e[3]-1;this.outputShape=e;let l;const u=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${u})`:i===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dbe{constructor(e,n,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=n,a=e[3]-1;this.outputShape=e;let l;const u=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${u})`:i===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nbe=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=s,u=ue().getBool("WEBGL_PACK_NORMALIZATION")?new Dbe(r.shape,i,o,a,l):new Pbe(r.shape,i,o,a,l);return n.runWebGLProgram(u,[r],r.dtype)},Mbe={kernelName:Sf,backendName:"webgl",kernelFunc:Nbe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Lbe=class{constructor(e,n,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Obe=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=s,h=new Lbe(r.shape,a,l,u,c);return n.runWebGLProgram(h,[r,i,o],r.dtype)},Fbe={kernelName:k0,backendName:"webgl",kernelFunc:Obe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ube(t,e,n,s){const r=oe(e),o=oe(t.shape)/r,a=je({inputs:{x:t},attrs:{shape:[o,r]},backend:s}),l=Vl(a,t.dtype,"max",s),u=je({inputs:{x:l},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZD(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:i,keepDims:o}=s,a=r.shape.length,l=wt(i,r.shape);let u=l;const c=Jt(u,a),h=c!=null,d=n.shouldExecuteOnCPU([r]);let f=r;if(h){if(d){const v=n.texData.get(f.dataId).values,y=new Array(a);for(let $=0;$<y.length;$++)y[$]=r.shape[c[$]];const C=rw(v,r.shape,r.dtype,c,y);f=n.makeTensorInfo(y,r.dtype);const I=n.texData.get(f.dataId);I.values=C}else f=Nx(r,c,n);u=an(u.length,a)}qn("max",u,a);const[p,g]=Gn(f.shape,u);let m=p;o&&(m=zn(p,l));let x;if(d){const v=n.texData.get(f.dataId).values,y=Kfe(v,oe(g),m,r.dtype);x=n.makeTensorInfo(m,r.dtype);const C=n.texData.get(x.dataId);C.values=y}else x=Ube(f,g,m,n);return h&&n.disposeIntermediateTensorInfo(f),x}const Bbe={kernelName:Cf,backendName:"webgl",kernelFunc:ZD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zbe=iw+`
  return max(a, b);
`,Gbe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Gl+`
  return result;
`,Vbe=ws({opSnippet:zbe,packedOpSnippet:Gbe,cpuKernelImpl:jfe}),Wbe={kernelName:_c,backendName:"webgl",kernelFunc:Vbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hbe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;fp(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,u=1;G(ds(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=ks(r.shape,i,o,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&Pt(c.inShape,c.outShape))return fr({inputs:{x:r},backend:n});const h=new Nd(c,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}const Kbe={kernelName:Tf,backendName:"webgl",kernelFunc:Hbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jbe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:u}=s,c=[1,1,1],h=Er(r.shape,i,o,c,a,u,l),d=new aw(h,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}const Xbe={kernelName:If,backendName:"webgl",kernelFunc:jbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qbe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=i-1-e.padInfo.top,l=o-1-e.padInfo.left,u=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Ybe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=l-1-e.padInfo.front,d=u-1-e.padInfo.top,f=c-1-e.padInfo.left,p=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zbe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=[1,1,1],d=Er(o.shape,a,l,h,u,c),f=new aw(d,"max",!0),p=n.runWebGLProgram(f,[o],o.dtype),g=new Ybe(d),m=n.runWebGLProgram(g,[r,p],o.dtype);return n.disposeIntermediateTensorInfo(p),m}const Qbe={kernelName:_0,backendName:"webgl",kernelFunc:Zbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jbe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i,output:o}=e,a=i;fp([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=ks(a.shape,l,u,1,c,h),f=!0,p=new Nd(d,"max",f),g=n.runWebGLProgram(p,[a],a.dtype),m=new qbe(d),x=n.runWebGLProgram(m,[r,g],a.dtype);return n.disposeIntermediateTensorInfo(g),x}const e1e={kernelName:E0,backendName:"webgl",kernelFunc:Jbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t1e(t,e,n,s){let r=new Nd(n,"max",!1);const i=s.runWebGLProgram(r,[t],"float32");r=new Nd(n,"max",!0,!0,e);const o=s.runWebGLProgram(r,[t],"float32");return[i,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n1e={kernelName:vv,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=e,l=n;G(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const u=[1,1];G(ds(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=ks(s.shape,r,i,u,o),[h,d]=t1e(s,a,c,l);return[h,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s1e(t,e,n,s){const r=oe(e),o=oe(t.shape)/r,a=je({inputs:{x:t},attrs:{shape:[o,r]},backend:s}),l=Vl(a,"float32","mean",s),u=je({inputs:{x:l},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r1e={kernelName:kf,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{keepDims:r,axis:i}=e,o=n,a=s.shape.length,l=wt(i,s.shape);let u=l;const c=Jt(u,a),h=c!=null,d=o.shouldExecuteOnCPU([s]),f=[];let p=s;if(h){if(d){const y=o.texData.get(p.dataId).values,C=new Array(a);for(let T=0;T<C.length;T++)C[T]=s.shape[c[T]];const I=rw(y,s.shape,s.dtype,c,C);p=o.makeTensorInfo(C,s.dtype);const $=o.texData.get(p.dataId);$.values=I}else p=Nx(s,c,o);f.push(p),u=an(u.length,a)}qn("sum",u,a);const[g,m]=Gn(p.shape,u);let x=g;r&&(x=zn(g,l));const b=s1e(p,m,x,o);for(const v of f)o.disposeIntermediateTensorInfo(v);return b}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i1e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=wt(i,r.shape);let u=l;const c=Jt(u,a);let h=r;c!=null&&(h=Us({inputs:{x:r},backend:n,attrs:{perm:c}}),u=an(u.length,r.shape.length)),qn("min",u,a);const[d,f]=Gn(h.shape,u),p=oe(f),g=je({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}}),m=Vl(g,g.dtype,"min",n);let x;if(o){const b=zn(d,l);x=je({inputs:{x:m},backend:n,attrs:{shape:b}})}else x=je({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),c!=null&&n.disposeIntermediateTensorInfo(h),x}const o1e={kernelName:Ef,backendName:"webgl",kernelFunc:i1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a1e=iw+`
  return min(a, b);
`,l1e=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Gl+`
  return result;
`,u1e=ws({opSnippet:a1e,packedOpSnippet:l1e,cpuKernelImpl:Xfe}),c1e={kernelName:$c,backendName:"webgl",kernelFunc:u1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let h1e=class{constructor(e,n,s){this.variableNames=["x"],this.outputShape=n.map((c,h)=>c[0]+e[h]+c[1]);const r=e.length,i=Qt(r),o=n.map(c=>c[0]).join(","),a=n.map((c,h)=>c[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d1e{constructor(e,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((p,g)=>p[0]+e[g]+p[1]);const r=e.length,i=Qt(r),o=n.map(p=>p[0]).join(","),a=n.map((p,g)=>p[0]+e[g]).join(","),l=Os("rc",r),u=Os("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,d=s==="reflect"?0:1;let f="";if(r===1){const p=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;f=`
        ${i} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `}else{const p=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;f=`
        ${i} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${p}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${l[r-1]} += 1;
          if(${c}) {
            ${p}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f1e=({inputs:t,backend:e,attrs:n})=>{const{x:s}=t,{paddings:r,mode:i}=n,o=ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new d1e(s.shape,r,i):new h1e(s.shape,r,i);return e.runWebGLProgram(o,[s],s.dtype)},p1e={kernelName:_f,backendName:"webgl",kernelFunc:f1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m1e=`if (b == 0.0) return NAN;
  return mod(a, b);`,g1e=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Gl+`
  return result;
`,x1e=ws({opSnippet:m1e,packedOpSnippet:g1e}),b1e={kernelName:Rc,backendName:"webgl",kernelFunc:x1e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let y1e=class{constructor(e,n,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v1e=`
if (a == b) {
  return 1.0;
};
return a / b;`,w1e=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,QD=ws({opSnippet:v1e,packedOpSnippet:w1e,checkOutOfBounds:!0}),S1e={kernelName:pc,backendName:"webgl",kernelFunc:QD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B3="return a - b;",JD=ws({opSnippet:B3,packedOpSnippet:B3,supportsComplex:!0,cpuKernelImpl:mpe}),C1e={kernelName:Kc,backendName:"webgl",kernelFunc:JD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eN(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:i}=s,o=wt([i],r.shape),a=ZD({inputs:{x:r},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=zn(a.shape,o),u=je({inputs:{x:a},backend:n,attrs:{shape:l}}),c=JD({inputs:{a:r,b:u},backend:n}),h=XD({inputs:{x:c},backend:n}),d=Mx({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),f=je({inputs:{x:d},backend:n,attrs:{shape:l}}),p=QD({inputs:{a:h,b:f},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),p}const T1e={kernelName:Kf,backendName:"webgl",kernelFunc:eN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I1e(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s,l=a?r:eN({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new y1e(u,c,i),d=[[o]],f=n.runWebGLProgram(h,[l],"int32",d);return a||n.disposeIntermediateTensorInfo(l),f}const k1e={kernelName:wv,backendName:"webgl",kernelFunc:I1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E1e=qr+`
  return -x;
`,_1e=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function $1e(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])){const i=n.texData.get(s.dataId),[o,a]=Yfe(i.values,s.shape,s.dtype);return n.makeTensorInfo(a,s.dtype,o)}let r;return ue().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Qo(s.shape,_1e):r=new Oi(s.shape,E1e),n.runWebGLProgram(r,[s],s.dtype)}const R1e={kernelName:$f,backendName:"webgl",kernelFunc:$1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A1e=Y0;function P1e(t){yr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,u=n.readSync(r.dataId),c=n.readSync(i.dataId),{selectedIndices:h}=A1e(u,c,o,a,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const D1e={kernelName:$0,backendName:"webgl",kernelFunc:P1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N1e=m2;function M1e(t){yr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),{selectedIndices:d,validOutputs:f}=N1e(c,h,o,a,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}const L1e={kernelName:Sv,backendName:"webgl",kernelFunc:M1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O1e=Z0;function F1e(t){yr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),d=o,f=a,p=l,g=u,{selectedIndices:m,selectedScores:x}=O1e(c,h,d,f,p,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}const U1e={kernelName:R0,backendName:"webgl",kernelFunc:F1e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let B1e=class{constructor(e,n,s,r){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z1e=t=>{const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{dtype:i,depth:o,onValue:a,offValue:l}=s,u=oe(r.shape),c=new B1e(u,o,a,l),h=je({inputs:{x:r},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(c,[h],i);n.disposeIntermediateTensorInfo(h);const f=[...r.shape,o],p=je({inputs:{x:d},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(d),p},G1e={kernelName:Pf,backendName:"webgl",kernelFunc:z1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vg(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="complex64"){const r=mp({inputs:{input:s},backend:n}),i=vg({inputs:{x:r},backend:n}),o=Lx({inputs:{input:s},backend:n}),a=vg({inputs:{x:o},backend:n}),l=Sa({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return gp({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:n})}const V1e={kernelName:qf,backendName:"webgl",kernelFunc:vg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tN(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=mp({inputs:{input:s},backend:n}),i=tN({inputs:{x:r},backend:n}),o=Lx({inputs:{input:s},backend:n}),a=vg({inputs:{x:o},backend:n}),l=Sa({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return gp({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:n})}const W1e={kernelName:Af,backendName:"webgl",kernelFunc:tN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H1e(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(e.length===1)return dy({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(c=>{n0(i,c.shape,"All tensors passed to stack must have matching shapes"),G(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=dy({inputs:{input:c},backend:n,attrs:{dim:r}});return a.push(h),h}),u=BD({inputs:l,backend:n,attrs:{axis:r}});return a.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const K1e={kernelName:Df,backendName:"webgl",kernelFunc:H1e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let j1e=class{constructor(e,n,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((u,c)=>u[0]+e[c]+u[1]);const r=e.length,i=Qt(r),o=n.map(u=>u[0]).join(","),a=n.map((u,c)=>u[0]+e[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X1e{constructor(e,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((g,m)=>g[0]+e[m]+g[1]);const r=e.length,i=Qt(r),o=n.map(g=>g[0]).join(","),a=n.map((g,m)=>g[0]+e[m]).join(","),l=Os("rc",r),u=Os("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,d=[`${i} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${c}) {`],f=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let g=0,m=r===1?2:4;g<m;g++)p+=`
        ${d[g]}
        if (${f}) {
          result[${g}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${g}] = getChannel(getX(${u.join()}), ${h});
        }
      `;p+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nN=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:i,constantValue:o}=s;if(oe(r.shape)===0){const u=i.map((c,h)=>c[0]+r.shape[h]+c[1]);return gp({backend:n,attrs:{shape:u,value:o,dtype:r.dtype}})}const a=ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new X1e(r.shape,i,o):new j1e(r.shape,i,o),l=[[o]];return n.runWebGLProgram(a,[r],r.dtype,l)},q1e={kernelName:Nf,backendName:"webgl",kernelFunc:nN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y1e=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Z1e=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Gl+`
  return result;
`,Q1e=ws({opSnippet:Y1e,packedOpSnippet:Z1e}),J1e={kernelName:Pc,backendName:"webgl",kernelFunc:Q1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eye(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=[],u=wt(i,r.shape);let c=u;const h=Jt(c,a);let d=r;h!=null&&(d=Us({inputs:{x:r},backend:n,attrs:{perm:h}}),c=an(c.length,a),l.push(d)),qn("prod",c,a);let f;if(n.shouldExecuteOnCPU([d])){const p=n.texData.get(d.dataId).values,{outVals:g,outShape:m,outDtype:x}=Qfe(d.shape,d.dtype,p,c);f=n.makeTensorInfo(m,x,g)}else{const[p,g]=Gn(d.shape,c),m=oe(g),x=je({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),b=z0(r.dtype),v=Vl(x,b,"prod",n);f=je({inputs:{x:v},backend:n,attrs:{shape:p}}),l.push(x),l.push(v)}if(o){l.push(f);const p=zn(f.shape,u);f=je({inputs:{x:f},backend:n,attrs:{shape:p}})}return l.forEach(p=>n.disposeIntermediateTensorInfo(p)),f}const tye={kernelName:Lf,backendName:"webgl",kernelFunc:eye};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nye(t){const{inputs:e,backend:n,attrs:s}=t,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=s,l=r.map(x=>n.readSync(x.dataId)),u=r.map(x=>x.shape),c=n.readSync(i.dataId),h=n.readSync(o.dataId),[d,f,p]=Jfe(l,u,c,i.shape,i.dtype,h,o.shape,a),g=d.map(x=>n.makeTensorInfo([x.length],"int32",x)),m=n.makeTensorInfo(p,i.dtype,f);return g.concat([m])}const sye={kernelName:BE,backendName:"webgl",kernelFunc:nye};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rye(t){const{inputs:e,backend:n}=t,{starts:s,limits:r,deltas:i}=e,o=n.readSync(s.dataId),a=n.readSync(r.dataId),l=n.readSync(i.dataId),[u,c]=epe(o,s.shape,s.dtype,a,r.shape,l,i.shape),h=n.makeTensorInfo([u.length],"int32",u),d=n.makeTensorInfo([c.length],s.dtype,c);return[h,d]}const iye={kernelName:zE,backendName:"webgl",kernelFunc:rye};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oye(t){const{inputs:e,backend:n,attrs:s}=t,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,u=n.readSync(r.dataId),c=n.readSync(i.dataId),h=n.readSync(o.dataId),d=a.map(m=>n.readSync(m.dataId)),f=a.map(m=>m.shape),[p,g]=tpe(u,r.shape,c,i.shape,i.dtype,h,o.shape,d,f,l);return n.makeTensorInfo(p,i.dtype,g)}const aye={kernelName:GE,backendName:"webgl",kernelFunc:oye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sN=t=>{const{backend:e,attrs:n}=t,{start:s,stop:r,step:i,dtype:o}=n,a=npe(s,r,i,o);return e.makeTensorInfo([a.length],o,a)},lye={kernelName:A0,backendName:"webgl",kernelFunc:sN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uye="return 1.0 / x;",cye=Ut({opSnippet:uye}),hye={kernelName:Dc,backendName:"webgl",kernelFunc:cye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dye=qr+`
  return (x < 0.0) ? 0.0 : x;
`,fye=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,pye=Ut({opSnippet:dye,packedOpSnippet:fye}),mye={kernelName:Nc,backendName:"webgl",kernelFunc:pye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gye=qr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,xye=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,bye=Ut({opSnippet:gye,packedOpSnippet:xye}),yye={kernelName:Mc,backendName:"webgl",kernelFunc:bye};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vye=class{constructor(e,n,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,n,s,u];const c=[r&&n>1?a-1:a,r&&s>1?l-1:l],h=[r&&n>1?n-1:n,r&&s>1?s-1:s];let d;i?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wye{constructor(e,n,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,n,s,u];const c=[r&&n>1?a-1:a,r&&s>1?l-1:l],h=[r&&n>1?n-1:n,r&&s>1?s-1:s];let d;i?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sye(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,u]=a,c=ue().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new wye(r.shape,l,u,i,o):new vye(r.shape,l,u,i,o);return n.runWebGLProgram(c,[r],"float32")}const Cye={kernelName:Uf,backendName:"webgl",kernelFunc:Sye};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Tye=class{constructor(e,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,i]=n,[,o,a]=e,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],u=[s&&o>1?o-1:o,s&&a>1?a-1:a],c=l[0]/u[0],h=l[1]/u[1],d=1/c,f=1/h,p=Math.ceil(d)*2+2,g=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${p});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iye(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:o}=s,a=new Tye(i.shape,r.shape,o);return n.runWebGLProgram(a,[i],i.dtype)}const kye={kernelName:N0,backendName:"webgl",kernelFunc:Iye};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Eye=class{constructor(e,n,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,n,s,u];const c=[r&&n>1?a-1:a,r&&s>1?l-1:l],h=[r&&n>1?n-1:n,r&&s>1?s-1:s],d=r?"0.5":"0.0";let f;i?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ye{constructor(e,n,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,n,s,u];const c=[r&&n>1?a-1:a,r&&s>1?l-1:l],h=[r&&n>1?n-1:n,r&&s>1?s-1:s],d=r?"0.5":"0.0";let f;i?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ye(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,u]=a,c=ue().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new _ye(r.shape,l,u,i,o):new Eye(r.shape,l,u,i,o);return n.runWebGLProgram(c,[r],r.dtype)}const Rye={kernelName:Ff,backendName:"webgl",kernelFunc:$ye};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Aye=class{constructor(e,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,i]=n,[,o,a]=e,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],u=[s&&o>1?o-1:o,s&&a>1?a-1:a],c=l[0]/u[0],h=l[1]/u[1],d=1/c,f=1/h,p=Math.ceil(d)*2+2,g=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${p});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pye(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:o}=s,a=new Aye(i.shape,r.shape,o);return n.runWebGLProgram(a,[i],i.dtype)}const Dye={kernelName:D0,backendName:"webgl",kernelFunc:Pye};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Nye=class{constructor(e,n){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=a=>n.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,i=e.map((a,l)=>r(l)).join(","),o=Qt(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mye{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=Os("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,a=Qt(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${i}){
            result.g = ${u(r.slice())};
          }
          if(${o}) {
            result.b = ${c(r.slice())};
            if(${i}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(p){return d(p)}function u(p){return p[s-1]="("+p[s-1]+" + 1)",d(p)}function c(p){return p[s-2]="("+p[s-2]+" + 1)",d(p)}function h(p){return p[s-1]="("+p[s-1]+" + 1)",p[s-2]="("+p[s-2]+" + 1)",d(p)}function d(p){const g=e.map((b,v)=>f(v,p)),m=g.join(","),x=g.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${x}))`}function f(p,g){return n.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${g[p]} - 1`:`${g[p]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lye(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:i}=s,o=r.shape.length,a=wt(i,r.shape);if(o===0)return fr({inputs:{x:r},backend:n});const l=ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mye(r.shape,a):new Nye(r.shape,a);return n.runWebGLProgram(l,[r],r.dtype)}const Oye={kernelName:Bf,backendName:"webgl",kernelFunc:Lye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Fye=class{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let i="";typeof n=="number"?i=`float outputValue = ${n.toFixed(2)};`:i=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uye={kernelName:U0,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:i,center:o}=e,a=n,l=new Fye(s.shape,i),[u,c]=rx(o,s.shape[1],s.shape[2]),h=[[u,c,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bye=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,zye=Ut({opSnippet:Bye}),Gye={kernelName:Lc,backendName:"webgl",kernelFunc:zye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vye="return inversesqrt(x);",Wye=Ut({opSnippet:Vye,cpuKernelImpl:spe}),Hye={kernelName:Oc,backendName:"webgl",kernelFunc:Wye};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lw=class{constructor(e,n,s,r,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const u=Qt(i.length),c=Qt(o.length);let h="";s===1?h="i":s===2&&(h="i, j");const d=`getIndices(${h})`;let f="";r===1?f="i":r===2&&(f="i, coords[1]");const p=`getUpdates(${f})`;let g="";l&&(g="coords[0], coords[1]");const m=`getDefaultValue(${g})`,x=n>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${x};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kye{constructor(e,n,s,r,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const u=Qt(i.length),c=Qt(o.length);let h="";s===1?h="i":s===2&&(h="i, j");const d=`getIndices(${h})`;let f="";r===1?f="i":r===2&&(f="i, coords[1]");const p=`getUpdates(${f})`;let g="";l&&(g="coords[0], coords[1]");const m=`getDefaultValue(${g})`,x=n>1?"strides[j]":"strides",b=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${x};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jye(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Ji(i,r,o),d=[h/u,u];if(h===0)return n.makeTensorInfo(o,r.dtype);const f=je({inputs:{x:r},backend:n,attrs:{shape:[l,a]}}),p=je({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let m;ue().getBool("WEBGL_PACK")?m=new Kye(l,a,f.shape.length,p.shape.length,c,d):m=new lw(l,a,f.shape.length,p.shape.length,c,d);const x=n.runWebGLProgram(m,[p,f,g],p.dtype),b=je({inputs:{x},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(g),b}const Xye={kernelName:Cv,backendName:"webgl",kernelFunc:jye};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qye=class{constructor(e,n,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,a=ue().getNumber("WEBGL_VERSION")===2?i:o,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yye(t){const{inputs:e,backend:n,attrs:s}=t,{sortedSequence:r,values:i}=e,{side:o}=s,a=new qye(r.shape[0],r.shape[1],i.shape[1],o),l=[[r.shape[1]]];return n.runWebGLProgram(a,[r,i],"int32",l)}const Zye={kernelName:Iv,backendName:"webgl",kernelFunc:Yye};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qye=class{constructor(e,n,s){this.variableNames=["c","a","b"],this.outputShape=n;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<n.length;c++)u.push(`${a[c]}`),c<e&&l.push(`${a[c]}`);r=l.join(),i=u.join()}const o=Qt(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jye(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:i}=e,o=new Qye(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(o,[s,r,i],hs(r.dtype,i.dtype))}const eve={kernelName:zf,backendName:"webgl",kernelFunc:Jye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tve=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${tp};
  float scale = ${np};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,nve=Ut({opSnippet:tve}),sve={kernelName:Fc,backendName:"webgl",kernelFunc:nve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rve=uh+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,ive=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ove=Ut({opSnippet:rve,packedOpSnippet:ive,cpuKernelImpl:ipe}),ave={kernelName:Gc,backendName:"webgl",kernelFunc:ove};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lve=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,uve=Ut({opSnippet:lve}),cve={kernelName:zc,backendName:"webgl",kernelFunc:uve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hve=uh+`
  return sin(x);
`,dve=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Gl}
  return result;
`,fve=Ut({opSnippet:hve,packedOpSnippet:dve}),pve={kernelName:Uc,backendName:"webgl",kernelFunc:fve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mve=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,gve=Ut({opSnippet:mve}),xve={kernelName:Bc,backendName:"webgl",kernelFunc:gve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bve=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,yve=Ut({opSnippet:bve}),vve={kernelName:Vc,backendName:"webgl",kernelFunc:yve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wve=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,paddings:o}=s;G(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((x,b)=>x*b),l=[[0,0]];l.push(...o);for(let x=1+i.length;x<r.shape.length;++x)l.push([0,0]);const u=[],c=nN({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),h=Ml(c.shape,i,a,!1),d=Ll(h.length,i.length,!1),f=Ol(c.shape,i,a,!1),p=je({inputs:{x:c},backend:n,attrs:{shape:h}}),g=Us({inputs:{x:p},backend:n,attrs:{perm:d}}),m=je({inputs:{x:g},backend:n,attrs:{shape:f}});return u.push(c),u.push(p),u.push(g),u.forEach(x=>n.disposeIntermediateTensorInfo(x)),m},Sve={kernelName:Wf,backendName:"webgl",kernelFunc:wve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cve(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=n.readSync(s.dataId),l=n.readSync(r.dataId),u=n.readSync(i.dataId),c=n.readSync(o.dataId)[0],[h,d,f,p,g]=ape(a,s.shape,s.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(d,s.dtype,h),n.makeTensorInfo([d[0]],r.dtype,f),n.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(m=>Number(m)))),n.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const Tve={kernelName:VE,backendName:"webgl",kernelFunc:Cve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ive(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(n.readSync(r.dataId)),a=n.readSync(s.dataId),l=Array.from(n.readSync(i.dataId)),[u,c,h]=lpe(a,s.shape,s.dtype,o,l);return[n.makeTensorInfo(c,s.dtype,u),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const kve={kernelName:WE,backendName:"webgl",kernelFunc:Ive};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eve(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=n.readSync(s.dataId),a=n.readSync(r.dataId),l=n.readSync(i.dataId),[u,c]=ED(o,s.shape,s.dtype,a,l,!0);return n.makeTensorInfo(c,s.dtype,u)}const _ve={kernelName:kv,backendName:"webgl",kernelFunc:Eve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ve(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=n.readSync(s.dataId),a=n.readSync(r.dataId),l=n.readSync(i.dataId),[u,c]=ED(o,s.shape,s.dtype,a,l);return n.makeTensorInfo(c,s.dtype,u)}const Rve={kernelName:Ev,backendName:"webgl",kernelFunc:$ve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ave(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=Ji(i,r,a),f=!1;if(i.dtype==="string"){const x=n.bufferSync(r),b=n.bufferSync(i),v=li(n.readSync(o.dataId)[0]),y=rpe(x,b,a,d,c,u,l,h,v,f);return n.makeTensorInfo(a,y.dtype,y.values)}const p=new lw(u,l,r.shape.length,i.shape.length,h,[d,1],f),g=n.runWebGLProgram(p,[i,r,o],i.dtype),m=je({inputs:{x:g},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(g),m}const Pve={kernelName:_v,backendName:"webgl",kernelFunc:Ave};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dve(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=wt(o,r.shape)[0],l=bx(r,i,a),u=r.shape.length,c=new Array(u).fill(0),h=r.shape.slice();return l.map(d=>{const f=[...h];f[a]=d;const p=ch({inputs:{x:r},backend:n,attrs:{begin:c,size:f}});return c[a]+=d,p})}const Nve={kernelName:Hf,backendName:"webgl",kernelFunc:Dve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z3="return sqrt(x);",Mve=Ut({opSnippet:z3,packedOpSnippet:z3,cpuKernelImpl:upe}),Lve={kernelName:Wc,backendName:"webgl",kernelFunc:Mve};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ove="return x * x;",Fve=Ut({opSnippet:Ove}),Uve={kernelName:M0,backendName:"webgl",kernelFunc:Fve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G3="return (a - b) * (a - b);",Bve=ws({opSnippet:G3,packedOpSnippet:G3}),zve={kernelName:Hc,backendName:"webgl",kernelFunc:Bve};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gve(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=n.readSync(r.dataId),o=ci(i),a=cpe(o,"string",s);return n.makeTensorInfo(r.shape,"string",a)}const Vve={kernelName:$v,backendName:"webgl",kernelFunc:Gve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wve({inputs:t,attrs:e,backend:n}){const{x:s}=t,r=qr+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new Oi(s.shape,r);return n.runWebGLProgram(i,[s],s.dtype)}const Hve={kernelName:Yc,backendName:"webgl",kernelFunc:Wve};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Kve=class{constructor(e,n,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=Qt(s.length),o=Qt(s.length);let a="";if(r===1)a="coords * strides + begin";else{let l=0;a=s.map((u,c)=>(l++,s.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${n});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jve(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:f,finalShape:p,isIdentity:g,sliceDim0:m,isSimpleSlice:x,begin:b,end:v,strides:y}=tx(r.shape,i,o,a,l,u,c,h,d);let C;if(g)C=je({inputs:{x:r},backend:n,attrs:{shape:p}});else if(m||x){G(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const $=ex(b,v,y),T=ch({inputs:{x:r},backend:n,attrs:{begin:b,size:$}});C=je({inputs:{x:T},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(T)}else if(n.shouldExecuteOnCPU([r])){const T=n.readSync(r.dataId),S=Ct(r.shape,r.dtype,T),E=hpe(f,S,y,b);C=n.makeTensorInfo(p,r.dtype,E.values)}else{const T=new Kve(b,y,f);C=n.runWebGLProgram(T,[r],r.dtype)}const I=je({inputs:{x:C},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(C),I}const Xve={kernelName:L0,backendName:"webgl",kernelFunc:jve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qve(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=n.readSync(c.dataId),f=n.readSync(h.dataId),[p,g]=dpe(d,f,r,i,o,a,l,u);return[n.makeTensorInfo([p.length],"string",p),n.makeTensorInfo(h.shape,"int32",g)]}const Yve={kernelName:Rv,backendName:"webgl",kernelFunc:qve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zve(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.readSync(i.dataId),l=n.readSync(o.dataId)[0],[u,c,h]=fpe(a,l,r),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}const Qve={kernelName:HE,backendName:"webgl",kernelFunc:Zve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jve(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(i.dataId),a=ppe(o,r);return n.makeTensorInfo(i.shape,"int32",a)}const e2e={kernelName:KE,backendName:"webgl",kernelFunc:Jve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t2e="return tan(x);",n2e=Ut({opSnippet:t2e}),s2e={kernelName:jc,backendName:"webgl",kernelFunc:n2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r2e=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,i2e=Ut({opSnippet:r2e}),o2e={kernelName:Xc,backendName:"webgl",kernelFunc:i2e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a2e(t){const{inputs:e,backend:n,attrs:s}=t,{tensor:r,indices:i,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Ji(o,i,r.shape),d=[h/u,u];if(h===0)return n.makeTensorInfo(r.shape,i.dtype);const f=je({inputs:{x:i},backend:n,attrs:{shape:[l,a]}}),p=je({inputs:{x:o},backend:n,attrs:{shape:[l,u]}}),g=je({inputs:{x:r},backend:n,attrs:{shape:d}}),m=new lw(l,a,f.shape.length,p.shape.length,c,d,!1,!0),x=n.runWebGLProgram(m,[p,f,g],g.dtype),b=je({inputs:{x},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),b}const l2e={kernelName:Tv,backendName:"webgl",kernelFunc:a2e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let u2e=class{constructor(e,n){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[o]*n[o];this.outputShape=s,this.rank=s.length;const r=Qt(this.rank),i=c2e(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}};function c2e(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<t.length;r++)s.push(`imod(${n[r]}, ${t[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rN(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const l=n.readSync(r.dataId),u=r.dtype==="string"?l.map(d=>li(d)):l,c=Ct(r.shape,r.dtype,u),h=gpe(c,i);return n.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new u2e(r.shape,i);return n.runWebGLProgram(o,[r],r.dtype)}const h2e={kernelName:qc,backendName:"webgl",kernelFunc:rN};let d2e=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},f2e=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function V3(t){let e=1;for(;e<t;)e*=2;return e}function p2e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:i,sorted:o}=s,a=ue().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ue().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([r])||c<a||i>l){const E=n.readSync(r.dataId),[_,N]=xpe(E,u,r.dtype,i,o);return[n.makeTensorInfo(_.shape,_.dtype,_.values),n.makeTensorInfo(N.shape,N.dtype,N.values)]}if(i===0)return u[u.length-1]=0,[n.makeTensorInfo(u,r.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[r,gp({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=n.texData.get(r.dataId),d=h!==null&&h.isPacked,f=d?n.unpackTensor(r):r,g=oe(u)/c,m=je({inputs:{x:f},attrs:{shape:[g,c]},backend:n});d&&Oa(n,f);const x=V3(i),b=V3(c);let v=null;const y=()=>v===null?[m,m]:[m,v],C=(E,_,N)=>{const P=y(),M=new d2e(N),A=[[c],[v===null?1:0],[Number.NEGATIVE_INFINITY],[E],[_]],B=v;v=n.runWebGLProgram(M,P,"int32",A),Oa(n,B)};for(let E=1;E<x;E*=2){const _=E*2;for(let N=E;N>=1;N/=2)C(_,N,[g,b])}for(let E=b;E>x;E/=2){const _=y(),N=new f2e([g,E/2]),M=[[c],[v===null?1:0],[x]],z=v;v=n.runWebGLProgram(N,_,"int32",M),Oa(n,z);const A=x/2,B=A*2;for(let L=A;L>=1;L/=2)C(B,L,v.shape)}let I=v;v=ch({inputs:{x:v},backend:n,attrs:{begin:0,size:[g,i]}}),Oa(n,I);let $=YD({inputs:{x:m,indices:v},backend:n,attrs:{axis:1,batchDims:1}});Oa(n,m);const T=u.slice(0,-1);T.push(i),I=v,v=je({inputs:{x:v},attrs:{shape:T},backend:n}),Oa(n,I);const S=$;return $=je({inputs:{x:$},attrs:{shape:T},backend:n}),Oa(n,S),[$,v]}const m2e={kernelName:O0,backendName:"webgl",kernelFunc:p2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let g2e=class{constructor(e,n,s,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2e(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=s,[c,h,d,f]=r.shape,[p,g]=u??[h,d],m=[c,p,g,f],x=new g2e(h,d,o,a,l,m);return n.runWebGLProgram(x,[r,i],"float32")}const b2e={kernelName:F0,backendName:"webgl",kernelFunc:x2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y2e(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:i}=e;fp(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:a,outputShape:l,indices:u}=bpe(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}const v2e={kernelName:Av,backendName:"webgl",kernelFunc:y2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w2e(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[i],u=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==i&&(u[c++]=o.shape[g]);const h=[],d=new Array(a).fill(0),f=o.shape.slice();f[i]=1;const p=new Array(l);for(let g=0;g<p.length;g++){d[i]=g;const m=ch({inputs:{x:o},backend:n,attrs:{begin:d,size:f}}),x=je({inputs:{x:m},backend:n,attrs:{shape:u}});p[g]=x,h.push(m)}return h.forEach(g=>n.disposeIntermediateTensorInfo(g)),p}const S2e={kernelName:jf,backendName:"webgl",kernelFunc:w2e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C2e{constructor(e,n){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,i=e.inSize,o=e.numSegments,a=o*Math.ceil(i/s);this.outputShape=[r,a];const l="0.0",u="sumValue",c=Math.floor(s/4)*4,h=s%4,d=`
        sumValue += dot(values, segFilter);
    `;let f="";i%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let p="";i%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T2e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:i}=e,{numSegments:o}=s,a=r.shape.length,l=[];let u=0;const c=Jt([u],a);let h=r;c!=null&&(h=Us({inputs:{x:r},backend:n,attrs:{perm:c}}),l.push(h),u=an(1,a)[0]);const d=S2(h.shape,u,o),f=oe([h.shape[u]]),p=je({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}});l.push(p);const g=z0(r.dtype),m=(y,C,I,$,T)=>{const S=y.shape[0],E=y.shape[1],_=F$(E,T),N={windowSize:_,inSize:E,batchSize:S,numSegments:T},P=new C2e(N,C),M=n.compileAndRun(P,[y,I],$);if(l.push(M),M.shape[1]===T)return M;const z=sN({backend:n,attrs:{start:0,stop:T,step:1,dtype:"float32"}}),A=rN({inputs:{x:z},backend:n,attrs:{reps:[E/_]}});return l.push(z),l.push(A),m(M,C,A,$,T)},x=m(p,"unsortedSegmentSum",i,g,o),b=je({inputs:{x},backend:n,attrs:{shape:d}});let v=b;if(c!=null){l.push(b);const y=Qi(c);v=Us({inputs:{x:v},backend:n,attrs:{perm:y}})}return l.forEach(y=>n.disposeIntermediateTensorInfo(y)),v}const I2e={kernelName:Xf,backendName:"webgl",kernelFunc:T2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k2e=[ume,hme,pme,xme,yme,Sme,Tme,kme,Rme,Pme,Mme,Fme,zme,Hme,Xme,Yme,Qme,nge,rge,oge,cge,xge,yge,Cge,Ige,Age,Dge,Oge,Kpe,Bge,Hge,qge,t0e,r0e,o0e,l0e,c0e,p0e,x0e,v0e,S0e,T0e,k0e,$0e,A0e,M0e,O0e,B0e,V0e,H0e,q0e,J0e,sxe,oxe,uxe,cxe,dxe,pxe,gxe,bxe,vxe,Txe,Exe,Rxe,Pxe,Mxe,Fxe,Gxe,Kxe,Hpe,Xxe,Vge,Zxe,ebe,sbe,Xpe,abe,hbe,fbe,xbe,vbe,Tbe,Ebe,Abe,Mbe,Fbe,Bbe,Wbe,Kbe,Xbe,Qbe,e1e,n1e,r1e,o1e,c1e,p1e,b1e,k1e,Zpe,R1e,D1e,L1e,U1e,Ege,G1e,W1e,K1e,q1e,J1e,Ype,tye,sye,iye,aye,lye,_ge,S1e,hye,mye,yye,Jpe,Cye,kye,Rye,Dye,Oye,Uye,Gye,Hye,Xye,Zye,eve,sve,ave,cve,pve,xve,mge,T1e,vve,Sve,Tve,kve,_ve,Rve,Pve,Nve,Lve,Uve,zve,Vve,Hve,Xve,Yve,Qve,e2e,C1e,ome,s2e,o2e,l2e,h2e,m2e,b2e,ame,v2e,S2e,I2e,V1e];for(const t of k2e)Dv(t);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rr=ue();Rr.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Rr.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Rr.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Rr.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Rr.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Rr.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Rr.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Rr.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Rr.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Rr.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Rr.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Rr.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Rr.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class E2e{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _2e{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,n,s=!1,r=!0){let i;const o=W3(e,n);return r?(this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).length>0?(i=this.freeBuffers.get(o).pop(),this.numFreeBuffers--):(i=this.device.createBuffer({size:e,usage:n,mappedAtCreation:s}),this.numBytesAllocated+=e)):(i=this.device.createBuffer({size:e,usage:n,mappedAtCreation:s}),this.numBytesAllocated+=e),this.usedBuffers.has(o)||this.usedBuffers.set(o,[]),this.usedBuffers.get(o).push(i),this.numUsedBuffers++,this.numBytesUsed+=e,i}releaseBuffer(e,n=!0){if(this.freeBuffers.size===0)return;const s=e.size,r=e.usage,i=W3(s,r),o=this.usedBuffers.get(i),a=o.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");o[a]=o[o.length-1],o.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,n?(this.freeBuffers.get(i).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,n)=>{e.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((e,n)=>{e.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function W3(t,e){return`${t}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $2e{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,n,s,r){const i=K3(s),o=e*n*i,a=H3(e,n,s,r);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=o,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const u=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(u),u}this.numBytesAllocated+=o;const l=this.device.createTexture({size:[e,n],format:s,usage:r});return this.usedTextures.get(a).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const n=e.width,s=e.height,r=e.format,i=e.usage,o=H3(n,s,r,i);this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.freeTextures.get(o).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(o),l=a.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(l,1);const u=K3(r),c=n*s*u;this.numBytesUsed-=c}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,n)=>{e.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((e,n)=>{e.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function H3(t,e,n,s){return`${t}_${e}_${n}_${s}`}function K3(t){if(t==="rgba8unorm")return 16;throw new Error(`${t} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R2e(t,e){if(Math.max(...t)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=t.length,s="xyzwuv",r=t.map(o=>`${e}.${s[o]}`),i=new Array(n-1);i[n-2]=r[n-1];for(let o=n-3;o>=0;--o)i[o]=`(${i[o+1]} * ${r[o+1]})`;return i}const Ca=(t,e,n)=>n==="int32"?`atomicAdd(${t}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${t}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var qu;(function(t){t[t.FROM_PIXELS=0]="FROM_PIXELS",t[t.DRAW=1]="DRAW"})(qu||(qu={}));const A2e=(t,e,n,s,r)=>{const i={dtype:s.dtype,shape:s.shape},o=D2e(n,i,e),a=t.createShaderModule({code:o,label:e.constructor.name});let l=ue().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const u=l.split(",");(l==="all"||u.some(c=>e.shaderKey.toLowerCase().includes(c)))&&(console.group(e.shaderKey),console.debug(o),console.groupEnd())}return r?t.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):t.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},kt=(t,e="f32")=>{switch(t){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component ${e} is not supported.`)}};function Fn(t){if(t<=1)return"i32";if(t===2)return"vec2<i32>";if(t===3)return"vec3<i32>";if(t===4)return"vec4<i32>";if(t===5)return"vec5";if(t===6)return"vec6";throw Error(`GPU for rank ${t} is not yet supported`)}function So(t){if(t===0)return"x";if(t===1)return"y";if(t===2)return"z";if(t===3)return"w";if(t===4)return"u";if(t===5)return"v";throw Error(`Index ${t} is not yet supported`)}function Ge(...t){let e;switch(t.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${t[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function j3(t,e){let n;return n=`
     ${P2e(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${t?"main(getGlobalIndex());":"main();"};
      }
    `,n}function P2e(t){return`
  @compute @workgroup_size(${t.workgroupSize[0]}, ${t.workgroupSize[1]}, ${t.workgroupSize[2]})
`}function D2e(t,e,n){const s=[],r=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${iN(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${r}u +
                localIndex);
        `}
      }
    `),n.pixelsOpType!=null){const p=n.pixelsOpType===qu.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${ja(e.dtype,n.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${ja(t[0].dtype,n.outputComponent)}>;`,g=e.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${g},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${p}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const m=q3(n);return[X3,s.join(`
`),Em(e.shape),n.getUserCode(),j3(m,n)].join(`
`)}let i,o,a="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach((p,g)=>{const m=Fn(t[g].shape.length);a+=`${p.charAt(0).toLowerCase()+p.slice(1)}Shape : ${m}, `,i=t[g].shape.length-1,o=Fn(i),a+=`${p.charAt(0).toLowerCase()+p.slice(1)}ShapeStrides: ${o}, `});const l=Fn(e.shape.length);a+=`outShape : ${l}, `,i=e.shape.length-1,o=Fn(i),a+=`
         outShapeStrides: ${o}, `,n.size&&(a+="size : i32, "),n.uniforms&&(a+=n.uniforms),a+="};",a=G2e(a),s.push(a),n.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${ja(e.dtype,n.outputComponent)}>;
    `),n.variableNames.forEach((p,g)=>{s.push(`
      @group(0) @binding(${1+g}) var<storage, read> ${p}: array<${n.variableComponents?ja(t[g].dtype,n.variableComponents[g]):ja(t[g].dtype,n.outputComponent)}>;
        `)}),a!==""&&s.push(`
      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const u=U2e(e.shape,n.dispatchLayout),c=[X3,s.join(`
`)+M2e,Em(e.shape),u,B2e(e.shape.length)];n.atomic||c.push(z2e(e.shape,e.dtype,n.outputComponent)),n.variableNames.forEach((p,g)=>{c.push(`${Em(t[g].shape,p)}`)});const h=t.map((p,g)=>F2e(p,e.shape,n.variableComponents?n.variableComponents[g]:n.outputComponent,n.dispatchLayout.x.length===e.shape.length)).join(`
`);c.push(h),c.push(n.getUserCode());const d=q3(n);return c.push(j3(d,n)),c.join(`
`)}function N2e(t,e,n){let s=t.shaderKey;if(t.pixelsOpType!=null)return s;const r=[],i=[];e.forEach(c=>{r.push(c.shape),i.push(c.dtype)}),r.push(n.shape),i.push(n.dtype);const o=e.map(c=>oa(c.shape,n.shape)),a=e.map(c=>Pt(c.shape,n.shape)).join("_"),l=o.map(c=>c.join("_")).join(";"),u=iN(t)?"flatDispatch":"";return s+="_"+(t.workgroupSize?t.workgroupSize.join(","):"")+r.map(c=>c.length).join(",")+i.join(",")+t.variableNames.join(",")+l+a+u,s}const X3=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,M2e=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function Em(t,e=""){const n=t.length,s=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",r=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const i=lt(t),o=Fn(n),a=[];for(let u=0;u<n;u++)a.push(`d${u}`);if(i.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${r}; let d1 = index - d0 * uniforms.${r};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+i.map((u,c)=>{const h=`let ${a[c]} = index2 / uniforms.${r}.${So(c)}`,d=c===i.length-1?`let ${a[c+1]} = index2 - ${a[c]} * uniforms.${r}.${So(c)}`:`index2 = index2 - ${a[c]} * uniforms.${r}.${So(c)}`;return`${h}; ${d};`}).join(""),`
    fn ${s}(index : i32) -> ${o} {
      ${l}
      return ${o}(${a.join(",")});
    }
  `}function L2e(t,e){const n=t.name,s=t.shape.length,r=Fn(s),i="get"+n.charAt(0).toUpperCase()+n.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=o.map(c=>`${c} : i32`).join(", ");if(s<1)return`
      fn ${i}() -> ${kt(e)} {
        return ${kt(e)}(${n}[0]);
      }
    `;const l=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let u=`${s}D`;return s===0&&(u="1D"),`
    fn ${i}(${a}) -> ${kt(e)} {
      return ${kt(e)}(${n}[getIndexFromCoords${u}(${r}(${o.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function O2e(t,e,n,s){const r=t.name,i=r.charAt(0).toUpperCase()+r.slice(1),o="get"+i+"ByOutput",a=t.shape.length,l=e.length,u=Fn(l);if(Pt(t.shape,e)&&s)return`
    fn ${o}Index(globalIndex : i32) -> ${kt(n)} {
      return ${kt(n)}(${r}[globalIndex]);
    }

    fn ${o}Coords(coords : ${u}) -> ${kt(n)} {
      return ${kt(n)}(${r}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${n===1?"":` / ${n}`}]);
    }
    `;const c=oa(t.shape,e),h=l-a;let d="";if(a===0)return`
    fn ${o}Index(globalIndex : i32) -> ${kt(n)}{
      return get${i}();
    }

    fn ${o}Coords(coords : ${u}) -> ${kt(n)}{
      return get${i}();
    }
  `;l<2&&c.length>=1?d="coords = 0;":d=c.map(m=>`coords.${So(m+h)} = 0;`).join(`
`);let f="";if(l<2&&a>0)f="coords";else if(l>1){const m=Fn(a),x=t.shape.map((b,v)=>`coords.${So(v+h)}`).join(", ");f=`${m}(${x})`}else f="coords";const p=`uniforms.${r.charAt(0).toLowerCase()+r.slice(1)}Shape`,g=`${a}D`;return`
  fn ${o}Index(globalIndex : i32) -> ${kt(n)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${d}
    return ${kt(n)}(${r}[getIndexFromCoords${g}(${f}, ${p})${n===1?"":` / ${n}`}]);
  }

  fn ${o}Coords(coordsIn : ${u}) -> ${kt(n)} {
    var coords = coordsIn;
    ${d}
    return ${kt(n)}(${r}[getIndexFromCoords${g}(${f}, ${p})${n===1?"":` / ${n}`}]);
  }
`}function F2e(t,e,n,s){let r=L2e(t,n);return t.shape.length<=e.length&&(r+=O2e(t,e,n,s)),r}function U2e(t,e){const{x:n,y:s=[],z:r=[]}=e,i=t.length,o=n.length+s.length+r.length;if(o!==i)return"";if(n.length===i)return`fn getOutputCoords() -> ${Fn(i)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const l=[n,s,r];for(let d=0;d<l.length;d++){const f=l[d];if(f.length!==0)if(f.length===1)a+=`let d${f[0]} = i32(globalId[${d}]);`;else{const p=R2e(f,"uniforms.outShape");a+=`var index${d} = i32(globalId[${d}]);`;for(let g=0;g<p.length;g++)a+=`let d${f[g]} = index${d} / ${p[g]};`,g===p.length-1?a+=`let d${f[g+1]} = index${d} - d${f[g]} * ${p[g]};`:a+=`index${d} = index${d} - d${f[g]} * ${p[g]};`}}const u=[];for(let d=0;d<o;d++)u.push(`d${d}`);const c=Fn(o);let h=`fn getOutputCoords() -> ${c} {
  ${a}
`;return u.length===0?h+=`return ${c}(0); }`:h+=`return ${c}(${u.join(",")}); }`,h}function B2e(t){let e="";switch(t){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:G(!1,()=>`Unsupported ${t}D shape`);break}return e}function iN(t){return t.dispatch[1]===1&&t.dispatch[2]===1}function ja(t,e=1){if(t==="float32")return kt(e,"f32");if(t==="int32"||t==="bool")return kt(e,"i32");throw new Error(`type ${t} is not supported.`)}function z2e(t,e,n){const s=t.length,r=ja(e,n);let i=`fn setOutputAtIndex(flatIndex : i32, value : ${kt(n)}) {
      result[flatIndex] = ${r}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${kt(n,"i32")}) {
      result[flatIndex] = ${r}(value);
    }
    `;if(s>=2){const o=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=Fn(s);i+=`
      fn setOutputAtCoords(${o.map(l=>`${l} : i32`).join(", ")}, value : ${kt(n)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndex(flatIndex${n===1?"":` / ${n}`}, value);
      }
      fn setOutputAtCoordsI32(${o.map(l=>`${l} : i32`).join(", ")}, value : ${kt(n,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndexI32(flatIndex${n===1?"":` / ${n}`}, value);
      }
    `}return i}function G2e(t){const e=/(\w+)\s*:\s*vec(5|6)/g;t=t.replace(e,s=>"@align(16) "+s);const n=/vec(5|6)\s*,\s*(\w+)/g;return t=t.replace(n,(s,r,i)=>`vec${r}, @align(16) ${i}`),t}function q3(t){return!(t.dispatchLayout.hasOwnProperty("y")&&t.dispatchLayout.y.length!==0||t.dispatchLayout.hasOwnProperty("z")&&t.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ll=t=>{let e=1;for(let n=0;n<t.length;n++)e*=t[n];return e};function Ve(t,e,n=[1,1,1],s=[1,1,1]){const[r,i,o]=[Math.ceil(ll(t.x.map(a=>e[a]))/(n[0]*s[0])),t.y?Math.ceil(ll(t.y.map(a=>e[a]))/(n[1]*s[1])):1,t.z?Math.ceil(ll(t.z.map(a=>e[a]))/(n[2]*s[2])):1];return[r,i,o]}function V2e(t,e,n,s=!1){const r=[8,8,1],i=[4,4,1];return s||(t<=8&&(i[1]=1),e<=16&&n<=16&&(r[0]=4)),{workgroupSize:r,elementsPerThread:i}}function oN(t,e,n=!1){if(n)return[8,8,1];const s=ll(t.x.map(i=>e[i])),r=ll(t.y.map(i=>e[i]));return s<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function aN(t,e,n=!1){if(n)return[4,4,1];const s=ll(t.x.map(i=>e[i])),r=ll(t.y.map(i=>e[i]));return s<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function Qe(t){return{x:t.map((e,n)=>n)}}function Y3(t){if(t==="float32"||t==="int32"||t==="bool"||t==="string")return 4;if(t==="complex64")return 8;throw new Error(`Unknown dtype ${t}`)}function lN(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function uN(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&G(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var ki;(function(t){t[t.MatMulReduceProgram=0]="MatMulReduceProgram",t[t.MatMulSplitKProgram=1]="MatMulSplitKProgram",t[t.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",t[t.MatMulPackedProgram=3]="MatMulPackedProgram",t[t.MatMulMax=4]="MatMulMax"})(ki||(ki={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W2e=ue().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),H2e=(t,e)=>{const n=t.limits.maxComputeWorkgroupsPerDimension,s=e.dispatchLayout,r=e.dispatch;if(r.every(o=>o<=n))return r;G(r[0]>n&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(r[0]));return i>n?(i=Math.ceil(Math.cbrt(r[0])),G(i<=n,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]};class Ox extends t0{nextDataId(){return Ox.nextDataId++}constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!lN())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new E2e(n),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new _2e(this.device),this.textureManager=new $2e(this.device),this.tensorMap=new lv(this,br()),ue().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,n=!1){if(!this.tensorMap.has(e))return!0;const s=this.tensorMap.get(e);return n?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const n=this.tensorMap.get(e);if(!(!n||!n.resource)){if(n.external){n.resource=null;return}n.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(n.resource):n.resource instanceof GPUTexture&&this.textureManager.releaseTexture(n.resource),n.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const n=this.tensorMap.get(e);n.refCount++}decRef(e){if(this.tensorMap.has(e)){const n=this.tensorMap.get(e);n.refCount--}}write(e,n,s){if(s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:s,shape:n,values:e,refCount:1}),r}move(e,n,s,r,i){if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:s,values:n,refCount:i})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(n){throw new Error(n.message)}Object.keys(this.pipelineCache).map((n,s)=>{this.pipelineCache[n]=e[s]})}async getBufferData(e){if(ue().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const n=e.size,s=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,n),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const r=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),ue().getBool("WEBGPU_USE_PROFILE_TOOL")&&(G(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(e,n){const s=this.tensorMap.get(e);return s.values=n,s.values}readSync(e){const n=this.tensorMap.get(e),{values:s,complexTensorInfos:r}=n;if(s!=null||n.dtype==="string")return s;if(n.dtype==="complex64"){const g=this.readSync(r.real.dataId),m=this.readSync(r.imag.dataId),x=Tm(ui(g,m).buffer,"float32");return this.convertAndCacheOnCPU(e,x),x}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const i=["opaque","premultiplied"],o=n.resource,a=o.size;G(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=a/4,u=new ArrayBuffer(a),c=256,h=256,d=i.map(g=>new OffscreenCanvas(c,h)),f=new OffscreenCanvas(c,h);this.endComputePassEncoder(),d.map((g,m)=>{const x=g.getContext("webgpu");return x.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:i[m]}),x.getCurrentTexture()}).map((g,m)=>{const x=c*4,b=(T,S,E)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:o,bytesPerRow:x,offset:E},{texture:g},{width:T,height:S}),this.submitQueue();const _=f.getContext("2d",{willReadFrequently:!0});_.clearRect(0,0,T,S),_.drawImage(d[m],0,0);const N=_.getImageData(0,0,T,S).data,P=i[m],M=new Uint8ClampedArray(u,E,T*S*4);for(let z=0;z<M.length;z+=4)if(P==="premultiplied")M[z+3]=N[z+3];else{const A=N[z];M[z]=N[z+2],M[z+1]=N[z+1],M[z+2]=A}},v=Math.floor(l/(c*h));let y=c,C=h,I=0;for(let T=0;T<v;T++)b(y,C,I),I+=c*h*4;const $=l%(c*h);C=Math.floor($/c),C>0&&(b(y,C,I),I+=C*(c*4)),y=$%c,y>0&&b(y,1,I)});const p=Tm(u,n.dtype);return this.convertAndCacheOnCPU(e,p),p}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const n=this.tensorMap.get(e),{values:s}=n;if(s!=null)return s;let r;if(n.dtype==="complex64"){const i=await Promise.all([this.read(n.complexTensorInfos.real.dataId),this.read(n.complexTensorInfos.imag.dataId)]),o=i[0],a=i[1];r=ui(o,a)}else{const i=await this.getBufferData(n.resource);r=Tm(i,n.dtype)}return this.convertAndCacheOnCPU(e,r),r}copyBuffer(e){const n=e.size,s=e.usage,r=this.bufferManager.acquireBuffer(n,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,n),this.submitQueue(),r}createTensorFromGPUData(e,n,s){let r=e.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const i={id:this.nextDataId()};this.tensorMap.set(i,{dtype:s,shape:n,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(i),a=Y3(o.dtype)*oe(o.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(r=this.copyBuffer(r)),o.resource=r,br().makeTensorFromDataId(i,n,s,this)}readToGPU(e){const n=this.tensorMap.get(e),{values:s,dtype:r,shape:i,resource:o}=n;if(r==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(o==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=o,l=a.size,u=a.usage,c=this.bufferManager.acquireBuffer(l,u);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,c,0,l),this.submitQueue();const h=this.makeTensorInfo(i,r),d=br().makeTensorFromTensorInfo(h),f=this.tensorMap.get(h.dataId);return f.resource=c,{tensorRef:d,buffer:c}}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const s=n.map(r=>li(r));return Ct(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ct(e.shape,e.dtype,n)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const n=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=Eo(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),o=Eo(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=n,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(i);return a.kernelMs=DE(l),a.getExtraProfileInfo=()=>l.map((u,c)=>({name:o[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,n,s){return n==="string"&&s!=null&&s.length>0&&ec(s[0])&&(s=s.map(i=>vo(i))),{dataId:this.write(s,e,n),shape:e,dtype:n}}tensorToBinding(e){if(!e)return null;const s=this.tensorMap.get(e.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(e){const n=this.tensorMap.get(e);if(n.resource!=null)return;const s=Y3(n.dtype)*oe(n.shape);let r;const i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(n.values){if(r=this.bufferManager.acquireBuffer(s,i,!0),r.mapState==="unmapped"){const o=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=o.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(a).set(n.values):new Float32Array(a).set(n.values),o.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,r,0,s),this.stagingPendingDisposal.push(o)}else{const o=r.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(o).set(n.values):new Float32Array(o).set(n.values),r.unmap()}n.values=null}else r=this.bufferManager.acquireBuffer(s,i);n.resource=r}makeUniforms(e){let n=0,s=0;const r=[];let i=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let u;switch(l.data.length){case 1:u=4;break;case 2:u=8;break;case 3:u=16;break;case 4:u=16;break;case 5:u=16;break;case 6:u=16;break;default:G(!1,()=>`Unsupported ${l.data.length}D shape`)}(s===5||s===6)&&(u=16),u>i&&(i=u),n=Math.ceil(n/u)*u,s=l.data.length,r.push(n),n+=l.data.length*4}),n=Math.ceil(n/i)*i;const o=new ArrayBuffer(n);e.forEach((l,u)=>{const c=r[u];l.type==="int32"?new Int32Array(o,c,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(o,c,l.data.length).set(l.data):new Float32Array(o,c,l.data.length).set(l.data)});const a=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,o,0,n),this.uniformPendingDisposal.push(a),{offset:0,size:n,buffer:a}}runWebGPUProgram(e,n,s,r,i){if(i||(i=this.makeTensorInfo(e.outputShape,s)),oe(i.shape)===0)return this.tensorMap.get(i.dataId).values=cs(i.dtype,0),i;this.uploadToGPU(i.dataId),e.dispatch=H2e(this.device,e);const o=n.map((l,u)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[u]}});e.shaderKey=N2e(e,o,i);const a=ue().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=A2e(this.device,e,o,i,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,i,n,r),i}recordAndSubmit(e,n,s,r){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let i=[],o=[];const a="int32";if(e.pixelsOpType==null){i.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),o=s.concat(n).map(f=>f.shape);const d="int32";o.map(f=>{i.push({type:d,data:f});const p=lt(f);i.push({type:d,data:p})})}else{const d=lt(n.shape);i.push({type:a,data:d})}if(e.size){const d=oe(e.outputShape);i.push({type:a,data:[e.outputComponent?d/e.outputComponent:d]})}r&&(i=[...i,...r]);const l=[this.tensorToBinding(n),...s.map(d=>this.tensorToBinding(d)),this.makeUniforms(i)];s.forEach(d=>{this.commandQueueOwnedIds.add(d.dataId)}),this.commandQueueOwnedIds.add(n.dataId);const u=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((d,f)=>({binding:f,resource:d}))}),c=this.activeTimers!=null;this.ensureCommandEncoderReady();const h={};c&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),h.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(h)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(h)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,u),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(c||ue().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===qu.DRAW)&&(this.endComputePassEncoder(),c?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const n=new BigUint64Array(e.getMappedRange()),s=Number(n[1]-n[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),s}shouldExecuteOnCPU(e,n=W2e){return ue().getBool("WEBGPU_CPU_FORWARD")&&e.every(s=>this.tensorMap.get(s.dataId).resource==null&&oe(s.shape)<n)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Ox.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */lN()&&Mv("webgpu",async()=>{const t={powerPreference:ue().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(t),n={},s=[];e.features.has("timestamp-query")&&s.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),n.requiredFeatures=s;const r=e.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup};const i=await e.requestDevice(n),o="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new Ox(i,o)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var xt;(function(t){t[t.ADD=0]="ADD",t[t.ATAN2=1]="ATAN2",t[t.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",t[t.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",t[t.DIV=4]="DIV",t[t.ELU_DER=5]="ELU_DER",t[t.EQUAL=6]="EQUAL",t[t.FLOOR_DIV=7]="FLOOR_DIV",t[t.GREATER=8]="GREATER",t[t.GREATER_EQUAL=9]="GREATER_EQUAL",t[t.LESS=10]="LESS",t[t.LESS_EQUAL=11]="LESS_EQUAL",t[t.LOGICAL_AND=12]="LOGICAL_AND",t[t.LOGICAL_OR=13]="LOGICAL_OR",t[t.MAX=14]="MAX",t[t.MIN=15]="MIN",t[t.MOD=16]="MOD",t[t.MUL=17]="MUL",t[t.NOT_EQUAL=18]="NOT_EQUAL",t[t.POW=19]="POW",t[t.PRELU=20]="PRELU",t[t.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",t[t.SUB=22]="SUB"})(xt||(xt={}));const K2e="let resultTemp = a + b;",j2e="let resultTemp = atan2(a, b);",X2e="let resultTemp = areal * breal - aimag * bimag;",q2e="let resultTemp = areal * bimag + aimag * breal;",Y2e="let resultTemp = a / b;",Z2e="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",Q2e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,J2e=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,ewe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,twe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,nwe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,swe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,rwe="return f32(a >= 1.0 && b >= 1.0);",iwe=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,owe="return f32(a >= 1.0 || b >= 1.0);",awe=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,lwe="let resultTemp = max(a, b);",uwe="let resultTemp = min(a, b);",cwe=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,hwe=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,dwe="let resultTemp = a * b;",fwe=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,pwe=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,mwe=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,gwe=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,xwe="if (a < 0.0) { return b * a; }  return a;",bwe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,ywe="let resultTemp = (a - b) * (a - b);",vwe="let resultTemp = a - b;";function uw(t,e){let n;do{switch(t){case xt.ATAN2:n=j2e;break;case xt.MAX:n=lwe;break;case xt.MIN:n=uwe;break;case xt.MOD:n=e?hwe:cwe;break;case xt.NOT_EQUAL:n=e?pwe:fwe;break;case xt.POW:n=e?gwe:mwe;break;default:continue}let s,r,i;return e?(s="isnanVec4",r="vec4<f32>",i="vec4<bool>"):(s="isnan",r="f32",i="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${r}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${r}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${n}
        return select(
            resultTemp, ${r}(valueForNaN),
            ${i}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(t){case xt.ADD:n=K2e;break;case xt.COMPLEX_MULTIPLY_IMAG:n=q2e;break;case xt.COMPLEX_MULTIPLY_REAL:n=X2e;break;case xt.DIV:n=Y2e;break;case xt.ELU_DER:n=Z2e;break;case xt.EQUAL:n=Q2e;break;case xt.FLOOR_DIV:n=J2e;break;case xt.GREATER:n=ewe;break;case xt.GREATER_EQUAL:n=twe;break;case xt.LESS:n=nwe;break;case xt.LESS_EQUAL:n=swe;break;case xt.LOGICAL_AND:return e?iwe:rwe;case xt.LOGICAL_OR:return e?awe:owe;case xt.MUL:n=dwe;break;case xt.PRELU:return e?bwe:xwe;case xt.SQUARED_DIFFERENCE:n=ywe;break;case xt.SUB:n=vwe;break}return`
    ${n}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Oe;(function(t){t[t.ABS=0]="ABS",t[t.ACOS=1]="ACOS",t[t.ACOSH=2]="ACOSH",t[t.ASIN=3]="ASIN",t[t.ASINH=4]="ASINH",t[t.ATAN=5]="ATAN",t[t.ATANH=6]="ATANH",t[t.CEIL=7]="CEIL",t[t.COS=8]="COS",t[t.COSH=9]="COSH",t[t.ELU=10]="ELU",t[t.ERF=11]="ERF",t[t.EXP=12]="EXP",t[t.EXPM1=13]="EXPM1",t[t.FLOOR=14]="FLOOR",t[t.IS_FINITE=15]="IS_FINITE",t[t.IS_INF=16]="IS_INF",t[t.IS_NAN=17]="IS_NAN",t[t.LINEAR=18]="LINEAR",t[t.LOG=19]="LOG",t[t.LOG1P=20]="LOG1P",t[t.LOGICAL_NOT=21]="LOGICAL_NOT",t[t.NEG=22]="NEG",t[t.RELU=23]="RELU",t[t.RELU6=24]="RELU6",t[t.LEAKYRELU=25]="LEAKYRELU",t[t.RECIPROCAL=26]="RECIPROCAL",t[t.ROUND=27]="ROUND",t[t.RSQRT=28]="RSQRT",t[t.SELU=29]="SELU",t[t.SIGMOID=30]="SIGMOID",t[t.SIGN=31]="SIGN",t[t.SIN=32]="SIN",t[t.SINH=33]="SINH",t[t.SOFTPLUS=34]="SOFTPLUS",t[t.SQRT=35]="SQRT",t[t.SQUARE=36]="SQUARE",t[t.STEP=37]="STEP",t[t.TAN=38]="TAN",t[t.TANH=39]="TANH",t[t.TO_INT=40]="TO_INT"})(Oe||(Oe={}));const wwe="return abs(a);",Swe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,Cwe=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,Twe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,Iwe="return asinh(a);",kwe=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,Ewe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,_we="return ceil(a);",$we="return cos(a);",Rwe=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,Awe="return exp(a) - 1.0;",Pwe="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",Dwe=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,Nwe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${ax};
  let a1 = ${lx};
  let a2 = ${ux};
  let a3 = ${cx};
  let a4 = ${hx};
  let a5 = ${dx};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,Mwe="return exp(a);",Lwe="return floor(a);",Owe="return f32(!isnan(a) && !isinf(a));",Fwe="return f32(isinf(a));",Uwe="return f32(isnan(a));",Bwe="return a;",zwe=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,Gwe=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,Vwe="return f32(!(a >= 1.0));",Wwe="return -a;",Hwe="if (a < 0.0) { return uniforms.alpha * a; } return a;",Kwe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,jwe="return 1.0 / a;",Xwe="return select(a, 0.0, a < 0.0);",qwe="return clamp(a, 0.0, 6.0);",Ywe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",Zwe=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,Qwe="return round(a);",Jwe="return inverseSqrt(a);",eSe=`
  if (a >= 0.0) {
    return ${np} * a;
  } else {
    return ${tp} * (exp(a) - 1.0);
  }
`,tSe="return 1.0 / (1.0 + exp(-1.0 * a));",nSe="return sign(a);",sSe="return sin(a);",rSe=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,iSe=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,oSe="return sqrt(a);",aSe="return a * a;",lSe=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,uSe="return tan(a);",cSe=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,hSe="return f32(i32((a)));";function Ga(t,e){switch(t){case Oe.ABS:return wwe;case Oe.ACOS:return Swe;case Oe.ACOSH:return Cwe;case Oe.ASIN:return Twe;case Oe.ASINH:return Iwe;case Oe.ATAN:return kwe;case Oe.ATANH:return Ewe;case Oe.COS:return $we;case Oe.COSH:return Rwe;case Oe.CEIL:return _we;case Oe.ELU:return e?Dwe:Pwe;case Oe.ERF:return Nwe;case Oe.EXP:return Mwe;case Oe.EXPM1:return Awe;case Oe.FLOOR:return Lwe;case Oe.IS_FINITE:return Owe;case Oe.IS_INF:return Fwe;case Oe.IS_NAN:return Uwe;case Oe.LINEAR:return Bwe;case Oe.LOG:return zwe;case Oe.LOG1P:return Gwe;case Oe.LOGICAL_NOT:return Vwe;case Oe.NEG:return Wwe;case Oe.LEAKYRELU:return e?Kwe:Hwe;case Oe.RECIPROCAL:return jwe;case Oe.RELU:return e?Zwe:Xwe;case Oe.RELU6:return e?Ywe:qwe;case Oe.ROUND:return Qwe;case Oe.RSQRT:return Jwe;case Oe.SELU:return eSe;case Oe.SIGMOID:return tSe;case Oe.SIGN:return nSe;case Oe.SIN:return sSe;case Oe.SINH:return rSe;case Oe.SOFTPLUS:return iSe;case Oe.SQRT:return oSe;case Oe.SQUARE:return aSe;case Oe.STEP:return lSe;case Oe.TAN:return uSe;case Oe.TANH:return cSe;case Oe.TO_INT:return hSe;default:throw new Error(`BinaryType ${t} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Do(t,e=!1,n=!1,s=3){if(t===null)return"";let r="";if(t==="linear")r=Ga(Oe.LINEAR);else if(t==="relu")r=Ga(Oe.RELU,n);else if(t==="elu")r=Ga(Oe.ELU,n);else if(t==="relu6")r=Ga(Oe.RELU6,n);else if(t==="prelu")r=uw(xt.PRELU,n);else if(t==="sigmoid")r=Ga(Oe.SIGMOID,n);else if(t==="leakyrelu")r=Ga(Oe.LEAKYRELU,n);else throw new Error(`Activation ${t} has not been implemented for the WebGPU backend.`);const o=kt(n?4:1);let a="";return e?a=`
      fn activation(a : ${o}, coords : vec${s}<i32>) -> ${o} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${r}
      }`:a=`
      fn activation(a : ${o}, coords : vec${s}<i32>) -> ${o} {
        ${r}
      }`,a}function Wl(t,e){return`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cN(t,e,n=!1,s=!1,r=!1,i=1){G(t&&i===1||!t,()=>`transposeA ${t} is not compatible with component size ${i}`);const o=`
      ${t?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${kt(i)} {
    var value = ${kt(i)}(0.0);
    ${n&&r?o:`
    ${t?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${o}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${kt(i)} {
    var value = ${kt(i)}(0.0);
    ${a}
    return value;
  }
  `}function cw(t,e,n,s,r=!1,i=!1,o=!1,a=1){return`
  ${cN(n,s,r,i,o,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${kt(a)}) {
    ${r&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Wl(t,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const dSe=(t,e)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,fSe=(t,e,n,s)=>{if(t)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${n}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let r="",i="";for(let o=0;o<e;o++)r+=`let BCached${o} = mm_Bsub[k * ${e} + ${o}][tileCol];`,i+=`acc[i] = fma(BCached${o}, vec4<f32>(ACached[${o}]), acc[i]);`;return`
      for (var k = 0; k < ${s/e}; k++) {
        ${r}
        for (var i = 0; i < ${n}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${i}
        }
      }`}};function Fx(t,e,n=!1,s=32,r=!1,i=32,o=!1){const a=e[1]*t[1],l=e[0]*t[0],u=n?a:s,c=n?s:a,h=u/e[0],d=s/e[1],f=t[1],p=t[0];return G((n&&h===4&&t[1]===4||!n&&(h===3||h===4))&&u%e[0]===0&&s%e[1]===0&&t[0]===4,()=>`If transposeA ${n} is true, innerElementSize ${h} and workPerThread[1] ${t[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${u} must be divisible by workgroupSize[0]${e[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${u/h}>, ${c}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/t[0]}>, ${s}>;

  ${Ge()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${f};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${f};
    let globalCol = i32(globalId.x) * ${p};
    let batch = ${r?"0":"i32(globalId.z)"};
    let batchA = ${r||!o?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${r||!o?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${r?`${Math.ceil(i/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${r?`i32(globalId.z) * ${i}`:"0"};

    var acc: array<vec4<f32>, ${f}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${d};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${f}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${dSe(n,h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${fSe(n,h,f,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const Z3=t=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,pSe=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function Ux(t,e,n=!1,s=32,r=!1,i=32,o=!1,a=!1){const l=t[1]*e[1],u=t[0]*e[0],c=n?l:s,h=n?s:l;G(h%e[1]===0&&c%e[0]===0&&s%e[1]===0,()=>`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}, tileInner ${s} must be divisible by workgroupSize[1]${e[1]}`);const d=h/e[1],f=c/e[0],p=s/e[1],g=t[1],m=t[0],x=o?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${u};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            ${Z3(n)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${m}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${m}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${m}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${g};
  let tileCol = i32(localId.x) * ${m};

  let globalRow = i32(globalId.y) * ${g};
  let globalCol = i32(globalId.x) * ${m};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${d};
  let tileColA = i32(localId.x) * ${f};
  let tileRowB = i32(localId.y) * ${p};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
      for (var innerCol = 0; innerCol < ${f}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${Z3(n)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${m}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${m}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${m}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        ${pSe(n)}
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${g}; innerRow++) {
    for (var innerCol = 0; innerCol < ${m}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${u}>, ${s}>;

    ${Ge()} {
      let batch = ${r?"0":"i32(globalId.z)"};
      let batchA = ${r||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${r||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${r?`${Math.ceil(i/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${r?`i32(globalId.z) * ${i}`:"0"};

      var acc : array<array<f32, ${m}>, ${g}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${x}
    }
  `}const mSe=t=>t?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function gSe(t,e=!1){G(t[1]===1&&t[2]===1,()=>`A linear work group size is required. But got ${t}.`);const n=t[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${t[0]}>;

    ${Ge()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${n} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${mSe(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${n/4}; k++) {
          let rowB = t * ${n} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class xSe{constructor(e,n,s=!1,r=!1,i=null,o=null,a=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]};const u=s?e[1]:e[2];if(this.isVec4=(u%4===0&&!s||n[1]%4===0&&s)&&n[2]%4===0&&!r,this.outputComponent=this.isVec4?4:1,this.isVectorA=n[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const d=V2e(n[1],u,n[2],s);this.workgroupSize=d.workgroupSize,this.elementsPerThread=d.elementsPerThread}this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const c=i!=null,h=a!=null;c&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=s,this.transposeB=r,this.addBias=c,this.activation=o,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(n[1],n[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,n,s){const r=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=i;const o=e%r===0,a=n%i===0,l=s%this.tileInner===0;return[o,a,l]}getUserCode(){return`
      ${Do(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${cw(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?Fx(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?gSe(this.workgroupSize,this.transposeA):Ux(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bSe(t){return`
    var<workgroup> sumValues : array<f32, ${t}>;
    ${Ge()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${t}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${t/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class ySe{constructor(e,n=!1,s=!1,r=null,i=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=r!=null,l=o!=null;a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=n,this.transposeB=s,this.addBias=a,this.activation=i,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${n}_${s}`}getUserCode(){return`
      ${Do(this.activation,this.hasPreluActivationWeights)}
      ${cw(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${bSe(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vSe(t){const e=t[1],n=t[0],s=e>n?e:n;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Ge()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class wSe{constructor(e,n,s,r=!1,i=!1,o=null,a=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const u=o!=null;u&&this.variableNames.push("bias");const c=l!=null;c&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=u,this.activation=a,this.hasPreluActivationWeights=c,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${i}`}getUserCode(){return`
      ${Do(this.activation,this.hasPreluActivationWeights)}
      ${cw(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${vSe(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SSe{constructor(e,n,s=!1,r=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,G(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const i=(s&&this.outputShape[1]%4===0||!s&&n%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=i?4:1,i||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Ve(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],n],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=r,this.shaderKey=`matMulSplitK_${s}_${r}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${cN(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${kt(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Ca("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?Fx(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):Ux(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class CSe{constructor(e,n=null,s=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n!=null,this.hasPreluActivationWeights=r!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${Do(this.activation,this.hasPreluActivationWeights)}
    ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Wl(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TSe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Ge("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qs(t){const{backend:e,attrs:n}=t,{shape:s,value:r}=n;let{dtype:i}=n;if(i=i||_l(r),i==="string"){const o=_n(i,oe(s));return o.fill(r),e.makeTensorInfo(s,i,o)}else{const o=new TSe(s),a=[{type:"float32",data:[r]}];return e.runWebGPUProgram(o,[],i,a)}}const ISe={kernelName:S0,backendName:"webgpu",kernelFunc:Qs};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function it(t){const{inputs:e,attrs:n}=t,{x:s}=e,{shape:r}=n,i=oe(s.shape),o=cv(r,i),a=oe(o);return G(i===a,()=>`The new shape (${o}) has ${a} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),t.backend.incRef(s.dataId),{dataId:s.dataId,shape:o,dtype:s.dtype}}const kSe={kernelName:Of,backendName:"webgpu",kernelFunc:it};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bx({a:t,b:e,transposeA:n,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const u=t.shape.length,c=e.shape.length,h=n?t.shape[u-2]:t.shape[u-1],d=s?e.shape[c-1]:e.shape[c-2],f=n?t.shape[u-1]:t.shape[u-2],p=s?e.shape[c-2]:e.shape[c-1],g=t.shape.slice(0,-2),m=e.shape.slice(0,-2),x=oe(g),b=oe(m),y=pt(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([f,p]);G(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${s} must match.`);const C=n?[x,h,f]:[x,f,h],I=s?[b,p,d]:[b,d,p],$=it({inputs:{x:t},backend:r,attrs:{shape:C}}),T=it({inputs:{x:e},backend:r,attrs:{shape:I}}),S=[$,T],E=Math.max(x,b),_=[$,T],N=[{type:"int32",data:[f]},{type:"int32",data:[p]},{type:"int32",data:[h]}];let P,M;const z=[E,f,p];let A=ue().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(A<0){const L=ue().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),U=L>0?L:r.thresholdToIncreaseWorkgroups,j=E*Math.ceil(f/32)*Math.ceil(p/32);j<=U||f<=8&&j<=U*2?E*f*p<=128?A=ki.MatMulReduceProgram:E===1&&d>=2e3?A=ki.MatMulSplitKProgram:A=ki.MatMulSmallOutputSizeProgram:A=ki.MatMulPackedProgram}switch(A){case ki.MatMulReduceProgram:P=new ySe(z,n,s,i,l,o);break;case ki.MatMulSplitKProgram:{if(M=Qs({backend:r,attrs:{shape:z,value:0,dtype:t.dtype}}),P=new SSe(z,d,n,s),i||l){M=r.runWebGPUProgram(P,_,t.dtype,N,M);const U=new CSe(M.shape,i,l,o);let j=null;const Z=[M];i&&Z.push(i),o&&Z.push(o),l==="leakyrelu"&&(j=[{type:"float32",data:[a]}],U.uniforms+=" alpha : f32,");const J=r.runWebGPUProgram(U,Z,M.dtype,j);S.push(M);const se=it({inputs:{x:J},backend:r,attrs:{shape:y}});S.push(J);for(const fe of S)r.disposeData(fe.dataId);return se}break}case ki.MatMulSmallOutputSizeProgram:P=new wSe(C,I,z,n,s,i,l,o);break;case ki.MatMulPackedProgram:const L=r.adapterInfo.isIntel();P=new xSe(C,z,n,s,i,l,o,L);break;default:throw new Error(`Unsupported MatMulProgramType ${A}.`)}i&&_.push(i),o&&_.push(o),l==="leakyrelu"&&(N.push({type:"float32",data:[a]}),P.uniforms+=" alpha : f32,"),M=r.runWebGPUProgram(P,_,t.dtype,N,M);const B=it({inputs:{x:M},backend:r,attrs:{shape:y}});S.push(M);for(const L of S)r.disposeData(L.dataId);return B}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ESe(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;return Bx({a:r,b:i,transposeA:l,transposeB:u,backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}const _Se={kernelName:wd,backendName:"webgpu",kernelFunc:ESe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q3{constructor(e,n,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=pt(n,s),this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${uw(this.op,!1)}
      }

      ${Ge("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wg{constructor(e,n,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=pt(n,s),this.dispatchLayout=Qe(this.outputShape),this.op=e,this.useSharedMemoryWithA=n.length<=1&&s.length>1&&n[0]<128,this.useSharedMemoryWithB=s.length<=1&&n.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:n[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const r=n.length>0&&n[n.length-1]%4===0,i=s.length>0&&s[s.length-1]%4===0;r&&i?(this.outputComponent=4,this.variableComponents=[4,4]):r&&(oC(s)||s[s.length-1]===1)||i&&(oC(n)||n[n.length-1]===1)?(this.outputComponent=4,this.variableComponents=r?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const n=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${n}, b : ${n}) -> ${n} {
      ${uw(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const r=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${r}];`:`let a = sharedBuf[${r}];
          let b = getBByOutputIndex(index);`;e=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Ge("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${i}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${s}
       ${Ge("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${n}(getAByOutputCoords(coords));
           let b = ${n}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pr(t){const{inputs:e}=t,{x:n}=e;return t.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const $Se={kernelName:Sc,backendName:"webgpu",kernelFunc:pr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hl(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,i=n.makeTensorInfo(s.shape,"complex64"),o=n.tensorMap.get(i.dataId),a=pr({inputs:{x:s},backend:n}),l=pr({inputs:{x:r},backend:n});return o.complexTensorInfos={real:a,imag:l},i}const RSe={kernelName:u0,backendName:"webgpu",kernelFunc:Hl};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hh{constructor(e,n,s=""){this.variableNames=["A"],this.size=!0;const r=128;this.workgroupSize=[r,1,1],this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=n,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${n}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Ga(this.op,!1)}
      }
      ${Ge("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bt({opType:t,cpuKernelImpl:e,dtype:n}){return({inputs:s,backend:r})=>{const{x:i}=s,o=r,a=n||i.dtype;if(o.shouldExecuteOnCPU([i])&&e!=null){const u=o.tensorMap.get(i.dataId),c=e(u.values,a);return o.makeTensorInfo(i.shape,a,c)}const l=new hh(i.shape,t);return o.runWebGPUProgram(l,[i],a)}}function fs({opType:t,cpuKernelImpl:e,supportsComplex:n=!1,dtype:s}){return({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;if(n&&o.dtype==="complex64"){const h=l.tensorMap.get(o.dataId),d=l.tensorMap.get(a.dataId);let f,p;if(t!==xt.MUL)[f,p]=[[h.complexTensorInfos.real,d.complexTensorInfos.real],[h.complexTensorInfos.imag,d.complexTensorInfos.imag]].map(m=>{const[x,b]=m,v={dataId:x.dataId,dtype:x.dtype,shape:o.shape},y={dataId:b.dataId,dtype:b.dtype,shape:a.shape},C=new wg(t,o.shape,a.shape);return l.runWebGPUProgram(C,[v,y],hs(x.dtype,b.dtype))});else{const m=new Q3(xt.COMPLEX_MULTIPLY_REAL,o.shape,a.shape),x=new Q3(xt.COMPLEX_MULTIPLY_IMAG,o.shape,a.shape),b=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:o.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:a.shape},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:a.shape}];f=l.runWebGPUProgram(m,b,"float32"),p=l.runWebGPUProgram(x,b,"float32")}const g=Hl({inputs:{real:f,imag:p},backend:l});return l.disposeData(f.dataId),l.disposeData(p.dataId),g}const u=s||hs(o.dtype,a.dtype);if((o.dtype==="string"||a.dtype==="string"||l.shouldExecuteOnCPU([o,a]))&&e!=null){const h=l.tensorMap.get(o.dataId).values,d=l.tensorMap.get(a.dataId).values,f=o.dtype==="string"?ci(h):h,p=o.dtype==="string"?ci(d):d,[g,m]=e(o.shape,a.shape,f,p,u);return l.makeTensorInfo(m,u,g)}const c=new wg(t,o.shape,a.shape);return l.runWebGPUProgram(c,[o,a],u)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:ASe,castImpl:PSe,ceilImpl:DSe,concatImpl:NSe,equalImpl:MSe,expImpl:LSe,expm1Impl:OSe,floorImpl:FSe,floorDivImpl:USe,gatherNdImpl:BSe,gatherV2Impl:zSe,greaterEqualImpl:GSe,greaterImpl:VSe,lessEqualImpl:WSe,lessImpl:HSe,logImpl:KSe,maxImpl:jSe,maximumImpl:XSe,minimumImpl:qSe,multiplyImpl:YSe,negImpl:ZSe,notEqualImpl:QSe,prodImpl:JSe,rangeImpl:eCe,rsqrtImpl:tCe,scatterImpl:nCe,simpleAbsImpl:sCe,sliceImpl:rCe,stridedSliceImpl:iCe,stringNGramsImpl:oCe,subImpl:aCe,tileImpl:lCe,topKImpl:uCe,transposeImpl:cCe}=ZP;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hCe=Bt({opType:Oe.ABS,cpuKernelImpl:sCe}),dCe={kernelName:qd,backendName:"webgpu",kernelFunc:hCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fCe=Bt({opType:Oe.ACOS}),pCe={kernelName:nc,backendName:"webgpu",kernelFunc:fCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mCe=Bt({opType:Oe.ACOSH}),gCe={kernelName:sc,backendName:"webgpu",kernelFunc:mCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xCe=fs({opType:xt.ADD,cpuKernelImpl:ASe,supportsComplex:!0}),bCe={kernelName:$l,backendName:"webgpu",kernelFunc:xCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yCe{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((n,s)=>`T${s}`),this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(r=>{e.push(`let v${r} = get${r}ByOutputCoords(coords);`)});const n=this.variableNames.map(r=>`v${r}`).join(" + ");return`
      ${Ge("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${n});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vCe(t){const{inputs:e,backend:n}=t,s=e;if(s.length===1)return pr({inputs:{x:s[0]},backend:n});const r=s.map(a=>a.dtype).reduce((a,l)=>hs(a,l)),i=s.map(a=>a.shape),o=new yCe(i);return n.runWebGPUProgram(o,s,r)}const wCe={kernelName:s0,backendName:"webgpu",kernelFunc:vCe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SCe{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[n[r]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){G(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${Ge()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CCe{constructor(e,n){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[n[r]];this.outputShape=s,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=n,this.shaderKey=`transpose_${n}`}getUserCode(){const e=Fn(this.outputShape.length),n=hN(this.newDim);return`
      ${Ge("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${n}), uniforms.aShape)]);
          }
        }
      }
    `}}function hN(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=new Array(e);for(let s=0;s<t.length;s++)n[t[s]]=`coords.${So(s)}`;return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yi(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{perm:i}=s,o=n,a=r.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=r.shape[i[c]];if(n.shouldExecuteOnCPU([r])){const h=o.tensorMap.get(r.dataId).values,d=cCe(h,r.shape,r.dtype,i,l);return n.makeTensorInfo(l,r.dtype,d)}if(r.shape.length===2&&Pt(i,[1,0])){const c=new SCe(r.shape,i);return o.runWebGPUProgram(c,[r],r.dtype)}const u=new CCe(r.shape,i);return o.runWebGPUProgram(u,[r],r.dtype)}const TCe={kernelName:rl,backendName:"webgpu",kernelFunc:Yi};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ICe{constructor(e,n,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[r]=Gn(this.inputShape,[1]);this.outputShape=r.length===0?[1]:r,e.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=n,this.shaderKey=`reduce_${n}`}getUserCode(){let e="",n="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,n="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",n="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",n="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",n="0.0");const r=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Ge("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${n};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${r}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kCe={mean:"float32",all:"bool",any:"bool"};function Kl(t,e,n,s,r){const i=t.shape.length,o=[],a=wt(e,t.shape);let l=a;const u=Jt(l,i);let c=t;u!=null&&(c=Yi({inputs:{x:t},attrs:{perm:u},backend:r}),l=an(l.length,i),o.push(c)),qn(s,l,i);const[h,d]=Gn(c.shape,l);let f=h;n&&(f=zn(h,a));let p;if((s==="max"||s==="prod")&&r.shouldExecuteOnCPU([c])){const g=r.tensorMap.get(c.dataId).values;switch(s){case"max":const m=jSe(g,oe(d),f,t.dtype);p=r.makeTensorInfo(f,t.dtype,m);break;case"prod":const{outVals:x,outShape:b,outDtype:v}=JSe(c.shape,c.dtype,g,l);p=r.makeTensorInfo(b,v,x);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const g=oe(d),x=oe(c.shape)/g,b={windowSize:g,inSize:g,batchSize:x,outSize:1},v=kCe[s]||z0(t.dtype),y=[{type:"int32",data:[g]}],C=new ICe(b,s,r.device.limits.maxComputeWorkgroupSizeX),I=r.runWebGPUProgram(C,[c],v,y);o.push(I),p=it({inputs:{x:I},attrs:{shape:f},backend:r})}return o.forEach(g=>r.disposeData(g.dataId)),p}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ECe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{keepDims:i,axis:o}=s;return Kl(r,o,i,"all",n)}const _Ce={kernelName:r0,backendName:"webgpu",kernelFunc:ECe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ce(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{keepDims:i,axis:o}=s;return Kl(r,o,i,"any",n)}const RCe={kernelName:i0,backendName:"webgpu",kernelFunc:$Ce};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dN{constructor(e,n,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[n];this.op=s==="min"?"<":">";const[i,o]=Gn(e,r);this.outputShape=i.length===0?[1]:i,this.dispatchLayout=Qe(this.outputShape),oe(o)<32?(this.type="plain",this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Ve(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],n=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${So(this.inputShape.length-1)}`,s=()=>{let r="";if(this.outputShape.length===1)this.inputShape.length!==1&&(r+="outputCoords,");else for(let i=0;i<this.outputShape.length;i++)r+=`outputCoords.${So(i)},`;return r};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${Ge("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${n()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${n()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ACe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;let o=wt(i,r.shape);const a=Jt(o,r.shape.length);let l=r;const u=[];a!=null&&(l=Yi({inputs:{x:r},backend:n,attrs:{perm:a}}),u.push(l),o=an(o.length,l.shape.length)),qn("argMax",[o[0]],l.shape.length);const c=new dN(l.shape,o[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],d=n.runWebGPUProgram(c,[l],"int32",h);return u.forEach(f=>n.disposeData(f.dataId)),d}const PCe={kernelName:Yd,backendName:"webgpu",kernelFunc:ACe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DCe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;let o=wt(i,r.shape);const a=Jt(o,r.shape.length);let l=r;const u=[];a!=null&&(l=Yi({inputs:{x:r},backend:n,attrs:{perm:a}}),u.push(l),o=an(o.length,l.shape.length)),qn("argMin",[o[0]],l.shape.length);const c=new dN(l.shape,o[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],d=n.runWebGPUProgram(c,[l],"int32",h);return u.forEach(f=>n.disposeData(f.dataId)),d}const NCe={kernelName:Zd,backendName:"webgpu",kernelFunc:DCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MCe=Bt({opType:Oe.ASIN}),LCe={kernelName:rc,backendName:"webgpu",kernelFunc:MCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OCe=Bt({opType:Oe.ASINH}),FCe={kernelName:ic,backendName:"webgpu",kernelFunc:OCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UCe=Bt({opType:Oe.ATAN}),BCe={kernelName:oc,backendName:"webgpu",kernelFunc:UCe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zCe=fs({opType:xt.ATAN2}),GCe={kernelName:lc,backendName:"webgpu",kernelFunc:zCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VCe=Bt({opType:Oe.ATANH}),WCe={kernelName:ac,backendName:"webgpu",kernelFunc:VCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HCe{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ld{constructor(e,n,s=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool2D_${n}_${s}_${r}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}}class hw{constructor(e,n,s=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool3D_${n}_${s}_${r}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fN(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:i,keepDims:o}=s;return Kl(r,i,o,"max",n)}const KCe={kernelName:Cf,backendName:"webgpu",kernelFunc:fN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pN(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{keepDims:i,axis:o}=s;return Kl(r,o,i,"mean",n)}const jCe={kernelName:kf,backendName:"webgpu",kernelFunc:pN};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mN(t,e,n,s){if(e.filterWidth===1&&e.filterHeight===1&&Pt(e.inShape,e.outShape))return pr({inputs:{x:t},backend:s});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const o=t.shape.length,a=it({inputs:{x:t},backend:s,attrs:{shape:[t.shape[o-3]*t.shape[o-2],t.shape[o-1]]}});let l;n==="avg"?l=pN({inputs:{x:a},backend:s,attrs:{axis:0,keepDims:!1}}):(G(n==="max",()=>`Invalid pool type ${n}`),l=fN({inputs:{x:a},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const u=it({inputs:{x:l},backend:s,attrs:{shape:e.outShape}});return s.disposeData(a.dataId),s.disposeData(l.dataId),u}let r;const i=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?r=new HCe(e):(n==="avg"?r=new Ld(e,"avg"):(G(n==="max",()=>`Invalid pool type ${n}`),r=new Ld(e,"max")),i.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),s.runWebGPUProgram(r,[t],t.dtype,i)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XCe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=ks(r.shape,i,o,1,a,l);return mN(r,c,"avg",n)}const qCe={kernelName:Qd,backendName:"webgpu",kernelFunc:XCe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YCe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:u}=s,c=[1,1,1],h=Er(r.shape,i,o,c,a,u,l),d=new hw(h,"avg"),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return n.runWebGPUProgram(d,[r],r.dtype,f)}const ZCe={kernelName:Jd,backendName:"webgpu",kernelFunc:YCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QCe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class JCe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e3e(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=Er(o.shape,a,l,1,u,c),d=new JCe(h),f=1/(h.filterDepth*h.filterHeight*h.filterWidth),p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[f]}];return n.runWebGPUProgram(d,[r],o.dtype,p)}const t3e={kernelName:a0,backendName:"webgpu",kernelFunc:e3e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n3e(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,o=i;uN([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=ks(o.shape,a,l,1,u),h=new QCe(c),d=1/(c.filterHeight*c.filterWidth),f=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"float32",data:[d]}];return n.runWebGPUProgram(h,[r],o.dtype,f)}const s3e={kernelName:o0,backendName:"webgpu",kernelFunc:n3e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r3e(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;return Bx({a:r,b:i,transposeA:o,transposeB:a,backend:n})}const i3e={kernelName:ef,backendName:"webgpu",kernelFunc:r3e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o3e{constructor(e,n){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.rank=n.length,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Fn(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Fn(this.rank),n=a3e(this.rank);let s;return this.start.length===1?s=this.outputShape.map((i,o)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((i,o)=>`sourceLoc.${fy[o]} = uniforms.start.${So(o)} + coords.${fy[o]};`),`
      ${Ge("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${n}));
        }
      }
    `}}const fy=["x","y","z","w","u","v"];function a3e(t){if(t===1)return"sourceLoc";if(t<=6)return fy.slice(0,t).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dh(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,size:o}=s,[a,l]=ep(r,i,o);if(J0(r,a,l),n.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=n.tensorMap.get(r.dataId),d=rCe(h.values,a,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,d)}if(oe(l)===0)return n.makeTensorInfo(l,r.dtype,[]);const u=new o3e(a,l),c=[{type:"int32",data:a}];return n.runWebGPUProgram(u,[r],r.dtype,c)}const l3e={kernelName:Gf,backendName:"webgpu",kernelFunc:dh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u3e=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,crops:o}=s;G(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=i.reduce((b,v)=>b*v),l=Ml(r.shape,i,a),u=Ll(l.length,i.length),c=Ol(r.shape,i,a),h=ix(o,i.length),d=ox(c,o,i.length),f=[],p=it({inputs:{x:r},backend:n,attrs:{shape:l}}),g=Yi({inputs:{x:p},backend:n,attrs:{perm:u}}),m=it({inputs:{x:g},backend:n,attrs:{shape:c}}),x=dh({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return f.push(p),f.push(g),f.push(m),f.forEach(b=>n.disposeData(b.dataId)),x},c3e={kernelName:tf,backendName:"webgpu",kernelFunc:u3e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h3e=`
  fn bincount_write(index: i32, value: f32) {
    ${Ca("&result[index]","value","float32")}
  }
`,d3e=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class gN{constructor(e,n,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=n,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?d3e:h3e}
  ${Ge("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f3e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:o}=s,a=oe(r.shape),u=oe(i.shape)>0,c=[o],h=i.dtype,d=Qs({backend:n,attrs:{shape:c,value:0,dtype:h}}),f=new gN([a],u),p=[{type:"int32",data:[o]}],g=u?[r,i]:[r];return n.runWebGPUProgram(f,g,h,p,d)}const p3e={kernelName:l0,backendName:"webgpu",kernelFunc:f3e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m3e{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${Ge("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g3e(t){const{inputs:e,backend:n}=t,{s0:s,s1:r}=e;if(n.shouldExecuteOnCPU([s,r])){const c=n.tensorMap.get(s.dataId),h=n.tensorMap.get(r.dataId),d=c.values,f=h.values,p=pt(Array.from(d),Array.from(f));return n.makeTensorInfo([p.length],"int32",Int32Array.from(p))}const i=oe(s.shape),o=oe(r.shape),a=Math.max(i,o),l=new m3e(a),u=[{type:"int32",data:[i]},{type:"int32",data:[o]}];return n.runWebGPUProgram(l,[s,r],"int32",u)}const x3e={kernelName:gv,backendName:"webgpu",kernelFunc:g3e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xN=fs({opType:xt.NOT_EQUAL,dtype:"bool",cpuKernelImpl:QSe}),b3e={kernelName:Rf,backendName:"webgpu",kernelFunc:xN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xp(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.tensorMap.get(s.dataId);return pr({inputs:{x:r.complexTensorInfos.real},backend:n})}const y3e={kernelName:P0,backendName:"webgpu",kernelFunc:xp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v3e(t,e){const n=new hh(t.shape,Oe.TO_INT),s=e.runWebGPUProgram(n,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function py(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return pr({inputs:{x:r},backend:n});const o=Jn(r.shape),a=py({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),l=Hl({inputs:{real:a,imag:o},backend:n});return o.dispose(),n.disposeData(a.dataId),l}if(r.dtype==="complex64"){const o=xp({inputs:{input:r},backend:n}),a=py({inputs:{x:o},backend:n,attrs:{dtype:i}});return n.disposeData(o.dataId),a}if(!hv(r.dtype,i)){const o=pr({inputs:{x:r},backend:n});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(n.shouldExecuteOnCPU([r])){const o=n.tensorMap.get(r.dataId).values,[a,l,u]=PSe(o,r.shape,r.dtype,i);return n.makeTensorInfo(a,l,u)}if(i==="int32")return v3e(r,n);if(i==="bool"){const o=n.makeTensorInfo([],"bool",cs("bool",1)),l=xN({inputs:{a:r,b:o},backend:n});return n.disposeData(o.dataId),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const w3e={kernelName:uc,backendName:"webgpu",kernelFunc:py};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S3e=Bt({opType:Oe.CEIL,cpuKernelImpl:DSe}),C3e={kernelName:cc,backendName:"webgpu",kernelFunc:S3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T3e{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Ge("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I3e{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Ge("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k3e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{clipValueMin:i,clipValueMax:o}=s;let a;const l=[{type:"float32",data:[i]},{type:"float32",data:[o]}];return oe(r.shape)%4===0?a=new T3e(r.shape):a=new I3e(r.shape),n.runWebGPUProgram(a,[r],r.dtype,l)}const E3e={kernelName:hc,backendName:"webgpu",kernelFunc:k3e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _3e{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${Ge("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J3(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function $3e(t){const{inputs:e,backend:n}=t,{x:s}=e,r=n.tensorMap.get(s.dataId),i=new _3e(s.shape),o=[J3(s,r.complexTensorInfos.real),J3(s,r.complexTensorInfos.imag)];return n.runWebGPUProgram(i,o,o[0].dtype)}const R3e={kernelName:nf,backendName:"webgpu",kernelFunc:$3e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A3e{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=Zs(e,1),this.variableNames=e.map((n,s)=>`T${s}`),this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let n=0;n<this.offsetLength;n++)this.uniforms+=`offset${n} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let i=1;i<this.offsetLength;i++)e.push(`else if (yC < uniforms.offset${[i]}){ setOutputAtCoords(coords.x, coords.y, getT${i}(yR, yC - uniforms.offset${i-1})); }`);const s=this.offsetLength,r=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${r})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${Ge("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zx(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.tensorMap.get(s.dataId);return pr({inputs:{x:r.complexTensorInfos.imag},backend:n})}const P3e={kernelName:I0,backendName:"webgpu",kernelFunc:zx};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bh(t,e,n){const s=t[0].dtype;if(s==="complex64"){const p=t.map(v=>xp({inputs:{input:v},backend:n})),g=t.map(v=>zx({inputs:{input:v},backend:n})),m=Bh(p,e,n),x=Bh(g,e,n),b=Hl({inputs:{real:m,imag:x},backend:n});return p.forEach(v=>n.disposeData(v.dataId)),g.forEach(v=>n.disposeData(v.dataId)),n.disposeData(m.dataId),n.disposeData(x.dataId),b}let r=n.shouldExecuteOnCPU(t);if(s==="string"&&(r=!0),r){const p=t.map(C=>{const $=[-1,oe(C.shape.slice(e))];return it({inputs:{x:C},backend:n,attrs:{shape:$}})}),g=p.map(C=>({vals:n.readSync(C.dataId),shape:C.shape})),m=Zs(p.map(C=>C.shape),1),x=p[0].shape[0]===1,b=NSe(g,m,s,x),v=Zs(t.map(C=>C.shape),e),y=n.makeTensorInfo(v,s,b);return p.forEach(C=>n.disposeData(C.dataId)),y}const i=n.device.limits.maxStorageBuffersPerShaderStage-1;if(t.length>i){const p=[];for(let m=0;m<t.length;m+=i){const x=t.slice(m,m+i);p.push(Bh(x,e,n))}const g=Bh(p,e,n);for(const m of p)n.disposeData(m.dataId);return g}const{tensors2D:o,outShape:a}=D3e(t,e,n),l=o.map(p=>p.shape),u=new A3e(l),c=[],h=new Array(l.length-1);if(h.length>0){h[0]=l[0][1],c.push({type:"int32",data:[h[0]]});for(let p=1;p<h.length;p++)h[p]=h[p-1]+l[p][1],c.push({type:"int32",data:[h[p]]})}const d=n.runWebGPUProgram(u,o,o[0].dtype,c);o.forEach(p=>n.disposeData(p.dataId));const f=it({inputs:{x:d},backend:n,attrs:{shape:a}});return n.disposeData(d.dataId),f}function D3e(t,e,n){const s=Zs(t.map(i=>i.shape),e);return{tensors2D:t.map(i=>it({inputs:{x:i},backend:n,attrs:{shape:[oe(i.shape.slice(0,e)),oe(i.shape.slice(e))]}})),outShape:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bN(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,i=wt(r,e[0].shape)[0],o=e.map(u=>u.shape);nx(o,i);const a=Zs(e.map(u=>u.shape),i);if(oe(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(u=>oe(u.shape)>0);return l.length===1?pr({inputs:{x:l[0]},backend:n}):Bh(l,i,n)}const N3e={kernelName:sf,backendName:"webgpu",kernelFunc:bN};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M3e(t,e,n,s,r=!1,i=null,o=!1,a=4,l=4,u=4){const c=S=>{switch(S){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${S} is not supported.`)}},h=S=>{switch(S){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${S} is not supported.`)}},d=t?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,f=t?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,p=t?"uniforms.xShape[1]":"uniforms.xShape[2]",g=t?"uniforms.xShape[2]":"uniforms.xShape[3]",m=t?"row":"col",x=t?"col":"row",b=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${m} / outWidth;
      let outCol = ${m} % outWidth;

      let WRow = ${x} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${x} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${x} % inChannels;
      var resData = ${kt(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${g}) {
        ${d}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${c(a)}
      }
      return resData;`,v=t?e&&s?`
      ${b}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${b}
      }
      return ${kt(a)}(0.0);`:s&&n?`
      ${b}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${b}
      }
      return ${kt(a)}(0.0);`,y=`${h(l)}`,C=kt(u),I=kt(t?a:l),$=kt(t?l:a);return`
      ${Do(i,o,u===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${I} {
        ${t?v:y}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${$} {
        ${t?y:v}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${C}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${f}
        ${Wl(r,i)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class L3e{constructor(e,n,s,r,i=!1,o=null,a=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=oN(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=aN(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),i&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=i,this.activation=o,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=n%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=r%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?Fx(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):Ux(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),n=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${M3e(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,n[0],n[1],n[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O3e{constructor(e,n=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n,this.activation=s,this.hasPreluActivationWeights=r,n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${Do(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Wl(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${Ge("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F3e{constructor(e,n){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=n,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${Ge("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${r};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${n}] && xCol >= 0) {
            value = ${i};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sg(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function U3e({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.dataFormat==="channelsLast",u=!l,c=!1,h=l&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",d=[];let f,p;if(h){const x=n.inHeight*n.inWidth*n.inChannels;f=it({inputs:{x:t},backend:s,attrs:{shape:[1,n.batchSize,x]}}),p=it({inputs:{x:e},backend:s,attrs:{shape:[1,x,n.outChannels]}})}else f=it({inputs:{x:t},backend:s,attrs:{shape:l?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),p=it({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(d.push(f),d.push(p),i!=null){const x=Sg(i.shape,l);x!=null&&(i=it({inputs:{x:i},backend:s,attrs:{shape:x}}),d.push(i))}if(r!=null){const x=Sg(r.shape,l);x!=null&&(r=it({inputs:{x:r},backend:s,attrs:{shape:x}}),d.push(r))}const g=Bx({a:l?f:p,b:l?p:f,transposeA:u,transposeB:c,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),m=it({inputs:{x:g},backend:s,attrs:{shape:n.outShape}});d.push(g);for(const x of d)s.disposeData(x.dataId);return m}function B3e({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,strideWidth:h,strideHeight:d,padInfo:f,outWidth:p,outHeight:g,dilationWidth:m,dilationHeight:x,dataFormat:b}=n,v=b==="channelsLast",y=l*u*c,C=g*p,I=v?[n.batchSize,C,y]:[n.batchSize,y,C],$=new F3e(I,v),T=[{type:"int32",data:[f.top,f.left]},{type:"int32",data:[d,h]},{type:"int32",data:[x,m]},{type:"int32",data:[p]},{type:"int32",data:[c*l]},{type:"int32",data:[c]}],S=s.runWebGPUProgram($,[t],t.dtype,T),E=[];E.push(S);const _=it({inputs:{x:e},backend:s,attrs:{shape:[1,y,-1]}});if(E.push(_),i!=null){const A=Sg(i.shape,v);A!=null&&(i=it({inputs:{x:i},backend:s,attrs:{shape:A}}),E.push(i))}if(r!=null){const A=Sg(r.shape,v);A!=null&&(r=it({inputs:{x:r},backend:s,attrs:{shape:A}}),E.push(r))}const M=Bx({a:v?S:_,b:v?_:S,transposeA:!v,transposeB:!1,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),z=it({inputs:{x:M},backend:s,attrs:{shape:n.outShape}});E.push(M);for(const A of E)s.disposeData(A.dataId);return z}function yN({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=r!=null,u=i!=null,c=n.dataFormat==="channelsLast",h=c&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",d=ue().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!d&&(h||n.filterHeight===1&&n.filterWidth===1&&n.dilationHeight===1&&n.dilationWidth===1&&n.strideHeight===1&&n.strideWidth===1&&(n.padInfo.type==="SAME"||n.padInfo.type==="VALID")))return U3e({x:t,filter:e,convInfo:n,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o});const f=ue().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),p=f>-1?f:s.thresholdToIncreaseWorkgroups,g=n.batchSize*Math.ceil(n.outHeight*n.outWidth/32)*Math.ceil(n.outChannels/32);if(ue().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=p)return B3e({x:t,filter:e,convInfo:n,backend:s,bias:r,preluActivationWeights:i,leakyreluAlpha:o,activation:a});let m;const x=[n.padInfo.top,n.padInfo.left],b=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...x]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]}];if(d)m=new O3e(n,l,a,u);else{const I=c?n.outHeight*n.outWidth:n.outChannels,$=c?n.outChannels:n.outHeight*n.outWidth,T=n.filterHeight*n.filterWidth*n.inChannels;b.push({type:"int32",data:[I]},{type:"int32",data:[$]},{type:"int32",data:[T]});const S=s.adapterInfo.isIntel();m=new L3e(n,I,$,T,l,a,u,S)}const v=[],y=[t,e];l&&(!c&&r.shape.length===1&&(r=it({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),v.push(r)),y.push(r)),u&&(!c&&i.shape.length===1&&(i=it({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),v.push(i)),y.push(i)),a==="leakyrelu"&&(b.push({type:"float32",data:[o]}),m.uniforms+=" alpha : f32,");const C=s.runWebGPUProgram(m,y,t.dtype,b);for(const I of v)s.disposeData(I.dataId);return C}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z3e(t){const{inputs:e,attrs:n,backend:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=n,h=gr(l),d=gn(r.shape,i.shape,o,u,a,c,!1,h);return yN({x:r,filter:i,convInfo:d,backend:s})}const G3e={kernelName:rf,backendName:"webgpu",kernelFunc:z3e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V3e{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,r=`
    ${Ge()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${r}
    `:`
    ${Ge("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${n}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class W3e{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${Ge("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class H3e{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${Ge("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class K3e{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${Ge("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j3e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,h=gr(l),d=gn(r.shape,c,o,1,a,u,!1,h),f=new W3e(d),p=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return n.runWebGPUProgram(f,[r,i],r.dtype,p)}const X3e={kernelName:c0,backendName:"webgpu",kernelFunc:j3e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q3e(t=4){const e=i=>{switch(i){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${i} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${kt(t)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${kt(t)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${t}];`}
      }
      return ${kt(t)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${kt(t)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${kt(t)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(t)}
    }
    return ${kt(t)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${kt(t)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${t}] = value;
    }
  }`}class Y3e{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,G(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=oN(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=aN(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?Fx(this.elementsPerThread,this.workgroupSize):Ux(this.elementsPerThread,this.workgroupSize);return`
    ${q3e(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3e(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s,h=gr(u),d=gn(o,i.shape,a,1,l,c,!1,h),f=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize,d.outHeight,d.outWidth,d.outChannels]}];let p;if(ue().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||d.dataFormat!=="channelsLast")p=new V3e(d);else{p=new Y3e(d);const g=d.inHeight*d.inWidth,m=d.inChannels,x=d.filterHeight*d.filterWidth*d.outChannels;f.push({type:"uint32",data:[g]},{type:"uint32",data:[m]},{type:"uint32",data:[x]})}return n.runWebGPUProgram(p,[r,i],"float32",f)}const Q3e={kernelName:of,backendName:"webgpu",kernelFunc:Z3e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class J3e{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eTe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s,u=gi(r.shape,i.shape,o,l,a),c=[u.padInfo.front,u.padInfo.top,u.padInfo.left],h=[{type:"int32",data:[u.filterDepth,u.filterHeight,u.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationDepth,u.dilationHeight,u.dilationWidth]}],d=new J3e(u),f=hs(r.dtype,i.dtype);return n.runWebGPUProgram(d,[r,i],f,h)}const tTe={kernelName:af,backendName:"webgpu",kernelFunc:eTe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nTe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:l}=s,u=gi(r.shape,l,o,1,a),c=new H3e(u),h=[{type:"int32",data:[u.padInfo.front,u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.batchSize]},{type:"int32",data:[u.outDepth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"int32",data:[u.inDepth]},{type:"int32",data:[u.inHeight]},{type:"int32",data:[u.inWidth]}];return n.runWebGPUProgram(c,[r,i],i.dtype,h)}const sTe={kernelName:h0,backendName:"webgpu",kernelFunc:nTe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rTe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{strides:o,pad:a,inputShape:l}=s,u=gi(l,i.shape,o,1,a),c=new K3e(u),h=[{type:"int32",data:[u.filterDepth,u.filterHeight,u.filterWidth]},{type:"int32",data:[u.filterDepth-1-u.padInfo.front,u.filterHeight-1-u.padInfo.top,u.filterWidth-1-u.padInfo.left]},{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.outDepth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"int32",data:[u.outChannels]}];return n.runWebGPUProgram(c,[r,i],r.dtype,h)}const iTe={kernelName:d0,backendName:"webgpu",kernelFunc:rTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oTe=Bt({opType:Oe.COS}),aTe={kernelName:dc,backendName:"webgpu",kernelFunc:oTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lTe=Bt({opType:Oe.COSH}),uTe={kernelName:fc,backendName:"webgpu",kernelFunc:lTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cTe{constructor(e,n,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=n;this.outputShape=[i,s[0],s[1],e],this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=r==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,n]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,r,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[o,a,l]=this.cropWidthBiggerThan1?[`(${n} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${n} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${n}`];return`
    ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${o});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${r};
        let width_scale = ${a};
        let in_y = ${i};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${n} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hTe=t=>{const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=s,c=new cTe(r.shape[3],i.shape,a,l),h=[{type:"float32",data:[u]}];return n.runWebGPUProgram(c,[r,i,o],"float32",h)},dTe={kernelName:p0,backendName:"webgpu",kernelFunc:hTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Od;(function(t){t.Prod="*",t.Sum="+"})(Od||(Od={}));class eT{constructor(e,n,s,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=n,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,n=this.op===Od.Prod?"1.0":"0.0",s=this.exclusive?n:`getX(${tT(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let i="",o="";return this.exclusive?(i=this.reverse?`end != ${r-1}`:"end != 0",o=this.reverse?"end + 1":"end - 1"):(i=this.reverse?`end + pow2 < ${r}`:"end >= pow2",o=this.reverse?"end + pow2":"end - pow2"),`
      ${Ge("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${nT(e,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${i}) {
           let idx = ${o};
           ${nT(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${tT(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function tT(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function nT(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vN(t,e,n,s,r,i){const o=e.shape.length,a=Jt([s],o);let l=e;a!=null&&(l=Yi({inputs:{x:e},backend:n,attrs:{perm:a}}));const u=an(1,o)[0];if(u!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const c=l.shape[u];let h=pr({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const f=new eT(t,l.shape,!1,i),p=h,g=[{type:"float32",data:[d]}];h=n.runWebGPUProgram(f,[h],h.dtype,g),n.disposeData(p.dataId)}if(r){const d=new eT(t,l.shape,r,i),f=h,p=[{type:"float32",data:[0]}];h=n.runWebGPUProgram(d,[h],h.dtype,p),n.disposeData(f.dataId)}if(a!=null){const d=Qi(a),f=Yi({inputs:{x:h},backend:n,attrs:{perm:d}});return n.disposeData(h.dataId),n.disposeData(l.dataId),f}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fTe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;return vN(Od.Prod,r,n,i,o,a)}const pTe={kernelName:f0,backendName:"webgpu",kernelFunc:fTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mTe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;return vN(Od.Sum,r,n,i,o,a)}const gTe={kernelName:lf,backendName:"webgpu",kernelFunc:mTe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xTe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s,l=r.shape.length===1,c=oe(i.shape)>0,h=i.dtype,d=l?[r.shape[0]]:[r.shape[0],r.shape[1]],f=l?[o]:[r.shape[0],o],p=Qs({backend:n,attrs:{shape:f,value:0,dtype:h}}),g=new gN(d,c,a),m=[{type:"int32",data:[o]}],x=c?[r,i]:[r];return n.runWebGPUProgram(g,x,h,m,p)}const bTe={kernelName:m0,backendName:"webgpu",kernelFunc:xTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yTe{constructor(e,n){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${n}`,this.dataFormat=n}getUserCode(){return`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vTe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:i,dataFormat:o}=s,a=r.shape[0],l=o==="NHWC"?r.shape[1]:r.shape[2],u=o==="NHWC"?r.shape[2]:r.shape[3],c=o==="NHWC"?r.shape[3]:r.shape[1],h=l*i,d=u*i,f=c/(i*i),p=o==="NHWC"?[a,h,d,f]:[a,f,h,d],g=[{type:"int32",data:[i]}],m=new yTe(p,o);return n.runWebGPUProgram(m,[r],r.dtype,g)}const wTe={kernelName:g0,backendName:"webgpu",kernelFunc:vTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class STe{constructor(e,n,s,r=!1,i=null,o=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=i,this.hasPreluActivation=o,this.filterHeight=n,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,n=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`
      ${Do(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Ge()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<n?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${n})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Wl(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wN{constructor(e,n=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const i=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=Qe(i),this.dispatch=Ve(this.dispatchLayout,i,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),G(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,n=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${Do(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${Ge("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${n}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Wl(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SN{constructor(e,n=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${Do(this.activation,this.hasPreluActivation,!1,4)}

      ${Ge("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Wl(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CTe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s,h=gr(l);let d=u;d==null&&(d=[1,1]);const f=gn(r.shape,i.shape,o,d,a,c,!0,h),p=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],g=f.dataFormat==="channelsLast";let m;return!g&&f.inHeight>16&&f.inWidth>16&&f.strideHeight===1&&f.strideWidth===1&&f.dilationWidth===1&&f.dilationHeight===1&&f.inChannels===f.outChannels?m=new STe(f.outShape,f.filterHeight,f.filterWidth):g&&f.outHeight>4&&f.outWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&f.dilationHeight===1&&f.dilationWidth===1&&f.inChannels%4===0?(m=new wN(f),p.push({type:"int32",data:[m.virtualWidth]})):(m=new SN(f),p.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),n.runWebGPUProgram(m,[r,i],r.dtype,p)}const TTe={kernelName:uf,backendName:"webgpu",kernelFunc:CTe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ITe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class kTe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ETe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s,h=gn(r.shape,c,o,a,l,u,!0),d=new ITe(h),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(d,[r,i],"float32",f)}const _Te={kernelName:x0,backendName:"webgpu",kernelFunc:ETe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Te(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s,h=gn(c,i.shape,o,a,l,u,!0),d=new kTe(h),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(d,[r,i],r.dtype,f)}const RTe={kernelName:b0,backendName:"webgpu",kernelFunc:$Te};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ATe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PTe(t){const{inputs:e,backend:n}=t,{x:s}=e,r=[...s.shape,...s.shape],i=oe(s.shape),o=it({inputs:{x:s},backend:n,attrs:{shape:[i]}}),a=new ATe(i),l=n.runWebGPUProgram(a,[o],o.dtype),u=it({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeData(o.dataId),n.disposeData(l.dataId),u}const DTe={kernelName:xv,backendName:"webgpu",kernelFunc:PTe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NTe{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${Ge("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MTe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s,u=ga(r.shape,i.shape,o,a,"NHWC",l),c=[u.padInfo.top,u.padInfo.left],h=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]}],d=new NTe(u);return n.runWebGPUProgram(d,[r,i],r.dtype,h)}const LTe={kernelName:cf,backendName:"webgpu",kernelFunc:MTe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OTe{constructor(e,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=Qe(e.outShape),this.dispatch=Ve(this.dispatchLayout,e.outShape,this.workgroupSize),n!=="float32"&&n!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${Ge("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Ca("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class FTe{constructor(e,n,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=Qe(e.outShape),this.dispatch=Ve(this.dispatchLayout,e.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${Ge("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Ca("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UTe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,dy:o}=e,{strides:a,pad:l,dilations:u}=s,c=ga(r.shape,i.shape,a,l,"NHWC",u),h=i.dtype,d=new FTe(c,i.shape,h),f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[oe(c.outShape)]}],p=Qs({backend:n,attrs:{shape:i.shape,value:0,dtype:h}});return n.runWebGPUProgram(d,[r,i,o],h,f,p)}const BTe={kernelName:Xm,backendName:"webgpu",kernelFunc:UTe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zTe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,dy:o}=e,{strides:a,pad:l,dilations:u}=s,c=ga(r.shape,i.shape,a,l,"NHWC",u),h=r.dtype,d=new OTe(c,h),f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[oe(c.outShape)]}],p=Qs({backend:n,attrs:{shape:c.inShape,value:0,dtype:h}});return n.runWebGPUProgram(d,[r,i,o],h,f,p)}const GTe={kernelName:jm,backendName:"webgpu",kernelFunc:zTe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VTe{constructor(e,n,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=qu.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=n,this.textureFormat=s,this.shaderKey=`draw_${n}_${s}`}getUserCode(){let e;const n=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${n};
        rgba[1] = ${n};
        rgba[2] = ${n};
      } else {
        rgba[d] = ${n};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${Ge("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WTe(t){const{inputs:e,backend:n,attrs:s}=t,{image:r}=e,{canvas:i,options:o}=s,[a,l]=r.shape.slice(0,2),{imageOptions:u}=o||{},c=(u==null?void 0:u.alpha)||1,h=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",d=[a,l],f=new VTe(d,r.dtype,h);i.width=l,i.height=a;const p="webgpu";let g=i.getContext(p),m;g||(m=new OffscreenCanvas(l,a),g=m.getContext(p));const x=r.shape.length===3?r.shape[2]:1;g.configure({device:n.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const b="int32",v=n.makeTensorInfo(d,b),y=n.tensorMap.get(v.dataId);y.resource=g.getCurrentTexture(),y.external=!0;const C=[{type:"uint32",data:[x]},{type:"float32",data:[c]}];if(n.runWebGPUProgram(f,[r],b,C,v),m){const I=i.getContext("2d");if(!I)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");I.drawImage(m,0,0)}return n.disposeData(v.dataId),r}const HTe={kernelName:UE,backendName:"webgpu",kernelFunc:WTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CN=fs({opType:xt.MUL,cpuKernelImpl:YSe,supportsComplex:!0}),KTe={kernelName:Ac,backendName:"webgpu",kernelFunc:CN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TN(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;return Kl(r,i,o,"sum",n)}const jTe={kernelName:Vf,backendName:"webgpu",kernelFunc:TN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XTe(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:l}=fx(r,i.length);mx(o.length,l,i);const{path:u,steps:c}=gx(a,l),h=c.length;let d=null,f=o.length;const p=[];for(let g=0;g<h;++g){for(const m of c[g]){const{permutationIndices:x,expandDims:b}=px(f,l[m]);let v;xx(x)?v=i[m]:(v=Yi({inputs:{x:i[m]},backend:n,attrs:{perm:x}}),p.push(v));const y=v.shape.slice();for(let C=0;C<b.length;++C)y.splice(b[C],0,1);Pt(v.shape,y)||(v=it({inputs:{x:v},backend:n,attrs:{shape:y}}),p.push(v)),d===null?d=v:(d=CN({inputs:{a:v,b:d},backend:n}),p.push(d))}g<h-1&&(u[g]>=0&&(d=TN({inputs:{x:d},backend:n,attrs:{axis:u[g]-(o.length-f),keepDims:!1}}),p.push(d)),f--)}for(const g of p)g!==d&&n.disposeData(g.dataId);return d}const qTe={kernelName:y0,backendName:"webgpu",kernelFunc:XTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YTe=Bt({opType:Oe.ELU}),ZTe={kernelName:mc,backendName:"webgpu",kernelFunc:YTe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QTe=t=>{const{inputs:e,backend:n}=t,{dy:s,y:r}=e,i=new wg(xt.ELU_DER,s.shape,r.shape);return n.runWebGPUProgram(i,[s,r],s.dtype)},JTe={kernelName:v0,backendName:"webgpu",kernelFunc:QTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eIe=fs({opType:xt.EQUAL,dtype:"bool",cpuKernelImpl:MSe}),tIe={kernelName:hf,backendName:"webgpu",kernelFunc:eIe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nIe=Bt({opType:Oe.ERF}),sIe={kernelName:gc,backendName:"webgpu",kernelFunc:nIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rIe=Bt({opType:Oe.EXP,cpuKernelImpl:LSe,dtype:"float32"}),iIe={kernelName:xc,backendName:"webgpu",kernelFunc:rIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function my(t){const{inputs:e,attrs:n,backend:s}=t,{dim:r}=n,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&(G(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),it({inputs:{x:i},backend:s,attrs:{shape:a}})}const oIe={kernelName:df,backendName:"webgpu",kernelFunc:my};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aIe=Bt({opType:Oe.EXPM1,cpuKernelImpl:OSe}),lIe={kernelName:bc,backendName:"webgpu",kernelFunc:aIe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sT{constructor(e,n){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IN(t,e,n){const s=n.tensorMap.get(t.dataId),r=oe(t.shape),i=t.shape[t.shape.length-1],o=r/i,a=[],l=it({inputs:{x:t},backend:n,attrs:{shape:[o,i]}});a.push(l);const u=l.shape,c=new sT("real",u),h=new sT("imag",u),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],f=e?2*Math.PI:-2*Math.PI,p=e?u[1]:1,g=[{type:"float32",data:[f]},{type:"float32",data:[p]}],m=n.runWebGPUProgram(c,d,"float32",g);a.push(m);const x=n.runWebGPUProgram(h,d,"float32",g);a.push(x);const b=Hl({inputs:{real:m,imag:x},backend:n});a.push(b);const v=it({inputs:{x:b},backend:n,attrs:{shape:t.shape}});return a.forEach(y=>n.disposeData(y.dataId)),v}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uIe(t){const{inputs:e,backend:n}=t,{input:s}=e;return IN(s,!1,n)}const cIe={kernelName:w0,backendName:"webgpu",kernelFunc:uIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hIe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dIe={kernelName:C0,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=new hIe(n.shape);return s.runWebGPUProgram(r,[n],n.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fIe=Bt({opType:Oe.FLOOR,cpuKernelImpl:FSe}),pIe={kernelName:yc,backendName:"webgpu",kernelFunc:fIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mIe=fs({opType:xt.FLOOR_DIV,cpuKernelImpl:USe,dtype:"int32"}),gIe={kernelName:vc,backendName:"webgpu",kernelFunc:mIe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xIe{constructor(e,n,s=!1){this.pixelsOpType=qu.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,[n,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${Ge("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bIe={kernelName:jE,backendName:"webgpu",kernelFunc:yIe};let uu,Kb=ue().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function yIe(t){const{inputs:e,backend:n,attrs:s}=t;let{pixels:r}=e;const{numChannels:i}=s;if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&r instanceof OffscreenCanvas,u=typeof ImageBitmap<"u"&&r instanceof ImageBitmap,[c,h]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[h,c,i],f=ue().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&o,p=o||a;if(u||l||p){let b;if(f)b=n.device.importExternalTexture({source:r});else{if(p){const P=ue().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(uu==null||P!==Kb)&&(Kb=P,uu=document.createElement("canvas").getContext("2d",{willReadFrequently:Kb})),uu.canvas.width=c,uu.canvas.height=h,uu.drawImage(r,0,0,c,h),r=uu.canvas}const E=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,N=n.textureManager.acquireTexture(d[1],d[0],"rgba8unorm",E);n.queue.copyExternalImageToTexture({source:r},{texture:N},[d[1],d[0]]),b=N}const v=oe(d),y=lt(d),C=new xIe(d,i,f),I=[{type:"uint32",data:[v]},{type:"uint32",data:[i]},{type:"uint32",data:[...y]}],$=n.makeTensorInfo([h,c],"int32"),T=n.tensorMap.get($.dataId);T.resource=b;const S=n.runWebGPUProgram(C,[$],"int32",I);return n.disposeData($.dataId),S}const g=r.data;let m=g;if(i!=null&&i!==4){m=new Uint8Array(r.width*r.height*i);const b=g.length;let v=0;for(let y=0;y<b;y++)y%4<i&&(m[v++]=g[y])}const x=n.makeTensorInfo(d,"int32",new Int32Array(m));return n.uploadToGPU(x.dataId),x}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vIe{constructor(e,n,s,r,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],pt(e,n),pt(e,s),this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),r!=null&&(pt(e,r),this.variableNames.push("offset")),i!=null&&(pt(e,i),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let n="1.0";return this.scaleShape!=null&&(n="getScaleByOutputIndex(index)"),`
      ${Ge("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${n};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wIe={kernelName:ff,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s,scale:r,offset:i,mean:o,variance:a}=t,{varianceEpsilon:l}=e,u=n,c=[s,o,a];let h=null;i!=null&&(h=i.shape,c.push(i));let d=null;r!=null&&(d=r.shape,c.push(r));const f=new vIe(s.shape,o.shape,a.shape,h,d),p=[{type:"float32",data:[l]}];return u.runWebGPUProgram(f,c,s.dtype,p)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SIe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:p}=s,g=gr(c),m=gn(r.shape,i.shape,l,h,u,d,!1,g);return yN({x:r,filter:i,convInfo:m,backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:p,activation:f})}const CIe={kernelName:Sd,backendName:"webgpu",kernelFunc:SIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TIe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:f}=s;let p=c;p==null&&(p=[1,1]),G(ds(l,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${p}'`);const g=gn(r.shape,i.shape,l,p,u,h,!0),m=[r,i],x=o!=null,b=a!=null;x&&m.push(o),b&&m.push(a);const v=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];let y;return g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&g.dilationHeight===1&&g.dilationWidth===1&&g.inChannels%4===0?(y=new wN(g,x,d,b),v.push({type:"int32",data:[y.virtualWidth]})):(y=new SN(g,x,d,b),v.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),d==="leakyrelu"&&(v.push({type:"float32",data:[f]}),y.uniforms+=" alpha : f32,"),n.runWebGPUProgram(y,m,"float32",v)}const IIe={kernelName:Pv,backendName:"webgpu",kernelFunc:TIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kIe{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Fn(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EIe(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,i=r.shape,o=i[i.length-1],a=oe(s.shape),[l,u,c,h]=Q0(s,r),d=it({inputs:{x:r},backend:n,attrs:{shape:[u,o]}}),f=it({inputs:{x:s},backend:n,attrs:{shape:[oe(s.shape)/c,c]}});if(n.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const b=n.readSync(r.dataId),v=n.bufferSync(s),y=BSe(b,v,s.dtype,u,o,c,h,s.shape,a);return n.makeTensorInfo(l,s.dtype,y.values)}const p=new kIe(o,[u,c]),g=[{type:"int32",data:[o]},{type:"int32",data:h}],m=n.runWebGPUProgram(p,[f,d],f.dtype,g),x=it({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeData(d.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),x}const _Ie={kernelName:bv,backendName:"webgpu",kernelFunc:EIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Ie{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=n,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=RIe(this.aShape);return`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function RIe(t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let s=0;s<t.length;s++)s===2?n.push("indexZ"):n.push(`${e[s]}`);return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kN(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:i}=e,{axis:o,batchDims:a}=s,l=wt(o,r.shape)[0],u=yx(r,i,l,a),c=oe(i.shape),h=[],d=it({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=it({inputs:{x:i},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(f);const p=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,i])){const v=n.tensorMap.get(f.dataId).values,y=Ct(f.shape,f.dtype,v),I=n.tensorMap.get(d.dataId).values,$=Ct(d.shape,d.dtype,I),T=zSe($,y,p);return h.forEach(S=>n.disposeData(S.dataId)),n.makeTensorInfo(u.outputShape,T.dtype,T.values)}const g=new $Ie(d.shape,p),m=n.runWebGPUProgram(g,[d,f],d.dtype);h.push(m);const x=it({inputs:{x:m},backend:n,attrs:{shape:u.outputShape}});return h.forEach(b=>n.disposeData(b.dataId)),x}const AIe={kernelName:pf,backendName:"webgpu",kernelFunc:kN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PIe=fs({opType:xt.GREATER,cpuKernelImpl:VSe,dtype:"bool"}),DIe={kernelName:mf,backendName:"webgpu",kernelFunc:PIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NIe=fs({opType:xt.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:GSe}),MIe={kernelName:wc,backendName:"webgpu",kernelFunc:NIe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LIe(t){const{inputs:e,backend:n}=t,{input:s}=e;return IN(s,!0,n)}const OIe={kernelName:T0,backendName:"webgpu",kernelFunc:LIe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FIe=Bt({opType:Oe.IS_FINITE,dtype:"bool"}),UIe={kernelName:Cc,backendName:"webgpu",kernelFunc:FIe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BIe=Bt({opType:Oe.IS_INF,dtype:"bool"}),zIe={kernelName:Tc,backendName:"webgpu",kernelFunc:BIe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GIe=Bt({opType:Oe.IS_NAN,dtype:"bool"}),VIe={kernelName:Ic,backendName:"webgpu",kernelFunc:GIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WIe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:i}=s,o=[{type:"float32",data:[i]}],a=new hh(r.shape,Oe.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(a,[r],"float32",o)}const HIe={kernelName:gf,backendName:"webgpu",kernelFunc:WIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KIe=fs({opType:xt.LESS,dtype:"bool",cpuKernelImpl:HSe}),jIe={kernelName:xf,backendName:"webgpu",kernelFunc:KIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XIe=fs({opType:xt.LESS_EQUAL,dtype:"bool",cpuKernelImpl:WSe}),qIe={kernelName:bf,backendName:"webgpu",kernelFunc:XIe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YIe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${Ge("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZIe(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:i}=n,o=(r-s)/(i-1),a=new YIe(i),l=[{type:"float32",data:[s]},{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],"float32",l)}const QIe={kernelName:yv,backendName:"webgpu",kernelFunc:ZIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JIe=Bt({opType:Oe.LOG,cpuKernelImpl:KSe}),eke={kernelName:kc,backendName:"webgpu",kernelFunc:JIe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tke=Bt({opType:Oe.LOG1P}),nke={kernelName:Ec,backendName:"webgpu",kernelFunc:tke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ske=fs({opType:xt.LOGICAL_AND,dtype:"bool"}),rke={kernelName:yf,backendName:"webgpu",kernelFunc:ske};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ike=Bt({opType:Oe.LOGICAL_NOT}),oke={kernelName:vf,backendName:"webgpu",kernelFunc:ike};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ake=fs({opType:xt.LOGICAL_OR}),lke={kernelName:wf,backendName:"webgpu",kernelFunc:ake};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EN=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class uke{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${EN}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class cke{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,G(n<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${n}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Ve(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${Ge()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${EN}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hke(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=s;let u;i>16?u=new uke(r.shape):u=new cke(r.shape,i);const c=[{type:"int32",data:[i]},{type:"float32",data:[o]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return n.runWebGPUProgram(u,[r],r.dtype,c)}const dke={kernelName:Sf,backendName:"webgpu",kernelFunc:hke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fke{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pke(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=s,h=new fke(r.shape),d=[{type:"int32",data:[a]},{type:"float32",data:[l]},{type:"float32",data:[u]},{type:"float32",data:[c]}];return n.runWebGPUProgram(h,[r,i,o],r.dtype,d)}const mke={kernelName:k0,backendName:"webgpu",kernelFunc:pke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gke=fs({opType:xt.MAX,cpuKernelImpl:XSe}),xke={kernelName:_c,backendName:"webgpu",kernelFunc:gke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bke(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=ks(r.shape,i,o,1,a,l);return mN(r,c,"max",n)}const yke={kernelName:Tf,backendName:"webgpu",kernelFunc:bke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vke(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:u}=s,c=[1,1,1],h=Er(r.shape,i,o,c,a,u,l),d=new hw(h,"max"),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return n.runWebGPUProgram(d,[r],r.dtype,f)}const wke={kernelName:If,backendName:"webgpu",kernelFunc:vke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ske{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class Cke{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tke(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=[1,1,1],d=Er(o.shape,a,l,h,u,c),f=new hw(d,"max",!0);let p=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];const g=n.runWebGPUProgram(f,[o],"int32",p),m=new Cke(d);p=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const x=n.runWebGPUProgram(m,[r,g],o.dtype,p);return n.disposeData(g.dataId),x}const Ike={kernelName:_0,backendName:"webgpu",kernelFunc:Tke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kke(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i,output:o}=e,a=i;uN([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=ks(a.shape,l,u,1,c,h),f=new Ld(d,"max",!0);let p=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];const g=n.runWebGPUProgram(f,[a],"int32",p),m=new Ske(d);p=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const x=n.runWebGPUProgram(m,[r,g],a.dtype,p);return n.disposeData(g.dataId),x}const Eke={kernelName:E0,backendName:"webgpu",kernelFunc:kke};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ke(t){const{inputs:e,backend:n,attrs:s}=t,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=s,{x:l}=e;G(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const u=[1,1];G(ds(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=ks(l.shape,r,i,u,o),h=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]}];let d=new Ld(c,"max",!1);const f=n.runWebGPUProgram(d,[l],l.dtype,h);d=new Ld(c,"max",!0,!0,a);const p=n.runWebGPUProgram(d,[l],"int32",h);return[f,p]}const $ke={kernelName:vv,backendName:"webgpu",kernelFunc:_ke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rke(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;return Kl(r,i,o,"min",n)}const Ake={kernelName:Ef,backendName:"webgpu",kernelFunc:Rke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pke=fs({opType:xt.MIN,cpuKernelImpl:qSe}),Dke={kernelName:$c,backendName:"webgpu",kernelFunc:Pke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nke{constructor(e,n,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((r,i)=>r[0]+e[i]+r[1]),this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,n.map((r,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const e=this.xShape.length,n=this.xShape.map((u,c)=>`uniforms.pad${c}[0]`).join(","),s=this.xShape.map((u,c)=>`uniforms.pad${c}[0] + uniforms.xShape${e>1?`[${c}]`:""}`).join(","),r=e===1?"start":"start[i]",i=e===1?"end":"end[i]",o=e===1?"outC":"outC[i]",a=Fn(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${n});
          let end = ${a}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${o} < ${r}) {
              ${o} = ${r} * 2 - ${o} - ${this.offset};
            } else if(${o} >= ${i}) {
              ${o} = (${i} - 1) * 2 - ${o} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mke={kernelName:_f,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{paddings:r,mode:i}=e,o=n,a=r.map(c=>({type:"int32",data:[c[0],c[1]]})),l=new Nke(s.shape,r,i);return o.runWebGPUProgram(l,[s],s.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lke=fs({opType:xt.MOD}),Oke={kernelName:Rc,backendName:"webgpu",kernelFunc:Lke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fke{constructor(e,n){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Ge("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uke{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${Ge("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _N(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:i}=s,o=it({inputs:{x:r},backend:n,attrs:{shape:[oe(r.shape)/r.shape[i],r.shape[i]]}}),a=new Uke(o.shape),l=n.runWebGPUProgram(a,[o],r.dtype),u=it({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeData(o.dataId),n.disposeData(l.dataId),u}const Bke={kernelName:Kf,backendName:"webgpu",kernelFunc:_N};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zke(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s,l=a?r:_N({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new Fke(u,i),d=[{type:"float32",data:[o]},{type:"int32",data:[c]}],f=n.runWebGPUProgram(h,[l],"int32",d);return a||n.disposeData(l.dataId),f}const Gke={kernelName:wv,backendName:"webgpu",kernelFunc:zke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vke(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])){const i=n.tensorMap.get(s.dataId),[o,a]=ZSe(i.values,s.shape,s.dtype);return n.makeTensorInfo(a,s.dtype,o)}const r=new hh(s.shape,Oe.NEG);return n.runWebGPUProgram(r,[s],s.dtype)}const Wke={kernelName:$f,backendName:"webgpu",kernelFunc:Vke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hke(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,u=n.readSync(r.dataId),c=n.readSync(i.dataId),{selectedIndices:h}=Y0(u,c,o,a,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const Kke={kernelName:$0,backendName:"webgpu",kernelFunc:Hke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jke(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),d=o,f=a,p=l,g=u,{selectedIndices:m,selectedScores:x}=Z0(c,h,d,f,p,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}const Xke={kernelName:R0,backendName:"webgpu",kernelFunc:jke};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qke{constructor(e,n){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${Ge("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yke(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{dtype:i,depth:o,onValue:a,offValue:l}=s,u=oe(r.shape),c=new qke(u,o),h=it({inputs:{x:r},backend:n,attrs:{shape:[u]}}),d=[{type:"float32",data:[a]},{type:"float32",data:[l]}],f=n.runWebGPUProgram(c,[h],i,d);n.disposeData(h.dataId);const p=[...r.shape,o],g=it({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeData(f.dataId),g}const Zke={kernelName:Pf,backendName:"webgpu",kernelFunc:Yke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cg(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="complex64"){const r=xp({inputs:{input:s},backend:n}),i=Cg({inputs:{x:r},backend:n}),o=zx({inputs:{input:s},backend:n}),a=Cg({inputs:{x:o},backend:n}),l=Hl({inputs:{real:i,imag:a},backend:n});return n.disposeData(r.dataId),n.disposeData(i.dataId),n.disposeData(o.dataId),n.disposeData(a.dataId),l}else return Qs({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:n})}const Qke={kernelName:qf,backendName:"webgpu",kernelFunc:Cg};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=xp({inputs:{input:s},backend:n}),i=$N({inputs:{x:r},backend:n}),o=zx({inputs:{input:s},backend:n}),a=Cg({inputs:{x:o},backend:n}),l=Hl({inputs:{real:i,imag:a},backend:n});return n.disposeData(r.dataId),n.disposeData(i.dataId),n.disposeData(o.dataId),n.disposeData(a.dataId),l}else return Qs({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:n})}const Jke={kernelName:Af,backendName:"webgpu",kernelFunc:$N};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eEe(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(e.length===1)return my({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(c=>{n0(i,c.shape,"All tensors passed to stack must have matching shapes"),G(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=my({inputs:{input:c},backend:n,attrs:{dim:r}});return a.push(h),h}),u=bN({inputs:l,backend:n,attrs:{axis:r}});return a.forEach(c=>n.disposeData(c.dataId)),u}const tEe={kernelName:Df,backendName:"webgpu",kernelFunc:eEe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RN(t,e=!1){const n=t.length,s=Fn(n),r=t.map((h,d)=>`uniforms.pad${d}[0]`).join(","),i=t.map((h,d)=>`uniforms.pad${d}[0] + uniforms.xShape${n>1?`[${d}]`:""}`).join(","),o=n>1?`${s}(${r})`:`${r}`,a=n>1?`${s}(${i})`:`${i}`,l=n>1?"any(paddedCoords < start)":"paddedCoords < start",u=n>1?"any(paddedCoords >= end)":"paddedCoords >= end",c=n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords";return`
        let start = ${o};
        let end = ${a};
        if (${l} || ${u}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${c}));
        }
  `}class nEe{constructor(e,n){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((s,r)=>s[0]+e[r]+s[1]),this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),n.map((s,r)=>{this.uniforms+=` pad${r} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${RN(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sEe=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:i,constantValue:o}=s;if(i.every(u=>Pt(u,[0,0])))return pr({inputs:{x:r},backend:n});if(oe(r.shape)===0){const u=i.map((c,h)=>c[0]+r.shape[h]+c[1]);return Qs({backend:n,attrs:{shape:u,value:o,dtype:r.dtype}})}const a=[{type:"float32",data:[o]}];i.map(u=>a.push({type:"int32",data:[u[0],u[1]]}));const l=new nEe(r.shape,i);return n.runWebGPUProgram(l,[r],r.dtype,a)},rEe={kernelName:Nf,backendName:"webgpu",kernelFunc:sEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iEe=fs({opType:xt.POW}),oEe={kernelName:Pc,backendName:"webgpu",kernelFunc:iEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aEe(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e,i=new wg(xt.PRELU,s.shape,r.shape);return n.runWebGPUProgram(i,[s,r],"float32")}const lEe={kernelName:Mf,backendName:"webgpu",kernelFunc:aEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uEe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;return Kl(r,i,o,"prod",n)}const cEe={kernelName:Lf,backendName:"webgpu",kernelFunc:uEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hEe=t=>{const{backend:e,attrs:n}=t,{start:s,stop:r,step:i,dtype:o}=n,a=eCe(s,r,i,o);return e.makeTensorInfo([a.length],o,a)},dEe={kernelName:A0,backendName:"webgpu",kernelFunc:hEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fEe=fs({opType:xt.DIV}),pEe={kernelName:pc,backendName:"webgpu",kernelFunc:fEe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mEe=Bt({opType:Oe.RECIPROCAL}),gEe={kernelName:Dc,backendName:"webgpu",kernelFunc:mEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xEe=Bt({opType:Oe.RELU}),bEe={kernelName:Nc,backendName:"webgpu",kernelFunc:xEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yEe=Bt({opType:Oe.RELU6}),vEe={kernelName:Mc,backendName:"webgpu",kernelFunc:yEe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wEe{constructor(e,n,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,s,e[3]],this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Ge("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SEe(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,size:o,halfPixelCenters:a}=s,[l,u]=o,c=i&&l>1?1:0,h=i&&u>1?1:0,f=[{type:"float32",data:[c,h]},{type:"float32",data:[a?.5:0]}],p=new wEe(r.shape,l,u);return n.runWebGPUProgram(p,[r],"float32",f)}const CEe={kernelName:Uf,backendName:"webgpu",kernelFunc:SEe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TEe{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeBilinearBackprop_${n}`}getUserCode(){return`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IEe(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:o}=s,[,a,l]=r.shape,[,u,c]=i.shape,h=[o&&u>1?a-1:a,o&&c>1?l-1:l],d=[o&&u>1?u-1:u,o&&c>1?c-1:c],f=h[0]/d[0],p=h[1]/d[1],g=1/f,m=1/p,x=Math.ceil(g)*2+2,b=Math.ceil(m)*2+2,v=new TEe(r.shape,o),y=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[f]},{type:"float32",data:[p]},{type:"float32",data:[g]},{type:"float32",data:[m]},{type:"int32",data:[x]},{type:"int32",data:[b]}];return n.runWebGPUProgram(v,[i],i.dtype,y)}const kEe={kernelName:N0,backendName:"webgpu",kernelFunc:IEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EEe{constructor(e,n,s,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,s,e[3]],this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ee(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,u]=a,c=i&&l>1?1:0,h=i&&u>1?1:0,f=[{type:"float32",data:[c,h]},{type:"float32",data:[i?.5:0]}],p=new EEe(r.shape,l,u,o);return n.runWebGPUProgram(p,[r],r.dtype,f)}const $Ee={kernelName:Ff,backendName:"webgpu",kernelFunc:_Ee};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class REe{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeNearestNeigborBackprop_${n}`}getUserCode(){return`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AEe(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:o}=s,[,a,l]=r.shape,[,u,c]=i.shape,h=[o&&u>1?a-1:a,o&&c>1?l-1:l],d=[o&&u>1?u-1:u,o&&c>1?c-1:c],f=h[0]/d[0],p=h[1]/d[1],g=1/f,m=1/p,x=Math.ceil(g)*2+2,b=Math.ceil(m)*2+2,v=new REe(r.shape,o),y=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[g]},{type:"float32",data:[m]},{type:"int32",data:[x]},{type:"int32",data:[b]}];return n.runWebGPUProgram(v,[i],i.dtype,y)}const PEe={kernelName:D0,backendName:"webgpu",kernelFunc:AEe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DEe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${Ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NEe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:i}=s,o=r.shape.length;if(o===0)return pr({inputs:{x:r},backend:n});const a=r.shape,l=[1,1,1,1];a.forEach((m,x)=>{const b=x+4-o;l[b]=m});const u=wt(i,r.shape),c=[0,0,0,0];u.forEach(m=>{const x=m+4-o;c[x]=1});const h=[{type:"int32",data:c}],d=it({inputs:{x:r},backend:n,attrs:{shape:l}}),f=new DEe(l),p=n.runWebGPUProgram(f,[d],d.dtype,h);n.disposeData(d.dataId);const g=it({inputs:{x:p},backend:n,attrs:{shape:a}});return n.disposeData(p.dataId),g}const MEe={kernelName:Bf,backendName:"webgpu",kernelFunc:NEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LEe{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof n=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Ge("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OEe={kernelName:U0,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:i,center:o}=e,a=n,l=new LEe(s.shape,i),[u,c]=rx(o,s.shape[1],s.shape[2]),h=[{type:"float32",data:[u]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];return typeof i=="number"?h.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):h.push({type:"float32",data:i}),a.runWebGPUProgram(l,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FEe=Bt({opType:Oe.ROUND}),UEe={kernelName:Lc,backendName:"webgpu",kernelFunc:FEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BEe=Bt({opType:Oe.RSQRT,cpuKernelImpl:tCe}),zEe={kernelName:Oc,backendName:"webgpu",kernelFunc:BEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class id{constructor(e,n,s,r,i,o,a,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=o,this.type=a,this.sumDupeIndices=l,this.dispatchLayout=Qe(e),this.dispatch=Ve(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=n>1,this.shaderKey=`scatter_${s}_${r}_${this.sliceDimGreaterThanOne}_${a}_${l}_${i.length}`;const u=Fn(i.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=s}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const n=`getIndices(${e})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",i="";this.dispatchLayout.x.length===1?(r="flattenedIndex",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(r="vec2<i32>(flattenedIndex, coords[1])",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(u,c)=>`coords[${c}]`).join(", ")})`;return`
    ${i}
      ${Ge("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${n}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${ja(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${r});

          ${this.sumDupeIndices?Ca("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GEe(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Ji(i,r,o),d=[h/u,u];if(h===0)return n.makeTensorInfo(o,r.dtype);const f=it({inputs:{x:r},backend:n,attrs:{shape:[l,a]}}),p=it({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),g=p.dtype,m=Qs({backend:n,attrs:{shape:d,value:0,dtype:g}}),x=oe(p.shape),b=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[x]}],v=new id(p.shape,a,f.shape.length,p.shape.length,c,d,g),y=n.runWebGPUProgram(v,[p,f],g,b,m),C=it({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeData(f.dataId),n.disposeData(p.dataId),n.disposeData(y.dataId),C}const VEe={kernelName:Cv,backendName:"webgpu",kernelFunc:GEe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WEe{constructor(e,n){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=n,this.shaderKey=`search_sorted_${n}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${Ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HEe(t){const{inputs:e,backend:n,attrs:s}=t,{sortedSequence:r,values:i}=e,{side:o}=s,a=new WEe([i.shape[0],i.shape[1]],o),l=[{type:"int32",data:[r.shape[1]]}];return n.runWebGPUProgram(a,[r,i],"int32",l)}const KEe={kernelName:Iv,backendName:"webgpu",kernelFunc:HEe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jEe{constructor(e,n,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=s,this.shaderKey="select"}getUserCode(){let e,n;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)n="resRC",e="resRC";else{const r=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],o=[];for(let a=0;a<this.outputShape.length;a++)o.push(`${r[a]}`),a<this.cRank&&i.push(`${r[a]}`);e=i.join(),n=o.join()}return`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${n}));
          } else {
            setOutputAtIndex(index, getB(${n}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XEe(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:i}=e,o=new jEe(s.shape.length,r.shape,r.shape.length);return n.runWebGPUProgram(o,[s,r,i],hs(r.dtype,i.dtype))}const qEe={kernelName:zf,backendName:"webgpu",kernelFunc:XEe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YEe=Bt({opType:Oe.SELU}),ZEe={kernelName:Fc,backendName:"webgpu",kernelFunc:YEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QEe=Bt({opType:Oe.SIGMOID}),JEe={kernelName:Gc,backendName:"webgpu",kernelFunc:QEe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e_e=Bt({opType:Oe.SIGN}),t_e={kernelName:zc,backendName:"webgpu",kernelFunc:e_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n_e=Bt({opType:Oe.SIN}),s_e={kernelName:Uc,backendName:"webgpu",kernelFunc:n_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r_e=Bt({opType:Oe.SINH}),i_e={kernelName:Bc,backendName:"webgpu",kernelFunc:r_e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o_e=Bt({opType:Oe.SOFTPLUS}),a_e={kernelName:Vc,backendName:"webgpu",kernelFunc:o_e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l_e{constructor(e,n,s,r,i,o){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(r.length);for(let l=0;l<a.length;l++)a[l]=r[i[l]];this.outputShape=a,this.newDim=i,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=n,this.uniforms+=`reshapedPaddedXShape : ${Fn(r.length)}, paddedXShapeStrides : ${Fn(o)}, `,s.map((l,u)=>{this.uniforms+=` pad${u} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${i}`}getUserCode(){const e=Fn(this.outputShape.length),n=hN(this.newDim);return`
      ${Em(this.paddedXShape,"PaddedX")}
      ${Ge("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${n}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${RN(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u_e=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,paddings:o}=s;G(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=i.reduce((b,v)=>b*v),l=[[0,0]];l.push(...o);for(let b=1+i.length;b<r.shape.length;++b)l.push([0,0]);const u=l.map((b,v)=>b[0]+r.shape[v]+b[1]),c=Ml(u,i,a,!1),h=Ll(c.length,i.length,!1),d=Ol(u,i,a,!1),f=lt(u),p=new l_e(r.shape,u,l,c,h,f.length),g=[{type:"int32",data:c},{type:"int32",data:f}];l.map(b=>g.push({type:"int32",data:[b[0],b[1]]}));const m=n.runWebGPUProgram(p,[r],r.dtype,g),x=it({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeData(m.dataId),x},c_e={kernelName:Wf,backendName:"webgpu",kernelFunc:u_e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h_e{constructor(e,n,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=s,this.dispatchLayout=Qe([n]),this.dispatch=Ve(this.dispatchLayout,[n],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${Ge("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Ca("&result[outIndex]","value",this.type)}
      }
    }
  `}}class d_e{constructor(e,n){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=Qe(n),this.dispatch=Ve(this.dispatchLayout,n,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${Ge("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Ca("&result[segmentId]","1","int32")}
      }
    }
  `}}class f_e{constructor(e,n){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=n,this.dispatchLayout=Qe(e),this.dispatch=Ve(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${Ge("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AN(t,e,n,s=!1,r){const o=oe(t.shape)/t.shape[0],a=t.dtype,l=oe(e.shape),u=r.readSync(n.dataId),h=l>0?u[l-1]+1:0;let d;const f=t.shape.slice();f[0]=h;const p=l*o,g=Qs({backend:r,attrs:{shape:f,value:0,dtype:a}});d=new h_e(f,p,a);let m=[{type:"int32",data:[o]},{type:"int32",data:[p]}];const x=r.runWebGPUProgram(d,[t,e,n],a,m,g);if(s)return x;const b=Qs({backend:r,attrs:{shape:[h],value:0,dtype:"int32"}});d=new d_e(h,n.shape);const v=r.runWebGPUProgram(d,[n],"int32",null,b),y=Qs({backend:r,attrs:{shape:f,value:0,dtype:a}});d=new f_e(f,a),m=[{type:"int32",data:[o]}];const C=r.runWebGPUProgram(d,[x,v],a,m,y);return r.disposeData(x.dataId),r.disposeData(v.dataId),C}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p_e(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;return AN(s,r,i,!1,n)}const m_e={kernelName:kv,backendName:"webgpu",kernelFunc:p_e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g_e(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;return AN(s,r,i,!0,n)}const x_e={kernelName:Ev,backendName:"webgpu",kernelFunc:g_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b_e{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[r]*n[r];this.outputShape=s,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=y_e(this.rank,"uniforms.");return`
      ${Ge("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function y_e(t,e=""){if(t>=5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`(resRC % ${e}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<t;r++)s.push(`(${n[r]} % ${e}aShape[${r}])`);return s.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dw(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:i}=s;if(n.shouldExecuteOnCPU([r])||r.dtype==="string"||r.shape.length>=5){const l=n.readSync(r.dataId),u=r.dtype==="string"?l.map(d=>li(d)):l,c=Ct(r.shape,r.dtype,u),h=lCe(c,i);return n.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new b_e(r.shape,i);return n.runWebGPUProgram(o,[r],r.dtype)}const v_e={kernelName:qc,backendName:"webgpu",kernelFunc:dw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_e(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=Ji(i,r,a),f=!1;if(i.dtype==="string"){const T=n.bufferSync(r),S=n.bufferSync(i),E=li(n.readSync(o.dataId)[0]),_=nCe(T,S,a,d,c,u,l,h,E,f);return n.makeTensorInfo(a,_.dtype,_.values)}const p=[d/c,c],g=it({inputs:{x:r},backend:n,attrs:{shape:[u,l]}}),m=i.shape.length?it({inputs:{x:i},backend:n,attrs:{shape:[u,c]}}):pr({inputs:{x:i},backend:n}),x=m.dtype,b=n.makeTensorInfo([],x,vs(1,x)),v=it({inputs:{x:o},backend:n,attrs:{shape:Array(p.length).fill(1)}}),y=dw({inputs:{x:v},backend:n,attrs:{reps:p}}),C=oe([u,c]),I=[{type:"int32",data:[l]},{type:"int32",data:h},{type:"int32",data:[C]}];switch(u){case 0:break;case 1:{const T=new id([u,c],l,g.shape.length,m.shape.length,h,p,x,f);n.runWebGPUProgram(T,[m,g],x,I,y)}break;default:{const T=new id([u,c],l,g.shape.length,b.shape.length,h,p,x,f);n.runWebGPUProgram(T,[b,g],x,I,y)}{const T=new id([u,c],l,g.shape.length,m.shape.length,h,p,x);n.runWebGPUProgram(T,[m,g],x,I,y)}}const $=it({inputs:{x:y},backend:n,attrs:{shape:a}});return n.disposeData(g.dataId),n.disposeData(m.dataId),n.disposeData(v.dataId),n.disposeData(b.dataId),n.disposeData(y.dataId),$}const S_e={kernelName:_v,backendName:"webgpu",kernelFunc:w_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C_e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=wt(o,r.shape)[0],l=bx(r,i,a),u=r.shape.length,c=new Array(u).fill(0),h=r.shape.slice();return l.map(d=>{const f=[...h];f[a]=d;const p=dh({inputs:{x:r},backend:n,attrs:{begin:c,size:f}});return c[a]+=d,p})}const T_e={kernelName:Hf,backendName:"webgpu",kernelFunc:C_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I_e=Bt({opType:Oe.SQRT}),k_e={kernelName:Wc,backendName:"webgpu",kernelFunc:I_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E_e={kernelName:M0,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,s=e,r=new hh(n.shape,Oe.SQUARE);return s.runWebGPUProgram(r,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const __e=fs({opType:xt.SQUARED_DIFFERENCE}),$_e={kernelName:Hc,backendName:"webgpu",kernelFunc:__e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R_e({inputs:t,attrs:e,backend:n}){const{x:s}=t,r=new hh(s.shape,Oe.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[e.alpha]}];return n.runWebGPUProgram(r,[s],s.dtype,i)}const A_e={kernelName:Yc,backendName:"webgpu",kernelFunc:R_e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P_e{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const n=Fn(this.outputShape.length);this.uniforms=`begin : ${n},  strides : ${n}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let n="";if(e===1)n="coords * uniforms.strides + uniforms.begin";else{let r=0;n=this.outputShape.map((i,o)=>(r++,this.outputShape.length===1?`coords * uniforms.strides[${o}] + uniforms.begin[${o}]`:`coords[${r-1}] * uniforms.strides[${o}] + uniforms.begin[${o}]`)).join(",")}return`
       ${Ge("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${n}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D_e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:f,finalShape:p,isIdentity:g,sliceDim0:m,isSimpleSlice:x,begin:b,end:v,strides:y}=tx(r.shape,i,o,a,l,u,c,h,d);let C;if(g)C=it({inputs:{x:r},backend:n,attrs:{shape:p}});else if(m||x){G(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const I=ex(b,v,y),$=dh({inputs:{x:r},backend:n,attrs:{begin:b,size:I}});C=it({inputs:{x:$},backend:n,attrs:{shape:p}}),n.disposeData($.dataId)}else if(n.shouldExecuteOnCPU([r])){const $=n.readSync(r.dataId),T=Ct(r.shape,r.dtype,$),S=iCe(f,T,y,b);C=n.makeTensorInfo(p,r.dtype,S.values)}else{const $=new P_e(f),T=[{type:"int32",data:b},{type:"int32",data:y}],S=n.runWebGPUProgram($,[r],r.dtype,T);C=it({inputs:{x:S},backend:n,attrs:{shape:p}}),n.disposeData(S.dataId)}return C}const N_e={kernelName:L0,backendName:"webgpu",kernelFunc:D_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M_e(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=n.readSync(c.dataId),f=n.readSync(h.dataId),[p,g]=oCe(d,f,r,i,o,a,l,u);return[n.makeTensorInfo([p.length],"string",p),n.makeTensorInfo(h.shape,"int32",g)]}const L_e={kernelName:Rv,backendName:"webgpu",kernelFunc:M_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O_e=fs({opType:xt.SUB,cpuKernelImpl:aCe,supportsComplex:!0}),F_e={kernelName:Kc,backendName:"webgpu",kernelFunc:O_e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U_e=Bt({opType:Oe.TAN}),B_e={kernelName:jc,backendName:"webgpu",kernelFunc:U_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z_e=Bt({opType:Oe.TANH}),G_e={kernelName:Xc,backendName:"webgpu",kernelFunc:z_e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V_e(t){const{inputs:e,backend:n,attrs:s}=t,{tensor:r,indices:i,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Ji(o,i,r.shape),d=[h/u,u];if(h===0)return n.makeTensorInfo(r.shape,i.dtype);const f=[],p=it({inputs:{x:i},backend:n,attrs:{shape:[l,a]}});f.push(p);const g=it({inputs:{x:o},backend:n,attrs:{shape:[l,u]}});f.push(g);const m=it({inputs:{x:r},backend:n,attrs:{shape:d}});f.push(m);const x=dw({inputs:{x:m},backend:n,attrs:{reps:Array(d.length).fill(1)}}),b=new id([l,u],a,p.shape.length,g.shape.length,c,d,r.dtype,!1),v=oe([l,u]),y=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[v]}],C=n.runWebGPUProgram(b,[g,p],m.dtype,y,x);f.push(C);const I=it({inputs:{x:C},backend:n,attrs:{shape:r.shape}});return f.forEach($=>n.disposeData($.dataId)),I}const W_e={kernelName:Tv,backendName:"webgpu",kernelFunc:V_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H_e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${Ge("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class K_e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${Ge("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cu(t,e){e!==null&&t.disposeData(e.dataId)}function rT(t){let e=1;for(;e<t;)e*=2;return e}function j_e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:i,sorted:o}=s,a=r.shape,l=a[a.length-1];if(n.shouldExecuteOnCPU([r])){const C=n.readSync(r.dataId),[I,$]=uCe(C,a,r.dtype,i,o);return[n.makeTensorInfo(I.shape,I.dtype,I.values),n.makeTensorInfo($.shape,$.dtype,$.values)]}if(i===0)return a[a.length-1]=0,[n.makeTensorInfo(a,r.dtype,[]),n.makeTensorInfo(a,"int32",[])];if(l===1)return[r,Qs({attrs:{shape:a,dtype:"int32",value:0},backend:n})];const c=oe(a)/l,h=it({inputs:{x:r},attrs:{shape:[c,l]},backend:n}),d=rT(i),f=rT(l);let p=null;const g=()=>p===null?[h,h]:[h,p],m=(C,I,$)=>{const T=g(),S=new H_e($),_=[{type:"int32",data:[l]},{type:"int32",data:[p===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[C]},{type:"int32",data:[I]}],N=p;p=n.runWebGPUProgram(S,T,"int32",_),cu(n,N)};for(let C=1;C<d;C*=2){const I=C*2;for(let $=C;$>=1;$/=2)m(I,$,[c,f])}for(let C=f;C>d;C/=2){const I=g(),$=new K_e([c,C/2]),S=[{type:"int32",data:[l]},{type:"int32",data:[p===null?1:0]},{type:"int32",data:[d]}],E=p;p=n.runWebGPUProgram($,I,"int32",S),cu(n,E);const _=d/2,N=_*2;for(let P=_;P>=1;P/=2)m(N,P,p.shape)}let x=p;p=dh({inputs:{x:p},backend:n,attrs:{begin:0,size:[c,i]}}),cu(n,x);let b=kN({inputs:{x:h,indices:p},backend:n,attrs:{axis:1,batchDims:1}});cu(n,h);const v=a.slice(0,-1);v.push(i),x=p,p=it({inputs:{x:p},attrs:{shape:v},backend:n}),cu(n,x);const y=b;return b=it({inputs:{x:b},attrs:{shape:v},backend:n}),cu(n,y),[b,p]}const X_e={kernelName:O0,backendName:"webgpu",kernelFunc:j_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q_e{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Qe(this.outputShape),this.dispatch=Ve(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Ge("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y_e(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=s,[c,h,d,f]=r.shape,[p,g]=u??[h,d],m=[c,p,g,f],x=new q_e(m),b=o==="nearest"?1:2;let v;switch(a){case"constant":v=1;break;case"reflect":v=2;break;case"wrap":v=3;break;case"nearest":v=4;break;default:v=1;break}const y=[{type:"int32",data:[b]},{type:"int32",data:[v]},{type:"float32",data:[l]}];return n.runWebGPUProgram(x,[r,i],"float32",y)}const Z_e={kernelName:F0,backendName:"webgpu",kernelFunc:Y_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q_e(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[i],u=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==i&&(u[c++]=o.shape[g]);const h=[],d=new Array(a).fill(0),f=o.shape.slice();f[i]=1;const p=new Array(l);for(let g=0;g<p.length;g++){d[i]=g;const m=dh({inputs:{x:o},backend:n,attrs:{begin:d,size:f}}),x=it({inputs:{x:m},backend:n,attrs:{shape:u}});p[g]=x,h.push(m)}return h.forEach(g=>n.disposeData(g.dataId)),p}const J_e={kernelName:jf,backendName:"webgpu",kernelFunc:Q_e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e$e{constructor(e,n,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=n,this.dispatchLayout=Qe(e),this.dispatch=Ve(this.dispatchLayout,e,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${Ge("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Ca("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t$e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:i}=e,{numSegments:o}=s,a=r.shape.length,l=[];let u=0;const c=Jt([u],a);let h=r;c!=null&&(h=Yi({inputs:{x:r},backend:n,attrs:{perm:c}}),l.push(h),u=an(1,a)[0]);const d=S2(h.shape,u,o),f=oe([h.shape[u]]),p=it({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}});l.push(p);const g=r.dtype,m=[p.shape[0],o],x=Qs({backend:n,attrs:{shape:m,value:0,dtype:g}}),b=new e$e(p.shape,m,g),v=[{type:"int32",data:[o]},{type:"int32",data:[oe(p.shape)]}],y=n.runWebGPUProgram(b,[p,i],g,v,x),C=it({inputs:{x:y},backend:n,attrs:{shape:d}});l.push(y);let I=C;if(c!=null){l.push(C);const $=Qi(c);I=Yi({inputs:{x:I},backend:n,attrs:{perm:$}})}return l.forEach($=>n.disposeData($.dataId)),I}const n$e={kernelName:Xf,backendName:"webgpu",kernelFunc:t$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s$e=[_Se,dCe,pCe,gCe,bCe,wCe,_Ce,RCe,PCe,NCe,LCe,FCe,BCe,GCe,WCe,qCe,ZCe,t3e,s3e,i3e,c3e,p3e,x3e,w3e,C3e,E3e,RSe,R3e,N3e,G3e,X3e,Q3e,tTe,sTe,iTe,aTe,uTe,dTe,pTe,gTe,bTe,wTe,_Te,RTe,TTe,DTe,LTe,BTe,GTe,HTe,qTe,ZTe,JTe,tIe,sIe,iIe,oIe,lIe,cIe,ISe,dIe,bIe,pIe,gIe,wIe,CIe,IIe,_Ie,AIe,DIe,MIe,$Se,OIe,P3e,UIe,zIe,VIe,HIe,jIe,qIe,QIe,nke,eke,rke,oke,lke,dke,mke,KCe,xke,yke,Eke,wke,Ike,$ke,jCe,Ake,Dke,Mke,Oke,Gke,KTe,Wke,Kke,Xke,b3e,Zke,Jke,tEe,rEe,oEe,lEe,cEe,dEe,y3e,pEe,gEe,bEe,vEe,kSe,CEe,kEe,$Ee,PEe,MEe,OEe,UEe,zEe,VEe,KEe,qEe,ZEe,JEe,t_e,s_e,i_e,l3e,A_e,N_e,L_e,Bke,a_e,c_e,m_e,x_e,S_e,T_e,k_e,E_e,$_e,F_e,jTe,B_e,G_e,W_e,v_e,X_e,Z_e,TCe,J_e,n$e,Qke];for(const t of s$e)Dv(t);async function r$e(t){await m_("webgpu"),await g_(),console.log(` TensorFlow.js : ${bq()}`);const e=3;let n=t,s=Wv(e),r=await n.array();const i=10,o=1e-10;for(let l=0;l<i;l++){let u=!0;for(let c=0;c<e-1;c++)for(let h=c+1;h<e;h++){const d=r[c][h],f=r[c][c],p=r[h][h];if(Math.abs(d)>o){u=!1;const g=.5*Math.atan2(2*d,p-f),m=Math.cos(g),x=Math.sin(g),b=sd(Array.from({length:e},(v,y)=>Array.from({length:e},(C,I)=>y===c&&I===c||y===h&&I===h?m:y===c&&I===h?-x:y===h&&I===c?x:y===I?1:0)));[n,s]=de(()=>{const v=b.transpose(),y=Lt(Lt(v,n),b),C=Lt(s,b);return[y,C]}),r=await n.array()}}if(u)break}return{eigenValues:Array.from({length:e},(l,u)=>r[u][u]),eigenVectors:await s.array()}}async function i$e(t,e){await m_("webgpu"),await g_();const n=t.data.length/4;let s=0,r=0,i=0,o=0,a=0,l=0,u=0,c=0,h=0;for(let g=0;g<n;g++){const m=g*4,x=t.data[m],b=t.data[m+1],v=t.data[m+2],y=x-s,C=b-r,I=v-i;s+=y/(g+1),r+=C/(g+1),i+=I/(g+1);const $=x-s,T=b-r,S=v-i;g>0&&(o+=y*$,a+=y*T,l+=y*S,u+=C*T,c+=C*S,h+=I*S)}const d=n-1;o/=d,a/=d,l/=d,u/=d,c/=d,h/=d;const f=sd([[o,a,l],[a,u,c],[l,c,h]]);return e=(await qo(r$e)(f)).eigenVectors,f.dispose(),e}function o$e(){let t=[];for(let e=0;e<3;e++)t[e]=[0,0,0];return t}async function a$e(t){let e=o$e();return e=await qo(i$e)(t,e),{output:await $X(t,e),eigenVectors:e}}const l$e=`// ---  ---\r
@group(0) @binding(0) var<storage, read> target_pixels: array<vec4<f32>>;\r
@group(0) @binding(1) var<storage, read> input_pixels: array<vec4<f32>>;\r
@group(0) @binding(2) var<storage, read_write> projected_values: array<f32>;\r
@group(0) @binding(3) var<storage, read_write> output_pixels: array<vec4<f32>>;\r
@group(0) @binding(4) var<uniform> eigen_vectors: mat3x3<f32>;\r
@group(0) @binding(5) var<uniform> params: Params;\r
\r
struct Params {\r
    operation: u32,\r
    k: u32,\r
    j: u32,\r
    padded_element_count: u32,\r
    total_invocations: u32,\r
    input_element_count: u32,\r
    target_element_count: u32,\r
};\r
\r
\r
// ---  ---\r
\r
fn do_projection(global_id: vec3<u32>) {\r
    // \r
    if (global_id.x >= params.padded_element_count) {\r
        return;\r
    }\r
    let pixel_index = global_id.x;\r
    let out_index = pixel_index * 3u;\r
\r
    if (pixel_index < params.target_element_count) {\r
        let pixel_rgb = target_pixels[pixel_index].rgb;\r
        // eigen_vectorsCPUeigenVectors\r
        // CPU: dot(pixel_rgb, eigenVectors[row])\r
        // GPU: dot(pixel_rgb, vec3(eigen_vectors[0][row], eigen_vectors[1][row], eigen_vectors[2][row]))\r
        let projected_r = dot(pixel_rgb, vec3(eigen_vectors[0][0], eigen_vectors[1][0], eigen_vectors[2][0]));\r
        let projected_g = dot(pixel_rgb, vec3(eigen_vectors[0][1], eigen_vectors[1][1], eigen_vectors[2][1]));\r
        let projected_b = dot(pixel_rgb, vec3(eigen_vectors[0][2], eigen_vectors[1][2], eigen_vectors[2][2]));\r
        projected_values[out_index] = projected_r;\r
        projected_values[out_index + 1u] = projected_g;\r
        projected_values[out_index + 2u] = projected_b;\r
    } else {\r
        // \r
        let infinity = 3.402823466e+38; // f32 max\r
        projected_values[out_index] = infinity;\r
        projected_values[out_index + 1u] = infinity;\r
        projected_values[out_index + 2u] = infinity;\r
    }\r
}\r
\r
fn do_sort(global_id: vec3<u32>) {\r
    let thread_index = global_id.x;\r
    for (var i = thread_index; i < params.padded_element_count; i = i + params.total_invocations) {\r
        let ix = i;\r
        let jx = ix ^ params.j;\r
\r
        if (jx < ix) { continue; }\r
\r
        let direction = ((ix & params.k) == 0u);\r
        let ix3 = ix * 3u;\r
        let jx3 = jx * 3u;\r
\r
        // R \r
        if (direction == (projected_values[ix3] > projected_values[jx3])) {\r
            let temp = projected_values[ix3];\r
            projected_values[ix3] = projected_values[jx3];\r
            projected_values[jx3] = temp;\r
        }\r
        // G \r
        if (direction == (projected_values[ix3 + 1u] > projected_values[jx3 + 1u])) {\r
            let temp = projected_values[ix3 + 1u];\r
            projected_values[ix3 + 1u] = projected_values[jx3 + 1u];\r
            projected_values[jx3 + 1u] = temp;\r
        }\r
        // B \r
        if (direction == (projected_values[ix3 + 2u] > projected_values[jx3 + 2u])) {\r
            let temp = projected_values[ix3 + 2u];\r
            projected_values[ix3 + 2u] = projected_values[jx3 + 2u];\r
            projected_values[jx3 + 2u] = temp;\r
        }\r
    }\r
}\r
\r
fn erf(x: f32) -> f32 {\r
    let a1 = 0.254829592; let a2 = -0.284496736; let a3 = 1.421413741;\r
    let a4 = -1.453152027; let a5 = 1.061405429; let p = 0.3275911;\r
    let sign = select(1.0, -1.0, x < 0.0);\r
    let abs_x = abs(x);\r
    let t = 1.0 / (1.0 + p * abs_x);\r
    let y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-abs_x * abs_x);\r
    return sign * y;\r
}\r
\r
fn mapValue(value: f32, channel_offset: u32) -> f32 {\r
    // \r
    // CPURindex\r
    let target_size = params.target_element_count;\r
    let U = 0.5 + 0.5 * erf(value / sqrt(2.0));\r
    let index = u32(floor(U * f32(target_size)));\r
    let clamped_index = min(index, target_size - 1u);\r
    return projected_values[clamped_index * 3u + channel_offset];\r
}\r
\r
fn do_mapping(global_id: vec3<u32>) {\r
    let pixel_index = global_id.x;\r
    let input_rgb = input_pixels[pixel_index].rgb;\r
\r
    let mapped_r = mapValue(input_rgb.r, 0u);\r
    let mapped_g = mapValue(input_rgb.g, 1u);\r
    let mapped_b = mapValue(input_rgb.b, 2u);\r
\r
    // CPU\r
    // eigen_vectorsCPUeigenVectorsevT\r
    // CPU: dot(mapped_rgb, evT[row])\r
    // GPU: dot(mapped_rgb, eigen_vectors[row].xyz)\r
    let final_r = dot(vec3<f32>(mapped_r, mapped_g, mapped_b), eigen_vectors[0].xyz);\r
    let final_g = dot(vec3<f32>(mapped_r, mapped_g, mapped_b), eigen_vectors[1].xyz);\r
    let final_b = dot(vec3<f32>(mapped_r, mapped_g, mapped_b), eigen_vectors[2].xyz);\r
    let final_rgb = vec3<f32>(final_r, final_g, final_b);\r
\r
    output_pixels[pixel_index] = vec4<f32>(final_rgb, input_pixels[pixel_index].a);\r
}\r
\r
\r
// ---  ---\r
@compute @workgroup_size(256)\r
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r
    let operation = params.operation;\r
\r
    if (operation == 0u) {\r
        do_projection(global_id);\r
    } else if (operation == 1u) {\r
        do_sort(global_id);\r
    } else if (operation == 2u) {\r
        do_mapping(global_id);\r
    }\r
}`;function jb(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function u$e(t,e,n){let s=[],r=[],i=[];for(let l=0;l<e.height;++l)for(let u=0;u<e.width;++u){const c=(l*e.width+u)*4;let h=[e.data[c],e.data[c+1],e.data[c+2]];const d=jb(h,n[0]),f=jb(h,n[1]),p=jb(h,n[2]);s[u+l*e.width]=d,r[u+l*e.width]=f,i[u+l*e.width]=p}s=Array.from(Float32Array.from(s).sort()),r=Array.from(Float32Array.from(r).sort()),i=Array.from(Float32Array.from(i).sort());const o=t.width*t.height,a=new Array(o*4);for(let l=0;l<o;l++){const u=t.data[l*4],c=t.data[l*4+1],h=t.data[l*4+2],d=C=>{var I=.254829592,$=-.284496736,T=1.421413741,S=-1.453152027,E=1.061405429,_=.3275911,N=C<0?-1:1;C=Math.abs(C);var P=1/(1+_*C),M=1-((((E*P+S)*P+T)*P+$)*P+I)*P*Math.exp(-C*C);return N*M},f=(C,I)=>{var $=.5+.5*d(C/Math.sqrt(2)),T=Math.floor($*s.length);return T=Math.min(T,s.length-1),{mappedValue:I[T],U:$,index:T}},p=f(u,s),g=f(c,r),m=f(h,i),x=p.mappedValue,b=g.mappedValue,v=m.mappedValue,y=[[n[0][0],n[1][0],n[2][0]],[n[0][1],n[1][1],n[2][1]],[n[0][2],n[1][2],n[2][2]]];a[l*4]=x*y[0][0]+b*y[0][1]+v*y[0][2],a[l*4+1]=x*y[1][0]+b*y[1][1]+v*y[1][2],a[l*4+2]=x*y[2][0]+b*y[2][1]+v*y[2][2],a[l*4+3]=t.data[l*4+3]}return{data:a,width:t.width,height:t.height}}const c$e=t=>(t&t-1)===0&&t!==0,h$e=t=>{if(t<=0)return 1;let e=1;for(;e<t;)e<<=1;return e};async function d$e(t,e,n){const s=await e0(),r=s.createShaderModule({code:l$e}),i=await s.createComputePipelineAsync({layout:"auto",compute:{module:r,entryPoint:"main"}}),o=e.width*e.height,a=t.width*t.height,l=c$e(o)?o:h$e(o),u=new Float32Array(e.data),c=new Float32Array(t.data),h=[n[0][0],n[1][0],n[2][0],0,n[0][1],n[1][1],n[2][1],0,n[0][2],n[1][2],n[2][2],0],d=new Float32Array(h),f=s.createBuffer({size:u.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),p=s.createBuffer({size:c.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),g=s.createBuffer({size:d.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),m=s.createBuffer({size:l*3*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),x=s.createBuffer({size:c.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(f,0,u),s.queue.writeBuffer(p,0,c),s.queue.writeBuffer(g,0,d);const b=s.createCommandEncoder(),v=s.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),y=new Uint32Array([0,0,0,l,0,a,o]);s.queue.writeBuffer(v,0,y);const C=s.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:p}},{binding:2,resource:{buffer:m}},{binding:3,resource:{buffer:x}},{binding:4,resource:{buffer:g}},{binding:5,resource:{buffer:v}}]}),I=b.beginComputePass();I.setPipeline(i),I.setBindGroup(0,C),I.dispatchWorkgroups(Math.ceil(l/256)),I.end();const $=Math.ceil(l/256)*256;for(let z=2;z<=l;z<<=1)for(let A=z>>1;A>0;A=A>>1){const B=s.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),L=new Uint32Array([1,z,A,l,$,a,o]);s.queue.writeBuffer(B,0,L);const U=s.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:p}},{binding:2,resource:{buffer:m}},{binding:3,resource:{buffer:x}},{binding:4,resource:{buffer:g}},{binding:5,resource:{buffer:B}}]}),j=b.beginComputePass();j.setPipeline(i),j.setBindGroup(0,U),j.dispatchWorkgroups(Math.ceil(l/256)),j.end()}const T=s.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),S=new Uint32Array([2,0,0,l,0,a,o]);s.queue.writeBuffer(T,0,S);const E=s.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:p}},{binding:2,resource:{buffer:m}},{binding:3,resource:{buffer:x}},{binding:4,resource:{buffer:g}},{binding:5,resource:{buffer:T}}]}),_=b.beginComputePass();_.setPipeline(i),_.setBindGroup(0,E),_.dispatchWorkgroups(Math.ceil(a/256)),_.end(),s.queue.submit([b.finish()]),await s.queue.onSubmittedWorkDone();const N=s.createBuffer({size:x.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),P=s.createCommandEncoder();P.copyBufferToBuffer(x,0,N,0,x.size),s.queue.submit([P.finish()]),await N.mapAsync(GPUMapMode.READ);const M=new Float32Array(N.getMappedRange().slice(0));return N.unmap(),f.destroy(),p.destroy(),g.destroy(),m.destroy(),x.destroy(),N.destroy(),{data:M,width:t.width,height:t.height}}async function f$e(t,e,n){try{const s={...t,data:new Float32Array(t.data)},r={...e,data:new Float32Array(e.data)},i=await d$e(s,r,n);return{...i,data:Array.from(i.data)}}catch(s){return console.error(s),u$e(t,e,n)}}const p$e=t=>{let e=t;return e=e^61^e>>16,e*=9,e=e^e>>4,e*=668265261,e=e^e>>15,e},m$e=p$e;function g$e(t,e,n,s,r,i){let o=0;if(t>=n/2&&t<n/2+r){let a=1-Math.floor(Math.abs(e-.5*(s-1)))/(s/2-1),l=1-a;o=a/Math.sqrt(a*a+l*l)}else if(e>=s/2&&e<s/2+i){let a=1-Math.floor(Math.abs(t-.5*(n-1)))/(n/2-1),l=1-a;o=a/Math.sqrt(a*a+l*l)}else{let a=e>=s/2+i?e-i:e,l=t>=n/2+r?t-r:t,u=1-Math.floor(Math.abs(l-.5*(n-1)))/(n/2-1),c=1-Math.floor(Math.abs(a-.5*(s-1)))/(s/2-1),h=(1-u)*(1-c),d=u*(1-c),f=(1-u)*c,p=u*c;o=u*c/Math.sqrt(h*h+d*d+f*f+p*p)}return o}function x$e(t,e,n,s,r){let{tileCountWidth:i,tileCountHeight:o,tileWidth:a,tileHeight:l,restWidth:u,restHeight:c}=n;for(let h=-1;h<i-1+(o-1);++h){let d=h<i-1?h:-1,f=h>=i-1?h-(i-1):-1,{tileCenterWidth:p,tileCenterHeight:g,cumulativeOffsetWidth:m,cumulativeOffsetHeight:x}=I$e(d,f,i,o,u,c),b=Math.floor((e.width-(a+p))*aT()),v=Math.floor((e.height-(l+g))*aT());for(let y=0;y<l+g;++y)for(let C=0;C<a+p;++C){let I=g$e(C,y,a,l,p,g),$=gy(C+d*a/2+m,s),T=gy(y+f*l/2+x,r),S=(C+b)%s,E=(y+v)%r;const _=(T*t.width+$)*4,N=_+1,P=_+2,M=(E*e.width+S)*4,z=M+1,A=M+2;t.data[_]+=I*e.data[M],t.data[N]+=I*e.data[z],t.data[P]+=I*e.data[A]}}return t}const b$e=`struct Uniforms {\r
  targetWidth: f32,\r
  targetHeight: f32,\r
  borderSize: f32\r
}\r
\r
@group(0) @binding(0) var<storage, read> inputData: array<f32>;\r
@group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\r
@group(0) @binding(2) var<uniform> uniforms: Uniforms;\r
\r
// \r
fn remapValue(value: f32, low1: f32, high1: f32, low2: f32, high2: f32) -> f32 {\r
  return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\r
}\r
\r
@compute @workgroup_size(16, 16, 1)\r
fn main(@builtin(global_invocation_id) global_id: vec3u) {\r
  let x = global_id.x;\r
  let y = global_id.y;\r
  \r
  // \r
  if (f32(x) >= uniforms.targetWidth || f32(y) >= uniforms.targetHeight) {\r
    return;\r
  }\r
  \r
  let targetWidth = u32(uniforms.targetWidth);\r
  let targetHeight = u32(uniforms.targetHeight);\r
  let borderSize = uniforms.borderSize;\r
  \r
  //  (RGB3)\r
  let pixelIndex = y * targetWidth + x;\r
  let rgbIndex = pixelIndex * 3u;\r
  \r
  // \r
  var w = min(remapValue(f32(x), 0.0, borderSize, 0.0, 1.0), 1.0); // Left border\r
  w *= min(remapValue(f32(x), uniforms.targetWidth - 1.0, uniforms.targetWidth - 1.0 - borderSize, 0.0, 1.0), 1.0); // Right border\r
  w *= min(remapValue(f32(y), 0.0, borderSize, 0.0, 1.0), 1.0); // Top border\r
  w *= min(remapValue(f32(y), uniforms.targetHeight - 1.0, uniforms.targetHeight - 1.0 - borderSize, 0.0, 1.0), 1.0); // Bottom border\r
  \r
  let w_inv = 1.0 - w;\r
  w = w / sqrt(w * w + w_inv * w_inv);\r
  \r
  // RGB\r
  outputData[rgbIndex] = w * inputData[rgbIndex];         // R\r
  outputData[rgbIndex + 1u] = w * inputData[rgbIndex + 1u]; // G\r
  outputData[rgbIndex + 2u] = w * inputData[rgbIndex + 2u]; // B\r
}`,iT=16,oT=(t,e,n)=>{if(!e||e.length===0)throw new Error(": 0");const s=t.createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0});return new Float32Array(s.getMappedRange()).set(e),s.unmap(),s},y$e=async(t,e,n,s,r)=>{if(!Number.isInteger(n)||n<=0)throw new Error(`Invalid targetWidth: ${n}. It must be a positive integer.`);if(!Number.isInteger(s)||s<=0)throw new Error(`Invalid targetHeight: ${s}. It must be a positive integer.`);if(r<=0)throw new Error(`Invalid borderSize: ${r}. It must be a positive number.`);if(!e||!(e.data instanceof Float32Array))throw new Error("Invalid imageInputGaussian: It must be an object with data as Float32Array.");const i=n*s*3;if(e.data.length!==i)throw new Error(`Data length mismatch. Expected ${i}, got ${e.data.length}`);const o=t.createShaderModule({code:b$e}),a=new Float32Array([n,s,r]),l=oT(t,a,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),u=oT(t,e.data,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),c=e.data.byteLength,h=t.createBuffer({size:c,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),d=t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),f=t.createBindGroup({layout:d,entries:[{binding:0,resource:{buffer:u}},{binding:1,resource:{buffer:h}},{binding:2,resource:{buffer:l}}]}),p=t.createComputePipeline({layout:t.createPipelineLayout({bindGroupLayouts:[d]}),compute:{module:o,entryPoint:"main"}}),g=t.createCommandEncoder(),m=g.beginComputePass();m.setPipeline(p),m.setBindGroup(0,f);const x=Math.ceil(n/iT),b=Math.ceil(s/iT);m.dispatchWorkgroups(x,b),m.end();const v=t.createBuffer({size:c,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});g.copyBufferToBuffer(h,0,v,0,c),t.queue.submit([g.finish()]),await t.queue.onSubmittedWorkDone(),await v.mapAsync(GPUMapMode.READ);const y=new Float32Array(v.getMappedRange().slice(0));return v.unmap(),{data:y,width:n,height:s}},v$e=async(t,e,n,s)=>{const r=await e0();return await y$e(r,t,e,n,s)};var Ei=0;const w$e=()=>{Ei^=Ei<<13,Ei^=Ei>>17,Ei^=Ei<<5,Ei=gy(Ei,4294967296)},aT=()=>(w$e(),Ei*(1/4294967296)),S$e=t=>{Ei=m$e(t)},gy=(t,e)=>{let n=t%e;return n<0&&(n+=e),n},C$e=(t,e)=>{const n=t/100;return Math.max(Math.floor(n*Math.min(e.width,e.height)/2),2)},T$e=(t,e,n)=>{let s=Math.floor(t/n),r=n,i=t-r*s;r+=Math.floor(i/s),i=t-r*s;let o=Math.floor(e/n),a=n,l=e-a*o;a+=Math.floor(l/o),l=e-a*o;let u=r*2,c=a*2;return{tileCountWidth:s,tileRadiusWidth:r,restWidth:i,tileCountHeight:o,tileRadiusHeight:a,restHeight:l,tileWidth:u,tileHeight:c}},I$e=(t,e,n,s,r,i)=>{let o=0,a=0,l=0,u=0;return t>n-2-r?(o=1,l=t-1-(n-2-r)):e>s-2-i&&(a=1,u=e-1-(s-2-i)),{tileCenterWidth:o,tileCenterHeight:a,cumulativeOffsetWidth:l,cumulativeOffsetHeight:u}},k$e=(t,e,n)=>{const s=e*n,r=new Float32Array(s*4);for(let i=0;i<s;i++){const o=i*3,a=i*4;r[a]=t[o],r[a+1]=t[o+1],r[a+2]=t[o+2],r[a+3]=255}return r},E$e=(t,e,n)=>{const s=e*n,r=new Float32Array(s*3);for(let i=0;i<s;i++){const o=i*4,a=i*3;r[a]=t[o],r[a+1]=t[o+1],r[a+2]=t[o+2]}return r},_$e=async(t,e,n)=>{const s=performance.now();S$e(4256);const r=C$e(e,nC(t)),i=nC(t),o=i.width,a=i.height,l=T$e(o,a,r),u=performance.now();console.log(`setSeed: ${u-s} ms`);let c=mX(o,a);const h=await qo(a$e)(i),{eigenVectors:d}=h,f=h.output,p=performance.now();console.log(`setSeed: ${p-s} ms`);const g=new Float32Array(f.data),m=E$e(g,f.width,f.height),x=await qo(v$e)({data:m,width:f.width,height:f.height},o,a,r),b=k$e(x.data,o,a);c.data=Array.from(b),qo(x$e)(c,f,l,o,a),c=await qo(f$e)(c,i,d);const v=new ImageData(new Uint8ClampedArray(c.data),c.width,c.height),y=performance.now();return console.log(`setSeed: ${y-s} ms`),v};async function fw(t,e){const n=e.createBuffer({size:t.data.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new Uint8Array(n.getMappedRange()).set(t.data),n.unmap(),n}async function $$e(t,e){const n=await Ts(),s=new Image;s.crossOrigin="anonymous",await new Promise((a,l)=>{s.onload=()=>a(),s.onerror=()=>l(new Error("")),s.src=t});const r=RE(s,e),i=r.getContext("2d").getImageData(0,0,r.width,r.height);return{buffer:await fw(i,n),width:i.width,height:i.height}}const R$e=" ",A$e=" :";function P$e(t,e){const n={intensity:t.lutIntensity||1};return t.maskData?(console.warn(A$e,e),n.maskData={data:t.maskData,width:e.width,height:e.height},n.maskIntensity=1,n.enableMask=!0,n):(console.warn(R$e),n)}async function D$e(t){const{imageData:e,lutData:n,maskOptions:s,device:r}=t,i=await pX({data:new Uint8Array(e.data.buffer),width:e.width,height:e.height},n,s);if(!i.success||!i.result)return null;const o=new ImageData(new Uint8ClampedArray(i.result),e.width,e.height);return{buffer:await fw(o,r),width:e.width,height:e.height}}async function N$e(t,e){if(!e.lutFile)return t;const n=await Ts();try{const s=await El(t.buffer,t.width,t.height,n),r=await fX(e.lutFile,e.lutFile.name),i=P$e(e,s),o=await D$e({imageData:s,lutData:r.data,maskOptions:i,device:n});if(o)return t.buffer.destroy(),{buffer:o.buffer,width:t.width,height:t.height}}catch(s){console.warn("LUT:",s)}return t}async function M$e(t,e){if(e.borderSize===0)return t;const n=await Ts(),s=await El(t.buffer,t.width,t.height,n),r=await _$e(s,e.borderSize),i=await fw(r,n);return t.buffer.destroy(),{buffer:i,width:r.width,height:r.height}}async function L$e(t){const e=await Ts(),n=await El(t.buffer,t.width,t.height,e),s=document.createElement("canvas");return s.width=n.width,s.height=n.height,s.getContext("2d").putImageData(n,0,0),s.toDataURL()}let O$e=null,pw=null,Ch=null;const mw=async()=>Ch||(Ch=(async()=>{try{if(!navigator.gpu)throw new Error("WebGPU");const t=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!t)throw new Error("WebGPU");O$e=t;const e=await t.requestDevice({requiredFeatures:[],requiredLimits:{maxStorageBufferBindingSize:1024*1024*1024,maxBufferSize:1024*1024*1024}});return pw=e,console.log("WebGPU"),e}catch(t){throw console.warn("WebGPU:",t),Ch=null,t}})(),Ch),lT=()=>pw,F$e=()=>pw!==null;mw().catch(t=>{console.warn("WebGPU:",t)});const U$e=(t,e,n,s="rgba8unorm",r=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)=>t.createTexture({size:{width:e,height:n},format:s,usage:r}),gw=(t,e,n="",s=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC)=>t.createBuffer({label:n,size:e,usage:s}),Jo=new Map,B$e=t=>{const{width:e,height:n,data:s}=t;let r=`${e}x${n}`;if(s.length>1024){const i=Array.from(s.slice(0,512)),o=Array.from(s.slice(-512));r+=`_${i.join(",")}_${o.join(",")}`}else r+=`_${Array.from(s).join(",")}`;return r},z$e=(t=10)=>{if(Jo.size>t){const n=Array.from(Jo.entries()).slice(0,Jo.size-t);for(const[s,r]of n)r.destroy(),Jo.delete(s);console.log(` ${n.length} `)}},G$e=async(t,e,n=!0)=>{if(e.data.length===0)throw new Error("");const s=n?B$e(e):null;if(n&&s&&Jo.has(s))return console.log(""),Jo.get(s);const r=U$e(t,e.width,e.height,"rgba8unorm",GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC),i=Math.ceil(e.width*4/256)*256,o=new Uint8Array(i*e.height);for(let a=0;a<e.height;a++){const l=a*e.width*4,u=a*i;o.set(e.data.slice(l,l+e.width*4),u)}return t.queue.writeTexture({texture:r},o,{bytesPerRow:i},{width:e.width,height:e.height}),await t.queue.onSubmittedWorkDone(),n&&s&&(Jo.set(s,r),console.log(`: ${Jo.size}`),z$e()),r},V$e=async(t,e,n,s)=>{const r=n*s*4*4,i=t.createBuffer({size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),o=t.createCommandEncoder();o.copyBufferToBuffer(e,0,i,0,r),t.queue.submit([o.finish()]),await i.mapAsync(GPUMapMode.READ);const a=i.getMappedRange(),l=new Float32Array(a.slice(0));if(i.unmap(),l.length===0)throw new Error("");const u=new Uint8ClampedArray(n*s*4);for(let c=0;c<n*s*4;c++)u[c]=Math.max(0,Math.min(255,Math.round(l[c]*255)));return new ImageData(u,n,s)},W$e=async(t,e,n,s,r,i=.1)=>{const o=t.createBuffer({size:s*r*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),a=t.createCommandEncoder();a.copyBufferToBuffer(e,0,o,0,s*r*4),t.queue.submit([a.finish()]),await o.mapAsync(GPUMapMode.READ);const l=o.getMappedRange(),u=new Float32Array(l.slice(0));o.unmap();const c=64,h=Math.max(1,Math.floor(s/c)),d=Math.max(1,Math.floor(r/c)),f=[],p=[];for(let S=0;S<c;S++)for(let E=0;E<c;E++){const _=Math.floor(E*h),P=Math.floor(S*d)*s+_;if(P<u.length){f.push(u[P]);const M=P*4;M<n.data.length-3&&p.push({r:n.data[M]/255,g:n.data[M+1]/255,b:n.data[M+2]/255,luminance:(n.data[M]*.299+n.data[M+1]*.587+n.data[M+2]*.114)/255})}}const g=f.length,m=Math.floor(g*i);class x{constructor(){this.heap=[]}insert(E){this.heap.push(E),this.bubbleUp()}removeMin(){if(this.heap.length===0)return null;if(this.heap.length===1)return this.heap.pop();const E=this.heap[0];return this.heap[0]=this.heap.pop(),this.bubbleDown(),E}peek(){return this.heap[0]}size(){return this.heap.length}bubbleUp(){let E=this.heap.length-1;for(;E>0;){const _=Math.floor((E-1)/2);if(this.heap[E].darkChannel>=this.heap[_].darkChannel)break;[this.heap[E],this.heap[_]]=[this.heap[_],this.heap[E]],E=_}}bubbleDown(){let E=0;for(;;){let _=E;const N=2*E+1,P=2*E+2;if(N<this.heap.length&&this.heap[N].darkChannel<this.heap[_].darkChannel&&(_=N),P<this.heap.length&&this.heap[P].darkChannel<this.heap[_].darkChannel&&(_=P),_===E)break;[this.heap[E],this.heap[_]]=[this.heap[_],this.heap[E]],E=_}}}const b=new x;for(let S=0;S<g;S++){const E={index:S,darkChannel:f[S],pixel:p[S]};b.size()<m?b.insert(E):E.darkChannel>b.peek().darkChannel&&(b.removeMin(),b.insert(E))}const v=[];for(;b.size()>0;)v.push(b.removeMin());v.sort((S,E)=>E.darkChannel-S.darkChannel);let y=0,C=0,I=0,$=0,T=0;for(let S=0;S<v.length;S++){const E=v[S],_=E.pixel;_.r>y&&(y=_.r),_.g>C&&(C=_.g),_.b>I&&(I=_.b),_.luminance>$&&($=_.luminance,T=E.darkChannel)}return{r:y,g:C,b:I,luminance:$,maxDarkChannel:T,pixelCount:m}},H$e=t=>t.createShaderModule({label:"DarkChannelShader",code:`
      struct Uniforms {
        width: f32,
        height: f32,
        windowSize: f32,
      }
      
      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(0) @binding(1) var inputTexture: texture_2d<f32>;
      @group(0) @binding(2) var<storage, read_write> outputBuffer: array<f32>;
      
      @compute @workgroup_size(16, 8)
      fn computeDarkChannel(@builtin(global_invocation_id) globalId: vec3<u32>) {
        let x = globalId.x;
        let y = globalId.y;
        
        if (x >= u32(uniforms.width) || y >= u32(uniforms.height)) {
          return;
        }
        
        let halfWindow = u32(uniforms.windowSize / 2.0);
        var minValue: f32 = 1.0;
        
        // 
        let startX = max(halfWindow, x);
        let endX = min(u32(uniforms.width) - 1 - halfWindow, x);
        let startY = max(halfWindow, y);
        let endY = min(u32(uniforms.height) - 1 - halfWindow, y);
        
        // 
        var actualHalfWindow = halfWindow;
        if (x < halfWindow || x >= u32(uniforms.width) - halfWindow ||
            y < halfWindow || y >= u32(uniforms.height) - halfWindow) {
          // 
          actualHalfWindow = min(halfWindow, min(x, min(u32(uniforms.width) - 1 - x,
                                                     min(y, u32(uniforms.height) - 1 - y))));
        }
        
        for (var wy = y - actualHalfWindow; wy <= y + actualHalfWindow; wy++) {
          for (var wx = x - actualHalfWindow; wx <= x + actualHalfWindow; wx++) {
            // 
            if (wx < u32(uniforms.width) && wy < u32(uniforms.height)) {
              let pixel = textureLoad(inputTexture, vec2<i32>(i32(wx), i32(wy)), 0);
              // rgba8unorm0-1f32
              
              // 
              // ITU-R BT.709R:0.299, G:0.587, B:0.114
              let luminance = pixel.r * 0.299 + pixel.g * 0.587 + pixel.b * 0.114;
              let minChannel = min(min(pixel.r, pixel.g), pixel.b);
              
              // 
              let darkChannel = min(luminance, minChannel);
              minValue = min(minValue, darkChannel);
            }
          }
        }
        
        let outputIndex = y * u32(uniforms.width) + x;
        outputBuffer[outputIndex] = minValue;
      }
    `}),K$e=t=>t.createShaderModule({label:"TransmissionShader",code:`
      struct Uniforms {
        width: f32,
        height: f32,
        atmosphericLight: f32,
        omega: f32,
      }
      
      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(0) @binding(1) var<storage, read> darkChannelBuffer: array<f32>;
      @group(0) @binding(2) var<storage, read_write> transmissionBuffer: array<f32>;
      
      @compute @workgroup_size(16, 8)
      fn estimateTransmission(@builtin(global_invocation_id) globalId: vec3<u32>) {
        let x = globalId.x;
        let y = globalId.y;
        
        if (x >= u32(uniforms.width) || y >= u32(uniforms.height)) {
          return;
        }
        
        let pixelIndex = y * u32(uniforms.width) + x;
        let darkValue = darkChannelBuffer[pixelIndex];
        let transmission = 1.0 - uniforms.omega * (darkValue / uniforms.atmosphericLight);
        transmissionBuffer[pixelIndex] = transmission;
      }
    `}),j$e=t=>t.createShaderModule({label:"SpatialAdaptiveTransmissionShader",code:`
      struct Uniforms {
        width: f32,
        height: f32,
        atmosphericLight: f32,
        userOmega: f32,
        userT0: f32,
        omegaAdjustRange: f32,
        t0AdjustRange: f32,
        hazeWeight: f32,
        atmosphericWeight: f32,
        adaptiveStrength: f32,
        _padding: f32, // 16
      }
      
      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(0) @binding(1) var<storage, read> darkChannelBuffer: array<f32>;
      @group(0) @binding(2) var<storage, read_write> transmissionBuffer: array<f32>;
      
      // omegat0
      fn computeSpatialAdaptiveParameters(darkValue: f32) -> vec2<f32> {
        // 
        let hazeFactor = min(1.0, darkValue * 1.5);
        
        // 
        let atmosphericFactor = min(1.0, uniforms.atmosphericLight * 1.2);
        
        //  - 
        let contrastFactor = min(1.0, darkValue * 1.2);
        
        // 
        let adaptiveFactor = 
          uniforms.hazeWeight * hazeFactor +
          uniforms.atmosphericWeight * atmosphericFactor +
          (1.0 - uniforms.hazeWeight - uniforms.atmosphericWeight) * contrastFactor;
        
        // 
        // adaptiveStrength
        var adjustedAdaptiveFactor: f32;
        if (uniforms.adaptiveStrength < 1.0) {
          // 
          // 
          let reductionFactor = 1.0 - uniforms.adaptiveStrength;
          adjustedAdaptiveFactor = adaptiveFactor * (1.0 - reductionFactor * adaptiveFactor);
        } else if (uniforms.adaptiveStrength > 1.0) {
          // 
          // 
          let enhancementFactor = uniforms.adaptiveStrength - 1.0;
          let relativeEnhancement = enhancementFactor * adaptiveFactor;
          adjustedAdaptiveFactor = min(1.0, adaptiveFactor + relativeEnhancement);
        } else {
          // 
          adjustedAdaptiveFactor = adaptiveFactor;
        }
        
        // omega
        let omegaAdjustment = uniforms.omegaAdjustRange * adjustedAdaptiveFactor;
        let adaptiveOmega = uniforms.userOmega + omegaAdjustment;
        
        // t0
        let t0Adjustment = uniforms.t0AdjustRange * adjustedAdaptiveFactor;
        let adaptiveT0 = uniforms.userT0 + t0Adjustment;
        
        // 
        return vec2<f32>(
          clamp(adaptiveOmega, 0.1, 0.99),
          clamp(adaptiveT0, 0.01, 0.3)
        );
      }
      
      @compute @workgroup_size(16, 8)
      fn estimateSpatialAdaptiveTransmission(@builtin(global_invocation_id) globalId: vec3<u32>) {
        let x = globalId.x;
        let y = globalId.y;
        
        if (x >= u32(uniforms.width) || y >= u32(uniforms.height)) {
          return;
        }
        
        let pixelIndex = y * u32(uniforms.width) + x;
        let darkValue = darkChannelBuffer[pixelIndex];
        
        // 
        let adaptiveParams = computeSpatialAdaptiveParameters(darkValue);
        let adaptiveOmega = adaptiveParams.x;
        let adaptiveT0 = adaptiveParams.y;
        
        // omega
        var transmission = 1.0 - adaptiveOmega * (darkValue / uniforms.atmosphericLight);
        
        // 
        transmission = max(transmission, adaptiveT0);
        transmissionBuffer[pixelIndex] = transmission;
      }
    `}),X$e=t=>t.createShaderModule({label:"RecoverImageShader",code:`
      struct Uniforms {
        width: f32,
        height: f32,
        atmosphericLightR: f32,
        atmosphericLightG: f32,
        atmosphericLightB: f32,
        atmosphericLightLuminance: f32,
        t0: f32,
      }
      
      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(0) @binding(1) var inputTexture: texture_2d<f32>;
      @group(0) @binding(2) var<storage, read> transmissionBuffer: array<f32>;
      @group(0) @binding(3) var<storage, read_write> outputBuffer: array<f32>;
      
      @compute @workgroup_size(16, 8)
      fn recoverImage(@builtin(global_invocation_id) globalId: vec3<u32>) {
        let x = globalId.x;
        let y = globalId.y;
        
        if (x >= u32(uniforms.width) || y >= u32(uniforms.height)) {
          return;
        }
        
        // Y
        let pos = vec2<i32>(i32(x), i32(y));
        let pixel = textureLoad(inputTexture, pos, 0);
        
        // rgba8unorm0-1f32
        let r = pixel.r;
        let g = pixel.g;
        let b = pixel.b;
        let a = pixel.a;
        
        let transmission = max(transmissionBuffer[y * u32(uniforms.width) + x], uniforms.t0);
        
        // 
        // 
        let originalLuminance = r * 0.299 + g * 0.587 + b * 0.114;
        
        // 
        let recoveredLuminance = (originalLuminance - uniforms.atmosphericLightLuminance) / transmission + uniforms.atmosphericLightLuminance;
        
        // 
        let luminanceRatio = recoveredLuminance / max(originalLuminance, 1e-6);
        
        // RGB
        let recoveredR = (r - uniforms.atmosphericLightR) / transmission + uniforms.atmosphericLightR;
        let recoveredG = (g - uniforms.atmosphericLightG) / transmission + uniforms.atmosphericLightG;
        let recoveredB = (b - uniforms.atmosphericLightB) / transmission + uniforms.atmosphericLightB;
        
        // 
        let finalR = mix(recoveredR, r * luminanceRatio, 0.7);
        let finalG = mix(recoveredG, g * luminanceRatio, 0.7);
        let finalB = mix(recoveredB, b * luminanceRatio, 0.7);
        
        let outputIndex = (y * u32(uniforms.width) + x) * 4u;
        // f32u32
        outputBuffer[outputIndex] = clamp(finalR, 0.0, 1.0);
        outputBuffer[outputIndex + 1u] = clamp(finalG, 0.0, 1.0);
        outputBuffer[outputIndex + 2u] = clamp(finalB, 0.0, 1.0);
        outputBuffer[outputIndex + 3u] = a;
      }
    `}),q$e=t=>t.createShaderModule({label:"EnhancedRecoverImageShader",code:`
      struct Uniforms {
        width: f32,
        height: f32,
        atmosphericLightR: f32,
        atmosphericLightG: f32,
        atmosphericLightB: f32,
        atmosphericLightLuminance: f32,
        t0: f32,
        saturationEnhancement: f32,  //  (0.0-2.0)
        contrastEnhancement: f32,    //  (0.5-2.0)
        brightnessEnhancement: f32,  //  (0.5-2.0)
        enableEnhancement: f32,      //  (0.01.0)
        _padding1: f32,              // 16
      }
      
      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(0) @binding(1) var inputTexture: texture_2d<f32>;
      @group(0) @binding(2) var<storage, read> transmissionBuffer: array<f32>;
      @group(0) @binding(3) var<storage, read_write> outputBuffer: array<f32>;
      
      // RGBHSV
      fn rgbToHsv(r: f32, g: f32, b: f32) -> vec3<f32> {
        let maxVal = max(max(r, g), b);
        let minVal = min(min(r, g), b);
        let delta = maxVal - minVal;
        
        var h: f32 = 0.0;
        var s: f32 = 0.0;
        let v = maxVal;
        
        if (delta != 0.0) {
          if (maxVal == r) {
            h = ((g - b) / delta) % 6.0;
          } else if (maxVal == g) {
            h = (b - r) / delta + 2.0;
          } else {
            h = (r - g) / delta + 4.0;
          }
          h = h * 60.0;
          if (h < 0.0) {
            h = h + 360.0;
          }
          
          if (maxVal != 0.0) {
            s = delta / maxVal;
          }
        }
        
        return vec3<f32>(h, s, v);
      }
      
      // HSVRGB
      fn hsvToRgb(h: f32, s: f32, v: f32) -> vec3<f32> {
        let c = v * s;
        let x = c * (1.0 - abs((h / 60.0) % 2.0 - 1.0));
        let m = v - c;
        
        var r: f32 = 0.0;
        var g: f32 = 0.0;
        var b: f32 = 0.0;
        
        if (h < 60.0) {
          r = c; g = x; b = 0.0;
        } else if (h < 120.0) {
          r = x; g = c; b = 0.0;
        } else if (h < 180.0) {
          r = 0.0; g = c; b = x;
        } else if (h < 240.0) {
          r = 0.0; g = x; b = c;
        } else if (h < 300.0) {
          r = x; g = 0.0; b = c;
        } else {
          r = c; g = 0.0; b = x;
        }
        
        return vec3<f32>(r + m, g + m, b + m);
      }
      
      // 
      fn enhanceSaturation(r: f32, g: f32, b: f32, factor: f32) -> vec3<f32> {
        let hsv = rgbToHsv(r, g, b);
        let enhancedS = clamp(hsv.y * factor, 0.0, 1.0);
        return hsvToRgb(hsv.x, enhancedS, hsv.z);
      }
      
      // 
      fn enhanceContrast(r: f32, g: f32, b: f32, factor: f32) -> vec3<f32> {
        return vec3<f32>(
          clamp((r - 0.5) * factor + 0.5, 0.0, 1.0),
          clamp((g - 0.5) * factor + 0.5, 0.0, 1.0),
          clamp((b - 0.5) * factor + 0.5, 0.0, 1.0)
        );
      }
      
      // 
      fn enhanceBrightness(r: f32, g: f32, b: f32, factor: f32) -> vec3<f32> {
        return vec3<f32>(
          clamp(r * factor, 0.0, 1.0),
          clamp(g * factor, 0.0, 1.0),
          clamp(b * factor, 0.0, 1.0)
        );
      }
      
      @compute @workgroup_size(16, 8)
      fn recoverImage(@builtin(global_invocation_id) globalId: vec3<u32>) {
        let x = globalId.x;
        let y = globalId.y;
        
        if (x >= u32(uniforms.width) || y >= u32(uniforms.height)) {
          return;
        }
        
        // 
        let pos = vec2<i32>(i32(x), i32(y));
        let pixel = textureLoad(inputTexture, pos, 0);
        
        let r = pixel.r;
        let g = pixel.g;
        let b = pixel.b;
        let a = pixel.a;
        
        let transmission = max(transmissionBuffer[y * u32(uniforms.width) + x], uniforms.t0);
        
        // 
        let originalLuminance = r * 0.299 + g * 0.587 + b * 0.114;
        
        // 
        let recoveredLuminance = (originalLuminance - uniforms.atmosphericLightLuminance) / transmission + uniforms.atmosphericLightLuminance;
        
        // 
        let luminanceRatio = recoveredLuminance / max(originalLuminance, 1e-6);
        
        // RGB
        let recoveredR = (r - uniforms.atmosphericLightR) / transmission + uniforms.atmosphericLightR;
        let recoveredG = (g - uniforms.atmosphericLightG) / transmission + uniforms.atmosphericLightG;
        let recoveredB = (b - uniforms.atmosphericLightB) / transmission + uniforms.atmosphericLightB;
        
        // 
        var finalR = mix(recoveredR, r * luminanceRatio, 0.7);
        var finalG = mix(recoveredG, g * luminanceRatio, 0.7);
        var finalB = mix(recoveredB, b * luminanceRatio, 0.7);
        
        // 
        if (uniforms.enableEnhancement > 0.5) {
          // 
          let saturated = enhanceSaturation(finalR, finalG, finalB, uniforms.saturationEnhancement);
          
          // 
          let contrasted = enhanceContrast(saturated.x, saturated.y, saturated.z, uniforms.contrastEnhancement);
          
          // 
          let brightened = enhanceBrightness(contrasted.x, contrasted.y, contrasted.z, uniforms.brightnessEnhancement);
          
          finalR = brightened.x;
          finalG = brightened.y;
          finalB = brightened.z;
        }
        
        let outputIndex = (y * u32(uniforms.width) + x) * 4u;
        // f32u32
        outputBuffer[outputIndex] = clamp(finalR, 0.0, 1.0);
        outputBuffer[outputIndex + 1u] = clamp(finalG, 0.0, 1.0);
        outputBuffer[outputIndex + 2u] = clamp(finalB, 0.0, 1.0);
        outputBuffer[outputIndex + 3u] = a;
      }
    `}),Y$e=async(t,e,n,s,r,i=.95)=>{const o=K$e(t),a=gw(t,s*r*4,"TransmissionBuffer"),l=t.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),u=new Float32Array([s,r,n,i]);t.queue.writeBuffer(l,0,u);const c=t.createComputePipeline({label:"TransmissionPipeline",layout:"auto",compute:{module:o,entryPoint:"estimateTransmission"}}),h=t.createBindGroup({label:"TransmissionBindGroup",layout:c.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:l}},{binding:1,resource:{buffer:e}},{binding:2,resource:{buffer:a}}]}),d=t.createCommandEncoder(),f=d.beginComputePass();return f.setPipeline(c),f.setBindGroup(0,h),f.dispatchWorkgroups(Math.ceil(s/16),Math.ceil(r/8)),f.end(),t.queue.submit([d.finish()]),await t.queue.onSubmittedWorkDone(),a},Z$e=async(t,e,n,s,r,i,o,a={})=>{const{omegaAdjustRange:l=.2,t0AdjustRange:u=.05,hazeWeight:c=.6,atmosphericWeight:h=.4,adaptiveStrength:d=1}=a,f=j$e(t),p=gw(t,s*r*4,"SpatialAdaptiveTransmissionBuffer"),g=t.createBuffer({label:"SpatialAdaptiveTransmissionUniformBuffer",size:44,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),m=new Float32Array([s,r,n,i,o,l,u,c,h,d,0]);t.queue.writeBuffer(g,0,m);const x=t.createComputePipeline({label:"SpatialAdaptiveTransmissionPipeline",layout:"auto",compute:{module:f,entryPoint:"estimateSpatialAdaptiveTransmission"}}),b=t.createBindGroup({label:"SpatialAdaptiveTransmissionBindGroup",layout:x.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:g}},{binding:1,resource:{buffer:e}},{binding:2,resource:{buffer:p}}]}),v=t.createCommandEncoder(),y=v.beginComputePass();return y.setPipeline(x),y.setBindGroup(0,b),y.dispatchWorkgroups(Math.ceil(s/16),Math.ceil(r/8)),y.end(),t.queue.submit([v.finish()]),await t.queue.onSubmittedWorkDone(),p},Q$e=(t,e,n,s,r,i,o,a,l,u,c)=>{const h=a?`_e_s${l.toFixed(2)}_c${u.toFixed(2)}_b${c.toFixed(2)}`:"";return`${t}x${e}_${n.toFixed(3)}_${s.toFixed(3)}_${r.toFixed(3)}_${i.toFixed(3)}_${o.toFixed(3)}${h}`},tm=new Map,Xb=new Map,qb=new Map,Yb=new Map,J$e=(t,e,n=!1)=>{if(tm.has(e)){const i=tm.get(e);try{return i.getBindGroupLayout(0),i}catch{tm.delete(e)}}let s;try{s=n?q$e(t):X$e(t)}catch(i){throw new Error(`: ${i.message}`)}const r=t.createComputePipeline({label:n?"EnhancedRecoverImagePipeline":"RecoverImagePipeline",layout:"auto",compute:{module:s,entryPoint:"recoverImage"}});return tm.set(e,r),r},eRe=(t,e,n,s=!1)=>{const r=s?48:32;if(Xb.has(e)){const o=Xb.get(e);if(o.size===r)return t.queue.writeBuffer(o,0,n),o}const i=t.createBuffer({size:r,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return t.queue.writeBuffer(i,0,n),Xb.set(e,i),i},tRe=(t,e,n,s)=>{if(qb.has(e)){const o=qb.get(e),a=n*s*4*4;if(o.size>=a){const l=new Float32Array(n*s*4);return t.queue.writeBuffer(o,0,l),o}}const r=t.createBuffer({size:n*s*4*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),i=new Float32Array(n*s*4);return t.queue.writeBuffer(r,0,i),qb.set(e,r),r},nRe=(t,e,n,s,r,i,o)=>{if(Yb.has(e)){const c=Yb.get(e).layout||n.getBindGroupLayout(0);return t.createBindGroup({label:"RecoverImageBindGroup",layout:c,entries:[{binding:0,resource:{buffer:s}},{binding:1,resource:r.createView()},{binding:2,resource:{buffer:i}},{binding:3,resource:{buffer:o}}]})}const a=n.getBindGroupLayout(0),l=t.createBindGroup({label:"RecoverImageBindGroup",layout:a,entries:[{binding:0,resource:{buffer:s}},{binding:1,resource:r.createView()},{binding:2,resource:{buffer:i}},{binding:3,resource:{buffer:o}}]});return Yb.set(e,{layout:a}),l},sRe=async(t,e,n,s,r,i,o=.1,a={})=>{const{enableEnhancement:l=!1,saturationEnhancement:u=1.2,contrastEnhancement:c=1.1,brightnessEnhancement:h=1}=a;let d,f,p,g;if(typeof s=="object"&&s.r!==void 0)d=s.r,f=s.g,p=s.b,g=s.luminance;else{const E=s;d=E,f=E,p=E,g=E}const m=Q$e(r,i,d,f,p,g,o,l,u,c,h),x=J$e(t,m,l);let b;l?b=new Float32Array([r,i,d,f,p,g,o,u,c,h,l?1:0,0]):b=new Float32Array([r,i,d,f,p,g,o]);const v=eRe(t,m,b,l),y=tRe(t,m,r,i);let C;try{C=nRe(t,m,x,v,e,n,y)}catch(E){throw new Error(`BindGroup: ${E.message}`)}const I=t.createCommandEncoder(),$=I.beginComputePass();$.setPipeline(x),$.setBindGroup(0,C);const T=Math.ceil(r/16),S=Math.ceil(i/8);return $.dispatchWorkgroups(T,S),$.end(),t.queue.submit([I.finish()]),await t.queue.onSubmittedWorkDone(),y},ea=new Map;let xy=null,by=null,Th=null;const PN=async t=>Th||(Th=(async()=>{try{console.log("...");const e=H$e(t),n=t.createComputePipeline({label:"DarkChannelPipeline",layout:"auto",compute:{module:e,entryPoint:"computeDarkChannel"}});return xy=e,by=n,console.log(""),{shader:e,pipeline:n}}catch(e){throw console.warn(":",e),Th=null,e}})(),Th),rRe=async t=>xy&&by?{shader:xy,pipeline:by}:await PN(t),iRe=(t,e,n,s)=>`${t}_${e}x${n}_${s}`,oRe=(t=5)=>{if(ea.size>t){const n=Array.from(ea.entries()).slice(0,ea.size-t);for(const[s,r]of n)r.destroy(),ea.delete(s);console.log(` ${n.length} `)}},aRe=async(t,e,n,s,r=15,i=!0)=>{const o=i?iRe(e,n,s,r):null;if(i&&o&&ea.has(o))return console.log(""),ea.get(o);const{shader:a,pipeline:l}=await rRe(t),u=gw(t,n*s*4,"DarkChannelOutputBuffer"),c=t.createBuffer({label:"DarkChannelUniformBuffer",size:12,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),h=new Float32Array([n,s,r]);t.queue.writeBuffer(c,0,h);const d=t.createBindGroup({label:"DarkChannelBindGroup",layout:l.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:c}},{binding:1,resource:e.createView({format:"rgba8unorm"})},{binding:2,resource:{buffer:u}}]}),f=t.createCommandEncoder(),p=f.beginComputePass();return p.setPipeline(l),p.setBindGroup(0,d),p.dispatchWorkgroups(Math.ceil(n/16),Math.ceil(s/8)),p.end(),t.queue.submit([f.finish()]),await t.queue.onSubmittedWorkDone(),i&&o&&(ea.set(o,u),console.log(`: ${ea.size}`),oRe()),u},lRe=(t,e,n)=>{const s=e*n;let r=0,i=1,o=0,a=0;for(let v=0;v<s;v++){const y=t[v];r+=y,i=Math.min(i,y),o=Math.max(o,y)}const l=r/s;for(let v=0;v<s;v++){const y=t[v]-l;a+=y*y}const u=a/s,c=Math.sqrt(u),h=new Float32Array(t);h.sort();const d=h[Math.floor(s*.25)],f=h[Math.floor(s*.5)],p=h[Math.floor(s*.75)],g=h[Math.floor(s*.9)],m=(l+p)/2,x=(o-i)/(o+i+1e-6),b=1-c/(l+1e-6);return{mean:l,stdDev:c,min:i,max:o,q25:d,q50:f,q75:p,q90:g,variance:u,hazeIntensity:m,contrastRatio:x,uniformityIndex:b}},uRe=(t,e,n,s,r={})=>{const{omegaAdjustRange:i=.2,t0AdjustRange:o=.05,hazeWeight:a=.6,atmosphericWeight:l=.4,adaptiveStrength:u=1}=r,c=Math.min(1,t.hazeIntensity*1.5),h=Math.min(1,e*1.2),d=Math.max(.5,1-t.contrastRatio),f=Math.min(1,t.uniformityIndex*1.3),p=a*c+l*h+(1-a-l)*(d+f)/2;let g;if(u<1){const $=1-u;g=p*(1-$*p)}else if(u>1){const T=(u-1)*p;g=Math.min(1,p+T)}else g=p;const m=i*g,x=n+m,b=Math.max(.1,Math.min(.99,x)),v=o*g,y=s+v,C=Math.max(.01,Math.min(.3,y)),I=Math.min(1,t.hazeIntensity*.4+e*.4+(1-t.contrastRatio)*.2);return{omega:b,t0:C,adaptiveFactor:p,adjustedAdaptiveFactor:g,adaptiveStrength:u,hazeLevel:I,stats:{hazeIntensity:t.hazeIntensity,atmosphericLight:e,contrastRatio:t.contrastRatio,uniformityIndex:t.uniformityIndex}}},cRe=(t,e,n,s,r,i,o={})=>{const a=lRe(t,n,s),l=uRe(a,e,r,i,o),u=hRe(l.hazeLevel,a);return{...l,darkStats:a,description:u}},hRe=(t,e)=>{let n="",s=[];return t<.3?n="":t<.6?n="":t<.8?n="":n="",e.contrastRatio<.3&&s.push(""),e.uniformityIndex>.7&&s.push(""),e.hazeIntensity>.6&&s.push(""),`${n} (${Math.round(t*100)}%) - ${s.join(", ")}`},dRe=async(t,e={})=>{console.time("");const{windowSize:n=15,topRatio:s=.1,omega:r=.95,t0:i=.1,adaptiveMode:o=!1,spatialAdaptiveMode:a=!1,adaptiveStrength:l=1,adaptiveOptions:u={},enhancementOptions:c={}}=e;if(!t||!t.data||t.data.length===0)throw new Error("");const{width:h,height:d}=t;console.time("WebGPU");let f;if(F$e())f=lT(),console.timeEnd("WebGPU");else{try{await mw(),f=lT()}catch(p){throw new Error(`WebGPU: ${p.message}`)}console.timeEnd("WebGPU")}console.time("");try{await PN(f),console.timeEnd("")}catch(p){console.warn(":",p),console.timeEnd("")}try{console.time("");const p=await G$e(f,t);console.timeEnd(""),console.time("");const g=await aRe(f,p,h,d,n);console.timeEnd(""),console.time("");const m=f.createBuffer({size:h*d*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),x=f.createCommandEncoder();x.copyBufferToBuffer(g,0,m,0,h*d*4),f.queue.submit([x.finish()]),await m.mapAsync(GPUMapMode.READ);const b=m.getMappedRange(),v=new Float32Array(b.slice(0));m.unmap();const y=new Uint8ClampedArray(h*d);for(let N=0;N<h*d;N++)y[N]=Math.round(v[N]*255);console.timeEnd(""),console.time("");const C=await W$e(f,g,t,h,d,s,"all");console.timeEnd(""),console.time("");let I=r,$=i,T=null;o&&(T=cRe(v,C.luminance,h,d,r,i,{...u,adaptiveStrength:l}),I=T.omega,$=T.t0),console.timeEnd(""),console.time("");let S;a?S=await Z$e(f,g,C.luminance,h,d,I,i,{...u,adaptiveStrength:l}):S=await Y$e(f,g,C.luminance,h,d,I),console.timeEnd(""),a&&($=Math.max(i*.8,.05)),console.time("");const E=await sRe(f,p,S,C,h,d,$,c);console.timeEnd(""),console.time("");const _=await V$e(f,E,h,d);return console.timeEnd(""),console.timeEnd(""),{imageData:_,adaptiveInfo:T,originalOmega:r,finalOmega:I,atmosphericLight:C,spatialAdaptiveMode:a,enhancementOptions:c}}catch(p){throw console.timeEnd(""),p}},xw={light:{omega:.8,t0:.15,windowSize:15,topRatio:.1,adaptiveMode:!1,spatialAdaptiveMode:!1,adaptiveStrength:1,hazeWeight:.5,atmosphericWeight:.3,enableEnhancement:!1,saturationEnhancement:1.1,contrastEnhancement:1.05,brightnessEnhancement:1},medium:{omega:.9,t0:.1,windowSize:15,topRatio:.1,adaptiveMode:!1,spatialAdaptiveMode:!1,adaptiveStrength:1,hazeWeight:.5,atmosphericWeight:.3,enableEnhancement:!1,saturationEnhancement:1.2,contrastEnhancement:1.1,brightnessEnhancement:1},heavy:{omega:.95,t0:.05,windowSize:21,topRatio:.05,adaptiveMode:!1,spatialAdaptiveMode:!1,adaptiveStrength:1,hazeWeight:.5,atmosphericWeight:.3,enableEnhancement:!1,saturationEnhancement:1.3,contrastEnhancement:1.15,brightnessEnhancement:1.05},adaptive:{omega:.95,t0:.1,windowSize:15,topRatio:.1,adaptiveMode:!0,spatialAdaptiveMode:!1,adaptiveStrength:1.2,hazeWeight:.6,atmosphericWeight:.3,enableEnhancement:!1,saturationEnhancement:1.2,contrastEnhancement:1.1,brightnessEnhancement:1},spatialAdaptive:{omega:.95,t0:.1,windowSize:15,topRatio:.1,adaptiveMode:!0,spatialAdaptiveMode:!0,adaptiveStrength:1.3,hazeWeight:.7,atmosphericWeight:.2,enableEnhancement:!1,saturationEnhancement:1.2,contrastEnhancement:1.1,brightnessEnhancement:1},enhanced:{omega:.9,t0:.1,windowSize:15,topRatio:.1,adaptiveMode:!1,spatialAdaptiveMode:!1,adaptiveStrength:1,hazeWeight:.5,atmosphericWeight:.3,enableEnhancement:!0,saturationEnhancement:1.4,contrastEnhancement:1.2,brightnessEnhancement:1.1},default:{omega:.95,t0:.1,windowSize:15,topRatio:.1,adaptiveMode:!1,spatialAdaptiveMode:!1,adaptiveStrength:1,hazeWeight:.5,atmosphericWeight:.3,enableEnhancement:!1,saturationEnhancement:1.2,contrastEnhancement:1.1,brightnessEnhancement:1}},fRe=t=>`: ${t instanceof Error?t.message:String(t)}`,Si={OMEGA_RANGE:"(omega)0.1-0.99",T0_RANGE:"(t0)0.01-0.3",WINDOW_SIZE_RANGE:"3-31",TOP_RATIO_RANGE:"0.01-0.5",ADAPTIVE_STRENGTH_RANGE:"0.1-2.0",HAZE_WEIGHT_RANGE:"0.0-1.0",ATMOSPHERIC_WEIGHT_RANGE:"0.0-1.0",SATURATION_ENHANCEMENT_RANGE:"0.0-2.0",CONTRAST_ENHANCEMENT_RANGE:"0.5-2.0",BRIGHTNESS_ENHANCEMENT_RANGE:"0.5-2.0"},Gx=xw.default;async function pRe(t,e){try{await mw();const n={windowSize:e.windowSize,topRatio:e.topRatio,omega:e.omega,t0:e.t0,adaptiveMode:e.adaptiveMode,spatialAdaptiveMode:e.spatialAdaptiveMode,adaptiveStrength:e.adaptiveStrength,adaptiveOptions:{hazeWeight:e.hazeWeight,atmosphericWeight:e.atmosphericWeight},enhancementOptions:{enableEnhancement:e.enableEnhancement,saturationEnhancement:e.saturationEnhancement,contrastEnhancement:e.contrastEnhancement,brightnessEnhancement:e.brightnessEnhancement}},s=await dRe(t,n),r=new Uint8ClampedArray(s.imageData.data);return new ImageData(r,s.imageData.width,s.imageData.height)}catch(n){throw console.error(":",n),new Error(fRe(n))}}function mRe(t){return{...xw[t]}}const gRe={sigma:8,epsilon:.04,radius:8,blockSize:16,detailStrength:2,enhancementStrength:1,macroEnhancement:0,contrastBoost:1.2},xRe={subtle:{name:"",params:{sigma:6,epsilon:.03,radius:6,blockSize:16,detailStrength:1.5,enhancementStrength:.8,macroEnhancement:0,contrastBoost:1.1}},moderate:{name:"",params:{sigma:8,epsilon:.04,radius:8,blockSize:16,detailStrength:2,enhancementStrength:1,macroEnhancement:0,contrastBoost:1.2}},strong:{name:"",params:{sigma:10,epsilon:.05,radius:10,blockSize:16,detailStrength:3,enhancementStrength:1.5,macroEnhancement:.2,contrastBoost:1.4}},aggressive:{name:"",params:{sigma:12,epsilon:.06,radius:12,blockSize:16,detailStrength:4,enhancementStrength:2,macroEnhancement:.3,contrastBoost:1.6}}},Vx=gRe,DN=xRe,da={:"Clarity Input Texture",:"Clarity Output Buffer",:"Composition Result",Uniform:"Composition Uniforms",:"Composition Shader",:"Composition Pipeline",:"Composition Encoder",Pass:"Composition Pass"},NN={RGBA32Float:"rgba32float"},uT={:"auto",:"main"},cT=16,bRe=48,yRe=`
    struct CompositionParams {
        detailStrength: f32,
        enhancementStrength: f32,
        macroEnhancement: f32,
        contrastBoost: f32,
        padding1: vec4<f32>,
        padding2: vec4<f32>
    }

    @group(0) @binding(0) var originalTexture: texture_2d<f32>;
    @group(0) @binding(1) var baseTexture: texture_2d<f32>;
    @group(0) @binding(2) var detailTexture: texture_2d<f32>;
    @group(0) @binding(3) var outputTexture: texture_storage_2d<rgba32float, write>;
    @group(0) @binding(4) var<uniform> params: CompositionParams;

    @compute @workgroup_size(16, 16)
    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
        let coord = vec2<i32>(global_id.xy);
        let dims = textureDimensions(originalTexture);
        
        if (coord.x >= i32(dims.x) || coord.y >= i32(dims.y)) {
            return;
        }
        
        // 
        let original = textureLoad(originalTexture, coord, 0);
        let base = textureLoad(baseTexture, coord, 0);
        let detail = textureLoad(detailTexture, coord, 0);
        
        // 
        let originalLum = dot(original.rgb, vec3<f32>(0.299, 0.587, 0.114));
        let baseLum = dot(base.rgb, vec3<f32>(0.299, 0.587, 0.114));
        
        // 
        let brightnessDiff = abs(originalLum - baseLum);
        let contrastFactor = 1.0 - brightnessDiff * 0.7;
        
        // 
        let smartStrength = params.detailStrength * contrastFactor * 0.7;
        
        // 
        let meanLum = baseLum;
        // 
        var macroBase = base.rgb * params.contrastBoost;
        macroBase = clamp(macroBase, vec3<f32>(0.0), vec3<f32>(1.0));
        
        // 
        let detailEnhanced = original.rgb + detail.rgb * smartStrength;
        
        // 
        let macroWeight = params.macroEnhancement * 0.8; // 
        let macroEnhanced = mix(detailEnhanced, macroBase, macroWeight);
        
        // 
        let contrastAdjusted = mix(original.rgb, macroEnhanced, params.enhancementStrength);
        
        // 
        let meanValue = dot(contrastAdjusted, vec3<f32>(0.299, 0.587, 0.114));
        let contrastEnhanced = meanValue + (contrastAdjusted - meanValue) * (1.0 + params.contrastBoost * 0.5);
        
        var enhanced = clamp(contrastEnhanced, vec3<f32>(0.0), vec3<f32>(1.0));
        
        // 
        textureStore(outputTexture, coord, vec4<f32>(enhanced, original.a));
    }
`;function vRe(t){if(!t||typeof t!="object")return!1;const{sigma:e,epsilon:n,radius:s,blockSize:r}=t;return!(typeof e!="number"||e<1||e>16||typeof n!="number"||n<.01||n>.1||typeof s!="number"||s<2||s>32||typeof r!="number"||r<8||r>32)}function wRe(t){return`
    // Guided Filter 
    struct GuidedFilterParams {
      width: u32,
      height: u32,
      sigma: f32,        // 
      epsilon: f32,      // 
      radius: u32        // 
    }
    
    // 
    @group(0) @binding(2) var<uniform> params: GuidedFilterParams;
    
    // 
    @group(0) @binding(0) var inputTexture: texture_2d<f32>;
    
    // 
    @group(0) @binding(1) var outputTexture: texture_storage_2d<rgba32float, write>;
    
    // 
    var<workgroup> sharedCache: array<vec4<f32>, 256>;
    
    /**
     * 
     * 
     * 
     */
    fn computeLocalMean(pos: vec2<i32>) -> vec4<f32> {
      var sum = vec4<f32>(0.0);
      var weightSum = 0.0;
      
      let radius = i32(params.radius);
      let width = i32(params.width);
      let height = i32(params.height);
      
      // 
      var normalizationFactor = 0.0;
      for (var i = -radius; i <= radius; i++) {
        normalizationFactor += exp(-f32(i * i) / (2.0 * params.sigma * params.sigma));
      }
      
      //  - 
      for (var x = -radius; x <= radius; x++) {
        let sampleX = clamp(pos.x + x, 0, width - 1);
        let samplePos = vec2<i32>(sampleX, pos.y);
        let weight = exp(-f32(x * x) / (2.0 * params.sigma * params.sigma)) / normalizationFactor;
        sum += textureLoad(inputTexture, samplePos, 0) * weight;
      }
      
      let horizontalResult = sum;
      
      //  - 
      sum = vec4<f32>(0.0);
      for (var y = -radius; y <= radius; y++) {
        let sampleY = clamp(pos.y + y, 0, height - 1);
        let samplePos = vec2<i32>(pos.x, sampleY);
        let weight = exp(-f32(y * y) / (2.0 * params.sigma * params.sigma)) / normalizationFactor;
        sum += horizontalResult * weight;
      }
      
      return sum;
    }
    
    /**
     * 
     * 
     */
    fn computeLocalVariance(pos: vec2<i32>, mean: vec4<f32>) -> vec4<f32> {
      var sum = vec4<f32>(0.0);
      var weightSum = 0.0;
      
      let radius = i32(params.radius);
      let width = i32(params.width);
      let height = i32(params.height);
      
      // 
      var normalizationFactor = 0.0;
      for (var i = -radius; i <= radius; i++) {
        normalizationFactor += exp(-f32(i * i) / (2.0 * params.sigma * params.sigma));
      }
      
      //  - 
      for (var x = -radius; x <= radius; x++) {
        let sampleX = clamp(pos.x + x, 0, width - 1);
        let samplePos = vec2<i32>(sampleX, pos.y);
        let weight = exp(-f32(x * x) / (2.0 * params.sigma * params.sigma)) / normalizationFactor;
        let sample = textureLoad(inputTexture, samplePos, 0);
        sum += sample * sample * weight;
      }
      
      let horizontalResult = sum;
      
      //  - 
      sum = vec4<f32>(0.0);
      for (var y = -radius; y <= radius; y++) {
        let sampleY = clamp(pos.y + y, 0, height - 1);
        let samplePos = vec2<i32>(pos.x, sampleY);
        let weight = exp(-f32(y * y) / (2.0 * params.sigma * params.sigma)) / normalizationFactor;
        sum += horizontalResult * weight;
      }
      
      let meanSquared = sum;
      let variance = meanSquared - mean * mean;
      return max(variance, vec4<f32>(0.0));
    }
    
    /**
     * 
     * 
     */
    fn computeLocalCovariance(pos: vec2<i32>, guideMean: vec4<f32>, inputMean: vec4<f32>) -> vec4<f32> {
      var sum = vec4<f32>(0.0);
      var weightSum = 0.0;
      
      let radius = i32(params.radius);
      let width = i32(params.width);
      let height = i32(params.height);
      
      // 
      var normalizationFactor = 0.0;
      for (var i = -radius; i <= radius; i++) {
        normalizationFactor += exp(-f32(i * i) / (2.0 * params.sigma * params.sigma));
      }
      
      //  - 
      for (var x = -radius; x <= radius; x++) {
        let sampleX = clamp(pos.x + x, 0, width - 1);
        let samplePos = vec2<i32>(sampleX, pos.y);
        let weight = exp(-f32(x * x) / (2.0 * params.sigma * params.sigma)) / normalizationFactor;
        let guideSample = textureLoad(inputTexture, samplePos, 0);
        let inputSample = textureLoad(inputTexture, samplePos, 0); 
        sum += guideSample * inputSample * weight;
      }
      
      let horizontalResult = sum;
      
      //  - 
      sum = vec4<f32>(0.0);
      for (var y = -radius; y <= radius; y++) {
        let sampleY = clamp(pos.y + y, 0, height - 1);
        let samplePos = vec2<i32>(pos.x, sampleY);
        let weight = exp(-f32(y * y) / (2.0 * params.sigma * params.sigma)) / normalizationFactor;
        sum += horizontalResult * weight;
      }
      
      let covariance = sum;
      return covariance - guideMean * inputMean;
    }
    
    /**
     * 
     */
    @compute @workgroup_size(16, 16)
    fn main(@builtin(global_invocation_id) globalId: vec3<u32>) {
      let pos = vec2<i32>(globalId.xy);
      
      // 
      if (pos.x >= i32(params.width) || pos.y >= i32(params.height)) {
        return;
      }
      
      // 
      let guide = textureLoad(inputTexture, pos, 0);
      let input = guide; // 
      
      // 1. 
      let guideMean = computeLocalMean(pos);
      
      // 2. 
      let guideVariance = computeLocalVariance(pos, guideMean);
      
      // 3. 
      let inputMean = guideMean; // 
      
      // 4. 
      let covariance = computeLocalCovariance(pos, guideMean, inputMean);
      
      // 5. 
      let epsilon = params.epsilon;
      let a = covariance / (guideVariance + vec4<f32>(epsilon));
      let b = inputMean - a * guideMean;
      
      // 6. Guided Filter - base layer
      let baseLayer = a * guide + b;
      
      // 7. base layer
      textureStore(outputTexture, pos, vec4<f32>(baseLayer));
    }
  `}function SRe(){return`
    struct DetailParams {
      width: u32,
      height: u32
    }
    
    @group(0) @binding(0) var inputTexture: texture_2d<f32>;
    @group(0) @binding(1) var baseTexture: texture_2d<f32>;
    @group(0) @binding(2) var<uniform> params: DetailParams;
    @group(0) @binding(3) var detailTexture: texture_storage_2d<rgba32float, write>;
    
    @compute @workgroup_size(16, 16)
    fn main(@builtin(global_invocation_id) globalId: vec3<u32>) {
      let pos = vec2<i32>(globalId.xy);
      
      if (pos.x >= i32(params.width) || pos.y >= i32(params.height)) {
        return;
      }
      
      // : detail = input - base
      let input = textureLoad(inputTexture, pos, 0);
      let base = textureLoad(baseTexture, pos, 0);
      let detail = input - base;
      
      // 
      textureStore(detailTexture, pos, vec4<f32>(detail));
    }
  `}function CRe(t,e,n){const s=wRe(),r=t.createShaderModule({code:s});return t.createComputePipeline({layout:t.createPipelineLayout({bindGroupLayouts:[n]}),compute:{module:r,entryPoint:"main"},label:"GuidedFilter Pipeline"})}function TRe(t,e){const n=SRe();console.log("Detail Extraction shader code:",n);const s=t.createShaderModule({code:n});return t.createComputePipeline({layout:t.createPipelineLayout({bindGroupLayouts:[e]}),compute:{module:s,entryPoint:"main"},label:"Detail Extraction Pipeline"})}function IRe(t){return t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}],label:"GuidedFilter Params BindGroup"})}function kRe(t){return t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:3,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float"}}],label:"Detail Extraction Params BindGroup"})}function ERe(t,e,n){const{inputTexture:s,outputTexture:r,uniformBuffer:i}=n;return t.createBindGroup({layout:e,entries:[{binding:0,resource:s.createView()},{binding:1,resource:r.createView()},{binding:2,resource:i}],label:"GuidedFilter BindGroup"})}function _Re(t,e,n){const{inputTexture:s,baseTexture:r,outputTexture:i,uniformBuffer:o}=n;return t.createBindGroup({layout:e,entries:[{binding:0,resource:s.createView()},{binding:1,resource:r.createView()},{binding:2,resource:o},{binding:3,resource:i.createView()}],label:"Detail Extraction BindGroup"})}function $Re(t,e,n,s){const r=new ArrayBuffer(20),i=new DataView(r);i.setUint32(0,n,!0),i.setUint32(4,s,!0),i.setFloat32(8,e.sigma,!0),i.setFloat32(12,e.epsilon,!0),i.setUint32(16,e.radius,!0);const o=t.createBuffer({size:20,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"GuidedFilter Uniform Buffer"});return t.queue.writeBuffer(o,0,r),o}function RRe(t,e,n){const s=new ArrayBuffer(8),r=new DataView(s);r.setUint32(0,e,!0),r.setUint32(4,n,!0);const i=t.createBuffer({size:8,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"Detail Extraction Uniform Buffer"});return t.queue.writeBuffer(i,0,s),i}async function ARe(t,e,n,s,r){if(!vRe(n))throw new Error("Invalid Guided Filter parameters");const i=t.createTexture({size:{width:s,height:r},format:"rgba32float",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,label:"Base Texture"}),o=t.createTexture({size:{width:s,height:r},format:"rgba32float",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,label:"Detail Texture"}),a=$Re(t,n,s,r),l=RRe(t,s,r),u=IRe(t),c=kRe(t),h=CRe(t,n,u),d=TRe(t,c),f=ERe(t,u,{inputTexture:e,outputTexture:i,uniformBuffer:a}),p=_Re(t,c,{inputTexture:e,baseTexture:i,outputTexture:o,uniformBuffer:l}),g=t.createCommandEncoder({label:"Guided Filter Encoder"}),m=g.beginComputePass({label:"Guided Filter Pass"});m.setPipeline(h),m.setBindGroup(0,f);const x=Math.ceil(s/16),b=Math.ceil(r/16);m.dispatchWorkgroups(x,b),m.end(),t.queue.submit([g.finish()]),await t.queue.onSubmittedWorkDone();const v=t.createCommandEncoder({label:"Detail Extraction Encoder"}),y=v.beginComputePass({label:"Detail Extraction Pass"});y.setPipeline(d),y.setBindGroup(0,p),y.dispatchWorkgroups(x,b),y.end(),t.queue.submit([v.finish()]);try{await t.queue.onSubmittedWorkDone(),console.log("Detail Extraction completed successfully")}catch(C){throw console.error("Detail Extraction failed:",C),C}return{baseTexture:i,detailTexture:o}}function PRe(t,e){const{width:n,height:s,data:r}=e,i=new Float32Array(n*s*4);for(let a=0;a<r.length;a+=4)i[a]=r[a]/255,i[a+1]=r[a+1]/255,i[a+2]=r[a+2]/255,i[a+3]=r[a+3]/255;const o=t.createTexture({size:{width:n,height:s},format:NN.RGBA32Float,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:da.});return t.queue.writeTexture({texture:o},i,{bytesPerRow:n*16},{width:n,height:s}),o}async function DRe(t){const{device:e,texture:n,width:s,height:r}=t,i=s*16,o=Math.ceil(i/256)*256,a=o*r,l=e.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:da.}),u=e.createCommandEncoder();u.copyTextureToBuffer({texture:n},{buffer:l,bytesPerRow:o},{width:s,height:r}),e.queue.submit([u.finish()]),await e.queue.onSubmittedWorkDone(),await l.mapAsync(GPUMapMode.READ);const c=new Float32Array(l.getMappedRange()),h=new Uint8ClampedArray(s*r*4),d=s*4,f=o/4;for(let p=0;p<r;p++){const g=p*f,m=p*d;for(let x=0;x<d;x++){const b=c[g+x];h[m+x]=Math.max(0,Math.min(255,Math.round(b*255)))}}return l.unmap(),l.destroy(),new ImageData(h,s,r)}function NRe(t,e,n){return t.createTexture({size:{width:e,height:n},format:NN.RGBA32Float,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC,label:da.})}function MRe(t,e){const n=t.createBuffer({size:bRe,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:da.Uniform}),s=new Float32Array([e.detailStrength,e.enhancementStrength,e.macroEnhancement||0,e.contrastBoost||1.2,0,0,0,0,0,0,0,0]);return t.queue.writeBuffer(n,0,s),n}function LRe(t){const e=t.createShaderModule({code:yRe,label:da.});return t.createComputePipeline({layout:uT.,compute:{module:e,entryPoint:uT.},label:da.})}async function ORe(t){const{device:e,width:n,height:s,params:r}=t,i=NRe(e,n,s),o=MRe(e,r),a=LRe(e),l=e.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:t.originalTexture.createView()},{binding:1,resource:t.baseTexture.createView()},{binding:2,resource:t.detailTexture.createView()},{binding:3,resource:i.createView()},{binding:4,resource:{buffer:o}}]}),u=e.createCommandEncoder({label:da.}),c=u.beginComputePass({label:da.Pass});c.setPipeline(a),c.setBindGroup(0,l);const h=Math.ceil(n/cT),d=Math.ceil(s/cT);return c.dispatchWorkgroups(h,d),c.end(),e.queue.submit([u.finish()]),await e.queue.onSubmittedWorkDone(),i}async function FRe(t,e,n){try{const{width:s,height:r}=e,i=PRe(t,e),o={sigma:n.sigma,epsilon:n.epsilon,radius:n.radius,blockSize:n.blockSize},a=await ARe(t,i,o,s,r),{baseTexture:l,detailTexture:u}=a,h=await ORe({device:t,originalTexture:i,baseTexture:l,detailTexture:u,params:n,width:s,height:r}),f=await DRe({device:t,texture:h,width:s,height:r});return i.destroy(),l.destroy(),u.destroy(),h.destroy(),f}catch(s){throw console.error(":",s),s}}function Wx(t){return Nn("clarity-adjustment",t)}function URe(t){var e;return((e=DN[t])==null?void 0:e.params)||Vx}class BRe{constructor(e){Wt(this,"device");Wt(this,"buffers",new Map);Wt(this,"textures",new Map);Wt(this,"mappedBuffers",new Set);this.device=e}async getBuffer(e,n,s=""){const r=`${e}_${n}_${s}`;let i;if(this.buffers.has(r)){const o=this.buffers.get(r);if(i=o.buffer,o.refCount++,i){if(this.mappedBuffers.has(i))try{i.unmap(),this.mappedBuffers.delete(i)}catch{}return i}}return i=this.device.createBuffer({size:e,usage:n,label:`pool_buffer_${s}`}),this.buffers.set(r,{buffer:i,refCount:1}),i}markBufferMapped(e){this.mappedBuffers.add(e)}markBufferUnmapped(e){this.mappedBuffers.delete(e)}getTexture(e,n,s,r,i=""){const o=`${e}_${n}_${s}_${r}_${i}`;if(this.textures.has(o)){const l=this.textures.get(o);return l.refCount++,l.texture}const a=this.device.createTexture({size:[e,n],format:s,usage:r,label:`pool_texture_${i}`});return this.textures.set(o,{texture:a,refCount:1}),a}releaseBuffer(e){for(const[n,s]of this.buffers.entries())if(s.buffer===e){if(s.refCount--,s.refCount<=0){if(this.mappedBuffers.has(e)){try{e.unmap()}catch{}this.mappedBuffers.delete(e)}this.buffers.delete(n)}break}}releaseTexture(e){for(const[n,s]of this.textures.entries())if(s.texture===e){s.refCount--,s.refCount<=0&&this.textures.delete(n);break}}}let yy=null;async function zRe(){if(!navigator.gpu)throw new Error("WebGPU not supported");const t=await navigator.gpu.requestAdapter();if(!t)throw new Error("Failed to get GPU adapter");const e=await t.requestDevice();return yy=new BRe(e),e}async function GRe(){return yy||await zRe(),yy}async function VRe(){return(await GRe()).device}function WRe(t){const e=new Uint32Array(256),n=t.data;for(let s=0;s<n.length;s+=4){const r=n[s],i=n[s+1],o=n[s+2],a=Math.round(.299*r+.587*i+.114*o);e[a]++}return e}function HRe(t){const e=t.reduce((o,a)=>o+a,0);let n=0,s=0,r=0,i=0;for(let o=0;o<256;o++)t[o]>s&&(s=t[o],n=o),o<64&&(r+=t[o]),o>192&&(i+=t[o]);return{peakBin:n/255,darkRatio:r/e,brightRatio:i/e}}function KRe(t,e,n){let s=0;for(let r=0;r<256;r++){const o=r/255-e;s+=o*o*t[r]}return s/n}function jRe(t){return 1*(1-Math.min(t*4,1)*.5)}function XRe(t){const e=t.reduce((l,u)=>l+u,0);let n=0;for(let l=0;l<256;l++)n+=l/255*t[l];const s=n/e;let r=.5-s;const i=HRe(t);i.peakBin<.3?r*=1.2:i.peakBin>.7&&(r*=.8);const o=KRe(t,s,e);let a=jRe(o);return(i.darkRatio>.4||i.brightRatio>.4)&&(a*=.8),{strength:1,targetExposure:r,localAdjustFactor:a}}function qRe(t){const e=t.reduce((r,i)=>r+i,0),n=new Float32Array(256);let s=0;for(let r=0;r<256;r++)s+=t[r],n[r]=s/e;return n}const YRe=`
struct Uniforms {
    width: u32,
    height: u32,
    strength: f32,
    targetExposure: f32,
    localAdjustFactor: f32,
};

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var inputTexture: texture_2d<f32>;
@group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(3) var<storage, read> histogram: array<u32, 256>;
@group(0) @binding(4) var<storage, read> cdf: array<f32, 256>;

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let pixel_coord = vec2<i32>(global_id.xy);
    if (pixel_coord.x >= i32(uniforms.width) || pixel_coord.y >= i32(uniforms.height)) {
        return;
    }

    let color = textureLoad(inputTexture, pixel_coord, 0);
    let luminance = dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114));
    
    let luminanceDiff = abs(luminance - 0.5) * 2.0;
    let luminanceIndex = u32(luminance * 255.0);
    
    let protectionFactor = sqrt(luminanceDiff);
    let targetBaseLuminance = cdf[luminanceIndex];
    let targetLuminance = mix(targetBaseLuminance, luminance, protectionFactor);
    
    let sigmoid = 1.0 / (1.0 + exp(-8.0 * (luminance - 0.5)));
    let adjustmentStrength = 0.5 + sigmoid * 0.5;
    
    let baseLuminanceAdjust = uniforms.strength * (targetLuminance - luminance + uniforms.targetExposure);
    let luminanceAdjust = baseLuminanceAdjust * adjustmentStrength;
    
    let adjustmentFactor = 1.0 + (uniforms.localAdjustFactor * 0.2);
    let fineAdjust = luminanceAdjust * adjustmentFactor;
    
    let baseLimit = 45.0 / 255.0;
    let dynamicLimit = baseLimit * (1.0 - luminanceDiff * luminanceDiff);
    let limitedAdjust = clamp(fineAdjust, -dynamicLimit, dynamicLimit);
    
    let newColor = clamp(color.rgb + vec3<f32>(limitedAdjust), vec3<f32>(0.0), vec3<f32>(1.0));
    textureStore(outputTexture, pixel_coord, vec4<f32>(newColor, color.a));
}
`;function ZRe(t){return t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba8unorm"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]})}async function QRe(t){if(!t)throw new Error("GPU");try{const e=ZRe(t),n=t.createPipelineLayout({bindGroupLayouts:[e]}),s=await t.createComputePipelineAsync({layout:n,compute:{module:t.createShaderModule({code:YRe}),entryPoint:"main"}}),r=t.createBuffer({size:20,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!1});return{pipeline:s,uniformBuffer:r,bindGroupLayout:e}}catch(e){throw console.error("GPU:",e),e}}async function JRe(t){const{device:e,imageData:n,width:s,height:r}=t;if(!e||!n||!s||!r)throw new Error("");try{const o=s*4,a=e.createTexture({size:[s,r],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,dimension:"2d"});return e.queue.writeTexture({texture:a},n.data,{bytesPerRow:o,rowsPerImage:r},{width:s,height:r}),a}catch(i){throw console.error(":",i),i}}function eAe(t){const{device:e,width:n,height:s}=t;if(!e||n<1||s<1)throw new Error("");return e.createTexture({size:[n,s],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,dimension:"2d",label:"output_texture"})}async function tAe(t,e,n){const s=t.createBuffer({size:1024,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Uint32Array(s.getMappedRange()).set(e),s.unmap();const r=t.createBuffer({size:256*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new Float32Array(r.getMappedRange()).set(n),r.unmap(),{histogramBuffer:s,cdfBuffer:r}}const hT=16,_m=4,dT=256;function nAe(t){return Math.ceil(t*_m/dT)*dT}function sAe(t,e){const n=t.createBuffer({size:e,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST,label:"staging_buffer"}),s=t.createBuffer({size:e,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,label:"output_buffer"});return{stagingBuffer:n,outputBuffer:s}}async function rAe(t){const{device:e,pipeline:n,bindGroupLayout:s,uniformBuffer:r,inputTexture:i,outputTexture:o,histogramBuffer:a,cdfBuffer:l,width:u,height:c}=t,h=e.createBindGroup({layout:s,entries:[{binding:0,resource:{buffer:r}},{binding:1,resource:i.createView()},{binding:2,resource:o.createView()},{binding:3,resource:{buffer:a}},{binding:4,resource:{buffer:l}}],label:"auto_exposure_bind_group"}),d=e.createCommandEncoder({label:"compute_encoder"}),f=d.beginComputePass({label:"compute_pass"});f.setPipeline(n),f.setBindGroup(0,h),f.dispatchWorkgroups(Math.ceil(u/hT),Math.ceil(c/hT)),f.end(),e.queue.submit([d.finish()]),await e.queue.onSubmittedWorkDone()}async function iAe(t,e,n,s,r,i,o,a){const l=t.createCommandEncoder({label:"copy_encoder"});l.copyTextureToBuffer({texture:e},{buffer:n,bytesPerRow:o,rowsPerImage:i},{width:r,height:i,depthOrArrayLayers:1}),l.copyBufferToBuffer(n,0,s,0,a),t.queue.submit([l.finish()]),await t.queue.onSubmittedWorkDone()}async function oAe(t,e,n,s,r){await t.mapAsync(GPUMapMode.READ);const i=new Uint8Array(t.getMappedRange()),o=new Uint8ClampedArray(n*s*_m);for(let a=0;a<s;a++){const l=a*r,u=a*n*_m;o.set(i.subarray(l,l+n*_m),u)}return t.unmap(),t.destroy(),e.destroy(),new ImageData(o,n,s)}async function aAe(t){const{device:e,pipeline:n,bindGroupLayout:s,uniformBuffer:r,inputTexture:i,outputTexture:o,histogramBuffer:a,cdfBuffer:l,width:u,height:c}=t;if(!e||!n||!s||!r||!i||!o||!a||!l)throw new Error("ExposureContext  GPU ");try{const h=nAe(u),d=h*c,{stagingBuffer:f,outputBuffer:p}=sAe(e,d);return await rAe(t),await iAe(e,o,p,f,u,c,h,d),await oAe(f,p,u,c,h)}catch(h){throw console.error("GPU:",h),h}}async function lAe(t,e=1){var i,o,a,l,u;const n=await VRe(),{width:s,height:r}=t;try{const c=WRe(t),h=XRe(c);h.strength=e;const d=qRe(c),f={device:n,imageData:t,width:s,height:r},{pipeline:p,uniformBuffer:g,bindGroupLayout:m}=await QRe(n);f.pipeline=p,f.uniformBuffer=g,f.bindGroupLayout=m,f.inputTexture=await JRe(f),f.outputTexture=eAe(f);const{histogramBuffer:x,cdfBuffer:b}=await tAe(n,c,d);f.histogramBuffer=x,f.cdfBuffer=b,n.queue.writeBuffer(g,0,new Float32Array([s,r,h.strength,h.targetExposure,h.localAdjustFactor]));const v=await aAe(f);return(i=f.uniformBuffer)==null||i.destroy(),(o=f.inputTexture)==null||o.destroy(),(a=f.outputTexture)==null||a.destroy(),(l=f.histogramBuffer)==null||l.destroy(),(u=f.cdfBuffer)==null||u.destroy(),v}catch(c){throw console.error(":",c),c}}function uAe(t,e,n=1,s=1){const r=new Uint8ClampedArray(t.data),i=new ImageData(r,t.width,t.height);for(let o=0;o<r.length;o+=4){let a=r[o]/255,l=r[o+1]/255,u=r[o+2]/255;a=a*e,l=l*e,u=u*e,a=(a-.5)*n+.5,l=(l-.5)*n+.5,u=(u-.5)*n+.5,a=Math.pow(a,1/s),l=Math.pow(l,1/s),u=Math.pow(u,1/s),r[o]=Math.max(0,Math.min(255,a*255)),r[o+1]=Math.max(0,Math.min(255,l*255)),r[o+2]=Math.max(0,Math.min(255,u*255))}return i}const Dn={shadows:{brightness:0,contrast:0,saturation:0,red:0,green:0,blue:0},midtones:{brightness:0,contrast:0,saturation:0,red:0,green:0,blue:0},highlights:{brightness:0,contrast:0,saturation:0,red:0,green:0,blue:0},shadowEnd:.33,highlightStart:.66,softness:.1},MN={default:{name:"",params:{...Dn}},enhanceShadows:{name:"",params:{...Dn,shadows:{brightness:.2,contrast:.1,saturation:.1,red:0,green:0,blue:0}}},enhanceHighlights:{name:"",params:{...Dn,highlights:{brightness:-.1,contrast:.1,saturation:.05,red:0,green:0,blue:0}}},popColors:{name:"",params:{...Dn,shadows:{brightness:.1,contrast:0,saturation:.2,red:0,green:0,blue:0},midtones:{brightness:0,contrast:.1,saturation:.3,red:0,green:0,blue:0},highlights:{brightness:0,contrast:0,saturation:.1,red:0,green:0,blue:0}}},contrastBoost:{name:"",params:{...Dn,shadows:{brightness:-.05,contrast:.2,saturation:0,red:0,green:0,blue:0},midtones:{brightness:0,contrast:.3,saturation:0,red:0,green:0,blue:0},highlights:{brightness:.05,contrast:.2,saturation:0,red:0,green:0,blue:0}}},warmTones:{name:"",params:{...Dn,shadows:{brightness:0,contrast:0,saturation:.1,red:.05,green:.02,blue:-.05},midtones:{brightness:0,contrast:0,saturation:.1,red:.08,green:.03,blue:-.08},highlights:{brightness:0,contrast:0,saturation:.05,red:.05,green:0,blue:-.05}}},coolTones:{name:"",params:{...Dn,shadows:{brightness:0,contrast:0,saturation:.1,red:-.05,green:0,blue:.05},midtones:{brightness:0,contrast:0,saturation:.1,red:-.08,green:0,blue:.08},highlights:{brightness:0,contrast:0,saturation:.05,red:-.05,green:0,blue:.05}}}};function cAe(t){return MN[t].params}const Ci={zone:{brightness:t=>`${t} brightness must be between -1.0 and 1.0`,contrast:t=>`${t} contrast must be between -1.0 and 1.0`,saturation:t=>`${t} saturation must be between -1.0 and 1.0`,red:t=>`${t} red must be between -1.0 and 1.0`,green:t=>`${t} green must be between -1.0 and 1.0`,blue:t=>`${t} blue must be between -1.0 and 1.0`},:{shadowEnd:"shadowEnd must be between 0.0 and 1.0",highlightStart:"highlightStart must be between 0.0 and 1.0",shadowEndhighlightStart:"shadowEnd must be less than highlightStart",softness:"softness must be between 0.0 and 1.0"}},hAe=`
struct ZoneParams {
    brightness: f32,
    contrast: f32,
    saturation: f32,
    red: f32,
    green: f32,
    blue: f32,
    padding1: f32,
    padding2: f32,
}`,dAe=`
struct LuminanceParams {
    shadows: ZoneParams,
    midtones: ZoneParams,
    highlights: ZoneParams,
    
    // Range controls
    shadowEnd: f32,      // Point where shadows fade out (e.g., 0.33)
    highlightStart: f32, // Point where highlights fade in (e.g., 0.66)
    softness: f32,       // Softness of the transition (0.0 - 1.0)
    padding: f32,
}`,fAe=`
@group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(2) var<uniform> params: LuminanceParams;`,pAe=`
// Helper: Calculate Luminance
fn getLuminance(color: vec3<f32>) -> f32 {
    return dot(color, vec3<f32>(0.2126, 0.7152, 0.0722));
}`,mAe=`
// Helper: RGB to HSL (for Saturation adjustment)
fn rgbToHsl(rgb: vec3<f32>) -> vec3<f32> {
    let r = rgb.r;
    let g = rgb.g;
    let b = rgb.b;
    let maxVal = max(max(r, g), b);
    let minVal = min(min(r, g), b);
    let l = (maxVal + minVal) * 0.5;
    
    var h = 0.0;
    var s = 0.0;
    
    if (maxVal != minVal) {
        let d = maxVal - minVal;
        s = select(d / (2.0 - maxVal - minVal), d / (maxVal + minVal), l > 0.5);
        if (maxVal == r) {
            h = (g - b) / d + select(6.0, 0.0, g >= b);
        } else if (maxVal == g) {
            h = (b - r) / d + 2.0;
        } else {
            h = (r - g) / d + 4.0;
        }
        h = h / 6.0;
    }
    return vec3<f32>(h, s, l);
}`,gAe=`
// Helper: HSL to RGB
fn hue2rgb(p: f32, q: f32, t: f32) -> f32 {
    var tAdjusted = t;
    if (tAdjusted < 0.0) { tAdjusted = tAdjusted + 1.0; }
    if (tAdjusted > 1.0) { tAdjusted = tAdjusted - 1.0; }
    if (tAdjusted < 1.0/6.0) { return p + (q - p) * 6.0 * tAdjusted; }
    if (tAdjusted < 1.0/2.0) { return q; }
    if (tAdjusted < 2.0/3.0) { return p + (q - p) * (2.0/3.0 - tAdjusted) * 6.0; }
    return p;
}`,xAe=`
fn hslToRgb(hsl: vec3<f32>) -> vec3<f32> {
    let h = hsl.x;
    let s = hsl.y;
    let l = hsl.z;
    var r = 0.0; var g = 0.0; var b = 0.0;
    if (s == 0.0) {
        r = l; g = l; b = l;
    } else {
        let q = select(l * (1.0 + s), l + s - l * s, l < 0.5);
        let p = 2.0 * l - q;
        r = hue2rgb(p, q, h + 1.0/3.0);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1.0/3.0);
    }
    return vec3<f32>(r, g, b);
}`,bAe=`
// Apply adjustments to a color
fn applyAdjustments(color: vec3<f32>, p: ZoneParams) -> vec3<f32> {
    var res = color;
    
    // 1. Brightness
    res = res + p.brightness;
    
    // 2. Contrast
    res = (res - 0.5) * (1.0 + p.contrast) + 0.5;
    
    // 3. Color Tint (RGB Offset)
    res = res + vec3<f32>(p.red, p.green, p.blue);
    
    // 4. Saturation
    let hsl = rgbToHsl(res);
    let newS = clamp(hsl.y * (1.0 + p.saturation), 0.0, 1.0);
    res = hslToRgb(vec3<f32>(hsl.x, newS, hsl.z));
    
    return clamp(res, vec3<f32>(0.0), vec3<f32>(1.0));
}`,yAe=(t,e)=>`
@compute @workgroup_size(${t}, ${e})
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let dims = textureDimensions(inputTexture);
    let coords = vec2<u32>(global_id.xy);

    if (coords.x >= dims.x || coords.y >= dims.y) {
        return;
    }

    let originalColor = textureLoad(inputTexture, vec2<i32>(coords), 0);
    let rgb = originalColor.rgb;
    let l = getLuminance(rgb);
    
    // Calculate weights
    // Softness controls the transition width
    let soft = max(0.01, params.softness);
    
    // Shadow weight: 1.0 at 0, 0.0 at shadowEnd
    let w_shadow = 1.0 - smoothstep(params.shadowEnd - soft, params.shadowEnd + soft, l);
    
    // Highlight weight: 0.0 at highlightStart, 1.0 at 1.0
    let w_highlight = smoothstep(params.highlightStart - soft, params.highlightStart + soft, l);
    
    // Midtone weight: Remainder
    let w_midtone = max(0.0, 1.0 - w_shadow - w_highlight);
    
    // Normalize weights to sum to 1.0 (optional, but good for consistency)
    let total_w = w_shadow + w_midtone + w_highlight;
    let nw_shadow = w_shadow / total_w;
    let nw_midtone = w_midtone / total_w;
    let nw_highlight = w_highlight / total_w;
    
    // Apply adjustments for each zone
    let adj_shadow = applyAdjustments(rgb, params.shadows);
    let adj_midtone = applyAdjustments(rgb, params.midtones);
    let adj_highlight = applyAdjustments(rgb, params.highlights);
    
    // Blend results
    let finalRGB = adj_shadow * nw_shadow + adj_midtone * nw_midtone + adj_highlight * nw_highlight;
    
    textureStore(outputTexture, coords, vec4<f32>(finalRGB, originalColor.a));
}`,vAe=(t,e)=>[hAe,dAe,fAe,pAe,mAe,gAe,xAe,bAe,yAe(t,e)].join(`
`),wAe=vAe(16,16);function SAe(t){const e=new Float32Array(32);let n=0;return e[n++]=t.shadows.brightness,e[n++]=t.shadows.contrast,e[n++]=t.shadows.saturation,e[n++]=t.shadows.red,e[n++]=t.shadows.green,e[n++]=t.shadows.blue,e[n++]=0,e[n++]=0,e[n++]=t.midtones.brightness,e[n++]=t.midtones.contrast,e[n++]=t.midtones.saturation,e[n++]=t.midtones.red,e[n++]=t.midtones.green,e[n++]=t.midtones.blue,e[n++]=0,e[n++]=0,e[n++]=t.highlights.brightness,e[n++]=t.highlights.contrast,e[n++]=t.highlights.saturation,e[n++]=t.highlights.red,e[n++]=t.highlights.green,e[n++]=t.highlights.blue,e[n++]=0,e[n++]=0,e[n++]=t.shadowEnd,e[n++]=t.highlightStart,e[n++]=t.softness,e[n++]=0,e}class CAe{constructor(e){Wt(this,"device");Wt(this,"pipeline",null);Wt(this,"uniformBuffer",null);Wt(this,"bindGroup",null);this.device=e}async initialize(){this.uniformBuffer=this.device.createBuffer({size:256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const e=this.device.createShaderModule({code:wAe});this.pipeline=this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"main"}})}async processImage(e,n,s){if(!this.pipeline||!this.uniformBuffer)throw new Error("Processor not initialized");const r=SAe(s);this.device.queue.writeBuffer(this.uniformBuffer,0,r.buffer),this.bindGroup=this.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:e.createView()},{binding:1,resource:n.createView()},{binding:2,resource:{buffer:this.uniformBuffer}}]});const i=this.device.createCommandEncoder(),o=i.beginComputePass();o.setPipeline(this.pipeline),o.setBindGroup(0,this.bindGroup);const a=Math.ceil(e.width/16),l=Math.ceil(e.height/16);return o.dispatchWorkgroups(a,l),o.end(),i}destroy(){var e;(e=this.uniformBuffer)==null||e.destroy(),this.pipeline=null,this.uniformBuffer=null,this.bindGroup=null}}async function TAe(t){const{device:e,imageData:n,texture:s}=t,r=256,i=n.width*4,o=Math.ceil(i/r)*r,a=e.createBuffer({size:o*n.height,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),l=new Uint8Array(a.getMappedRange());for(let c=0;c<n.height;c++){const h=c*i,d=c*o;l.set(n.data.subarray(h,h+i),d)}a.unmap();const u=e.createCommandEncoder();return u.copyBufferToTexture({buffer:a,bytesPerRow:o},{texture:s},{width:n.width,height:n.height}),e.queue.submit([u.finish()]),a}async function IAe(t){const{device:e,texture:n,width:s,height:r}=t,i=256,o=s*4,a=Math.ceil(o/i)*i,l=e.createBuffer({size:a*r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),u=e.createCommandEncoder();u.copyTextureToBuffer({texture:n},{buffer:l,bytesPerRow:a},{width:s,height:r}),e.queue.submit([u.finish()]),await l.mapAsync(GPUMapMode.READ);const c=new Uint8Array(l.getMappedRange()),h=new Uint8ClampedArray(s*r*4);for(let d=0;d<r;d++){const f=d*a,p=d*o;h.set(c.subarray(f,f+o),p)}return l.unmap(),l.destroy(),new ImageData(h,s,r)}async function kAe(t,e,n){const s={size:{width:e.width,height:e.height},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING},r=t.createTexture(s),i=t.createTexture(s),o=await TAe({device:t,imageData:e,texture:r}),a=new CAe(t);await a.initialize();const l=await a.processImage(r,i,n);t.queue.submit([l.finish()]);const u=await IAe({device:t,texture:i,width:e.width,height:e.height});return r.destroy(),i.destroy(),o.destroy(),a.destroy(),u}function EAe(t){const e=[],n=[{name:"shadows",zoneParams:t.shadows},{name:"midtones",zoneParams:t.midtones},{name:"highlights",zoneParams:t.highlights}];for(const{name:s,zoneParams:r}of n)(r.brightness<-1||r.brightness>1)&&e.push(Ci.zone.brightness(s)),(r.contrast<-1||r.contrast>1)&&e.push(Ci.zone.contrast(s)),(r.saturation<-1||r.saturation>1)&&e.push(Ci.zone.saturation(s)),(r.red<-1||r.red>1)&&e.push(Ci.zone.red(s)),(r.green<-1||r.green>1)&&e.push(Ci.zone.green(s)),(r.blue<-1||r.blue>1)&&e.push(Ci.zone.blue(s));return(t.shadowEnd<0||t.shadowEnd>1)&&e.push(Ci..shadowEnd),(t.highlightStart<0||t.highlightStart>1)&&e.push(Ci..highlightStart),t.shadowEnd>=t.highlightStart&&e.push(Ci..shadowEndhighlightStart),(t.softness<0||t.softness>1)&&e.push(Ci..softness),{isValid:e.length===0,errors:e}}function _Ae(t){return{type:"update-data",detail:{action:"luminance-adjustment",data:t}}}const $Ae={guard:t=>{const e=t.exposureStrength&&t.exposureStrength!==1,n=t.exposureManual&&(t.exposureManual.exposure!==1||t.exposureManual.contrast!==1||t.exposureManual.gamma!==1);return e||n},process:async t=>{const{options:e,pipelineData:n}=t,s=await t.getWebGPUDevice(),r=await El(n.buffer,n.width,n.height,s);try{let o;return e.exposureStrength&&e.exposureStrength!==1?(o=await lAe(r,e.exposureStrength),i(o)):e.exposureManual?(o=uAe(r,e.exposureManual.exposure,e.exposureManual.contrast,e.exposureManual.gamma),i(o)):(o=r,i(o))}catch(o){console.warn(":",o)}function i(o){const a=s.createBuffer({size:o.data.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Uint8Array(a.getMappedRange()).set(o.data),a.unmap(),n.buffer instanceof GPUBuffer&&n.buffer.destroy(),n.buffer instanceof GPUTexture&&n.buffer.destroy(),t.pipelineData={buffer:a,width:o.width,height:o.height}}}},RAe={guard:t=>t.clarityParams&&(t.clarityParams.enhancementStrength!==1||t.clarityParams.macroEnhancement!==0),process:async t=>{const{options:e,pipelineData:n}=t,s=await t.getWebGPUDevice(),r=await El(n.buffer,n.width,n.height,s);try{const i=await FRe(s,r,e.clarityParams),o=s.createBuffer({size:i.data.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Uint8Array(o.getMappedRange()).set(i.data),o.unmap(),n.buffer instanceof GPUBuffer&&n.buffer.destroy(),n.buffer instanceof GPUTexture&&n.buffer.destroy(),t.pipelineData={buffer:o,width:i.width,height:i.height}}catch(i){console.warn(":",i)}}},AAe={guard:t=>t.luminanceParams&&(t.luminanceParams.shadows.brightness!==0||t.luminanceParams.shadows.contrast!==0||t.luminanceParams.shadows.saturation!==0||t.luminanceParams.midtones.brightness!==0||t.luminanceParams.midtones.contrast!==0||t.luminanceParams.midtones.saturation!==0||t.luminanceParams.highlights.brightness!==0||t.luminanceParams.highlights.contrast!==0||t.luminanceParams.highlights.saturation!==0),process:async t=>{const{options:e,pipelineData:n}=t,s=await t.getWebGPUDevice(),r=await El(n.buffer,n.width,n.height,s);try{const i=await kAe(s,r,e.luminanceParams),o=s.createBuffer({size:i.data.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Uint8Array(o.getMappedRange()).set(i.data),o.unmap(),n.buffer instanceof GPUBuffer&&n.buffer.destroy(),n.buffer instanceof GPUTexture&&n.buffer.destroy(),t.pipelineData={buffer:o,width:i.width,height:i.height}}catch(i){console.warn(":",i)}}},PAe={guard:t=>t.dehazeParams&&JSON.stringify(t.dehazeParams)!==JSON.stringify(Gx),process:async t=>{const{options:e,pipelineData:n}=t,s=await t.getWebGPUDevice(),r=await El(n.buffer,n.width,n.height,s);try{const i=await pRe(r,e.dehazeParams),o=s.createBuffer({size:i.data.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Uint8Array(o.getMappedRange()).set(i.data),o.unmap(),n.buffer instanceof GPUBuffer&&n.buffer.destroy(),n.buffer instanceof GPUTexture&&n.buffer.destroy(),t.pipelineData={buffer:o,width:i.width,height:i.height}}catch(i){console.warn(":",i)}}},DAe=[$Ae,PAe,RAe,AAe],fT={EMPTY_ORIGINAL_IMAGE:"",UNKNOWN_ERROR:""},NAe={processingError:t=>`: ${t}`};async function MAe(t){const{originalImage:e,...n}=t;let s=await $$e(e,n.maxResolution??2048);if(s=await N$e(s,n),n.hslLayers&&n.hslLayers.length>0){const o=await Ts();s=await Gj(s,n.hslLayers,o)}const i={options:n,pipelineData:s,cache:new WeakMap,getWebGPUDevice:()=>Ts()};for(const o of DAe)o.guard(n)&&(await o.process(i),s=i.pipelineData);return s=await M$e(s,n),s}async function LN(t){const{originalImage:e,onProcessingStart:n,onProcessingEnd:s,onError:r}=t;if(!e)throw new Error(fT.EMPTY_ORIGINAL_IMAGE);n==null||n();try{const i=await MAe(t),o=await L$e(i);return i.buffer.destroy(),o}catch(i){const o=i instanceof Error?i.message:fT.UNKNOWN_ERROR,a=NAe.processingError(o);throw r==null||r(a),i}finally{s==null||s()}}const LAe="SeamlessTextureGeneratorDB",Tg="luts",OAe=`${Tg}/`;function nm(t){return`${OAe}${t}`}const FAe=1;function UAe(t){async function e(){try{await t.list(Tg)}catch(o){throw console.error("Failed to init LUTDB FS",o),o}}async function n(o){await t.write(nm(o.id),o)}async function s(){const o=await t.readdir(Tg);return o.sort((a,l)=>l.createdAt-a.createdAt),o}async function r(o){await t.delete(nm(o))}async function i(o,a){const l=await t.read(nm(o));if(!l)throw new Error("LUT not found");l.thumbnail=a,await t.write(nm(o),l)}return{init:e,addLUT:n,getAllLUTs:s,deleteLUT:r,updateLUTThumbnail:i}}function Ie(t,e,n){function s(a,l){if(a._zod||Object.defineProperty(a,"_zod",{value:{def:l,constr:o,traits:new Set},enumerable:!1}),a._zod.traits.has(t))return;a._zod.traits.add(t),e(a,l);const u=o.prototype,c=Object.keys(u);for(let h=0;h<c.length;h++){const d=c[h];d in a||(a[d]=u[d].bind(a))}}const r=(n==null?void 0:n.Parent)??Object;class i extends r{}Object.defineProperty(i,"name",{value:t});function o(a){var l;const u=n!=null&&n.Parent?new i:this;s(u,a),(l=u._zod).deferred??(l.deferred=[]);for(const c of u._zod.deferred)c();return u}return Object.defineProperty(o,"init",{value:s}),Object.defineProperty(o,Symbol.hasInstance,{value:a=>{var l,u;return n!=null&&n.Parent&&a instanceof n.Parent?!0:(u=(l=a==null?void 0:a._zod)==null?void 0:l.traits)==null?void 0:u.has(t)}}),Object.defineProperty(o,"name",{value:t}),o}class Nu extends Error{constructor(){super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")}}class ON extends Error{constructor(e){super(`Encountered unidirectional transform during encode: ${e}`),this.name="ZodEncodeError"}}const FN={};function Cl(t){return FN}function BAe(t){const e=Object.values(t).filter(s=>typeof s=="number");return Object.entries(t).filter(([s,r])=>e.indexOf(+s)===-1).map(([s,r])=>r)}function vy(t,e){return typeof e=="bigint"?e.toString():e}function bw(t){return{get value(){{const e=t();return Object.defineProperty(this,"value",{value:e}),e}}}}function yw(t){return t==null}function vw(t){const e=t.startsWith("^")?1:0,n=t.endsWith("$")?t.length-1:t.length;return t.slice(e,n)}function zAe(t,e){const n=(t.toString().split(".")[1]||"").length,s=e.toString();let r=(s.split(".")[1]||"").length;if(r===0&&/\d?e-\d?/.test(s)){const l=s.match(/\d?e-(\d?)/);l!=null&&l[1]&&(r=Number.parseInt(l[1]))}const i=n>r?n:r,o=Number.parseInt(t.toFixed(i).replace(".","")),a=Number.parseInt(e.toFixed(i).replace(".",""));return o%a/10**i}const pT=Symbol("evaluating");function fn(t,e,n){let s;Object.defineProperty(t,e,{get(){if(s!==pT)return s===void 0&&(s=pT,s=n()),s},set(r){Object.defineProperty(t,e,{value:r})},configurable:!0})}function jl(t,e,n){Object.defineProperty(t,e,{value:n,writable:!0,enumerable:!0,configurable:!0})}function Xl(...t){const e={};for(const n of t){const s=Object.getOwnPropertyDescriptors(n);Object.assign(e,s)}return Object.defineProperties({},e)}function mT(t){return JSON.stringify(t)}function GAe(t){return t.toLowerCase().trim().replace(/[^\w\s-]/g,"").replace(/[\s_-]+/g,"-").replace(/^-+|-+$/g,"")}const UN="captureStackTrace"in Error?Error.captureStackTrace:(...t)=>{};function Ig(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)}const VAe=bw(()=>{var t;if(typeof navigator<"u"&&((t=navigator==null?void 0:navigator.userAgent)!=null&&t.includes("Cloudflare")))return!1;try{const e=Function;return new e(""),!0}catch{return!1}});function Fd(t){if(Ig(t)===!1)return!1;const e=t.constructor;if(e===void 0||typeof e!="function")return!0;const n=e.prototype;return!(Ig(n)===!1||Object.prototype.hasOwnProperty.call(n,"isPrototypeOf")===!1)}function BN(t){return Fd(t)?{...t}:Array.isArray(t)?[...t]:t}const WAe=new Set(["string","number","symbol"]);function Hx(t){return t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function Ta(t,e,n){const s=new t._zod.constr(e??t._zod.def);return(!e||n!=null&&n.parent)&&(s._zod.parent=t),s}function ht(t){const e=t;if(!e)return{};if(typeof e=="string")return{error:()=>e};if((e==null?void 0:e.message)!==void 0){if((e==null?void 0:e.error)!==void 0)throw new Error("Cannot specify both `message` and `error` params");e.error=e.message}return delete e.message,typeof e.error=="string"?{...e,error:()=>e.error}:e}function HAe(t){return Object.keys(t).filter(e=>t[e]._zod.optin==="optional"&&t[e]._zod.optout==="optional")}const KAe={safeint:[Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER],int32:[-2147483648,2147483647],uint32:[0,4294967295],float32:[-34028234663852886e22,34028234663852886e22],float64:[-Number.MAX_VALUE,Number.MAX_VALUE]};function jAe(t,e){const n=t._zod.def,s=Xl(t._zod.def,{get shape(){const r={};for(const i in e){if(!(i in n.shape))throw new Error(`Unrecognized key: "${i}"`);e[i]&&(r[i]=n.shape[i])}return jl(this,"shape",r),r},checks:[]});return Ta(t,s)}function XAe(t,e){const n=t._zod.def,s=Xl(t._zod.def,{get shape(){const r={...t._zod.def.shape};for(const i in e){if(!(i in n.shape))throw new Error(`Unrecognized key: "${i}"`);e[i]&&delete r[i]}return jl(this,"shape",r),r},checks:[]});return Ta(t,s)}function qAe(t,e){if(!Fd(e))throw new Error("Invalid input to extend: expected a plain object");const n=t._zod.def.checks;if(n&&n.length>0)throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");const r=Xl(t._zod.def,{get shape(){const i={...t._zod.def.shape,...e};return jl(this,"shape",i),i},checks:[]});return Ta(t,r)}function YAe(t,e){if(!Fd(e))throw new Error("Invalid input to safeExtend: expected a plain object");const n={...t._zod.def,get shape(){const s={...t._zod.def.shape,...e};return jl(this,"shape",s),s},checks:t._zod.def.checks};return Ta(t,n)}function ZAe(t,e){const n=Xl(t._zod.def,{get shape(){const s={...t._zod.def.shape,...e._zod.def.shape};return jl(this,"shape",s),s},get catchall(){return e._zod.def.catchall},checks:[]});return Ta(t,n)}function QAe(t,e,n){const s=Xl(e._zod.def,{get shape(){const r=e._zod.def.shape,i={...r};if(n)for(const o in n){if(!(o in r))throw new Error(`Unrecognized key: "${o}"`);n[o]&&(i[o]=t?new t({type:"optional",innerType:r[o]}):r[o])}else for(const o in r)i[o]=t?new t({type:"optional",innerType:r[o]}):r[o];return jl(this,"shape",i),i},checks:[]});return Ta(e,s)}function JAe(t,e,n){const s=Xl(e._zod.def,{get shape(){const r=e._zod.def.shape,i={...r};if(n)for(const o in n){if(!(o in i))throw new Error(`Unrecognized key: "${o}"`);n[o]&&(i[o]=new t({type:"nonoptional",innerType:r[o]}))}else for(const o in r)i[o]=new t({type:"nonoptional",innerType:r[o]});return jl(this,"shape",i),i},checks:[]});return Ta(e,s)}function Su(t,e=0){var n;if(t.aborted===!0)return!0;for(let s=e;s<t.issues.length;s++)if(((n=t.issues[s])==null?void 0:n.continue)!==!0)return!0;return!1}function zN(t,e){return e.map(n=>{var s;return(s=n).path??(s.path=[]),n.path.unshift(t),n})}function sm(t){return typeof t=="string"?t:t==null?void 0:t.message}function Tl(t,e,n){var r,i,o,a,l,u;const s={...t,path:t.path??[]};if(!t.message){const c=sm((o=(i=(r=t.inst)==null?void 0:r._zod.def)==null?void 0:i.error)==null?void 0:o.call(i,t))??sm((a=e==null?void 0:e.error)==null?void 0:a.call(e,t))??sm((l=n.customError)==null?void 0:l.call(n,t))??sm((u=n.localeError)==null?void 0:u.call(n,t))??"Invalid input";s.message=c}return delete s.inst,delete s.continue,e!=null&&e.reportInput||delete s.input,s}function ww(t){return Array.isArray(t)?"array":typeof t=="string"?"string":"unknown"}function Ud(...t){const[e,n,s]=t;return typeof e=="string"?{message:e,code:"custom",input:n,inst:s}:{...e}}const GN=(t,e)=>{t.name="$ZodError",Object.defineProperty(t,"_zod",{value:t._zod,enumerable:!1}),Object.defineProperty(t,"issues",{value:e,enumerable:!1}),t.message=JSON.stringify(e,vy,2),Object.defineProperty(t,"toString",{value:()=>t.message,enumerable:!1})},VN=Ie("$ZodError",GN),WN=Ie("$ZodError",GN,{Parent:Error});function ePe(t,e=n=>n.message){const n={},s=[];for(const r of t.issues)r.path.length>0?(n[r.path[0]]=n[r.path[0]]||[],n[r.path[0]].push(e(r))):s.push(e(r));return{formErrors:s,fieldErrors:n}}function tPe(t,e=n=>n.message){const n={_errors:[]},s=r=>{for(const i of r.issues)if(i.code==="invalid_union"&&i.errors.length)i.errors.map(o=>s({issues:o}));else if(i.code==="invalid_key")s({issues:i.issues});else if(i.code==="invalid_element")s({issues:i.issues});else if(i.path.length===0)n._errors.push(e(i));else{let o=n,a=0;for(;a<i.path.length;){const l=i.path[a];a===i.path.length-1?(o[l]=o[l]||{_errors:[]},o[l]._errors.push(e(i))):o[l]=o[l]||{_errors:[]},o=o[l],a++}}};return s(t),n}const Sw=t=>(e,n,s,r)=>{const i=s?Object.assign(s,{async:!1}):{async:!1},o=e._zod.run({value:n,issues:[]},i);if(o instanceof Promise)throw new Nu;if(o.issues.length){const a=new((r==null?void 0:r.Err)??t)(o.issues.map(l=>Tl(l,i,Cl())));throw UN(a,r==null?void 0:r.callee),a}return o.value},Cw=t=>async(e,n,s,r)=>{const i=s?Object.assign(s,{async:!0}):{async:!0};let o=e._zod.run({value:n,issues:[]},i);if(o instanceof Promise&&(o=await o),o.issues.length){const a=new((r==null?void 0:r.Err)??t)(o.issues.map(l=>Tl(l,i,Cl())));throw UN(a,r==null?void 0:r.callee),a}return o.value},Kx=t=>(e,n,s)=>{const r=s?{...s,async:!1}:{async:!1},i=e._zod.run({value:n,issues:[]},r);if(i instanceof Promise)throw new Nu;return i.issues.length?{success:!1,error:new(t??VN)(i.issues.map(o=>Tl(o,r,Cl())))}:{success:!0,data:i.value}},nPe=Kx(WN),jx=t=>async(e,n,s)=>{const r=s?Object.assign(s,{async:!0}):{async:!0};let i=e._zod.run({value:n,issues:[]},r);return i instanceof Promise&&(i=await i),i.issues.length?{success:!1,error:new t(i.issues.map(o=>Tl(o,r,Cl())))}:{success:!0,data:i.value}},sPe=jx(WN),rPe=t=>(e,n,s)=>{const r=s?Object.assign(s,{direction:"backward"}):{direction:"backward"};return Sw(t)(e,n,r)},iPe=t=>(e,n,s)=>Sw(t)(e,n,s),oPe=t=>async(e,n,s)=>{const r=s?Object.assign(s,{direction:"backward"}):{direction:"backward"};return Cw(t)(e,n,r)},aPe=t=>async(e,n,s)=>Cw(t)(e,n,s),lPe=t=>(e,n,s)=>{const r=s?Object.assign(s,{direction:"backward"}):{direction:"backward"};return Kx(t)(e,n,r)},uPe=t=>(e,n,s)=>Kx(t)(e,n,s),cPe=t=>async(e,n,s)=>{const r=s?Object.assign(s,{direction:"backward"}):{direction:"backward"};return jx(t)(e,n,r)},hPe=t=>async(e,n,s)=>jx(t)(e,n,s),dPe=/^[cC][^\s-]{8,}$/,fPe=/^[0-9a-z]+$/,pPe=/^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,mPe=/^[0-9a-vA-V]{20}$/,gPe=/^[A-Za-z0-9]{27}$/,xPe=/^[a-zA-Z0-9_-]{21}$/,bPe=/^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/,yPe=/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,gT=t=>t?new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${t}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`):/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,vPe=/^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,wPe="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";function SPe(){return new RegExp(wPe,"u")}const CPe=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,TPe=/^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/,IPe=/^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,kPe=/^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,EPe=/^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,HN=/^[A-Za-z0-9_-]*$/,_Pe=/^\+(?:[0-9]){6,14}[0-9]$/,KN="(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))",$Pe=new RegExp(`^${KN}$`);function jN(t){const e="(?:[01]\\d|2[0-3]):[0-5]\\d";return typeof t.precision=="number"?t.precision===-1?`${e}`:t.precision===0?`${e}:[0-5]\\d`:`${e}:[0-5]\\d\\.\\d{${t.precision}}`:`${e}(?::[0-5]\\d(?:\\.\\d+)?)?`}function RPe(t){return new RegExp(`^${jN(t)}$`)}function APe(t){const e=jN({precision:t.precision}),n=["Z"];t.local&&n.push(""),t.offset&&n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");const s=`${e}(?:${n.join("|")})`;return new RegExp(`^${KN}T(?:${s})$`)}const PPe=t=>{const e=t?`[\\s\\S]{${(t==null?void 0:t.minimum)??0},${(t==null?void 0:t.maximum)??""}}`:"[\\s\\S]*";return new RegExp(`^${e}$`)},DPe=/^-?\d+$/,NPe=/^-?\d+(?:\.\d+)?/,MPe=/^(?:true|false)$/i,LPe=/^[^A-Z]*$/,OPe=/^[^a-z]*$/,xr=Ie("$ZodCheck",(t,e)=>{var n;t._zod??(t._zod={}),t._zod.def=e,(n=t._zod).onattach??(n.onattach=[])}),XN={number:"number",bigint:"bigint",object:"date"},qN=Ie("$ZodCheckLessThan",(t,e)=>{xr.init(t,e);const n=XN[typeof e.value];t._zod.onattach.push(s=>{const r=s._zod.bag,i=(e.inclusive?r.maximum:r.exclusiveMaximum)??Number.POSITIVE_INFINITY;e.value<i&&(e.inclusive?r.maximum=e.value:r.exclusiveMaximum=e.value)}),t._zod.check=s=>{(e.inclusive?s.value<=e.value:s.value<e.value)||s.issues.push({origin:n,code:"too_big",maximum:e.value,input:s.value,inclusive:e.inclusive,inst:t,continue:!e.abort})}}),YN=Ie("$ZodCheckGreaterThan",(t,e)=>{xr.init(t,e);const n=XN[typeof e.value];t._zod.onattach.push(s=>{const r=s._zod.bag,i=(e.inclusive?r.minimum:r.exclusiveMinimum)??Number.NEGATIVE_INFINITY;e.value>i&&(e.inclusive?r.minimum=e.value:r.exclusiveMinimum=e.value)}),t._zod.check=s=>{(e.inclusive?s.value>=e.value:s.value>e.value)||s.issues.push({origin:n,code:"too_small",minimum:e.value,input:s.value,inclusive:e.inclusive,inst:t,continue:!e.abort})}}),FPe=Ie("$ZodCheckMultipleOf",(t,e)=>{xr.init(t,e),t._zod.onattach.push(n=>{var s;(s=n._zod.bag).multipleOf??(s.multipleOf=e.value)}),t._zod.check=n=>{if(typeof n.value!=typeof e.value)throw new Error("Cannot mix number and bigint in multiple_of check.");(typeof n.value=="bigint"?n.value%e.value===BigInt(0):zAe(n.value,e.value)===0)||n.issues.push({origin:typeof n.value,code:"not_multiple_of",divisor:e.value,input:n.value,inst:t,continue:!e.abort})}}),UPe=Ie("$ZodCheckNumberFormat",(t,e)=>{var o;xr.init(t,e),e.format=e.format||"float64";const n=(o=e.format)==null?void 0:o.includes("int"),s=n?"int":"number",[r,i]=KAe[e.format];t._zod.onattach.push(a=>{const l=a._zod.bag;l.format=e.format,l.minimum=r,l.maximum=i,n&&(l.pattern=DPe)}),t._zod.check=a=>{const l=a.value;if(n){if(!Number.isInteger(l)){a.issues.push({expected:s,format:e.format,code:"invalid_type",continue:!1,input:l,inst:t});return}if(!Number.isSafeInteger(l)){l>0?a.issues.push({input:l,code:"too_big",maximum:Number.MAX_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:t,origin:s,continue:!e.abort}):a.issues.push({input:l,code:"too_small",minimum:Number.MIN_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:t,origin:s,continue:!e.abort});return}}l<r&&a.issues.push({origin:"number",input:l,code:"too_small",minimum:r,inclusive:!0,inst:t,continue:!e.abort}),l>i&&a.issues.push({origin:"number",input:l,code:"too_big",maximum:i,inst:t})}}),BPe=Ie("$ZodCheckMaxLength",(t,e)=>{var n;xr.init(t,e),(n=t._zod.def).when??(n.when=s=>{const r=s.value;return!yw(r)&&r.length!==void 0}),t._zod.onattach.push(s=>{const r=s._zod.bag.maximum??Number.POSITIVE_INFINITY;e.maximum<r&&(s._zod.bag.maximum=e.maximum)}),t._zod.check=s=>{const r=s.value;if(r.length<=e.maximum)return;const o=ww(r);s.issues.push({origin:o,code:"too_big",maximum:e.maximum,inclusive:!0,input:r,inst:t,continue:!e.abort})}}),zPe=Ie("$ZodCheckMinLength",(t,e)=>{var n;xr.init(t,e),(n=t._zod.def).when??(n.when=s=>{const r=s.value;return!yw(r)&&r.length!==void 0}),t._zod.onattach.push(s=>{const r=s._zod.bag.minimum??Number.NEGATIVE_INFINITY;e.minimum>r&&(s._zod.bag.minimum=e.minimum)}),t._zod.check=s=>{const r=s.value;if(r.length>=e.minimum)return;const o=ww(r);s.issues.push({origin:o,code:"too_small",minimum:e.minimum,inclusive:!0,input:r,inst:t,continue:!e.abort})}}),GPe=Ie("$ZodCheckLengthEquals",(t,e)=>{var n;xr.init(t,e),(n=t._zod.def).when??(n.when=s=>{const r=s.value;return!yw(r)&&r.length!==void 0}),t._zod.onattach.push(s=>{const r=s._zod.bag;r.minimum=e.length,r.maximum=e.length,r.length=e.length}),t._zod.check=s=>{const r=s.value,i=r.length;if(i===e.length)return;const o=ww(r),a=i>e.length;s.issues.push({origin:o,...a?{code:"too_big",maximum:e.length}:{code:"too_small",minimum:e.length},inclusive:!0,exact:!0,input:s.value,inst:t,continue:!e.abort})}}),Xx=Ie("$ZodCheckStringFormat",(t,e)=>{var n,s;xr.init(t,e),t._zod.onattach.push(r=>{const i=r._zod.bag;i.format=e.format,e.pattern&&(i.patterns??(i.patterns=new Set),i.patterns.add(e.pattern))}),e.pattern?(n=t._zod).check??(n.check=r=>{e.pattern.lastIndex=0,!e.pattern.test(r.value)&&r.issues.push({origin:"string",code:"invalid_format",format:e.format,input:r.value,...e.pattern?{pattern:e.pattern.toString()}:{},inst:t,continue:!e.abort})}):(s=t._zod).check??(s.check=()=>{})}),VPe=Ie("$ZodCheckRegex",(t,e)=>{Xx.init(t,e),t._zod.check=n=>{e.pattern.lastIndex=0,!e.pattern.test(n.value)&&n.issues.push({origin:"string",code:"invalid_format",format:"regex",input:n.value,pattern:e.pattern.toString(),inst:t,continue:!e.abort})}}),WPe=Ie("$ZodCheckLowerCase",(t,e)=>{e.pattern??(e.pattern=LPe),Xx.init(t,e)}),HPe=Ie("$ZodCheckUpperCase",(t,e)=>{e.pattern??(e.pattern=OPe),Xx.init(t,e)}),KPe=Ie("$ZodCheckIncludes",(t,e)=>{xr.init(t,e);const n=Hx(e.includes),s=new RegExp(typeof e.position=="number"?`^.{${e.position}}${n}`:n);e.pattern=s,t._zod.onattach.push(r=>{const i=r._zod.bag;i.patterns??(i.patterns=new Set),i.patterns.add(s)}),t._zod.check=r=>{r.value.includes(e.includes,e.position)||r.issues.push({origin:"string",code:"invalid_format",format:"includes",includes:e.includes,input:r.value,inst:t,continue:!e.abort})}}),jPe=Ie("$ZodCheckStartsWith",(t,e)=>{xr.init(t,e);const n=new RegExp(`^${Hx(e.prefix)}.*`);e.pattern??(e.pattern=n),t._zod.onattach.push(s=>{const r=s._zod.bag;r.patterns??(r.patterns=new Set),r.patterns.add(n)}),t._zod.check=s=>{s.value.startsWith(e.prefix)||s.issues.push({origin:"string",code:"invalid_format",format:"starts_with",prefix:e.prefix,input:s.value,inst:t,continue:!e.abort})}}),XPe=Ie("$ZodCheckEndsWith",(t,e)=>{xr.init(t,e);const n=new RegExp(`.*${Hx(e.suffix)}$`);e.pattern??(e.pattern=n),t._zod.onattach.push(s=>{const r=s._zod.bag;r.patterns??(r.patterns=new Set),r.patterns.add(n)}),t._zod.check=s=>{s.value.endsWith(e.suffix)||s.issues.push({origin:"string",code:"invalid_format",format:"ends_with",suffix:e.suffix,input:s.value,inst:t,continue:!e.abort})}}),qPe=Ie("$ZodCheckOverwrite",(t,e)=>{xr.init(t,e),t._zod.check=n=>{n.value=e.tx(n.value)}});class YPe{constructor(e=[]){this.content=[],this.indent=0,this&&(this.args=e)}indented(e){this.indent+=1,e(this),this.indent-=1}write(e){if(typeof e=="function"){e(this,{execution:"sync"}),e(this,{execution:"async"});return}const s=e.split(`
`).filter(o=>o),r=Math.min(...s.map(o=>o.length-o.trimStart().length)),i=s.map(o=>o.slice(r)).map(o=>" ".repeat(this.indent*2)+o);for(const o of i)this.content.push(o)}compile(){const e=Function,n=this==null?void 0:this.args,r=[...((this==null?void 0:this.content)??[""]).map(i=>`  ${i}`)];return new e(...n,r.join(`
`))}}const ZPe={major:4,minor:1,patch:13},Yn=Ie("$ZodType",(t,e)=>{var r;var n;t??(t={}),t._zod.def=e,t._zod.bag=t._zod.bag||{},t._zod.version=ZPe;const s=[...t._zod.def.checks??[]];t._zod.traits.has("$ZodCheck")&&s.unshift(t);for(const i of s)for(const o of i._zod.onattach)o(t);if(s.length===0)(n=t._zod).deferred??(n.deferred=[]),(r=t._zod.deferred)==null||r.push(()=>{t._zod.run=t._zod.parse});else{const i=(a,l,u)=>{let c=Su(a),h;for(const d of l){if(d._zod.def.when){if(!d._zod.def.when(a))continue}else if(c)continue;const f=a.issues.length,p=d._zod.check(a);if(p instanceof Promise&&(u==null?void 0:u.async)===!1)throw new Nu;if(h||p instanceof Promise)h=(h??Promise.resolve()).then(async()=>{await p,a.issues.length!==f&&(c||(c=Su(a,f)))});else{if(a.issues.length===f)continue;c||(c=Su(a,f))}}return h?h.then(()=>a):a},o=(a,l,u)=>{if(Su(a))return a.aborted=!0,a;const c=i(l,s,u);if(c instanceof Promise){if(u.async===!1)throw new Nu;return c.then(h=>t._zod.parse(h,u))}return t._zod.parse(c,u)};t._zod.run=(a,l)=>{if(l.skipChecks)return t._zod.parse(a,l);if(l.direction==="backward"){const c=t._zod.parse({value:a.value,issues:[]},{...l,skipChecks:!0});return c instanceof Promise?c.then(h=>o(h,a,l)):o(c,a,l)}const u=t._zod.parse(a,l);if(u instanceof Promise){if(l.async===!1)throw new Nu;return u.then(c=>i(c,s,l))}return i(u,s,l)}}t["~standard"]={validate:i=>{var o;try{const a=nPe(t,i);return a.success?{value:a.data}:{issues:(o=a.error)==null?void 0:o.issues}}catch{return sPe(t,i).then(l=>{var u;return l.success?{value:l.data}:{issues:(u=l.error)==null?void 0:u.issues}})}},vendor:"zod",version:1}}),Tw=Ie("$ZodString",(t,e)=>{var n;Yn.init(t,e),t._zod.pattern=[...((n=t==null?void 0:t._zod.bag)==null?void 0:n.patterns)??[]].pop()??PPe(t._zod.bag),t._zod.parse=(s,r)=>{if(e.coerce)try{s.value=String(s.value)}catch{}return typeof s.value=="string"||s.issues.push({expected:"string",code:"invalid_type",input:s.value,inst:t}),s}}),kn=Ie("$ZodStringFormat",(t,e)=>{Xx.init(t,e),Tw.init(t,e)}),QPe=Ie("$ZodGUID",(t,e)=>{e.pattern??(e.pattern=yPe),kn.init(t,e)}),JPe=Ie("$ZodUUID",(t,e)=>{if(e.version){const s={v1:1,v2:2,v3:3,v4:4,v5:5,v6:6,v7:7,v8:8}[e.version];if(s===void 0)throw new Error(`Invalid UUID version: "${e.version}"`);e.pattern??(e.pattern=gT(s))}else e.pattern??(e.pattern=gT());kn.init(t,e)}),eDe=Ie("$ZodEmail",(t,e)=>{e.pattern??(e.pattern=vPe),kn.init(t,e)}),tDe=Ie("$ZodURL",(t,e)=>{kn.init(t,e),t._zod.check=n=>{try{const s=n.value.trim(),r=new URL(s);e.hostname&&(e.hostname.lastIndex=0,e.hostname.test(r.hostname)||n.issues.push({code:"invalid_format",format:"url",note:"Invalid hostname",pattern:e.hostname.source,input:n.value,inst:t,continue:!e.abort})),e.protocol&&(e.protocol.lastIndex=0,e.protocol.test(r.protocol.endsWith(":")?r.protocol.slice(0,-1):r.protocol)||n.issues.push({code:"invalid_format",format:"url",note:"Invalid protocol",pattern:e.protocol.source,input:n.value,inst:t,continue:!e.abort})),e.normalize?n.value=r.href:n.value=s;return}catch{n.issues.push({code:"invalid_format",format:"url",input:n.value,inst:t,continue:!e.abort})}}}),nDe=Ie("$ZodEmoji",(t,e)=>{e.pattern??(e.pattern=SPe()),kn.init(t,e)}),sDe=Ie("$ZodNanoID",(t,e)=>{e.pattern??(e.pattern=xPe),kn.init(t,e)}),rDe=Ie("$ZodCUID",(t,e)=>{e.pattern??(e.pattern=dPe),kn.init(t,e)}),iDe=Ie("$ZodCUID2",(t,e)=>{e.pattern??(e.pattern=fPe),kn.init(t,e)}),oDe=Ie("$ZodULID",(t,e)=>{e.pattern??(e.pattern=pPe),kn.init(t,e)}),aDe=Ie("$ZodXID",(t,e)=>{e.pattern??(e.pattern=mPe),kn.init(t,e)}),lDe=Ie("$ZodKSUID",(t,e)=>{e.pattern??(e.pattern=gPe),kn.init(t,e)}),uDe=Ie("$ZodISODateTime",(t,e)=>{e.pattern??(e.pattern=APe(e)),kn.init(t,e)}),cDe=Ie("$ZodISODate",(t,e)=>{e.pattern??(e.pattern=$Pe),kn.init(t,e)}),hDe=Ie("$ZodISOTime",(t,e)=>{e.pattern??(e.pattern=RPe(e)),kn.init(t,e)}),dDe=Ie("$ZodISODuration",(t,e)=>{e.pattern??(e.pattern=bPe),kn.init(t,e)}),fDe=Ie("$ZodIPv4",(t,e)=>{e.pattern??(e.pattern=CPe),kn.init(t,e),t._zod.bag.format="ipv4"}),pDe=Ie("$ZodIPv6",(t,e)=>{e.pattern??(e.pattern=TPe),kn.init(t,e),t._zod.bag.format="ipv6",t._zod.check=n=>{try{new URL(`http://[${n.value}]`)}catch{n.issues.push({code:"invalid_format",format:"ipv6",input:n.value,inst:t,continue:!e.abort})}}}),mDe=Ie("$ZodCIDRv4",(t,e)=>{e.pattern??(e.pattern=IPe),kn.init(t,e)}),gDe=Ie("$ZodCIDRv6",(t,e)=>{e.pattern??(e.pattern=kPe),kn.init(t,e),t._zod.check=n=>{const s=n.value.split("/");try{if(s.length!==2)throw new Error;const[r,i]=s;if(!i)throw new Error;const o=Number(i);if(`${o}`!==i)throw new Error;if(o<0||o>128)throw new Error;new URL(`http://[${r}]`)}catch{n.issues.push({code:"invalid_format",format:"cidrv6",input:n.value,inst:t,continue:!e.abort})}}});function ZN(t){if(t==="")return!0;if(t.length%4!==0)return!1;try{return atob(t),!0}catch{return!1}}const xDe=Ie("$ZodBase64",(t,e)=>{e.pattern??(e.pattern=EPe),kn.init(t,e),t._zod.bag.contentEncoding="base64",t._zod.check=n=>{ZN(n.value)||n.issues.push({code:"invalid_format",format:"base64",input:n.value,inst:t,continue:!e.abort})}});function bDe(t){if(!HN.test(t))return!1;const e=t.replace(/[-_]/g,s=>s==="-"?"+":"/"),n=e.padEnd(Math.ceil(e.length/4)*4,"=");return ZN(n)}const yDe=Ie("$ZodBase64URL",(t,e)=>{e.pattern??(e.pattern=HN),kn.init(t,e),t._zod.bag.contentEncoding="base64url",t._zod.check=n=>{bDe(n.value)||n.issues.push({code:"invalid_format",format:"base64url",input:n.value,inst:t,continue:!e.abort})}}),vDe=Ie("$ZodE164",(t,e)=>{e.pattern??(e.pattern=_Pe),kn.init(t,e)});function wDe(t,e=null){try{const n=t.split(".");if(n.length!==3)return!1;const[s]=n;if(!s)return!1;const r=JSON.parse(atob(s));return!("typ"in r&&(r==null?void 0:r.typ)!=="JWT"||!r.alg||e&&(!("alg"in r)||r.alg!==e))}catch{return!1}}const SDe=Ie("$ZodJWT",(t,e)=>{kn.init(t,e),t._zod.check=n=>{wDe(n.value,e.alg)||n.issues.push({code:"invalid_format",format:"jwt",input:n.value,inst:t,continue:!e.abort})}}),QN=Ie("$ZodNumber",(t,e)=>{Yn.init(t,e),t._zod.pattern=t._zod.bag.pattern??NPe,t._zod.parse=(n,s)=>{if(e.coerce)try{n.value=Number(n.value)}catch{}const r=n.value;if(typeof r=="number"&&!Number.isNaN(r)&&Number.isFinite(r))return n;const i=typeof r=="number"?Number.isNaN(r)?"NaN":Number.isFinite(r)?void 0:"Infinity":void 0;return n.issues.push({expected:"number",code:"invalid_type",input:r,inst:t,...i?{received:i}:{}}),n}}),CDe=Ie("$ZodNumberFormat",(t,e)=>{UPe.init(t,e),QN.init(t,e)}),TDe=Ie("$ZodBoolean",(t,e)=>{Yn.init(t,e),t._zod.pattern=MPe,t._zod.parse=(n,s)=>{if(e.coerce)try{n.value=!!n.value}catch{}const r=n.value;return typeof r=="boolean"||n.issues.push({expected:"boolean",code:"invalid_type",input:r,inst:t}),n}}),IDe=Ie("$ZodUnknown",(t,e)=>{Yn.init(t,e),t._zod.parse=n=>n}),kDe=Ie("$ZodNever",(t,e)=>{Yn.init(t,e),t._zod.parse=(n,s)=>(n.issues.push({expected:"never",code:"invalid_type",input:n.value,inst:t}),n)});function xT(t,e,n){t.issues.length&&e.issues.push(...zN(n,t.issues)),e.value[n]=t.value}const EDe=Ie("$ZodArray",(t,e)=>{Yn.init(t,e),t._zod.parse=(n,s)=>{const r=n.value;if(!Array.isArray(r))return n.issues.push({expected:"array",code:"invalid_type",input:r,inst:t}),n;n.value=Array(r.length);const i=[];for(let o=0;o<r.length;o++){const a=r[o],l=e.element._zod.run({value:a,issues:[]},s);l instanceof Promise?i.push(l.then(u=>xT(u,n,o))):xT(l,n,o)}return i.length?Promise.all(i).then(()=>n):n}});function kg(t,e,n,s){t.issues.length&&e.issues.push(...zN(n,t.issues)),t.value===void 0?n in s&&(e.value[n]=void 0):e.value[n]=t.value}function JN(t){var s,r,i,o;const e=Object.keys(t.shape);for(const a of e)if(!((o=(i=(r=(s=t.shape)==null?void 0:s[a])==null?void 0:r._zod)==null?void 0:i.traits)!=null&&o.has("$ZodType")))throw new Error(`Invalid element at key "${a}": expected a Zod schema`);const n=HAe(t.shape);return{...t,keys:e,keySet:new Set(e),numKeys:e.length,optionalKeys:new Set(n)}}function e4(t,e,n,s,r,i){const o=[],a=r.keySet,l=r.catchall._zod,u=l.def.type;for(const c in e){if(a.has(c))continue;if(u==="never"){o.push(c);continue}const h=l.run({value:e[c],issues:[]},s);h instanceof Promise?t.push(h.then(d=>kg(d,n,c,e))):kg(h,n,c,e)}return o.length&&n.issues.push({code:"unrecognized_keys",keys:o,input:e,inst:i}),t.length?Promise.all(t).then(()=>n):n}const _De=Ie("$ZodObject",(t,e)=>{Yn.init(t,e);const n=Object.getOwnPropertyDescriptor(e,"shape");if(!(n!=null&&n.get)){const a=e.shape;Object.defineProperty(e,"shape",{get:()=>{const l={...a};return Object.defineProperty(e,"shape",{value:l}),l}})}const s=bw(()=>JN(e));fn(t._zod,"propValues",()=>{const a=e.shape,l={};for(const u in a){const c=a[u]._zod;if(c.values){l[u]??(l[u]=new Set);for(const h of c.values)l[u].add(h)}}return l});const r=Ig,i=e.catchall;let o;t._zod.parse=(a,l)=>{o??(o=s.value);const u=a.value;if(!r(u))return a.issues.push({expected:"object",code:"invalid_type",input:u,inst:t}),a;a.value={};const c=[],h=o.shape;for(const d of o.keys){const p=h[d]._zod.run({value:u[d],issues:[]},l);p instanceof Promise?c.push(p.then(g=>kg(g,a,d,u))):kg(p,a,d,u)}return i?e4(c,u,a,l,s.value,t):c.length?Promise.all(c).then(()=>a):a}}),$De=Ie("$ZodObjectJIT",(t,e)=>{_De.init(t,e);const n=t._zod.parse,s=bw(()=>JN(e)),r=d=>{const f=new YPe(["shape","payload","ctx"]),p=s.value,g=v=>{const y=mT(v);return`shape[${y}]._zod.run({ value: input[${y}], issues: [] }, ctx)`};f.write("const input = payload.value;");const m=Object.create(null);let x=0;for(const v of p.keys)m[v]=`key_${x++}`;f.write("const newResult = {};");for(const v of p.keys){const y=m[v],C=mT(v);f.write(`const ${y} = ${g(v)};`),f.write(`
        if (${y}.issues.length) {
          payload.issues = payload.issues.concat(${y}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${C}, ...iss.path] : [${C}]
          })));
        }
        
        
        if (${y}.value === undefined) {
          if (${C} in input) {
            newResult[${C}] = undefined;
          }
        } else {
          newResult[${C}] = ${y}.value;
        }
        
      `)}f.write("payload.value = newResult;"),f.write("return payload;");const b=f.compile();return(v,y)=>b(d,v,y)};let i;const o=Ig,a=!FN.jitless,u=a&&VAe.value,c=e.catchall;let h;t._zod.parse=(d,f)=>{h??(h=s.value);const p=d.value;return o(p)?a&&u&&(f==null?void 0:f.async)===!1&&f.jitless!==!0?(i||(i=r(e.shape)),d=i(d,f),c?e4([],p,d,f,h,t):d):n(d,f):(d.issues.push({expected:"object",code:"invalid_type",input:p,inst:t}),d)}});function bT(t,e,n,s){for(const i of t)if(i.issues.length===0)return e.value=i.value,e;const r=t.filter(i=>!Su(i));return r.length===1?(e.value=r[0].value,r[0]):(e.issues.push({code:"invalid_union",input:e.value,inst:n,errors:t.map(i=>i.issues.map(o=>Tl(o,s,Cl())))}),e)}const RDe=Ie("$ZodUnion",(t,e)=>{Yn.init(t,e),fn(t._zod,"optin",()=>e.options.some(r=>r._zod.optin==="optional")?"optional":void 0),fn(t._zod,"optout",()=>e.options.some(r=>r._zod.optout==="optional")?"optional":void 0),fn(t._zod,"values",()=>{if(e.options.every(r=>r._zod.values))return new Set(e.options.flatMap(r=>Array.from(r._zod.values)))}),fn(t._zod,"pattern",()=>{if(e.options.every(r=>r._zod.pattern)){const r=e.options.map(i=>i._zod.pattern);return new RegExp(`^(${r.map(i=>vw(i.source)).join("|")})$`)}});const n=e.options.length===1,s=e.options[0]._zod.run;t._zod.parse=(r,i)=>{if(n)return s(r,i);let o=!1;const a=[];for(const l of e.options){const u=l._zod.run({value:r.value,issues:[]},i);if(u instanceof Promise)a.push(u),o=!0;else{if(u.issues.length===0)return u;a.push(u)}}return o?Promise.all(a).then(l=>bT(l,r,t,i)):bT(a,r,t,i)}}),ADe=Ie("$ZodIntersection",(t,e)=>{Yn.init(t,e),t._zod.parse=(n,s)=>{const r=n.value,i=e.left._zod.run({value:r,issues:[]},s),o=e.right._zod.run({value:r,issues:[]},s);return i instanceof Promise||o instanceof Promise?Promise.all([i,o]).then(([l,u])=>yT(n,l,u)):yT(n,i,o)}});function wy(t,e){if(t===e)return{valid:!0,data:t};if(t instanceof Date&&e instanceof Date&&+t==+e)return{valid:!0,data:t};if(Fd(t)&&Fd(e)){const n=Object.keys(e),s=Object.keys(t).filter(i=>n.indexOf(i)!==-1),r={...t,...e};for(const i of s){const o=wy(t[i],e[i]);if(!o.valid)return{valid:!1,mergeErrorPath:[i,...o.mergeErrorPath]};r[i]=o.data}return{valid:!0,data:r}}if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return{valid:!1,mergeErrorPath:[]};const n=[];for(let s=0;s<t.length;s++){const r=t[s],i=e[s],o=wy(r,i);if(!o.valid)return{valid:!1,mergeErrorPath:[s,...o.mergeErrorPath]};n.push(o.data)}return{valid:!0,data:n}}return{valid:!1,mergeErrorPath:[]}}function yT(t,e,n){if(e.issues.length&&t.issues.push(...e.issues),n.issues.length&&t.issues.push(...n.issues),Su(t))return t;const s=wy(e.value,n.value);if(!s.valid)throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(s.mergeErrorPath)}`);return t.value=s.data,t}const PDe=Ie("$ZodEnum",(t,e)=>{Yn.init(t,e);const n=BAe(e.entries),s=new Set(n);t._zod.values=s,t._zod.pattern=new RegExp(`^(${n.filter(r=>WAe.has(typeof r)).map(r=>typeof r=="string"?Hx(r):r.toString()).join("|")})$`),t._zod.parse=(r,i)=>{const o=r.value;return s.has(o)||r.issues.push({code:"invalid_value",values:n,input:o,inst:t}),r}}),DDe=Ie("$ZodTransform",(t,e)=>{Yn.init(t,e),t._zod.parse=(n,s)=>{if(s.direction==="backward")throw new ON(t.constructor.name);const r=e.transform(n.value,n);if(s.async)return(r instanceof Promise?r:Promise.resolve(r)).then(o=>(n.value=o,n));if(r instanceof Promise)throw new Nu;return n.value=r,n}});function vT(t,e){return t.issues.length&&e===void 0?{issues:[],value:void 0}:t}const NDe=Ie("$ZodOptional",(t,e)=>{Yn.init(t,e),t._zod.optin="optional",t._zod.optout="optional",fn(t._zod,"values",()=>e.innerType._zod.values?new Set([...e.innerType._zod.values,void 0]):void 0),fn(t._zod,"pattern",()=>{const n=e.innerType._zod.pattern;return n?new RegExp(`^(${vw(n.source)})?$`):void 0}),t._zod.parse=(n,s)=>{if(e.innerType._zod.optin==="optional"){const r=e.innerType._zod.run(n,s);return r instanceof Promise?r.then(i=>vT(i,n.value)):vT(r,n.value)}return n.value===void 0?n:e.innerType._zod.run(n,s)}}),MDe=Ie("$ZodNullable",(t,e)=>{Yn.init(t,e),fn(t._zod,"optin",()=>e.innerType._zod.optin),fn(t._zod,"optout",()=>e.innerType._zod.optout),fn(t._zod,"pattern",()=>{const n=e.innerType._zod.pattern;return n?new RegExp(`^(${vw(n.source)}|null)$`):void 0}),fn(t._zod,"values",()=>e.innerType._zod.values?new Set([...e.innerType._zod.values,null]):void 0),t._zod.parse=(n,s)=>n.value===null?n:e.innerType._zod.run(n,s)}),LDe=Ie("$ZodDefault",(t,e)=>{Yn.init(t,e),t._zod.optin="optional",fn(t._zod,"values",()=>e.innerType._zod.values),t._zod.parse=(n,s)=>{if(s.direction==="backward")return e.innerType._zod.run(n,s);if(n.value===void 0)return n.value=e.defaultValue,n;const r=e.innerType._zod.run(n,s);return r instanceof Promise?r.then(i=>wT(i,e)):wT(r,e)}});function wT(t,e){return t.value===void 0&&(t.value=e.defaultValue),t}const ODe=Ie("$ZodPrefault",(t,e)=>{Yn.init(t,e),t._zod.optin="optional",fn(t._zod,"values",()=>e.innerType._zod.values),t._zod.parse=(n,s)=>(s.direction==="backward"||n.value===void 0&&(n.value=e.defaultValue),e.innerType._zod.run(n,s))}),FDe=Ie("$ZodNonOptional",(t,e)=>{Yn.init(t,e),fn(t._zod,"values",()=>{const n=e.innerType._zod.values;return n?new Set([...n].filter(s=>s!==void 0)):void 0}),t._zod.parse=(n,s)=>{const r=e.innerType._zod.run(n,s);return r instanceof Promise?r.then(i=>ST(i,t)):ST(r,t)}});function ST(t,e){return!t.issues.length&&t.value===void 0&&t.issues.push({code:"invalid_type",expected:"nonoptional",input:t.value,inst:e}),t}const UDe=Ie("$ZodCatch",(t,e)=>{Yn.init(t,e),fn(t._zod,"optin",()=>e.innerType._zod.optin),fn(t._zod,"optout",()=>e.innerType._zod.optout),fn(t._zod,"values",()=>e.innerType._zod.values),t._zod.parse=(n,s)=>{if(s.direction==="backward")return e.innerType._zod.run(n,s);const r=e.innerType._zod.run(n,s);return r instanceof Promise?r.then(i=>(n.value=i.value,i.issues.length&&(n.value=e.catchValue({...n,error:{issues:i.issues.map(o=>Tl(o,s,Cl()))},input:n.value}),n.issues=[]),n)):(n.value=r.value,r.issues.length&&(n.value=e.catchValue({...n,error:{issues:r.issues.map(i=>Tl(i,s,Cl()))},input:n.value}),n.issues=[]),n)}}),BDe=Ie("$ZodPipe",(t,e)=>{Yn.init(t,e),fn(t._zod,"values",()=>e.in._zod.values),fn(t._zod,"optin",()=>e.in._zod.optin),fn(t._zod,"optout",()=>e.out._zod.optout),fn(t._zod,"propValues",()=>e.in._zod.propValues),t._zod.parse=(n,s)=>{if(s.direction==="backward"){const i=e.out._zod.run(n,s);return i instanceof Promise?i.then(o=>rm(o,e.in,s)):rm(i,e.in,s)}const r=e.in._zod.run(n,s);return r instanceof Promise?r.then(i=>rm(i,e.out,s)):rm(r,e.out,s)}});function rm(t,e,n){return t.issues.length?(t.aborted=!0,t):e._zod.run({value:t.value,issues:t.issues},n)}const zDe=Ie("$ZodReadonly",(t,e)=>{Yn.init(t,e),fn(t._zod,"propValues",()=>e.innerType._zod.propValues),fn(t._zod,"values",()=>e.innerType._zod.values),fn(t._zod,"optin",()=>{var n,s;return(s=(n=e.innerType)==null?void 0:n._zod)==null?void 0:s.optin}),fn(t._zod,"optout",()=>{var n,s;return(s=(n=e.innerType)==null?void 0:n._zod)==null?void 0:s.optout}),t._zod.parse=(n,s)=>{if(s.direction==="backward")return e.innerType._zod.run(n,s);const r=e.innerType._zod.run(n,s);return r instanceof Promise?r.then(CT):CT(r)}});function CT(t){return t.value=Object.freeze(t.value),t}const GDe=Ie("$ZodCustom",(t,e)=>{xr.init(t,e),Yn.init(t,e),t._zod.parse=(n,s)=>n,t._zod.check=n=>{const s=n.value,r=e.fn(s);if(r instanceof Promise)return r.then(i=>TT(i,n,s,t));TT(r,n,s,t)}});function TT(t,e,n,s){if(!t){const r={code:"custom",input:n,inst:s,path:[...s._zod.def.path??[]],continue:!s._zod.def.abort};s._zod.def.params&&(r.params=s._zod.def.params),e.issues.push(Ud(r))}}var IT;class VDe{constructor(){this._map=new WeakMap,this._idmap=new Map}add(e,...n){const s=n[0];if(this._map.set(e,s),s&&typeof s=="object"&&"id"in s){if(this._idmap.has(s.id))throw new Error(`ID ${s.id} already exists in the registry`);this._idmap.set(s.id,e)}return this}clear(){return this._map=new WeakMap,this._idmap=new Map,this}remove(e){const n=this._map.get(e);return n&&typeof n=="object"&&"id"in n&&this._idmap.delete(n.id),this._map.delete(e),this}get(e){const n=e._zod.parent;if(n){const s={...this.get(n)??{}};delete s.id;const r={...s,...this._map.get(e)};return Object.keys(r).length?r:void 0}return this._map.get(e)}has(e){return this._map.has(e)}}function WDe(){return new VDe}(IT=globalThis).__zod_globalRegistry??(IT.__zod_globalRegistry=WDe());const im=globalThis.__zod_globalRegistry;function HDe(t,e){return new t({type:"string",...ht(e)})}function KDe(t,e){return new t({type:"string",format:"email",check:"string_format",abort:!1,...ht(e)})}function kT(t,e){return new t({type:"string",format:"guid",check:"string_format",abort:!1,...ht(e)})}function jDe(t,e){return new t({type:"string",format:"uuid",check:"string_format",abort:!1,...ht(e)})}function XDe(t,e){return new t({type:"string",format:"uuid",check:"string_format",abort:!1,version:"v4",...ht(e)})}function qDe(t,e){return new t({type:"string",format:"uuid",check:"string_format",abort:!1,version:"v6",...ht(e)})}function YDe(t,e){return new t({type:"string",format:"uuid",check:"string_format",abort:!1,version:"v7",...ht(e)})}function ZDe(t,e){return new t({type:"string",format:"url",check:"string_format",abort:!1,...ht(e)})}function QDe(t,e){return new t({type:"string",format:"emoji",check:"string_format",abort:!1,...ht(e)})}function JDe(t,e){return new t({type:"string",format:"nanoid",check:"string_format",abort:!1,...ht(e)})}function eNe(t,e){return new t({type:"string",format:"cuid",check:"string_format",abort:!1,...ht(e)})}function tNe(t,e){return new t({type:"string",format:"cuid2",check:"string_format",abort:!1,...ht(e)})}function nNe(t,e){return new t({type:"string",format:"ulid",check:"string_format",abort:!1,...ht(e)})}function sNe(t,e){return new t({type:"string",format:"xid",check:"string_format",abort:!1,...ht(e)})}function rNe(t,e){return new t({type:"string",format:"ksuid",check:"string_format",abort:!1,...ht(e)})}function iNe(t,e){return new t({type:"string",format:"ipv4",check:"string_format",abort:!1,...ht(e)})}function oNe(t,e){return new t({type:"string",format:"ipv6",check:"string_format",abort:!1,...ht(e)})}function aNe(t,e){return new t({type:"string",format:"cidrv4",check:"string_format",abort:!1,...ht(e)})}function lNe(t,e){return new t({type:"string",format:"cidrv6",check:"string_format",abort:!1,...ht(e)})}function uNe(t,e){return new t({type:"string",format:"base64",check:"string_format",abort:!1,...ht(e)})}function cNe(t,e){return new t({type:"string",format:"base64url",check:"string_format",abort:!1,...ht(e)})}function hNe(t,e){return new t({type:"string",format:"e164",check:"string_format",abort:!1,...ht(e)})}function dNe(t,e){return new t({type:"string",format:"jwt",check:"string_format",abort:!1,...ht(e)})}function fNe(t,e){return new t({type:"string",format:"datetime",check:"string_format",offset:!1,local:!1,precision:null,...ht(e)})}function pNe(t,e){return new t({type:"string",format:"date",check:"string_format",...ht(e)})}function mNe(t,e){return new t({type:"string",format:"time",check:"string_format",precision:null,...ht(e)})}function gNe(t,e){return new t({type:"string",format:"duration",check:"string_format",...ht(e)})}function xNe(t,e){return new t({type:"number",checks:[],...ht(e)})}function bNe(t,e){return new t({type:"number",check:"number_format",abort:!1,format:"safeint",...ht(e)})}function yNe(t,e){return new t({type:"boolean",...ht(e)})}function vNe(t){return new t({type:"unknown"})}function wNe(t,e){return new t({type:"never",...ht(e)})}function ET(t,e){return new qN({check:"less_than",...ht(e),value:t,inclusive:!1})}function Zb(t,e){return new qN({check:"less_than",...ht(e),value:t,inclusive:!0})}function _T(t,e){return new YN({check:"greater_than",...ht(e),value:t,inclusive:!1})}function Qb(t,e){return new YN({check:"greater_than",...ht(e),value:t,inclusive:!0})}function $T(t,e){return new FPe({check:"multiple_of",...ht(e),value:t})}function t4(t,e){return new BPe({check:"max_length",...ht(e),maximum:t})}function Eg(t,e){return new zPe({check:"min_length",...ht(e),minimum:t})}function n4(t,e){return new GPe({check:"length_equals",...ht(e),length:t})}function SNe(t,e){return new VPe({check:"string_format",format:"regex",...ht(e),pattern:t})}function CNe(t){return new WPe({check:"string_format",format:"lowercase",...ht(t)})}function TNe(t){return new HPe({check:"string_format",format:"uppercase",...ht(t)})}function INe(t,e){return new KPe({check:"string_format",format:"includes",...ht(e),includes:t})}function kNe(t,e){return new jPe({check:"string_format",format:"starts_with",...ht(e),prefix:t})}function ENe(t,e){return new XPe({check:"string_format",format:"ends_with",...ht(e),suffix:t})}function fh(t){return new qPe({check:"overwrite",tx:t})}function _Ne(t){return fh(e=>e.normalize(t))}function $Ne(){return fh(t=>t.trim())}function RNe(){return fh(t=>t.toLowerCase())}function ANe(){return fh(t=>t.toUpperCase())}function PNe(){return fh(t=>GAe(t))}function DNe(t,e,n){return new t({type:"array",element:e,...ht(n)})}function NNe(t,e,n){return new t({type:"custom",check:"custom",fn:e,...ht(n)})}function MNe(t){const e=LNe(n=>(n.addIssue=s=>{if(typeof s=="string")n.issues.push(Ud(s,n.value,e._zod.def));else{const r=s;r.fatal&&(r.continue=!1),r.code??(r.code="custom"),r.input??(r.input=n.value),r.inst??(r.inst=e),r.continue??(r.continue=!e._zod.def.abort),n.issues.push(Ud(r))}},t(n.value,n)));return e}function LNe(t,e){const n=new xr({check:"custom",...ht(e)});return n._zod.check=t,n}const ONe=Ie("ZodISODateTime",(t,e)=>{uDe.init(t,e),$n.init(t,e)});function FNe(t){return fNe(ONe,t)}const UNe=Ie("ZodISODate",(t,e)=>{cDe.init(t,e),$n.init(t,e)});function BNe(t){return pNe(UNe,t)}const zNe=Ie("ZodISOTime",(t,e)=>{hDe.init(t,e),$n.init(t,e)});function GNe(t){return mNe(zNe,t)}const VNe=Ie("ZodISODuration",(t,e)=>{dDe.init(t,e),$n.init(t,e)});function WNe(t){return gNe(VNe,t)}const HNe=(t,e)=>{VN.init(t,e),t.name="ZodError",Object.defineProperties(t,{format:{value:n=>tPe(t,n)},flatten:{value:n=>ePe(t,n)},addIssue:{value:n=>{t.issues.push(n),t.message=JSON.stringify(t.issues,vy,2)}},addIssues:{value:n=>{t.issues.push(...n),t.message=JSON.stringify(t.issues,vy,2)}},isEmpty:{get(){return t.issues.length===0}}})},Yr=Ie("ZodError",HNe,{Parent:Error}),KNe=Sw(Yr),jNe=Cw(Yr),XNe=Kx(Yr),qNe=jx(Yr),YNe=rPe(Yr),ZNe=iPe(Yr),QNe=oPe(Yr),JNe=aPe(Yr),e4e=lPe(Yr),t4e=uPe(Yr),n4e=cPe(Yr),s4e=hPe(Yr),as=Ie("ZodType",(t,e)=>(Yn.init(t,e),t.def=e,t.type=e.type,Object.defineProperty(t,"_def",{value:e}),t.check=(...n)=>t.clone(Xl(e,{checks:[...e.checks??[],...n.map(s=>typeof s=="function"?{_zod:{check:s,def:{check:"custom"},onattach:[]}}:s)]})),t.clone=(n,s)=>Ta(t,n,s),t.brand=()=>t,t.register=(n,s)=>(n.add(t,s),t),t.parse=(n,s)=>KNe(t,n,s,{callee:t.parse}),t.safeParse=(n,s)=>XNe(t,n,s),t.parseAsync=async(n,s)=>jNe(t,n,s,{callee:t.parseAsync}),t.safeParseAsync=async(n,s)=>qNe(t,n,s),t.spa=t.safeParseAsync,t.encode=(n,s)=>YNe(t,n,s),t.decode=(n,s)=>ZNe(t,n,s),t.encodeAsync=async(n,s)=>QNe(t,n,s),t.decodeAsync=async(n,s)=>JNe(t,n,s),t.safeEncode=(n,s)=>e4e(t,n,s),t.safeDecode=(n,s)=>t4e(t,n,s),t.safeEncodeAsync=async(n,s)=>n4e(t,n,s),t.safeDecodeAsync=async(n,s)=>s4e(t,n,s),t.refine=(n,s)=>t.check(Y4e(n,s)),t.superRefine=n=>t.check(Z4e(n)),t.overwrite=n=>t.check(fh(n)),t.optional=()=>NT(t),t.nullable=()=>MT(t),t.nullish=()=>NT(MT(t)),t.nonoptional=n=>V4e(t,n),t.array=()=>$4e(t),t.or=n=>P4e([t,n]),t.and=n=>N4e(t,n),t.transform=n=>LT(t,O4e(n)),t.default=n=>B4e(t,n),t.prefault=n=>G4e(t,n),t.catch=n=>H4e(t,n),t.pipe=n=>LT(t,n),t.readonly=()=>X4e(t),t.describe=n=>{const s=t.clone();return im.add(s,{description:n}),s},Object.defineProperty(t,"description",{get(){var n;return(n=im.get(t))==null?void 0:n.description},configurable:!0}),t.meta=(...n)=>{if(n.length===0)return im.get(t);const s=t.clone();return im.add(s,n[0]),s},t.isOptional=()=>t.safeParse(void 0).success,t.isNullable=()=>t.safeParse(null).success,t)),s4=Ie("_ZodString",(t,e)=>{Tw.init(t,e),as.init(t,e);const n=t._zod.bag;t.format=n.format??null,t.minLength=n.minimum??null,t.maxLength=n.maximum??null,t.regex=(...s)=>t.check(SNe(...s)),t.includes=(...s)=>t.check(INe(...s)),t.startsWith=(...s)=>t.check(kNe(...s)),t.endsWith=(...s)=>t.check(ENe(...s)),t.min=(...s)=>t.check(Eg(...s)),t.max=(...s)=>t.check(t4(...s)),t.length=(...s)=>t.check(n4(...s)),t.nonempty=(...s)=>t.check(Eg(1,...s)),t.lowercase=s=>t.check(CNe(s)),t.uppercase=s=>t.check(TNe(s)),t.trim=()=>t.check($Ne()),t.normalize=(...s)=>t.check(_Ne(...s)),t.toLowerCase=()=>t.check(RNe()),t.toUpperCase=()=>t.check(ANe()),t.slugify=()=>t.check(PNe())}),r4e=Ie("ZodString",(t,e)=>{Tw.init(t,e),s4.init(t,e),t.email=n=>t.check(KDe(i4e,n)),t.url=n=>t.check(ZDe(o4e,n)),t.jwt=n=>t.check(dNe(w4e,n)),t.emoji=n=>t.check(QDe(a4e,n)),t.guid=n=>t.check(kT(AT,n)),t.uuid=n=>t.check(jDe(om,n)),t.uuidv4=n=>t.check(XDe(om,n)),t.uuidv6=n=>t.check(qDe(om,n)),t.uuidv7=n=>t.check(YDe(om,n)),t.nanoid=n=>t.check(JDe(l4e,n)),t.guid=n=>t.check(kT(AT,n)),t.cuid=n=>t.check(eNe(u4e,n)),t.cuid2=n=>t.check(tNe(c4e,n)),t.ulid=n=>t.check(nNe(h4e,n)),t.base64=n=>t.check(uNe(b4e,n)),t.base64url=n=>t.check(cNe(y4e,n)),t.xid=n=>t.check(sNe(d4e,n)),t.ksuid=n=>t.check(rNe(f4e,n)),t.ipv4=n=>t.check(iNe(p4e,n)),t.ipv6=n=>t.check(oNe(m4e,n)),t.cidrv4=n=>t.check(aNe(g4e,n)),t.cidrv6=n=>t.check(lNe(x4e,n)),t.e164=n=>t.check(hNe(v4e,n)),t.datetime=n=>t.check(FNe(n)),t.date=n=>t.check(BNe(n)),t.time=n=>t.check(GNe(n)),t.duration=n=>t.check(WNe(n))});function RT(t){return HDe(r4e,t)}const $n=Ie("ZodStringFormat",(t,e)=>{kn.init(t,e),s4.init(t,e)}),i4e=Ie("ZodEmail",(t,e)=>{eDe.init(t,e),$n.init(t,e)}),AT=Ie("ZodGUID",(t,e)=>{QPe.init(t,e),$n.init(t,e)}),om=Ie("ZodUUID",(t,e)=>{JPe.init(t,e),$n.init(t,e)}),o4e=Ie("ZodURL",(t,e)=>{tDe.init(t,e),$n.init(t,e)}),a4e=Ie("ZodEmoji",(t,e)=>{nDe.init(t,e),$n.init(t,e)}),l4e=Ie("ZodNanoID",(t,e)=>{sDe.init(t,e),$n.init(t,e)}),u4e=Ie("ZodCUID",(t,e)=>{rDe.init(t,e),$n.init(t,e)}),c4e=Ie("ZodCUID2",(t,e)=>{iDe.init(t,e),$n.init(t,e)}),h4e=Ie("ZodULID",(t,e)=>{oDe.init(t,e),$n.init(t,e)}),d4e=Ie("ZodXID",(t,e)=>{aDe.init(t,e),$n.init(t,e)}),f4e=Ie("ZodKSUID",(t,e)=>{lDe.init(t,e),$n.init(t,e)}),p4e=Ie("ZodIPv4",(t,e)=>{fDe.init(t,e),$n.init(t,e)}),m4e=Ie("ZodIPv6",(t,e)=>{pDe.init(t,e),$n.init(t,e)}),g4e=Ie("ZodCIDRv4",(t,e)=>{mDe.init(t,e),$n.init(t,e)}),x4e=Ie("ZodCIDRv6",(t,e)=>{gDe.init(t,e),$n.init(t,e)}),b4e=Ie("ZodBase64",(t,e)=>{xDe.init(t,e),$n.init(t,e)}),y4e=Ie("ZodBase64URL",(t,e)=>{yDe.init(t,e),$n.init(t,e)}),v4e=Ie("ZodE164",(t,e)=>{vDe.init(t,e),$n.init(t,e)}),w4e=Ie("ZodJWT",(t,e)=>{SDe.init(t,e),$n.init(t,e)}),qx=Ie("ZodNumber",(t,e)=>{QN.init(t,e),as.init(t,e),t.gt=(s,r)=>t.check(_T(s,r)),t.gte=(s,r)=>t.check(Qb(s,r)),t.min=(s,r)=>t.check(Qb(s,r)),t.lt=(s,r)=>t.check(ET(s,r)),t.lte=(s,r)=>t.check(Zb(s,r)),t.max=(s,r)=>t.check(Zb(s,r)),t.int=s=>t.check(PT(s)),t.safe=s=>t.check(PT(s)),t.positive=s=>t.check(_T(0,s)),t.nonnegative=s=>t.check(Qb(0,s)),t.negative=s=>t.check(ET(0,s)),t.nonpositive=s=>t.check(Zb(0,s)),t.multipleOf=(s,r)=>t.check($T(s,r)),t.step=(s,r)=>t.check($T(s,r)),t.finite=()=>t;const n=t._zod.bag;t.minValue=Math.max(n.minimum??Number.NEGATIVE_INFINITY,n.exclusiveMinimum??Number.NEGATIVE_INFINITY)??null,t.maxValue=Math.min(n.maximum??Number.POSITIVE_INFINITY,n.exclusiveMaximum??Number.POSITIVE_INFINITY)??null,t.isInt=(n.format??"").includes("int")||Number.isSafeInteger(n.multipleOf??.5),t.isFinite=!0,t.format=n.format??null});function Li(t){return xNe(qx,t)}const S4e=Ie("ZodNumberFormat",(t,e)=>{CDe.init(t,e),qx.init(t,e)});function PT(t){return bNe(S4e,t)}const C4e=Ie("ZodBoolean",(t,e)=>{TDe.init(t,e),as.init(t,e)});function T4e(t){return yNe(C4e,t)}const I4e=Ie("ZodUnknown",(t,e)=>{IDe.init(t,e),as.init(t,e)});function DT(){return vNe(I4e)}const k4e=Ie("ZodNever",(t,e)=>{kDe.init(t,e),as.init(t,e)});function E4e(t){return wNe(k4e,t)}const _4e=Ie("ZodArray",(t,e)=>{EDe.init(t,e),as.init(t,e),t.element=e.element,t.min=(n,s)=>t.check(Eg(n,s)),t.nonempty=n=>t.check(Eg(1,n)),t.max=(n,s)=>t.check(t4(n,s)),t.length=(n,s)=>t.check(n4(n,s)),t.unwrap=()=>t.element});function $4e(t,e){return DNe(_4e,t,e)}const R4e=Ie("ZodObject",(t,e)=>{$De.init(t,e),as.init(t,e),fn(t,"shape",()=>e.shape),t.keyof=()=>M4e(Object.keys(t._zod.def.shape)),t.catchall=n=>t.clone({...t._zod.def,catchall:n}),t.passthrough=()=>t.clone({...t._zod.def,catchall:DT()}),t.loose=()=>t.clone({...t._zod.def,catchall:DT()}),t.strict=()=>t.clone({...t._zod.def,catchall:E4e()}),t.strip=()=>t.clone({...t._zod.def,catchall:void 0}),t.extend=n=>qAe(t,n),t.safeExtend=n=>YAe(t,n),t.merge=n=>ZAe(t,n),t.pick=n=>jAe(t,n),t.omit=n=>XAe(t,n),t.partial=(...n)=>QAe(r4,t,n[0]),t.required=(...n)=>JAe(i4,t,n[0])});function Iw(t,e){const n={type:"object",shape:t??{},...ht(e)};return new R4e(n)}const A4e=Ie("ZodUnion",(t,e)=>{RDe.init(t,e),as.init(t,e),t.options=e.options});function P4e(t,e){return new A4e({type:"union",options:t,...ht(e)})}const D4e=Ie("ZodIntersection",(t,e)=>{ADe.init(t,e),as.init(t,e)});function N4e(t,e){return new D4e({type:"intersection",left:t,right:e})}const Sy=Ie("ZodEnum",(t,e)=>{PDe.init(t,e),as.init(t,e),t.enum=e.entries,t.options=Object.values(e.entries);const n=new Set(Object.keys(e.entries));t.extract=(s,r)=>{const i={};for(const o of s)if(n.has(o))i[o]=e.entries[o];else throw new Error(`Key ${o} not found in enum`);return new Sy({...e,checks:[],...ht(r),entries:i})},t.exclude=(s,r)=>{const i={...e.entries};for(const o of s)if(n.has(o))delete i[o];else throw new Error(`Key ${o} not found in enum`);return new Sy({...e,checks:[],...ht(r),entries:i})}});function M4e(t,e){const n=Array.isArray(t)?Object.fromEntries(t.map(s=>[s,s])):t;return new Sy({type:"enum",entries:n,...ht(e)})}const L4e=Ie("ZodTransform",(t,e)=>{DDe.init(t,e),as.init(t,e),t._zod.parse=(n,s)=>{if(s.direction==="backward")throw new ON(t.constructor.name);n.addIssue=i=>{if(typeof i=="string")n.issues.push(Ud(i,n.value,e));else{const o=i;o.fatal&&(o.continue=!1),o.code??(o.code="custom"),o.input??(o.input=n.value),o.inst??(o.inst=t),n.issues.push(Ud(o))}};const r=e.transform(n.value,n);return r instanceof Promise?r.then(i=>(n.value=i,n)):(n.value=r,n)}});function O4e(t){return new L4e({type:"transform",transform:t})}const r4=Ie("ZodOptional",(t,e)=>{NDe.init(t,e),as.init(t,e),t.unwrap=()=>t._zod.def.innerType});function NT(t){return new r4({type:"optional",innerType:t})}const F4e=Ie("ZodNullable",(t,e)=>{MDe.init(t,e),as.init(t,e),t.unwrap=()=>t._zod.def.innerType});function MT(t){return new F4e({type:"nullable",innerType:t})}const U4e=Ie("ZodDefault",(t,e)=>{LDe.init(t,e),as.init(t,e),t.unwrap=()=>t._zod.def.innerType,t.removeDefault=t.unwrap});function B4e(t,e){return new U4e({type:"default",innerType:t,get defaultValue(){return typeof e=="function"?e():BN(e)}})}const z4e=Ie("ZodPrefault",(t,e)=>{ODe.init(t,e),as.init(t,e),t.unwrap=()=>t._zod.def.innerType});function G4e(t,e){return new z4e({type:"prefault",innerType:t,get defaultValue(){return typeof e=="function"?e():BN(e)}})}const i4=Ie("ZodNonOptional",(t,e)=>{FDe.init(t,e),as.init(t,e),t.unwrap=()=>t._zod.def.innerType});function V4e(t,e){return new i4({type:"nonoptional",innerType:t,...ht(e)})}const W4e=Ie("ZodCatch",(t,e)=>{UDe.init(t,e),as.init(t,e),t.unwrap=()=>t._zod.def.innerType,t.removeCatch=t.unwrap});function H4e(t,e){return new W4e({type:"catch",innerType:t,catchValue:typeof e=="function"?e:()=>e})}const K4e=Ie("ZodPipe",(t,e)=>{BDe.init(t,e),as.init(t,e),t.in=e.in,t.out=e.out});function LT(t,e){return new K4e({type:"pipe",in:t,out:e})}const j4e=Ie("ZodReadonly",(t,e)=>{zDe.init(t,e),as.init(t,e),t.unwrap=()=>t._zod.def.innerType});function X4e(t){return new j4e({type:"readonly",innerType:t})}const q4e=Ie("ZodCustom",(t,e)=>{GDe.init(t,e),as.init(t,e)});function Y4e(t,e={}){return NNe(q4e,t,e)}function Z4e(t){return MNe(t)}const Q4e=new gE(LAe,[Tg],FAe),Yx=UAe(Q4e);async function J4e(){try{return await Yx.getAllLUTs()}catch(t){return console.error("Failed to load LUTs:",t),[]}}async function eMe(t){return confirm("Are you sure you want to delete this LUT?")?(await Yx.deleteLUT(t),!0):!1}async function tMe(t){const e={id:crypto.randomUUID(),name:t.name,file:t,createdAt:Date.now()};return await Yx.addLUT(e),e}function nMe(t){const{URL:e,URL:n,:s=32,:r=32}=t;return new Promise((i,o)=>{const a=new Image,l=new Image;a.crossOrigin="Anonymous",l.crossOrigin="Anonymous";let u=0;const c=()=>{u++,u===2&&h()};a.onload=c,l.onload=c,a.onerror=d=>o(new Error("Failed to load original image: "+d)),l.onerror=d=>o(new Error("Failed to load processed image: "+d)),a.src=e,l.src=n;function h(){const d=document.createElement("canvas");d.width=s,d.height=r;const f=d.getContext("2d");if(!f){o(new Error("Failed to get canvas context"));return}f.imageSmoothingEnabled=!0,f.imageSmoothingQuality="high";const p=s/2;f.drawImage(a,0,0,a.width/2,a.height,0,0,p,r),f.drawImage(l,l.width/2,0,l.width/2,l.height,p,0,p,r),i(d.toDataURL("image/png"))}})}async function o4(t,e,n){const s=n.find(r=>r.id===t);if(!s)return!1;try{console.log("Updating thumbnail for LUT:",s.name);const r=new File([s.file],s.name,{type:"text/plain"}),i=await LN({originalImage:e,maxResolution:512,borderSize:0,lutFile:r,lutIntensity:1}),o=await nMe({URL:e,URL:i});return await Yx.updateLUTThumbnail(t,o),console.log("Thumbnail updated successfully for:",s.name),!0}catch(r){return console.error("Failed to update thumbnail:",r),!1}}async function sMe(t,e){for(const n of e)await o4(n.id,t,e)}function rMe(t){return t!=="lut"&&t!=="add"}const iMe={class:"flex flex-col gap-4"},oMe={key:1},aMe={key:0},lMe={key:1,class:"pb-3 pt-3"},uMe={key:2,class:"pb-3 pt-3"},cMe=We({__name:"LUTPanel",props:{isMobile:{type:Boolean},originalImage:{},processedImage:{},lutIntensity:{},lutFileName:{}},emits:["toggle-lut","lut-file-change","clear-lut","slider-update","mask-update","control-event"],setup(t,{emit:e}){const n=t,s=e,r=ce([]),i=ce(null),o=ce(!1),a=ce("lut"),l=ce(null),u=Y5(),{states:c,generator:h,layerManager:d,maskGen:f,preview:p}=u,{quantizedColorBlocks:g,commonHslBlocks:m,layers:x,activeLayerId:b,maskOptions:v}=c,{generateColorBlocks:y}=h,{addColorLayer:C,addHslLayer:I,removeLayer:$,selectLayer:T,updateLayer:S}=d,{generateColorBlockMask:E}=f,{updateMaskPreview:_,generateMaskPreviewImageDataUrl:N}=p,P=ye(()=>!!n.lutFileName),M=ye(()=>{var ke;return((ke=r.value.find(H=>H.id===i.value))==null?void 0:ke.name)||n.lutFileName}),z=ye(()=>[{id:"lut-intensity",label:"Intensity",value:n.lutIntensity,min:0,max:1,step:.01}]),A=ye(()=>n.isMobile?"text-center text-white/30 py-8 text-sm":"flex flex-col items-center justify-center py-12 text-white/30 gap-4"),B=ye(()=>n.isMobile?"flex flex-col gap-3":"flex flex-col gap-3 bg-white/5 rounded-2xl border border-white/5"),L=async()=>{r.value=await J4e()},U=()=>{i.value=null,s("clear-lut")},j=ke=>{s("slider-update",ke)},Z=ke=>{Object.assign(v.value,ke)},J=()=>{var ke;(ke=l.value)==null||ke.toggleMaskPreview()},se=async ke=>{if(!(!ke||ke.length===0)){for(let H=0;H<ke.length;H++)await tMe(ke[H]);await L()}},fe=ke=>{i.value=ke.id,s("lut-file-change",new File([ke.file],ke.name,{type:"text/plain"}))},he=async ke=>{await eMe(ke)&&(i.value===ke&&U(),await L())},ve=async ke=>{n.originalImage&&await o4(ke,n.originalImage,r.value)&&await L()},Pe=async()=>{if(!(!n.originalImage||o.value)){o.value=!0;try{await sMe(n.originalImage,r.value),await L()}finally{o.value=!1}}},Ee=async()=>{i.value&&await ve(i.value)},Se=(ke,H)=>{s("control-event",{type:"update-data",detail:{action:"set-preview-overlay",data:{data:ke,component:H}}})},ze=ke=>{a.value=ke,rMe(ke)&&T(ke)};return kr(()=>{L(),n.originalImage&&y(n.originalImage)}),_t(()=>n.originalImage,ke=>{ke&&(y(ke),x.value=[],b.value=null)}),_t(()=>n.processedImage,async ke=>{if(ke&&i.value){const H=r.value.find(K=>K.id===i.value);H&&!H.thumbnail&&await Ee()}}),_t(()=>n.lutFileName,ke=>{ke||(i.value=null)}),_t([x,v],()=>{const ke=x.value.filter(H=>H.visible);s("mask-update",ke.length>0?()=>E(n.originalImage):null)},{deep:!0}),_t(b,ke=>{n.isMobile&&ke?a.value=ke:n.isMobile&&!ke&&a.value!=="add"&&(a.value="lut")}),(ke,H)=>(F(),V("div",iMe,[t.originalImage?(F(),V("div",oMe,[t.isMobile&&D(x).length>0?(F(),st(Fg,{key:0,to:"#header-actions-container"},[k("button",{onClick:J,class:"p-2 rounded-full bg-white/10 text-white/80 hover:bg-white/20 active:bg-white/30 transition-colors"},[...H[2]||(H[2]=[k("div",{class:"i-carbon-view text-lg"},null,-1)])])])):Ue("",!0),we(ij,{"is-mobile":t.isMobile,layers:D(x),"active-mobile-tab":a.value,onSwitchTab:ze},null,8,["is-mobile","layers","active-mobile-tab"]),k("div",{class:Q(B.value)},[!t.isMobile||a.value==="lut"?(F(),V("div",aMe,[we(Cj,{"is-mobile":t.isMobile,luts:r.value,"selected-lut-id":i.value,"selected-lut-name":M.value,"original-image":t.originalImage,"processed-image":t.processedImage,"is-updating-thumbnails":o.value,"lut-slider-items":z.value,"quantized-color-blocks":D(g),"common-hsl-blocks":D(m),layers:D(x),"active-layer-id":D(b),onUpdateAllThumbnails:Pe,onFilesSelected:se,onSelectLut:fe,onDeleteLut:he,onUpdateThumbnail:ve,onUpdateCurrentThumbnail:Ee,onClearSelection:U,onSliderUpdate:j,onAddColorLayer:D(C),onAddHslLayer:D(I),onRemoveLayer:D($),onSelectLayer:D(T),onUpdateLayer:H[0]||(H[0]=(K,re)=>D(S)(K,re))},null,8,["is-mobile","luts","selected-lut-id","selected-lut-name","original-image","processed-image","is-updating-thumbnails","lut-slider-items","quantized-color-blocks","common-hsl-blocks","layers","active-layer-id","onAddColorLayer","onAddHslLayer","onRemoveLayer","onSelectLayer"])])):Ue("",!0),t.isMobile&&a.value==="add"?(F(),V("div",lMe,[we(R1,{processing:!1,"quantized-color-blocks":D(g),"common-hsl-blocks":D(m),layers:D(x),"active-layer-id":D(b),mode:"add-only","is-mobile":!0,onAddColorLayer:D(C),onAddHslLayer:D(I),onRemoveLayer:D($),onSelectLayer:D(T),onUpdateLayer:D(S)},null,8,["quantized-color-blocks","common-hsl-blocks","layers","active-layer-id","onAddColorLayer","onAddHslLayer","onRemoveLayer","onSelectLayer","onUpdateLayer"])])):Ue("",!0),t.isMobile&&a.value!=="lut"&&a.value!=="add"?(F(),V("div",uMe,[we(R1,{processing:!1,"quantized-color-blocks":D(g),"common-hsl-blocks":D(m),layers:D(x),"active-layer-id":D(b),mode:"settings-only","is-mobile":!0,onAddColorLayer:D(C),onAddHslLayer:D(I),onRemoveLayer:D($),onSelectLayer:D(T),onUpdateLayer:D(S)},null,8,["quantized-color-blocks","common-hsl-blocks","layers","active-layer-id","onAddColorLayer","onAddHslLayer","onRemoveLayer","onSelectLayer","onUpdateLayer"])])):Ue("",!0),i.value?(F(),V("div",{key:3,class:Q(["mt-4 border-t border-white/5 pt-4",{"px-4":!t.isMobile}])},[we(ej,{ref_key:"maskPreviewPanelRef",ref:l,processing:!1,"original-image":t.originalImage,layers:D(x),"mask-options":D(v),"is-mobile":t.isMobile,"update-mask-preview":D(_),"generate-mask-preview-image-data-url":D(N),"generate-color-block-mask":D(E),"onUpdate:maskOptions":Z,onSetPreviewOverlay:Se},null,8,["original-image","layers","mask-options","is-mobile","update-mask-preview","generate-mask-preview-image-data-url","generate-color-block-mask"])],2)):Ue("",!0)],2),P.value&&!i.value?(F(),V("div",{key:1,class:Q(["pb-3",{"px-4":!t.isMobile}])},[...H[3]||(H[3]=[k("div",{class:"text-xs text-yellow-400/80 bg-yellow-400/10 rounded-lg px-3 py-2 border border-yellow-400/20"},[k("div",{class:"flex items-start gap-2"},[k("div",{class:"i-carbon-warning text-sm mt-0.5"}),k("span",null,"Please select a LUT from the library")])],-1)])],2)):Ue("",!0)])):(F(),V("div",{key:0,class:Q(A.value)},[...H[1]||(H[1]=[k("div",{class:"i-carbon-image text-1xl"},null,-1),k("span",{class:"text-sm"},"Please select an image first",-1)])],2))]))}}),a4=Zi(cMe,[["__scopeId","data-v-b68fc54d"]]),hMe=["#FF0000","#FF7F00","#FFFF00","#00FF00","#00FFFF","#0000FF","#FF00FF","#8B4513","#FFFFFF","#808080","#000000","#FFB6C1"],l4=t=>{var i;let e=-100,n=100,s=1;t.minValue!==void 0&&t.minValue!==null&&!isNaN(t.minValue)&&(e=t.minValue),t.maxValue!==void 0&&t.maxValue!==null&&!isNaN(t.maxValue)&&(n=t.maxValue);const r=(i=t.meta())==null?void 0:i.step;return typeof r=="number"&&!isNaN(r)&&(s=r),{min:e,max:n,step:s}},_g=Iw({label:RT(),gradient:RT().optional(),showRuler:T4e().optional(),step:Li().optional(),defaultValue:Li().optional()}),dMe=()=>Iw({hue:Li().min(-180).max(180).meta({step:1,label:"",gradient:"linear-gradient(90deg, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%)",showRuler:!1}),saturation:Li().min(-100).max(100).meta({step:1,label:"",gradient:"linear-gradient(90deg, #888 0%, #ff0000 100%)",showRuler:!1}),lightness:Li().min(-100).max(100).meta({step:1,label:"",gradient:"linear-gradient(90deg, #000 0%, #888 50%, #fff 100%)",showRuler:!1})}),u4=t=>Iw({hue:Li().min(-180).max(180).meta({step:1,label:"",gradient:"linear-gradient(90deg, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%)",showRuler:!1}),saturation:Li().min(-100).max(100).meta({step:1,label:"",gradient:`linear-gradient(90deg, #888 0%, ${(t==null?void 0:t.targetColor)||"#ff0000"} 100%)`,showRuler:!1}),lightness:Li().min(-100).max(100).meta({step:1,label:"",gradient:`linear-gradient(90deg, #000 0%, ${(t==null?void 0:t.targetColor)||"#888"} 50%, #fff 100%)`,showRuler:!1}),precision:Li().min(0).max(100).meta({step:1,label:"",gradient:"linear-gradient(90deg, #ff3b30 0%, #ffcc00 50%, #4cd964 100%)",showRuler:!0,defaultValue:30}),range:Li().min(0).max(100).meta({step:1,label:"",gradient:"linear-gradient(90deg, #007aff 0%, #5ac8fa 50%, #ffffff 100%)",showRuler:!0,defaultValue:50})}),fMe=t=>{const{globalHSL:e}=t,n=dMe(),s={hue:"global-hue",saturation:"global-saturation",lightness:"global-lightness"};return{get:()=>Object.entries(n.shape).map(([i,o])=>{if(o instanceof qx){const a=l4(o),l=_g.safeParse(o.meta()),u=l.success?l.data:{label:i},c=e.value[i];let h;if(c!=null&&typeof c=="number"&&!isNaN(c))h=c;else if(u.defaultValue!=null&&typeof u.defaultValue=="number"&&!isNaN(u.defaultValue))h=u.defaultValue;else throw new Error(` ${i} : ${c}: ${u.defaultValue}`);return{id:s[i]||i,label:u.label,value:h,min:a.min,max:a.max,step:a.step,gradient:u.gradient,showRuler:u.showRuler}}return null}).filter(i=>i!==null),set:()=>{}}},pMe=t=>{const e=u4(t);return{get:()=>Object.entries(e.shape).map(([s,r])=>{if(r instanceof qx){const i=l4(r),a=_g.safeParse(r.meta()).data;if(!a)throw new Error("");const l=t[s];let u;if(l!=null&&typeof l=="number"&&!isNaN(l))u=l;else if(a.defaultValue!=null&&typeof a.defaultValue=="number"&&!isNaN(a.defaultValue))u=a.defaultValue;else throw new Error(` ${s} : ${l}: ${a.defaultValue}`);return{id:s,label:a.label,value:u,min:i.min,max:i.max,step:i.step,gradient:a.gradient,showRuler:a.showRuler}}return null}).filter(s=>s!==null),set:()=>{}}},mMe={class:"flex items-center justify-between mb-3"},gMe={key:0,class:"mb-3 p-3 bg-black/30 rounded-lg border border-white/10"},xMe={class:"grid grid-cols-6 gap-2 mb-3"},bMe=["onClick"],yMe={key:1,class:"flex flex-col gap-2"},vMe=["onClick"],wMe={class:"flex items-center gap-2 flex-1"},SMe={class:"text-xs text-white/80 font-medium truncate"},CMe={class:"flex items-center gap-1"},TMe=["onClick"],IMe={key:0,class:"px-2 pb-2 border-t border-white/10"},kMe={key:2,class:"text-center text-white/30 text-xs py-4"},EMe=We({__name:"HSLLayersPanel",props:{isMobile:{type:Boolean},hslLayers:{}},emits:["controlEvent"],setup(t,{emit:e}){const n=t,s=e,r=ce(n.hslLayers||[]),i=ce(null),o=ce(!1),a=ce("#FF0000");_t(()=>n.hslLayers,d=>{d&&(r.value=[...d])},{deep:!0});const l=d=>{const p=u4({targetColor:d}),g=_g.safeParse(p.shape.precision.meta()),m=_g.safeParse(p.shape.range.meta()),x=g.success&&g.data.defaultValue!=null?g.data.defaultValue:30,b=m.success&&m.data.defaultValue!=null?m.data.defaultValue:50,v={id:crypto.randomUUID(),type:"selective",targetColor:d,hue:0,saturation:0,lightness:0,precision:x,range:b};s("controlEvent",Nn("add-hsl-layer",v))},u=d=>{s("controlEvent",Nn("remove-hsl-layer",d))},c=d=>{i.value=i.value===d?null:d},h=(d,f)=>{s("controlEvent",Nn("update-hsl-layer",{id:d,data:f}))};return(d,f)=>(F(),V("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[k("div",mMe,[f[3]||(f[3]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("button",{onClick:f[0]||(f[0]=p=>o.value=!o.value),class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex items-center gap-1"},[...f[2]||(f[2]=[k("div",{class:"i-carbon-add"},null,-1),k("span",null,"",-1)])])]),o.value?(F(),V("div",gMe,[k("div",xMe,[(F(!0),V(Xe,null,rt(D(hMe),p=>(F(),V("button",{key:p,class:Q(["w-full aspect-square rounded-lg border-2 transition-all hover:scale-110",a.value===p?"border-white shadow-lg":"border-white/20"]),style:bn({backgroundColor:p}),onClick:g=>l(p)},null,14,bMe))),128))]),k("button",{onClick:f[1]||(f[1]=p=>o.value=!1),class:"w-full glass-btn text-xs py-1.5 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors"},"  ")])):Ue("",!0),r.value.length>0?(F(),V("div",yMe,[(F(!0),V(Xe,null,rt(r.value,p=>(F(),V("div",{key:p.id,class:Q(["relative rounded-lg border transition-all",i.value===p.id?"border-white/40 bg-white/5":"border-white/10 bg-black/20"])},[k("div",{class:"flex items-center justify-between p-2 cursor-pointer",onClick:g=>c(p.id)},[k("div",wMe,[k("div",{class:"w-6 h-6 rounded border border-white/20 flex-shrink-0",style:bn({backgroundColor:p.targetColor})},null,4),k("span",SMe,Le(p.targetColor),1)]),k("div",CMe,[k("button",{onClick:gs(g=>u(p.id),["stop"]),class:"p-1 rounded hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors"},[...f[4]||(f[4]=[k("div",{class:"i-carbon-trash-can text-sm"},null,-1)])],8,TMe),k("div",{class:Q(["i-carbon-chevron-down text-sm text-white/60 transition-transform",{"rotate-180":i.value===p.id}])},null,2)])],8,vMe),i.value===p.id?(F(),V("div",IMe,[we(D(St),{items:D(pMe)(p).get(),onUpdateValue:g=>h(p.id,g)},null,8,["items","onUpdateValue"])])):Ue("",!0)],2))),128))])):(F(),V("div",kMe,"  "))],2))}}),_Me={class:"flex flex-col gap-4"},$Me={class:"flex items-center justify-between mb-3"},RMe=["disabled"],c4=We({__name:"HSLPanel",props:{isMobile:{type:Boolean},originalImage:{},globalHSL:{},hslLayers:{}},emits:["controlEvent"],setup(t,{emit:e}){var f,p,g;const n=t,s=e,r=ce({hue:((f=n.globalHSL)==null?void 0:f.hue)||0,saturation:((p=n.globalHSL)==null?void 0:p.saturation)||0,lightness:((g=n.globalHSL)==null?void 0:g.lightness)||0}),i=ce(n.hslLayers||[]);_t(()=>n.globalHSL,m=>{m&&(r.value={hue:m.hue,saturation:m.saturation,lightness:m.lightness})},{deep:!0}),_t(()=>n.hslLayers,m=>{m&&(i.value=[...m])},{deep:!0});const o=ye(()=>n.isMobile?"text-center text-white/30 py-8 text-sm":"flex flex-col items-center justify-center py-12 text-white/30 gap-4"),a=ye(()=>n.isMobile?"flex flex-col gap-3":"flex flex-col gap-3 bg-white/5 rounded-2xl border border-white/5"),l=ye(()=>r.value.hue!==0||r.value.saturation!==0||r.value.lightness!==0),u=ye(fMe({globalHSL:r})),c=m=>{const x=typeof m.value=="string"?parseFloat(m.value):m.value;if(isNaN(x)){console.error(`[HSLPanel] Invalid value for ${m.id}: ${m.value}`);return}m.id==="global-hue"?r.value.hue=x:m.id==="global-saturation"?r.value.saturation=x:m.id==="global-lightness"&&(r.value.lightness=x);const b={id:"global-hsl-layer",type:"global",hue:r.value.hue,saturation:r.value.saturation,lightness:r.value.lightness};s("controlEvent",Nn("global-hsl-change",b))},h=()=>{r.value={hue:0,saturation:0,lightness:0},s("controlEvent",Nn("global-hsl-change",{id:"global-hsl-layer",type:"global",hue:0,saturation:0,lightness:0}))},d=m=>{const{action:x,data:b}=m.detail;switch(x){case"add-hsl-layer":i.value.push(b);break;case"remove-hsl-layer":i.value=i.value.filter(T=>T.id!==b);break;case"update-hsl-layer":const{id:v,data:y}=b,C=i.value.find(T=>T.id===v);if(!C){console.error(`[HSLPanel] Layer not found: ${v}`);return}let I;if(typeof y.value=="string")I=parseFloat(y.value);else if(typeof y.value=="number")I=y.value;else{console.error(`[HSLPanel] Invalid value type for ${y.id}: ${typeof y.value}`);return}if(isNaN(I)||!isFinite(I)){console.error(`[HSLPanel] Invalid value for ${y.id}: ${y.value}`);return}const $={};if(y.id==="hue")$.hue=Math.max(-180,Math.min(180,I));else if(y.id==="saturation")$.saturation=Math.max(-100,Math.min(100,I));else if(y.id==="lightness")$.lightness=Math.max(-100,Math.min(100,I));else if(y.id==="precision")$.precision=Math.max(0,Math.min(100,I));else if(y.id==="range")$.range=Math.max(0,Math.min(100,I));else{console.error(`[HSLPanel] Unknown field: ${y.id}`);return}Object.assign(C,$);break}s("controlEvent",m)};return(m,x)=>(F(),V("div",_Me,[t.originalImage?(F(),V("div",{key:1,class:Q(a.value)},[k("div",{class:Q(["pb-3 pt-3",{"px-4":!t.isMobile}])},[k("div",$Me,[x[2]||(x[2]=k("label",{class:"block text-sm font-medium text-white/80"}," HSL ",-1)),k("button",{onClick:h,class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex items-center gap-1",disabled:!l.value},[...x[1]||(x[1]=[k("div",{class:"i-carbon-reset"},null,-1),k("span",null,"",-1)])],8,RMe)]),we(D(St),{items:u.value,onUpdateValue:c},null,8,["items"])],2),we(EMe,{isMobile:t.isMobile,hslLayers:i.value,onControlEvent:d},null,8,["isMobile","hslLayers"])],2)):(F(),V("div",{key:0,class:Q(o.value)},[...x[0]||(x[0]=[k("div",{class:"i-carbon-color-palette text-1xl"},null,-1),k("span",{class:"text-sm"},"Please select an image first",-1)])],2))]))}}),AMe={class:"flex flex-col gap-4"},PMe={class:"flex items-center justify-between mb-3"},DMe=["disabled"],NMe={class:"flex items-center justify-between mb-3"},MMe=["disabled"],LMe={class:"flex items-center justify-between"},OMe={class:"flex gap-2"},FMe={class:"flex items-center justify-between"},UMe=We({__name:"ExposurePanel",props:{isMobile:{type:Boolean},originalImage:{},exposureStrength:{},exposureManual:{}},emits:["controlEvent"],setup(t,{emit:e}){var C,I,$;const n=t,s=e,r=ce(n.exposureStrength||1),i=ce(((C=n.exposureManual)==null?void 0:C.exposure)||1),o=ce(((I=n.exposureManual)==null?void 0:I.contrast)||1),a=ce((($=n.exposureManual)==null?void 0:$.gamma)||1),l=ce("auto"),u=ce(!0),c=ye(()=>n.isMobile?"text-center text-white/30 py-8 text-sm":"flex flex-col items-center justify-center py-12 text-white/30 gap-4"),h=ye(()=>n.isMobile?"flex flex-col gap-3":"flex flex-col gap-3 bg-white/5 rounded-2xl border border-white/5"),d=ye(()=>r.value!==1),f=ye(()=>i.value!==1||o.value!==1||a.value!==1),p=ye(()=>[{id:"auto-exposure-strength",label:"",value:r.value,min:0,max:20,step:.01,gradient:"linear-gradient(90deg, #1a1a1a 0%, #888 50%, #ffffff 100%)",showRuler:!0}]),g=ye(()=>[{id:"manual-exposure",label:"",value:i.value,min:.1,max:3,step:.01,gradient:"linear-gradient(90deg, #000 0%, #888 50%, #fff 100%)",showRuler:!0},{id:"manual-contrast",label:"",value:o.value,min:.5,max:2,step:.01,gradient:"linear-gradient(90deg, #666 0%, #fff 50%, #666 100%)",showRuler:!0},{id:"manual-gamma",label:"",value:a.value,min:.5,max:2.2,step:.01,gradient:"linear-gradient(90deg, #000 0%, #888 50%, #fff 100%)",showRuler:!0}]),m=T=>{T.id==="auto-exposure-strength"&&(r.value=T.value,s("controlEvent",Nn("exposure-strength",T.value)))},x=T=>{T.id==="manual-exposure"?i.value=T.value:T.id==="manual-contrast"?o.value=T.value:T.id==="manual-gamma"&&(a.value=T.value),s("controlEvent",Nn("exposure-manual",{exposure:i.value,contrast:o.value,gamma:a.value}))},b=()=>{r.value=1,s("controlEvent",Nn("exposure-strength",1))},v=()=>{i.value=1,o.value=1,a.value=1,s("controlEvent",Nn("exposure-manual",{exposure:1,contrast:1,gamma:1}))},y=()=>{u.value=!u.value};return _t(l,T=>{T==="auto"?s("controlEvent",Nn("exposure-strength",r.value)):s("controlEvent",Nn("exposure-manual",{exposure:i.value,contrast:o.value,gamma:a.value}))}),_t(()=>n.originalImage,()=>{b(),v(),l.value="auto"}),(T,S)=>(F(),V("div",AMe,[t.originalImage?(F(),V("div",{key:1,class:Q(h.value)},[k("div",{class:Q(["pb-3 pt-3",{"px-4":!t.isMobile}])},[k("div",PMe,[S[4]||(S[4]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("button",{onClick:b,class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex items-center gap-1",disabled:!d.value},[...S[3]||(S[3]=[k("div",{class:"i-carbon-reset"},null,-1),k("span",null,"",-1)])],8,DMe)]),we(D(St),{items:p.value,onUpdateValue:m},null,8,["items"]),S[5]||(S[5]=k("div",{class:"mt-3 text-xs text-white/50"},[k("p",null,"")],-1))],2),k("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[k("div",NMe,[S[7]||(S[7]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("button",{onClick:v,class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex items-center gap-1",disabled:!f.value},[...S[6]||(S[6]=[k("div",{class:"i-carbon-reset"},null,-1),k("span",null,"",-1)])],8,MMe)]),we(D(St),{items:g.value,onUpdateValue:x},null,8,["items"]),S[8]||(S[8]=k("div",{class:"mt-3 text-xs text-white/50"},[k("p",null,"")],-1))],2),k("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[k("div",LMe,[S[9]||(S[9]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("div",OMe,[k("button",{onClick:S[0]||(S[0]=E=>l.value="auto"),class:Q(["glass-btn text-[10px] px-3 py-1.5 rounded transition-colors",l.value==="auto"?"bg-white/20 text-white border-white/40":"bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 border-white/10"])},"  ",2),k("button",{onClick:S[1]||(S[1]=E=>l.value="manual"),class:Q(["glass-btn text-[10px] px-3 py-1.5 rounded transition-colors",l.value==="manual"?"bg-white/20 text-white border-white/40":"bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 border-white/10"])},"  ",2)])])],2),k("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[k("div",FMe,[S[10]||(S[10]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("button",{onClick:y,class:Q(["glass-btn text-[10px] px-3 py-1.5 rounded transition-colors",u.value?"bg-white/20 text-white border-white/40":"bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 border-white/10"])},Le(u.value?"":""),3)])],2)],2)):(F(),V("div",{key:0,class:Q(c.value)},[...S[2]||(S[2]=[k("div",{class:"i-carbon-sun text-1xl"},null,-1),k("span",{class:"text-sm"},"Please select an image first",-1)])],2))]))}}),h4=Zi(UMe,[["__scopeId","data-v-f63bff44"]]);function BMe(t,e){return e in t&&t[e]!==void 0}function zMe(t,e){if(!BMe(t,e))return null;const n=t[e];return Dk(n)?n:null}function GMe(t,e){return e.validate(t)?null:e.errorMessage}function VMe(){return{omega:{validate:t=>t>=.1&&t<=.99,errorMessage:Si.OMEGA_RANGE},t0:{validate:t=>t>=.01&&t<=.3,errorMessage:Si.T0_RANGE},windowSize:{validate:t=>t>=3&&t<=31&&t%2===1,errorMessage:Si.WINDOW_SIZE_RANGE},topRatio:{validate:t=>t>=.01&&t<=.5,errorMessage:Si.TOP_RATIO_RANGE},adaptiveStrength:{validate:t=>t>=.1&&t<=2,errorMessage:Si.ADAPTIVE_STRENGTH_RANGE},hazeWeight:{validate:t=>t>=0&&t<=1,errorMessage:Si.HAZE_WEIGHT_RANGE},atmosphericWeight:{validate:t=>t>=0&&t<=1,errorMessage:Si.ATMOSPHERIC_WEIGHT_RANGE},saturationEnhancement:{validate:t=>t>=0&&t<=2,errorMessage:Si.SATURATION_ENHANCEMENT_RANGE},contrastEnhancement:{validate:t=>t>=.5&&t<=2,errorMessage:Si.CONTRAST_ENHANCEMENT_RANGE},brightnessEnhancement:{validate:t=>t>=.5&&t<=2,errorMessage:Si.BRIGHTNESS_ENHANCEMENT_RANGE}}}function WMe(t,e,n){const s=zMe(t,e);return s!==null?GMe(s,n[e]):null}function HMe(t){const e=[],n=VMe();for(const s of Object.keys(n)){const r=WMe(t,s,n);r&&e.push(r)}return{isValid:e.length===0,errors:e}}const KMe=[{id:"omega",label:"",min:.1,max:.99,step:.01,gradient:"linear-gradient(90deg, #007aff 0%, #5ac8fa 50%, #ffffff 100%)",showRuler:!0},{id:"t0",label:"",min:.01,max:.3,step:.01,gradient:"linear-gradient(90deg, #ff3b30 0%, #ffcc00 50%, #4cd964 100%)",showRuler:!0},{id:"windowSize",label:"",min:0,max:31,step:1,gradient:"linear-gradient(90deg, #5856d6 0%, #af52de 100%)",showRuler:!0}],jMe=[{id:"topRatio",label:"",min:.01,max:.5,step:.01,gradient:"linear-gradient(90deg, #ff9500 0%, #ffcc00 100%)",showRuler:!0},{id:"adaptiveStrength",label:"",min:.1,max:2,step:.01,gradient:"linear-gradient(90deg, #34c759 0%, #30d158 100%)",showRuler:!0},{id:"hazeWeight",label:"",min:0,max:1,step:.01,gradient:"linear-gradient(90deg, #007aff 0%, #5ac8fa 100%)",showRuler:!0},{id:"atmosphericWeight",label:"",min:0,max:1,step:.01,gradient:"linear-gradient(90deg, #ff2d55 0%, #ff3b30 100%)",showRuler:!0}],XMe=[{id:"saturationEnhancement",label:"",min:0,max:2,step:.01,gradient:"linear-gradient(90deg, #888 0%, #ff0000 100%)",showRuler:!0},{id:"contrastEnhancement",label:"",min:.5,max:2,step:.01,gradient:"linear-gradient(90deg, #000 0%, #fff 100%)",showRuler:!0},{id:"brightnessEnhancement",label:"",min:.5,max:2,step:.01,gradient:"linear-gradient(90deg, #000 0%, #888 50%, #fff 100%)",showRuler:!0}],qMe="dehaze-change",YMe="controlEvent",d4="text-center text-white/30 py-8 text-sm",f4="flex flex-col items-center justify-center py-12 text-white/30 gap-4",p4="flex flex-col gap-3",m4="flex flex-col gap-3 bg-white/5 rounded-2xl border border-white/5";function ZMe(){const t=ce({...Gx}),e=ce(null),n=ce(!1),s=ce(!1);return{dehazeParams:t,currentPreset:e,showAdvanced:n,isProcessing:s}}function QMe(t){const e=ye(()=>r=>r?d4:f4),n=ye(()=>r=>r?p4:m4),s=ye(()=>JSON.stringify(t.value)!==JSON.stringify(Gx));return{emptyStateClass:e.value,contentContainerClass:n.value,hasAdjustments:s}}function JMe(t){const e=ZMe(),n={...e,emit:t},s=QMe(e.dehazeParams);return{...e,ctx:n,...s}}function Zx(t){return["omega","t0","windowSize","topRatio","adaptiveMode","spatialAdaptiveMode","adaptiveStrength","hazeWeight","atmosphericWeight","enableEnhancement","saturationEnhancement","contrastEnhancement","brightnessEnhancement"].includes(t)}function eLe(t){return["omega","t0","windowSize","topRatio","adaptiveStrength","hazeWeight","atmosphericWeight","saturationEnhancement","contrastEnhancement","brightnessEnhancement"].includes(t)}const tLe="Invalid dehaze parameter key: ",Qx=t=>`${tLe}${t}`,nLe=":",sLe=t=>t?d4:f4,rLe=t=>t?p4:m4,iLe=(t,e)=>{if(!Zx(e.id)){console.warn(Qx(e.id));return}const n={};e.id==="omega"&&(n.omega=e.value),e.id==="t0"&&(n.t0=e.value),e.id==="windowSize"&&(n.windowSize=Math.round(e.value/2)*2+1),Object.assign(t.dehazeParams.value,n),t.currentPreset.value=null,bp(t)},oLe=(t,e)=>{if(!Zx(e.id)){console.warn(Qx(e.id));return}const n={};e.id==="topRatio"&&(n.topRatio=e.value),e.id==="adaptiveStrength"&&(n.adaptiveStrength=e.value),e.id==="hazeWeight"&&(n.hazeWeight=e.value),e.id==="atmosphericWeight"&&(n.atmosphericWeight=e.value),Object.assign(t.dehazeParams.value,n),t.currentPreset.value=null,bp(t)},aLe=(t,e)=>{if(!Zx(e.id)){console.warn(Qx(e.id));return}const n={};e.id==="saturationEnhancement"&&(n.saturationEnhancement=e.value),e.id==="contrastEnhancement"&&(n.contrastEnhancement=e.value),e.id==="brightnessEnhancement"&&(n.brightnessEnhancement=e.value),Object.assign(t.dehazeParams.value,n),t.currentPreset.value=null,bp(t)},lLe=(t,e)=>{t.dehazeParams.value={...mRe(e)},t.currentPreset.value=e,bp(t)},uLe=t=>{t.dehazeParams.value={...Gx},t.currentPreset.value=null,bp(t)},bp=t=>{const e=HMe(t.dehazeParams.value);if(!e.isValid){console.warn(nLe,e.errors);return}t.emit(YMe,Nn(qMe,{...t.dehazeParams.value}))},cLe=t=>({light:"",medium:"",heavy:"",adaptive:"",spatialAdaptive:"",enhanced:"",default:""})[t]||t;function hLe(t){const{dehazeParams:e,currentPreset:n,showAdvanced:s,isProcessing:r,ctx:i,emptyStateClass:o,contentContainerClass:a,hasAdjustments:l}=JMe(t);return{dehazeParams:e,currentPreset:n,showAdvanced:s,isProcessing:r,hasAdjustments:l,emptyStateClass:o,contentContainerClass:a,handleBasicSliderUpdate:u=>iLe(i,u),handleAdvancedSliderUpdate:u=>oLe(i,u),handleEnhancementSliderUpdate:u=>aLe(i,u),applyPreset:u=>lLe(i,u),resetDehaze:()=>uLe(i)}}function Jb(t,e){return ye(()=>t.map(n=>{const s=n.id;if(!Zx(s))throw new Error(Qx(s));if(!eLe(s))return{...n,value:0};const r=e.value[s];return Dk(r)?{...n,value:r}:{...n,value:0}}))}const dLe=We({__name:"DehazeEmptyState",props:{isMobile:{type:Boolean}},setup(t){return(e,n)=>(F(),V("div",{class:Q(D(sLe)(t.isMobile))},[...n[0]||(n[0]=[k("div",{class:"i-carbon-fog text-1xl"},null,-1),k("span",{class:"text-sm"},"Please select an image first",-1)])],2))}}),fLe={class:"flex items-center justify-between mb-3"},pLe=["disabled"],mLe={class:"grid grid-cols-3 gap-2 mb-4"},gLe=["onClick"],xLe={class:"text-lg opacity-70"},bLe={key:0,class:"i-carbon-sun"},yLe={key:1,class:"i-carbon-cloud"},vLe={key:2,class:"i-carbon-fog"},wLe={key:3,class:"i-carbon-settings-adjust"},SLe={key:4,class:"i-carbon-layers"},CLe={key:5,class:"i-carbon-contrast"},TLe=We({__name:"DehazePresetSelector",props:{isMobile:{type:Boolean},currentPreset:{},hasAdjustments:{type:Boolean}},emits:["reset","applyPreset"],setup(t,{emit:e}){const n=e,s=r=>{n("applyPreset",r)};return(r,i)=>(F(),V("div",{class:Q(["pb-3 pt-3",{"px-4":!t.isMobile}])},[k("div",fLe,[i[2]||(i[2]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("button",{onClick:i[0]||(i[0]=o=>r.$emit("reset")),class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex items-center gap-1",disabled:!t.hasAdjustments},[...i[1]||(i[1]=[k("div",{class:"i-carbon-reset"},null,-1),k("span",null,"",-1)])],8,pLe)]),k("div",mLe,[(F(!0),V(Xe,null,rt(D(xw),(o,a)=>(F(),V("button",{key:a,class:Q(["glass-btn text-xs py-2 px-2 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex flex-col items-center gap-1",{"bg-white/20 text-white/90":t.currentPreset===a}]),onClick:l=>s(a)},[k("div",xLe,[a==="light"?(F(),V("div",bLe)):a==="medium"?(F(),V("div",yLe)):a==="heavy"?(F(),V("div",vLe)):a==="adaptive"?(F(),V("div",wLe)):a==="spatialAdaptive"?(F(),V("div",SLe)):a==="enhanced"?(F(),V("div",CLe)):Ue("",!0)]),k("span",null,Le(D(cLe)(a)),1)],10,gLe))),128))])],2))}}),ILe=We({__name:"DehazeBasicParams",props:{isMobile:{type:Boolean},items:{}},emits:["updateValue"],setup(t){return(e,n)=>(F(),V("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[n[1]||(n[1]=k("div",{class:"flex items-center justify-between mb-3"},[k("label",{class:"block text-sm font-medium text-white/80"},"  ")],-1)),we(D(St),{items:t.items,onUpdateValue:n[0]||(n[0]=s=>e.$emit("updateValue",s))},null,8,["items"])],2))}}),kLe={class:"flex items-center justify-between"},ELe={class:"text-xs text-white/70"},_Le=["checked","disabled"],e1=We({__name:"LabeledCheckbox",props:{label:{},modelValue:{type:Boolean},disabled:{type:Boolean}},emits:["update:modelValue"],setup(t,{emit:e}){const n=e;function s(r){n("update:modelValue",r.target.checked)}return(r,i)=>(F(),V("div",kLe,[k("label",ELe,Le(t.label),1),k("input",{type:"checkbox",checked:t.modelValue,onChange:s,disabled:t.disabled,class:"w-4 h-4 rounded border-white/20 bg-white/10 text-white/60 focus:ring-white/20"},null,40,_Le)]))}}),$Le={class:"flex items-center justify-between mb-3"},RLe={key:0,class:"space-y-4"},ALe={class:"space-y-3"},PLe=We({__name:"DehazeAdvancedParams",props:{isMobile:{type:Boolean},showAdvanced:{type:Boolean},items:{},adaptiveMode:{type:Boolean},spatialAdaptiveMode:{type:Boolean},enableEnhancement:{type:Boolean}},emits:["toggleAdvanced","updateValue","update:adaptiveMode","update:spatialAdaptiveMode","update:enableEnhancement"],setup(t){return(e,n)=>(F(),V("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[k("div",$Le,[n[5]||(n[5]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("button",{onClick:n[0]||(n[0]=s=>e.$emit("toggleAdvanced")),class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex items-center gap-1"},[k("div",{class:Q(["i-carbon-chevron-down text-sm transition-transform",{"rotate-180":t.showAdvanced}])},null,2),k("span",null,Le(t.showAdvanced?"":""),1)])]),t.showAdvanced?(F(),V("div",RLe,[we(D(St),{items:t.items,onUpdateValue:n[1]||(n[1]=s=>e.$emit("updateValue",s))},null,8,["items"]),k("div",ALe,[we(e1,{label:"",modelValue:t.adaptiveMode,"onUpdate:modelValue":n[2]||(n[2]=s=>e.$emit("update:adaptiveMode",s))},null,8,["modelValue"]),we(e1,{label:"",modelValue:t.spatialAdaptiveMode,"onUpdate:modelValue":n[3]||(n[3]=s=>e.$emit("update:spatialAdaptiveMode",s)),disabled:!t.adaptiveMode},null,8,["modelValue","disabled"]),we(e1,{label:"",modelValue:t.enableEnhancement,"onUpdate:modelValue":n[4]||(n[4]=s=>e.$emit("update:enableEnhancement",s))},null,8,["modelValue"])])])):Ue("",!0)],2))}}),DLe=We({__name:"DehazeEnhancementParams",props:{isMobile:{type:Boolean},items:{}},emits:["updateValue"],setup(t){return(e,n)=>(F(),V("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[n[1]||(n[1]=k("div",{class:"flex items-center justify-between mb-3"},[k("label",{class:"block text-sm font-medium text-white/80"},"  ")],-1)),we(D(St),{items:t.items,onUpdateValue:n[0]||(n[0]=s=>e.$emit("updateValue",s))},null,8,["items"])],2))}}),NLe={class:"flex items-center justify-center py-4"},MLe=We({__name:"DehazeProcessingIndicator",setup(t){return(e,n)=>(F(),V("div",NLe,[...n[0]||(n[0]=[k("div",{class:"i-carbon-circle-dash animate-spin text-white/60 mr-2"},null,-1),k("span",{class:"text-sm text-white/60"},"...",-1)])]))}}),LLe={class:"flex flex-col gap-4"},g4=We({__name:"DehazePanel",props:{isMobile:{type:Boolean},originalImage:{}},emits:["controlEvent"],setup(t,{emit:e}){const n=e,{dehazeParams:s,currentPreset:r,showAdvanced:i,isProcessing:o,hasAdjustments:a,handleBasicSliderUpdate:l,handleAdvancedSliderUpdate:u,handleEnhancementSliderUpdate:c,applyPreset:h,resetDehaze:d}=hLe((m,x)=>{n(m,x)}),f=Jb(KMe,s),p=Jb(jMe,s),g=Jb(XMe,s);return(m,x)=>(F(),V("div",LLe,[t.originalImage?(F(),V("div",{key:1,class:Q(D(rLe)(t.isMobile))},[we(TLe,{isMobile:t.isMobile,currentPreset:D(r),hasAdjustments:D(a),onReset:D(d),onApplyPreset:D(h)},null,8,["isMobile","currentPreset","hasAdjustments","onReset","onApplyPreset"]),we(ILe,{isMobile:t.isMobile,items:D(f),onUpdateValue:D(l)},null,8,["isMobile","items","onUpdateValue"]),we(PLe,{isMobile:t.isMobile,showAdvanced:D(i),items:D(p),adaptiveMode:D(s).adaptiveMode,spatialAdaptiveMode:D(s).spatialAdaptiveMode,enableEnhancement:D(s).enableEnhancement,onToggleAdvanced:x[0]||(x[0]=b=>i.value=!D(i)),onUpdateValue:D(u),"onUpdate:adaptiveMode":x[1]||(x[1]=b=>D(s).adaptiveMode=b),"onUpdate:spatialAdaptiveMode":x[2]||(x[2]=b=>D(s).spatialAdaptiveMode=b),"onUpdate:enableEnhancement":x[3]||(x[3]=b=>D(s).enableEnhancement=b)},null,8,["isMobile","showAdvanced","items","adaptiveMode","spatialAdaptiveMode","enableEnhancement","onUpdateValue"]),D(s).enableEnhancement?(F(),st(DLe,{key:0,isMobile:t.isMobile,items:D(g),onUpdateValue:D(c)},null,8,["isMobile","items","onUpdateValue"])):Ue("",!0),D(o)?(F(),st(MLe,{key:1})):Ue("",!0)],2)):(F(),st(dLe,{key:0,isMobile:t.isMobile},null,8,["isMobile"]))]))}});function OLe(t){const e=ce({...Vx}),n=ce(null),s={state:{clarityParams:e,currentPreset:n},emit:t},r=ye(()=>o=>o?"text-center text-white/30 py-8 text-sm":"flex flex-col items-center justify-center py-12 text-white/30 gap-4"),i=ye(()=>o=>o?"flex flex-col gap-3":"flex flex-col gap-3 bg-white/5 rounded-2xl border border-white/5");return{clarityParams:e,currentPreset:n,ctx:s,emptyStateClass:r.value,contentContainerClass:i.value}}function FLe(t){return["sigma","epsilon","radius","blockSize","detailStrength","enhancementStrength","macroEnhancement","contrastBoost"].includes(t)}const ULe="Invalid clarity parameter key: ",BLe=t=>`${ULe}${t}`,zLe=t=>t!==null&&t instanceof HTMLInputElement,GLe=t=>typeof t=="string",VLe=(t,e,n)=>{const s=document.createElement("input");s.type="file",s.accept=".json",s.onchange=r=>{var a;const i=r.target;if(!zLe(i))return;const o=(a=i.files)==null?void 0:a[0];if(o){const l=new FileReader;l.onload=u=>{var c;try{if(!GLe((c=u.target)==null?void 0:c.result))throw new Error("FileReader result is not a string");const h=JSON.parse(u.target.result);t.value={...Vx,...h},e.value=null,n("controlEvent",Wx(t.value))}catch(h){console.error(":",h),alert("")}},l.readAsText(o)}},s.click()},WLe="clarity-params-{timestamp}.json",HLe=/:/g,KLe="-",jLe="application/json",XLe=t=>{const e=JSON.stringify(t,null,2),n=new Blob([e],{type:jLe}),s=URL.createObjectURL(n),r=document.createElement("a");r.href=s;const i=new Date().toISOString().slice(0,19).replace(HLe,KLe),o=WLe.replace("{timestamp}",i);r.download=o,document.body.appendChild(r),r.click(),document.body.removeChild(r),URL.revokeObjectURL(s)},qLe=(t,e)=>{if(!FLe(e.id)){console.warn(BLe(e.id));return}const n={};n[e.id]=e.value,Object.assign(t.state.clarityParams.value,n),t.state.currentPreset.value=null,t.emit("controlEvent",Wx(t.state.clarityParams.value))},YLe=t=>{VLe(t.state.clarityParams,t.state.currentPreset,t.emit)},ZLe=t=>{XLe(t.state.clarityParams.value)},QLe=t=>{t.state.clarityParams.value={...Vx},t.state.currentPreset.value=null,t.emit("controlEvent",Wx(t.state.clarityParams.value))},JLe=(t,e)=>{t.state.clarityParams.value={...URe(e)},t.state.currentPreset.value=e,t.emit("controlEvent",Wx(t.state.clarityParams.value))};function eOe(t){const{clarityParams:e,currentPreset:n,ctx:s,emptyStateClass:r,contentContainerClass:i}=OLe(t);return{clarityParams:e,currentPreset:n,emptyStateClass:r,contentContainerClass:i,handleParamUpdate:h=>{qLe(s,h)},resetParams:()=>{QLe(s)},applyPreset:h=>{JLe(s,h)},handleImportParams:()=>{YLe(s)},handleExportParams:()=>{ZLe(s)}}}const tOe=[{id:"sigma",label:"Sigma",min:1,max:16,step:.5,gradient:"linear-gradient(90deg, #3b82f6 0%, #8b5cf6 100%)",showRuler:!1},{id:"epsilon",label:"Epsilon",min:.01,max:.1,step:.01,gradient:"linear-gradient(90deg, #10b981 0%, #34d399 100%)",showRuler:!1},{id:"radius",label:"Radius",min:4,max:32,step:2,gradient:"linear-gradient(90deg, #f59e0b 0%, #f97316 100%)",showRuler:!0},{id:"blockSize",label:"Block Size",min:8,max:32,step:8,gradient:"linear-gradient(90deg, #8b5cf6 0%, #6366f1 100%)",showRuler:!0}],nOe=[{id:"detailStrength",label:"Detail Strength",min:.1,max:20,step:.1,gradient:"linear-gradient(90deg, #06b6d4 0%, #10b981 100%)",showRuler:!1},{id:"enhancementStrength",label:"Enhancement Strength",min:.1,max:10,step:.1,gradient:"linear-gradient(90deg, #3b82f6 0%, #8b5cf6 100%)",showRuler:!1},{id:"macroEnhancement",label:"Macro Enhancement",min:0,max:2,step:.1,gradient:"linear-gradient(90deg, #f59e0b 0%, #f97316 100%)",showRuler:!1},{id:"contrastBoost",label:"Contrast Boost",min:1,max:3,step:.1,gradient:"linear-gradient(90deg, #6366f1 0%, #8b5cf6 100%)",showRuler:!1}],x4=(t,e)=>({id:t.id,label:t.label,value:e[t.id],min:t.min,max:t.max,step:t.step,gradient:t.gradient,showRuler:t.showRuler}),sOe={class:"space-y-3"},rOe=We({__name:"FilterParamsGroup",props:{isMobile:{type:Boolean},clarityParams:{}},emits:["update-value"],setup(t,{emit:e}){const n=t,s=e,r=o=>x4(o,n.clarityParams),i=o=>{s("update-value",o)};return(o,a)=>(F(),V("div",{class:Q(["pb-3 pt-3",{"px-4":!t.isMobile}])},[a[0]||(a[0]=k("div",{class:"flex items-center justify-between mb-3"},[k("label",{class:"block text-sm font-medium text-white/80"},"  ")],-1)),k("div",sOe,[(F(!0),V(Xe,null,rt(D(tOe),l=>(F(),st(D(St),{key:l.id,items:[r(l)],onUpdateValue:i},null,8,["items"]))),128))])],2))}}),iOe={class:"space-y-3"},oOe=We({__name:"EnhancementParamsGroup",props:{isMobile:{type:Boolean},clarityParams:{}},emits:["update-value"],setup(t,{emit:e}){const n=t,s=e,r=o=>x4(o,n.clarityParams),i=o=>{s("update-value",o)};return(o,a)=>(F(),V("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[a[0]||(a[0]=k("div",{class:"flex items-center justify-between mb-3"},[k("label",{class:"block text-sm font-medium text-white/80"},"  ")],-1)),k("div",iOe,[(F(!0),V(Xe,null,rt(D(nOe),l=>(F(),st(D(St),{key:l.id,items:[r(l)],onUpdateValue:i},null,8,["items"]))),128))])],2))}}),aOe={class:"grid grid-cols-2 gap-2 mb-3"},lOe=["onClick"],uOe=We({__name:"PresetsAndActionsGroup",props:{isMobile:{type:Boolean},currentPreset:{}},emits:["reset-params","apply-preset","export-params","import-params"],setup(t,{emit:e}){const n=e,s=()=>{n("reset-params")},r=a=>{n("apply-preset",a)},i=()=>{n("export-params")},o=()=>{n("import-params")};return(a,l)=>(F(),V("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[k("div",{class:"flex items-center justify-between mb-3"},[l[1]||(l[1]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("button",{onClick:s,class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex items-center gap-1"},[...l[0]||(l[0]=[k("div",{class:"i-carbon-reset"},null,-1),k("span",null,"",-1)])])]),k("div",aOe,[(F(!0),V(Xe,null,rt(D(DN),(u,c)=>(F(),V("button",{key:c,onClick:h=>r(c),class:Q(["glass-btn text-xs py-2 rounded transition-colors",t.currentPreset===c?"bg-white/20 text-white":"bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90"])},Le(u.name),11,lOe))),128))]),k("div",{class:"flex gap-2"},[k("button",{onClick:i,class:"glass-btn text-xs py-2 rounded bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 transition-colors flex-1"},"  "),k("button",{onClick:o,class:"glass-btn text-xs py-2 rounded bg-white/5 text-white/60 hover:bg-white/10 hover:text-white/90 transition-colors flex-1"},"  ")])],2))}}),cOe={class:"flex flex-col gap-4"},b4=We({__name:"ClarityPanel",props:{isMobile:{type:Boolean},originalImage:{}},emits:["controlEvent"],setup(t,{emit:e}){const n=e,{clarityParams:s,currentPreset:r,emptyStateClass:i,contentContainerClass:o,handleParamUpdate:a,resetParams:l,applyPreset:u,handleImportParams:c,handleExportParams:h}=eOe((d,f)=>{n(d,f)});return(d,f)=>(F(),V("div",cOe,[t.originalImage?(F(),V("div",{key:1,class:Q(D(o)(t.isMobile||!1))},[we(rOe,{isMobile:t.isMobile,clarityParams:D(s),onUpdateValue:D(a)},null,8,["isMobile","clarityParams","onUpdateValue"]),we(oOe,{isMobile:t.isMobile,clarityParams:D(s),onUpdateValue:D(a)},null,8,["isMobile","clarityParams","onUpdateValue"]),we(uOe,{isMobile:t.isMobile,currentPreset:D(r),onResetParams:D(l),onApplyPreset:D(u),onExportParams:D(h),onImportParams:D(c)},null,8,["isMobile","currentPreset","onResetParams","onApplyPreset","onExportParams","onImportParams"])],2)):(F(),V("div",{key:0,class:Q(D(i)(t.isMobile||!1))},[...f[0]||(f[0]=[k("div",{class:"i-carbon-color-palette text-1xl"},null,-1),k("span",{class:"text-sm"},"Please select an image first",-1)])],2))]))}}),hOe={class:"flex flex-col gap-4"},dOe={class:"flex items-center justify-between mb-3"},fOe=["disabled"],pOe={class:"grid grid-cols-3 gap-2 mb-4"},mOe=["onClick"],gOe={class:"text-lg opacity-70"},xOe={key:0,class:"i-carbon-settings"},bOe={key:1,class:"i-carbon-moon"},yOe={key:2,class:"i-carbon-sun"},vOe={key:3,class:"i-carbon-palette"},wOe={key:4,class:"i-carbon-contrast"},SOe={key:5},COe={key:6},TOe={class:"flex items-center justify-between mb-3"},IOe=["disabled"],kOe={class:"flex items-center justify-between mb-3"},EOe=["disabled"],_Oe={class:"flex items-center justify-between mb-3"},$Oe=["disabled"],ROe={class:"flex items-center justify-between mb-3"},AOe=["disabled"],POe={key:0,class:"flex items-center justify-center py-4"},DOe=We({__name:"LuminancePanel",props:{isMobile:{type:Boolean},originalImage:{},luminanceParams:{}},emits:["controlEvent"],setup(t,{emit:e}){const n=t,s=e,r=ce({...Dn}),i=ce(null),o=ce(!1),a=ye(()=>n.isMobile?"text-center text-white/30 py-8 text-sm":"flex flex-col items-center justify-center py-12 text-white/30 gap-4"),l=ye(()=>n.isMobile?"flex flex-col gap-3":"flex flex-col gap-3 bg-white/5 rounded-2xl border border-white/5"),u=ye(()=>JSON.stringify(r.value)!==JSON.stringify(Dn)),c=ye(()=>{const P=Dn.shadows,M=r.value.shadows;return JSON.stringify(M)!==JSON.stringify(P)}),h=ye(()=>{const P=Dn.midtones,M=r.value.midtones;return JSON.stringify(M)!==JSON.stringify(P)}),d=ye(()=>{const P=Dn.highlights,M=r.value.highlights;return JSON.stringify(M)!==JSON.stringify(P)}),f=ye(()=>r.value.shadowEnd!==Dn.shadowEnd||r.value.highlightStart!==Dn.highlightStart||r.value.softness!==Dn.softness),p=ye(()=>[{id:"shadow-brightness",label:"",value:r.value.shadows.brightness,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #000 0%, #888 50%, #fff 100%)",showRuler:!0},{id:"shadow-contrast",label:"",value:r.value.shadows.contrast,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #666 0%, #fff 50%, #666 100%)",showRuler:!0},{id:"shadow-saturation",label:"",value:r.value.shadows.saturation,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #888 0%, #ff0000 100%)",showRuler:!0},{id:"shadow-red",label:"",value:r.value.shadows.red,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #000 0%, #ff0000 100%)",showRuler:!1},{id:"shadow-green",label:"",value:r.value.shadows.green,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #000 0%, #00ff00 100%)",showRuler:!1},{id:"shadow-blue",label:"",value:r.value.shadows.blue,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #000 0%, #0000ff 100%)",showRuler:!1}]),g=ye(()=>[{id:"midtone-brightness",label:"",value:r.value.midtones.brightness,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #000 0%, #888 50%, #fff 100%)",showRuler:!0},{id:"midtone-contrast",label:"",value:r.value.midtones.contrast,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #666 0%, #fff 50%, #666 100%)",showRuler:!0},{id:"midtone-saturation",label:"",value:r.value.midtones.saturation,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #888 0%, #ff0000 100%)",showRuler:!0},{id:"midtone-red",label:"",value:r.value.midtones.red,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #000 0%, #ff0000 100%)",showRuler:!1},{id:"midtone-green",label:"",value:r.value.midtones.green,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #000 0%, #00ff00 100%)",showRuler:!1},{id:"midtone-blue",label:"",value:r.value.midtones.blue,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #000 0%, #0000ff 100%)",showRuler:!1}]),m=ye(()=>[{id:"highlight-brightness",label:"",value:r.value.highlights.brightness,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #000 0%, #888 50%, #fff 100%)",showRuler:!0},{id:"highlight-contrast",label:"",value:r.value.highlights.contrast,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #666 0%, #fff 50%, #666 100%)",showRuler:!0},{id:"highlight-saturation",label:"",value:r.value.highlights.saturation,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #888 0%, #ff0000 100%)",showRuler:!0},{id:"highlight-red",label:"",value:r.value.highlights.red,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #000 0%, #ff0000 100%)",showRuler:!1},{id:"highlight-green",label:"",value:r.value.highlights.green,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #000 0%, #00ff00 100%)",showRuler:!1},{id:"highlight-blue",label:"",value:r.value.highlights.blue,min:-1,max:1,step:.01,gradient:"linear-gradient(90deg, #000 0%, #0000ff 100%)",showRuler:!1}]),x=ye(()=>[{id:"shadow-end",label:"",value:r.value.shadowEnd,min:.1,max:.5,step:.01,gradient:"linear-gradient(90deg, #000 0%, #888 100%)",showRuler:!0},{id:"highlight-start",label:"",value:r.value.highlightStart,min:.5,max:.9,step:.01,gradient:"linear-gradient(90deg, #888 0%, #fff 100%)",showRuler:!0},{id:"softness",label:"",value:r.value.softness,min:0,max:.5,step:.01,gradient:"linear-gradient(90deg, #007aff 0%, #5ac8fa 100%)",showRuler:!0}]),b=P=>{i.value=P,r.value=cAe(P),N()},v=()=>{i.value=null,r.value={...Dn},N()},y=()=>{r.value.shadows={...Dn.shadows},i.value=null,N()},C=()=>{r.value.midtones={...Dn.midtones},i.value=null,N()},I=()=>{r.value.highlights={...Dn.highlights},i.value=null,N()},$=()=>{r.value.shadowEnd=Dn.shadowEnd,r.value.highlightStart=Dn.highlightStart,r.value.softness=Dn.softness,i.value=null,N()},T=P=>{const M={};P.id==="shadow-brightness"?M.brightness=P.value:P.id==="shadow-contrast"?M.contrast=P.value:P.id==="shadow-saturation"?M.saturation=P.value:P.id==="shadow-red"?M.red=P.value:P.id==="shadow-green"?M.green=P.value:P.id==="shadow-blue"&&(M.blue=P.value),Object.assign(r.value.shadows,M),i.value=null,N()},S=P=>{const M={};P.id==="midtone-brightness"?M.brightness=P.value:P.id==="midtone-contrast"?M.contrast=P.value:P.id==="midtone-saturation"?M.saturation=P.value:P.id==="midtone-red"?M.red=P.value:P.id==="midtone-green"?M.green=P.value:P.id==="midtone-blue"&&(M.blue=P.value),Object.assign(r.value.midtones,M),i.value=null,N()},E=P=>{const M={};P.id==="highlight-brightness"?M.brightness=P.value:P.id==="highlight-contrast"?M.contrast=P.value:P.id==="highlight-saturation"?M.saturation=P.value:P.id==="highlight-red"?M.red=P.value:P.id==="highlight-green"?M.green=P.value:P.id==="highlight-blue"&&(M.blue=P.value),Object.assign(r.value.highlights,M),i.value=null,N()},_=P=>{P.id==="shadow-end"?r.value.shadowEnd=P.value:P.id==="highlight-start"?r.value.highlightStart=P.value:P.id==="softness"&&(r.value.softness=P.value),i.value=null,N()},N=()=>{const P=EAe(r.value);if(!P.isValid){console.warn(":",P.errors);return}s("controlEvent",_Ae(r.value))};return _t(()=>n.luminanceParams,P=>{P&&(r.value={...P})},{deep:!0}),_t(()=>n.originalImage,()=>{v()}),(P,M)=>(F(),V("div",hOe,[t.originalImage?(F(),V("div",{key:1,class:Q(l.value)},[k("div",{class:Q(["pb-3 pt-3",{"px-4":!t.isMobile}])},[k("div",dOe,[M[2]||(M[2]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("button",{onClick:v,class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex items-center gap-1",disabled:!u.value},[...M[1]||(M[1]=[k("div",{class:"i-carbon-reset"},null,-1),k("span",null,"",-1)])],8,fOe)]),k("div",pOe,[(F(!0),V(Xe,null,rt(D(MN),(z,A)=>(F(),V("button",{key:A,class:Q(["glass-btn text-xs py-2 px-2 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex flex-col items-center gap-1",{"bg-white/20 text-white/90":i.value===A}]),onClick:B=>b(A)},[k("div",gOe,[A==="default"?(F(),V("div",xOe)):A==="enhanceShadows"?(F(),V("div",bOe)):A==="enhanceHighlights"?(F(),V("div",yOe)):A==="popColors"?(F(),V("div",vOe)):A==="contrastBoost"?(F(),V("div",wOe)):A==="warmTones"?(F(),V("div",SOe)):A==="coolTones"?(F(),V("div",COe)):Ue("",!0)]),k("span",null,Le(z.name),1)],10,mOe))),128))])],2),k("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[k("div",TOe,[M[4]||(M[4]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("button",{onClick:y,class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex items-center gap-1",disabled:!c.value},[...M[3]||(M[3]=[k("div",{class:"i-carbon-reset"},null,-1),k("span",null,"",-1)])],8,IOe)]),we(D(St),{items:p.value,onUpdateValue:T},null,8,["items"])],2),k("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[k("div",kOe,[M[6]||(M[6]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("button",{onClick:C,class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex items-center gap-1",disabled:!h.value},[...M[5]||(M[5]=[k("div",{class:"i-carbon-reset"},null,-1),k("span",null,"",-1)])],8,EOe)]),we(D(St),{items:g.value,onUpdateValue:S},null,8,["items"])],2),k("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[k("div",_Oe,[M[8]||(M[8]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("button",{onClick:I,class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex items-center gap-1",disabled:!d.value},[...M[7]||(M[7]=[k("div",{class:"i-carbon-reset"},null,-1),k("span",null,"",-1)])],8,$Oe)]),we(D(St),{items:m.value,onUpdateValue:E},null,8,["items"])],2),k("div",{class:Q(["border-t border-white/5 pt-3 pb-3",{"px-4":!t.isMobile}])},[k("div",ROe,[M[10]||(M[10]=k("label",{class:"block text-sm font-medium text-white/80"},"  ",-1)),k("button",{onClick:$,class:"glass-btn text-[10px] px-2 py-1 rounded bg-white/5 hover:bg-white/10 text-white/60 hover:text-white/90 transition-colors flex items-center gap-1",disabled:!f.value},[...M[9]||(M[9]=[k("div",{class:"i-carbon-reset"},null,-1),k("span",null,"",-1)])],8,AOe)]),we(D(St),{items:x.value,onUpdateValue:_},null,8,["items"])],2),o.value?(F(),V("div",POe,[...M[11]||(M[11]=[k("div",{class:"i-carbon-circle-dash animate-spin text-white/60 mr-2"},null,-1),k("span",{class:"text-sm text-white/60"},"...",-1)])])):Ue("",!0)],2)):(F(),V("div",{key:0,class:Q(a.value)},[...M[0]||(M[0]=[k("div",{class:"i-carbon-sun text-1xl"},null,-1),k("span",{class:"text-sm"},"Please select an image first",-1)])],2))]))}}),y4=Zi(DOe,[["__scopeId","data-v-461dfa30"]]),NOe={class:"flex flex-col gap-4"},MOe=["disabled"],v4=We({__name:"SettingsPanel",props:{isMobile:{type:Boolean},isProcessing:{type:Boolean},originalImage:{},settingsSliderItems:{}},emits:["process-image","slider-update"],setup(t){const e=t,n=ye(()=>e.isMobile?"text-center text-white/30 py-8 text-sm":"flex flex-col items-center justify-center py-12 text-white/30 gap-4"),s=ye(()=>e.isMobile?"flex flex-col gap-5 bg-white/5 rounded-2xl border border-white/5":"flex flex-col gap-4 bg-white/5 rounded-2xl border border-white/5"),r=ye(()=>e.isMobile?"py-3.5 gap-2":"py-4 gap-3"),i=ye(()=>e.isProcessing?"bg-white/10 cursor-not-allowed":"bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 text-white shadow-blue-500/20"),o=ye(()=>e.isMobile?"text-lg":"text-xl");return(a,l)=>(F(),V("div",NOe,[t.originalImage?(F(),V("div",{key:1,class:Q(s.value)},[we(D(St),{items:t.settingsSliderItems,onUpdateValue:l[0]||(l[0]=u=>a.$emit("slider-update",u))},null,8,["items"]),k("button",{onClick:l[1]||(l[1]=u=>a.$emit("process-image")),disabled:t.isProcessing,class:Q(["w-full rounded-xl font-medium shadow-lg flex items-center justify-center relative overflow-hidden group",[r.value,i.value]])},[t.isProcessing?(F(),V("div",{key:0,class:Q(["i-carbon-circle-dash animate-spin",o.value])},null,2)):(F(),V("div",{key:1,class:Q(["i-carbon-magic-wand",o.value,t.isMobile?"":"group-hover:rotate-12 transition-transform"])},null,2)),k("span",null,Le(t.isProcessing?"Processing...":t.isMobile?"Make Seamless":"Generate Seamless Texture"),1)],10,MOe)],2)):(F(),V("div",{key:0,class:Q(n.value)},[...l[2]||(l[2]=[k("div",{class:"i-carbon-image text-1xl"},null,-1),k("span",{class:"text-sm"},"Please select an image first",-1)])],2))]))}}),LOe={class:"flex flex-col gap-4"},OOe={key:0,class:"bg-white/5 rounded-2xl border border-white/5"},FOe={key:1,class:"bg-white/5 rounded-2xl border border-white/5"},w4=We({__name:"ViewPanel",props:{isMobile:{type:Boolean},originalImage:{},processedImage:{},magnifierEnabled:{type:Boolean},viewSliderItems:{}},emits:["reset-zoom","toggle-magnifier","slider-update"],setup(t){const e=t,n=ye(()=>e.isMobile?"text-center text-white/30 py-8 text-sm":"flex flex-col items-center justify-center py-12 text-white/30 gap-4"),s=ye(()=>e.isMobile?"flex flex-col gap-5":"flex flex-col gap-6"),r=ye(()=>e.isMobile?"grid grid-cols-2 gap-3":"grid grid-cols-2 gap-4"),i=ye(()=>e.isMobile?"py-3 px-3 rounded-xl bg-white/5 border border-white/5 text-white flex flex-col items-center gap-1":"py-3 px-4 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 text-white transition-all flex flex-col items-center gap-2"),o=ye(()=>{const u=e.isMobile?"py-3 px-3 rounded-xl border flex flex-col items-center gap-1":"py-3 px-4 rounded-xl border transition-all flex flex-col items-center gap-2",c=e.magnifierEnabled?"bg-purple-500/20 border-purple-500/30 text-purple-200":"bg-white/5 hover:bg-white/10 border-white/5 text-white";return`${u} ${c}`}),a=ye(()=>e.isMobile?"text-lg":"i-carbon-center-circle text-xl"),l=ye(()=>e.isMobile?"text-[10px] font-medium":"text-xs font-medium");return(u,c)=>(F(),V("div",LOe,[t.originalImage?(F(),V("div",{key:1,class:Q(s.value)},[t.isMobile?(F(),V("div",FOe,[we(D(St),{items:t.viewSliderItems,onUpdateValue:c[1]||(c[1]=h=>u.$emit("slider-update",h))},null,8,["items"])])):(F(),V("div",OOe,[we(D(St),{items:t.viewSliderItems,onUpdateValue:c[0]||(c[0]=h=>u.$emit("slider-update",h))},null,8,["items"])])),k("div",{class:Q(r.value)},[k("button",{onClick:c[2]||(c[2]=h=>u.$emit("reset-zoom")),class:Q(i.value)},[k("div",{class:Q(a.value)},null,2),k("span",{class:Q(l.value)},"Reset Zoom",2)],2),t.processedImage?(F(),V("button",{key:0,onClick:c[3]||(c[3]=h=>u.$emit("toggle-magnifier")),class:Q(o.value)},[k("div",{class:Q(["i-carbon-zoom-in",a.value])},null,2),k("span",{class:Q(l.value)},Le(t.magnifierEnabled?"Disable":"Enable")+" Magnifier",3)],2)):Ue("",!0)],2)],2)):(F(),V("div",{key:0,class:Q(n.value)},[...c[4]||(c[4]=[k("div",{class:"i-carbon-image text-1xl"},null,-1),k("span",{class:"text-sm"},"Please select an image first",-1)])],2))]))}}),UOe={class:"flex flex-col gap-4"},BOe={class:"flex flex-col"},zOe={key:0,class:"i-carbon-download ml-auto text-white/30 group-hover:text-white transition-colors"},GOe={class:"flex flex-col"},VOe={key:0,class:"i-carbon-download ml-auto text-white/30 group-hover:text-white transition-colors"},WOe={key:1,class:"p-4 rounded-2xl border border-dashed border-white/10 text-center text-gray-500 text-sm"},S4=We({__name:"SavePanel",props:{isMobile:{type:Boolean},originalImage:{},processedImage:{}},emits:["save-original","save-result"],setup(t){const e=t,n=ye(()=>e.isMobile?"text-center text-white/30 py-8 text-sm":"flex flex-col items-center justify-center py-12 text-white/30 gap-4"),s=ye(()=>e.isMobile?"flex flex-col gap-3":"flex flex-col gap-4"),r=ye(()=>e.isMobile?"w-full p-3.5 rounded-2xl bg-white/5 border border-white/5 flex items-center gap-3 text-left":"w-full p-4 rounded-2xl bg-white/5 hover:bg-white/10 border border-white/5 hover:border-white/20 transition-all flex items-center gap-4 group text-left"),i=u=>`${e.isMobile?"w-10 h-10 rounded-lg":"w-12 h-12 rounded-xl group-hover:scale-110 transition-transform"} ${u==="blue"?"bg-blue-500/20 text-blue-400":"bg-green-500/20 text-green-400"} flex items-center justify-center`,o=ye(()=>e.isMobile?"text-xl":"text-2xl"),a=ye(()=>e.isMobile?"font-bold text-white text-sm":"font-bold text-white"),l=ye(()=>e.isMobile?"text-[10px] text-gray-400":"text-xs text-gray-400");return(u,c)=>(F(),V("div",UOe,[t.originalImage?(F(),V("div",{key:1,class:Q(s.value)},[k("button",{onClick:c[0]||(c[0]=h=>u.$emit("save-original")),class:Q(r.value)},[k("div",{class:Q(i("blue"))},[k("div",{class:Q(["i-carbon-image",o.value])},null,2)],2),k("div",BOe,[k("span",{class:Q(a.value)},"Save Original",2),k("span",{class:Q(l.value)},Le(t.isMobile?"Download source":"Download the source image"),3)]),t.isMobile?Ue("",!0):(F(),V("div",zOe))],2),t.processedImage?(F(),V("button",{key:0,onClick:c[1]||(c[1]=h=>u.$emit("save-result")),class:Q(r.value)},[k("div",{class:Q(i("green"))},[k("div",{class:Q(["i-carbon-save",o.value])},null,2)],2),k("div",GOe,[k("span",{class:Q(a.value)},"Save Result",2),k("span",{class:Q(l.value)},Le(t.isMobile?"Download texture":"Download seamless texture"),3)]),t.isMobile?Ue("",!0):(F(),V("div",VOe))],2)):t.isMobile?Ue("",!0):(F(),V("div",WOe," Generate a texture to enable saving "))],2)):(F(),V("div",{key:0,class:Q(n.value)},[...c[2]||(c[2]=[k("div",{class:"i-carbon-image text-1xl"},null,-1),k("span",{class:"text-sm"},"Please select an image first",-1)])],2))]))}}),HOe={class:"flex flex-col h-full relative"},KOe={class:"flex-1 overflow-y-auto scrollbar-hide min-h-0 px-4 pb-4"},jOe={class:"flex flex-col gap-6 pt-6"},XOe={class:"w-full z-50 bg-black border-t flex-shrink-0 pb-[env(safe-area-inset-bottom)]"},qOe=["onClick"],YOe={class:"text-[10px] font-medium tracking-wide whitespace-nowrap"},ZOe=We({__name:"MobileControls",props:{isProcessing:{type:Boolean},originalImage:{},processedImage:{},maxResolution:{},borderSize:{},splitPosition:{},magnifierEnabled:{type:Boolean},zoomLevel:{},lutEnabled:{type:Boolean},lutIntensity:{},lutFileName:{},lutFile:{},globalHSL:{},hslLayers:{},exposureStrength:{},exposureManual:{},dehazeParams:{},clarityParams:{},luminanceParams:{}},emits:["controlEvent"],setup(t,{emit:e}){const n=t,s=e,{activeGroup:r,groups:i,inputSliderItems:o,settingsSliderItems:a,viewSliderItems:l,handleImageUpload:u,loadSampleImage:c,handleSliderUpdate:h,processImage:d,toggleMagnifier:f,resetZoom:p,openSamplingEditor:g,saveOriginal:m,saveResult:x,toggleLUT:b,handleLUTFileChange:v,clearLUT:y,handleMaskUpdate:C,setImage:I}=Pk(n,s),$=ce(),T=S=>{Nk(S)};return(S,E)=>(F(),V("div",HOe,[E[6]||(E[6]=k("div",{class:"flex items-center justify-between px-4 py-4 border-b border-white/5 flex-shrink-0"},[k("div",{id:"header-actions-container"})],-1)),k("div",KOe,[k("div",jOe,[D(r)==="contact"?(F(),st(Mk,{key:0,"is-mobile":""})):D(r)==="inputs"?(F(),st(SE,{key:1,"is-mobile":"","is-processing":t.isProcessing,"original-image":t.originalImage,"input-slider-items":D(o),onLoadSample:D(c),onImageUpload:D(u),onSliderUpdate:D(h),onSetImage:D(I)},null,8,["is-processing","original-image","input-slider-items","onLoadSample","onImageUpload","onSliderUpdate","onSetImage"])):D(r)==="crop"?(F(),st(CE,{key:2,"is-mobile":"","original-image":t.originalImage,onOpenSamplingEditor:D(g)},null,8,["original-image","onOpenSamplingEditor"])):D(r)==="lut"?(F(),st(a4,{key:3,"is-mobile":"","original-image":t.originalImage,"processed-image":t.processedImage,"lut-enabled":t.lutEnabled,"lut-intensity":t.lutIntensity,"lut-file-name":t.lutFileName,"lut-file":t.lutFile,onToggleLut:D(b),onLutFileChange:D(v),onClearLut:D(y),onSliderUpdate:D(h),onMaskUpdate:D(C),onControlEvent:E[0]||(E[0]=_=>s("controlEvent",_))},null,8,["original-image","processed-image","lut-enabled","lut-intensity","lut-file-name","lut-file","onToggleLut","onLutFileChange","onClearLut","onSliderUpdate","onMaskUpdate"])):D(r)==="hsl"?(F(),st(c4,{key:4,"is-mobile":"","original-image":t.originalImage,"processed-image":t.processedImage,"global-hsl":t.globalHSL,"hsl-layers":t.hslLayers,onControlEvent:E[1]||(E[1]=_=>s("controlEvent",_))},null,8,["original-image","processed-image","global-hsl","hsl-layers"])):D(r)==="exposure"?(F(),st(h4,{key:5,"is-mobile":"","original-image":t.originalImage,"exposure-strength":t.exposureStrength,"exposure-manual":t.exposureManual,onControlEvent:E[2]||(E[2]=_=>s("controlEvent",_))},null,8,["original-image","exposure-strength","exposure-manual"])):D(r)==="dehaze"?(F(),st(g4,{key:6,"is-mobile":"","original-image":t.originalImage,"dehaze-params":t.dehazeParams,onControlEvent:E[3]||(E[3]=_=>s("controlEvent",_))},null,8,["original-image","dehaze-params"])):D(r)==="clarity"?(F(),st(b4,{key:7,"is-mobile":"","original-image":t.originalImage,onControlEvent:E[4]||(E[4]=_=>s("controlEvent",_))},null,8,["original-image"])):D(r)==="luminance"?(F(),st(y4,{key:8,"is-mobile":"","original-image":t.originalImage,"luminance-params":t.luminanceParams,onControlEvent:E[5]||(E[5]=_=>s("controlEvent",_))},null,8,["original-image","luminance-params"])):D(r)==="tileablesettings"?(F(),st(v4,{key:9,"is-mobile":"",isProcessing:t.isProcessing,"original-image":t.originalImage,"settings-slider-items":D(a),onProcessImage:D(d),onSliderUpdate:D(h)},null,8,["isProcessing","original-image","settings-slider-items","onProcessImage","onSliderUpdate"])):D(r)==="view"?(F(),st(w4,{key:10,"is-mobile":"","original-image":t.originalImage,"processed-image":t.processedImage,"magnifier-enabled":t.magnifierEnabled,"view-slider-items":D(l),onResetZoom:D(p),onToggleMagnifier:D(f),onSliderUpdate:D(h)},null,8,["original-image","processed-image","magnifier-enabled","view-slider-items","onResetZoom","onToggleMagnifier","onSliderUpdate"])):D(r)==="save"?(F(),st(S4,{key:11,"is-mobile":"","original-image":t.originalImage,"processed-image":t.processedImage,onSaveOriginal:D(m),onSaveResult:D(x)},null,8,["original-image","processed-image","onSaveOriginal","onSaveResult"])):Ue("",!0)])]),E[7]||(E[7]=k("div",{id:"secondary-nav-container",class:"w-full z-40 flex-shrink-0"},null,-1)),k("div",XOe,[k("div",{ref_key:"navContainer",ref:$,class:"flex items-center h-16 px-2 overflow-x-auto scrollbar-hide",onWheel:T},[(F(!0),V(Xe,null,rt(D(i),_=>(F(),V("button",{key:_.id,onClick:N=>r.value=_.id,class:Q(["flex flex-col items-center justify-center min-w-[80px] h-full gap-1 transition-colors duration-200 !bg-transparent !border-none !shadow-none !outline-none flex-shrink-0",D(r)===_.id?"text-white":"text-neutral-500 hover:text-neutral-300"])},[k("div",{class:Q([_.icon,"text-2xl transition-transform duration-200",D(r)===_.id?"scale-100":"scale-90"])},null,2),k("span",YOe,Le(_.label),1)],10,qOe))),128))],544)])]))}});var ql=class{createTimeoutPromise(t,e=3e4){return Promise.race([t,new Promise((n,s)=>{setTimeout(()=>{s(Error(`Image loading timeout after ${e}ms`))},e)})])}loadImageElement(t,e){return new Promise((n,s)=>{let r=new Image;e!=null&&e.crossOrigin&&(r.crossOrigin=e.crossOrigin),r.onload=()=>{n(r)},r.onerror=i=>{s(Error(`Failed to load image from ${t}: ${i}`))},r.src=t})}loadImageFromBlob(t,e){return new Promise((n,s)=>{let r=URL.createObjectURL(t);this.loadImageElement(r,e).then(i=>{URL.revokeObjectURL(r),n(i)}).catch(i=>{URL.revokeObjectURL(r),s(i)})})}loadImageFromArrayBuffer(t,e="image/jpeg",n){let s=new Blob([t],{type:e});return this.loadImageFromBlob(s,n)}validateImageElement(t){if(!t||t.width===0||t.height===0)throw Error("Invalid image: zero width or height")}validateCanvasElement(t){if(!t||t.width===0||t.height===0)throw Error("Invalid canvas: zero width or height")}createProgressFetch(t,e){return new Promise((n,s)=>{fetch(t).then(r=>{if(!r.ok)throw Error(`HTTP error! status: ${r.status}`);if(!r.body){n(r);return}let i=r.headers.get("content-length"),o=i?parseInt(i,10):0,a=0,l=r.body.getReader(),u=[],c=()=>{l.read().then(({done:h,value:d})=>{if(h){let f=u.reduce((x,b)=>x+b.length,0),p=new Uint8Array(f),g=0;for(let x of u)p.set(x,g),g+=x.length;let m=new Blob([p]);n(new Response(m,{status:r.status,statusText:r.statusText,headers:r.headers}));return}u.push(d),a+=d.length,e&&o>0&&e({progress:a/o,loaded:a,total:o}),c()}).catch(s)};c()}).catch(s)})}},QOe=class extends ql{constructor(...t){super(...t),this.name="UrlImageLoader"}canLoad(t){return typeof t=="string"&&(t.startsWith("http://")||t.startsWith("https://")||t.startsWith("data:image/")||t.startsWith("blob:")||t.startsWith("file:"))}async load(t,e){if(!this.canLoad(t))throw Error(`UrlImageLoader cannot load source: ${t}`);let n=this.loadImageElement(t,e);if(e!=null&&e.timeout)return this.createTimeoutPromise(n,e.timeout);let s=await n;return this.validateImageElement(s),s}},JOe=class extends ql{constructor(...t){super(...t),this.name="FileImageLoader"}canLoad(t){return t instanceof File}async load(t,e){if(!this.canLoad(t))throw Error(`FileImageLoader cannot load source: ${t}`);if(!this.isImageFile(t))throw Error(`Unsupported file type: ${t.type}. Expected an image file.`);let n=this.loadImageFromBlob(t,e);if(e!=null&&e.timeout)return this.createTimeoutPromise(n,e.timeout);let s=await n;return this.validateImageElement(s),s}isImageFile(t){return["image/jpeg","image/jpg","image/png","image/gif","image/webp","image/bmp","image/svg+xml","image/x-icon","image/vnd.microsoft.icon"].some(e=>t.type===e)}},eFe=class extends ql{constructor(...t){super(...t),this.name="BlobImageLoader"}canLoad(t){return t instanceof Blob}async load(t,e){if(!this.canLoad(t))throw Error(`BlobImageLoader cannot load source: ${t}`);if(!this.isImageBlob(t))throw Error(`Unsupported blob type: ${t.type}. Expected an image blob.`);let n=this.loadImageFromBlob(t,e);if(e!=null&&e.timeout)return this.createTimeoutPromise(n,e.timeout);let s=await n;return this.validateImageElement(s),s}isImageBlob(t){return t.type?["image/jpeg","image/jpg","image/png","image/gif","image/webp","image/bmp","image/svg+xml","image/x-icon","image/vnd.microsoft.icon"].some(e=>t.type===e):!0}},tFe=class extends ql{constructor(...t){super(...t),this.name="ArrayBufferImageLoader"}canLoad(t){return t instanceof ArrayBuffer||t instanceof Uint8Array||t instanceof Uint8ClampedArray||t instanceof DataView}async load(t,e){if(!this.canLoad(t))throw Error(`ArrayBufferImageLoader cannot load source: ${t}`);let n;if(t instanceof ArrayBuffer)n=t;else if(t instanceof Uint8Array||t instanceof Uint8ClampedArray)n=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength);else if(t instanceof DataView)n=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength);else throw Error("Unsupported array buffer type");let s=(e==null?void 0:e.mimeType)||this.detectImageFormat(n);if(!s)if(e!=null&&e.width&&(e!=null&&e.height))s="image/raw-rgba";else throw Error("Unable to detect image format. Please specify mimeType option, or provide width/height for raw pixel data.");let r;if(s==="image/raw-rgba"){if(!(e!=null&&e.width)||!(e!=null&&e.height))throw Error("Width and height are required for raw RGBA data");r=this.loadRawRGBAData(n,e.width,e.height,e)}else r=this.loadImageFromArrayBuffer(n,s,e);if(e!=null&&e.timeout)return this.createTimeoutPromise(r,e.timeout);let i=await r;return this.validateImageElement(i),i}detectImageFormat(t){if(t.byteLength<3)return null;let e=new Uint8Array(t);if(e[0]===255&&e[1]===216&&e[2]===255)return"image/jpeg";if(t.byteLength>=8&&e[0]===137&&e[1]===80&&e[2]===78&&e[3]===71&&e[4]===13&&e[5]===10&&e[6]===26&&e[7]===10)return"image/png";if(t.byteLength>=4&&e[0]===71&&e[1]===73&&e[2]===70&&e[3]===56)return"image/gif";if(t.byteLength>=12&&e[0]===82&&e[1]===73&&e[2]===70&&e[3]===70&&e[8]===87&&e[9]===69&&e[10]===66&&e[11]===80)return"image/webp";if(t.byteLength>=2&&e[0]===66&&e[1]===77)return"image/bmp";let n=new TextDecoder("utf-8").decode(e.slice(0,Math.min(100,t.byteLength)));return n.includes("<svg")||n.includes("<?xml")?"image/svg+xml":null}async loadRawRGBAData(t,e,n,s){let r=e*n*4;if(t.byteLength<r)throw Error(`Buffer too small for ${e}x${n} RGBA image. Expected ${r} bytes, got ${t.byteLength}`);let i=document.createElement("canvas");i.width=e,i.height=n;let o=i.getContext("2d");if(!o)throw Error("Failed to get 2D context from canvas");let a=o.createImageData(e,n),l=new Uint8Array(t);return a.data.set(l.slice(0,r)),o.putImageData(a,0,0),new Promise((u,c)=>{let h=new Image;h.onload=()=>{u(h)},h.onerror=d=>{c(Error(`Failed to create image from canvas: ${d}`))},h.src=i.toDataURL("image/png")})}},nFe=class extends ql{constructor(...t){super(...t),this.name="ElementImageLoader"}canLoad(t){return t instanceof HTMLImageElement||t instanceof HTMLCanvasElement}async load(t,e){if(!this.canLoad(t))throw Error(`ElementImageLoader cannot load source: ${t}`);if(t instanceof HTMLImageElement)return t.complete||await new Promise((n,s)=>{let r=()=>{t.removeEventListener("load",r),t.removeEventListener("error",i),n()},i=o=>{t.removeEventListener("load",r),t.removeEventListener("error",i),s(Error(`Image failed to load: ${o}`))};t.addEventListener("load",r),t.addEventListener("error",i)}),this.validateImageElement(t),t;if(t instanceof HTMLCanvasElement)return this.validateCanvasElement(t),t;throw Error("Unsupported element type")}};function C4(t){return typeof t=="object"&&!!t&&t.type==="texture"&&t.texture&&typeof t.texture=="object"&&t.device&&typeof t.device=="object"}function T4(t){return typeof t=="object"&&!!t&&t.type==="buffer"&&t.buffer&&typeof t.buffer=="object"&&t.device&&typeof t.device=="object"&&typeof t.width=="number"&&typeof t.height=="number"}function sFe(t){return C4(t)||T4(t)}var Ni=class{static isSupported(){return"gpu"in navigator}static async getAdapter(t){if(!this.isSupported())throw Error("WebGPU is not supported in this browser");return await navigator.gpu.requestAdapter(t)}static async getDevice(t,e){let n=t||await this.getAdapter();if(!n)throw Error("Failed to get WebGPU adapter");return await n.requestDevice(e)}static async textureToCanvas(t,e,n){if(!t||!e)throw Error("Invalid texture or device");let s=document.createElement("canvas");s.width=t.width,s.height=t.height;let r=s.getContext("2d");if(!r)throw Error("Failed to get 2D context from canvas");try{let i=t.width*t.height*4,o=e.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"ReadbackBuffer"});try{let a=e.createCommandEncoder();a.copyTextureToBuffer({texture:t},{buffer:o,bytesPerRow:t.width*4},[t.width,t.height,1]),e.queue.submit([a.finish()]),await e.queue.onSubmittedWorkDone(),await o.mapAsync(GPUMapMode.READ);let l=o.getMappedRange(),u=new ImageData(new Uint8ClampedArray(l.slice(0)),t.width,t.height);return o.unmap(),r.putImageData(u,0,0),s}finally{o.destroy()}}catch(i){throw Error(`Failed to convert texture to canvas: ${i}`)}}static async bufferToCanvas(t,e,n,s,r,i){if(!t||!e)throw Error("Invalid buffer or device");let o=document.createElement("canvas");o.width=n,o.height=s;let a=o.getContext("2d");if(!a)throw Error("Failed to get 2D context from canvas");let l;try{let u=e.createBuffer({size:t.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"ReadbackBuffer"});try{let h=e.createCommandEncoder();h.copyBufferToBuffer(t,0,u,0,t.size),e.queue.submit([h.finish()]),await e.queue.onSubmittedWorkDone(),await u.mapAsync(GPUMapMode.READ),l=u.getMappedRange().slice(0),u.unmap()}finally{u.destroy()}let c=new ImageData(new Uint8ClampedArray(l),n,s);return a.putImageData(c,0,0),o}catch(u){throw Error(`Failed to convert buffer to canvas: ${u}`)}}static getFormatBytesPerPixel(t){switch(t){case"rgba8unorm":case"rgba8unorm-srgb":case"bgra8unorm":case"bgra8unorm-srgb":return 4;case"rgb9e5ufloat":case"rgb10a2unorm":case"rg11b10ufloat":return 4;case"depth32float":return 4;case"depth24plus":case"depth24plus-stencil8":return 4;default:return 4}}},rFe=class extends ql{constructor(...t){super(...t),this.name="WebGPUTextureLoader"}canLoad(t){return C4(t)}async load(t,e){if(!this.canLoad(t))throw Error(`WebGPUTextureLoader cannot load source: ${t}`);if(!Ni.isSupported())throw Error("WebGPU is not supported in this browser");let{texture:n,device:s}=t;if(!n||!s)throw Error("Invalid WebGPU texture source: missing texture or device");try{let r=await Ni.textureToCanvas(n,s,e);return this.validateCanvasElement(r),r}catch(r){throw Error(`Failed to load WebGPU texture: ${r}`)}}async loadWithDetails(t,e){if(!this.canLoad(t))throw Error(`WebGPUTextureLoader cannot load source: ${t}`);if(!Ni.isSupported())throw Error("WebGPU is not supported in this browser");let{texture:n,device:s}=t;if(!n||!s)throw Error("Invalid WebGPU texture source: missing texture or device");let r=t.width||n.width,i=t.height||n.height,o=t.format||n.format||"rgba8unorm";try{let a=await Ni.textureToCanvas(n,s,e);this.validateCanvasElement(a);let l={canvas:a,device:s,metadata:{width:r,height:i,format:o,sourceType:"texture"}};return e!=null&&e.preserveWebGPUObject&&(l.webGPUObject=n),l}catch(a){throw Error(`Failed to load WebGPU texture: ${a}`)}}static createSource(t,e,n){return{type:"texture",texture:t,device:e,width:(n==null?void 0:n.width)||t.width,height:(n==null?void 0:n.height)||t.height,format:(n==null?void 0:n.format)||t.format}}static async createTextureFromCanvas(t,e,n){if(!e)throw Error("Invalid GPU device");let s=(n==null?void 0:n.format)||"rgba8unorm",r=(n==null?void 0:n.usage)||GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,i=t.getContext("2d");if(!i)throw Error("Failed to get 2D context from canvas");let o=i.getImageData(0,0,t.width,t.height),a;try{a=e.createTexture({size:[t.width,t.height,1],format:s,usage:r,label:"CanvasTexture"})}catch(u){throw Error(`Failed to create GPU texture: ${u}`)}if(!a)throw Error("Failed to create GPU texture");let l;try{l=e.createBuffer({size:o.data.length,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,label:"CanvasTextureBuffer"})}catch(u){throw a.destroy(),Error(`Failed to create GPU buffer: ${u}`)}if(!l)throw a.destroy(),Error("Failed to create GPU buffer");try{e.queue.writeBuffer(l,0,o.data);let u=e.createCommandEncoder();u.copyBufferToTexture({buffer:l,bytesPerRow:t.width*4},{texture:a,mipLevel:0},[t.width,t.height,1]),e.queue.submit([u.finish()])}catch(u){throw l.destroy(),a.destroy(),Error(`Failed to create texture from canvas: ${u}`)}finally{l.destroy()}return a}},iFe=class extends ql{constructor(...t){super(...t),this.name="WebGPUBufferLoader"}canLoad(t){return T4(t)}async load(t,e){if(!this.canLoad(t))throw Error(`WebGPUBufferLoader cannot load source: ${t}`);if(!Ni.isSupported())throw Error("WebGPU is not supported in this browser");let{buffer:n,device:s,width:r,height:i,format:o}=t;if(!n||!s)throw Error("Invalid WebGPU buffer source: missing buffer or device");if(!r||!i)throw Error("Invalid WebGPU buffer source: missing width or height");try{let a=await Ni.bufferToCanvas(n,s,r,i,o,e);return this.validateCanvasElement(a),a}catch(a){throw Error(`Failed to load WebGPU buffer: ${a}`)}}async loadWithDetails(t,e){if(!this.canLoad(t))throw Error(`WebGPUBufferLoader cannot load source: ${t}`);if(!Ni.isSupported())throw Error("WebGPU is not supported in this browser");let{buffer:n,device:s,width:r,height:i,format:o}=t;if(!n||!s)throw Error("Invalid WebGPU buffer source: missing buffer or device");if(!r||!i)throw Error("Invalid WebGPU buffer source: missing width or height");try{let a=await Ni.bufferToCanvas(n,s,r,i,o,e);this.validateCanvasElement(a);let l={canvas:a,device:s,metadata:{width:r,height:i,format:o,sourceType:"buffer"}};return e!=null&&e.preserveWebGPUObject&&(l.webGPUObject=n),l}catch(a){throw Error(`Failed to load WebGPU buffer: ${a}`)}}static createSource(t,e,n,s,r,i){let o=Ni.getFormatBytesPerPixel(r),a=Math.ceil(n*o/256)*256;return{type:"buffer",buffer:t,device:e,width:n,height:s,format:r,bytesPerRow:(i==null?void 0:i.bytesPerRow)||a,rowsPerImage:(i==null?void 0:i.rowsPerImage)||s}}static async createBufferFromCanvas(t,e,n="rgba8unorm",s){if(!e)throw Error("Invalid GPU device");let r=t.getContext("2d");if(!r)throw Error("Failed to get 2D context from canvas");let i=r.getImageData(0,0,t.width,t.height),o=GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.STORAGE,a=(s==null?void 0:s.usage)||o,l;try{l=e.createBuffer({size:i.data.length,usage:a,label:"CanvasBuffer"})}catch(u){throw Error(`Failed to create GPU buffer: ${u}`)}if(!l)throw Error("Failed to create GPU buffer");try{if(a&GPUBufferUsage.MAP_WRITE){await l.mapAsync(GPUMapMode.WRITE);let u=l.getMappedRange();new Uint8Array(u).set(i.data),l.unmap()}else e.queue.writeBuffer(l,0,i.data)}catch(u){throw l.destroy(),Error(`Failed to write data to buffer: ${u}`)}return l}static createBufferFromArrayBuffer(t,e,n=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC){let s=e.createBuffer({size:t.byteLength,usage:n});return e.queue.writeBuffer(s,0,t),s}static createBufferFromTypedArray(t,e,n=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC){let s=e.createBuffer({size:t.byteLength,usage:n});return e.queue.writeBuffer(s,0,t.buffer),s}static async createTextureFromBuffer(t,e,n,s,r,i){if(!(t.usage&GPUBufferUsage.COPY_SRC))throw Error("Buffer must have COPY_SRC usage flag for copyBufferToTexture operation");let o=Ni.getFormatBytesPerPixel(r),a=Math.ceil(n*o/256)*256,l=(i==null?void 0:i.bytesPerRow)||a,u=(i==null?void 0:i.usage)||GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,c=e.createTexture({size:[n,s,1],format:r,usage:u}),h=e.createCommandEncoder();return h.copyBufferToTexture({buffer:t,bytesPerRow:l},{texture:c,mipLevel:0},[n,s,1]),e.queue.submit([h.finish()]),c}},Qa,Ny,_i=(Qa=class{static getLoader(e){for(let n of this.loaders)if(n.canLoad(e))return n;return null}static async loadImage(e,n){let s=this.getLoader(e);if(!s)throw Error(`No suitable loader found for source: ${typeof e}`);try{return await s.load(e,n)}catch(r){throw Error(`Failed to load image with ${s.name}: ${r}`)}}static canLoad(e){return this.getLoader(e)!==null}static getAllLoaders(){return[...this.loaders]}static registerLoader(e,n=this.loaders.length){let s=this.loaders.findIndex(r=>r.name===e.name);s===-1?this.loaders.splice(n,0,e):this.loaders[s]=e}static removeLoader(e){let n=this.loaders.findIndex(s=>s.name===e);return n===-1?!1:(this.loaders.splice(n,1),!0)}static getSupportedTypes(){return["string (URL, Data URL, Blob URL)","HTMLImageElement","HTMLCanvasElement","File","Blob","ArrayBuffer","Uint8Array","Uint8ClampedArray","DataView","WebGPUTextureSource","WebGPUBufferSource"]}static isWebGPUSupported(){return"gpu"in navigator}static isWebGPUSource(e){return sFe(e)}},Ny=new WeakMap,Xw(Qa,Ny,Qa.loaders=[new nFe,new JOe,new eFe,new tFe,new rFe,new iFe,new QOe]),Qa),oFe=class{constructor(t,e){this.leftImg=null,this.rightImg=null,this.animationFrameId=null,this.listeners=new Map,this.boundHandlers={},this.isDragging=!1,this.mouseX=0,this.mouseY=0,this.isMouseOver=!1,this.scale=1,this.offsetX=0,this.offsetY=0,this.isPinching=!1,this.lastPinchDistance=0,this.sceneNeedsRedraw=!0,this.resizeObserver=null,this.pendingRender=!1,this.canvas=t;let n=t.getContext("2d");if(!n)throw Error("Could not get 2D context");this.ctx=n,this.offscreenCanvas=document.createElement("canvas");let s=this.offscreenCanvas.getContext("2d");if(!s)throw Error("Could not get offscreen 2D context");this.offscreenCtx=s,this.config=this.normalizeConfig(e),this.currentSplitPosition=this.config.splitPosition,this.canvas.width=this.config.width,this.canvas.height=this.config.height,this.offscreenCanvas.width=this.config.width,this.offscreenCanvas.height=this.config.height,this.initEvents(),this.loadImages()}normalizeConfig(t){return{leftImage:t.leftImage,rightImage:t.rightImage,width:t.width,height:t.height,splitPosition:t.splitPosition??.5,splitDirection:t.splitDirection??"vertical",magnifier:{enabled:!1,size:150,zoomLevel:2,followCursor:!0,...t.magnifier}}}update(t){let e=this.config.leftImage,n=this.config.rightImage,s=this.config.splitPosition;this.config=this.normalizeConfig({...this.config,...t}),s!==this.config.splitPosition&&(this.currentSplitPosition=this.config.splitPosition,this.sceneNeedsRedraw=!0),(this.canvas.width!==this.config.width||this.canvas.height!==this.config.height)&&(this.canvas.width=this.config.width,this.canvas.height=this.config.height),e!==this.config.leftImage||n!==this.config.rightImage?this.loadImages():this.sceneNeedsRedraw&&this.requestDebouncedRender()}async loadImages(){try{let t=async s=>{if(s&&typeof s=="object"&&"source"in s&&"width"in s&&"height"in s){let{source:r,width:i,height:o,mimeType:a}=s;return _i.loadImage(r,{width:i,height:o,mimeType:a})}return _i.loadImage(s)},[e,n]=await Promise.all([t(this.config.leftImage),t(this.config.rightImage)]);this.leftImg=e,this.rightImg=n,this.canvas.width=this.config.width,this.canvas.height=this.config.height,this.sceneNeedsRedraw=!0,this.requestDebouncedRender(),this.emit("image-load","all")}catch(t){console.error("Failed to load images",t),this.emit("image-load","error")}}initEvents(){let t=a=>{let l=this.canvas.getBoundingClientRect(),u="touches"in a&&a.touches&&a.touches[0]?a.touches[0].clientX:a.clientX,c="touches"in a&&a.touches&&a.touches[0]?a.touches[0].clientY:a.clientY;return{x:u-l.left,y:c-l.top}},e=a=>{let l=this.canvas.getBoundingClientRect(),u="touches"in a&&a.touches&&a.touches[0]?a.touches[0].clientX:a.clientX,c="touches"in a&&a.touches&&a.touches[0]?a.touches[0].clientY:a.clientY;return{x:u-l.left,y:c-l.top}},n=a=>Math.hypot(a.touches[0].clientX-a.touches[1].clientX,a.touches[0].clientY-a.touches[1].clientY),s=a=>{let l=this.canvas.getBoundingClientRect();return{x:(a.touches[0].clientX+a.touches[1].clientX)/2-l.left,y:(a.touches[0].clientY+a.touches[1].clientY)/2-l.top}},r=a=>{if(window.TouchEvent&&a instanceof TouchEvent&&a.touches.length===2){this.isPinching=!0,this.isDragging=!1,this.lastPinchDistance=n(a),a.preventDefault();return}let{x:l,y:u}=t(a);this.isDragging=!0,this.handleMove(l,u)},i=a=>{let{x:l,y:u}=t(a);this.mouseX=l,this.mouseY=u,this.isMouseOver=!0,this.emit("mouse-move",l,u),this.isDragging?this.handleMove(l,u):this.config.magnifier.enabled&&this.config.magnifier.followCursor&&(this.requestDebouncedRender(),this.emit("magnifier-move",l,u))},o=()=>{this.isDragging=!1,this.isPinching=!1};this.boundHandlers={mousedown:r,touchstart:r,windowMouseMove:a=>{if(this.isDragging){let{x:l,y:u}=e(a);this.mouseX=l,this.mouseY=u,this.isMouseOver=!1,this.emit("mouse-move",l,u),this.handleMove(l,u)}},windowTouchMove:a=>{if(this.isPinching&&a.touches.length===2){a.preventDefault();let l=n(a),u=s(a);if(this.lastPinchDistance>0){let c=l/this.lastPinchDistance,h=this.scale*c;if(h>=.01&&h<=1e3){let d=u.x,f=u.y,p=(d-this.offsetX)/this.scale,g=(f-this.offsetY)/this.scale;this.offsetX=d-p*h,this.offsetY=f-g*h,this.scale=h,this.sceneNeedsRedraw=!0,this.requestDebouncedRender()}}this.lastPinchDistance=l;return}if(this.isDragging){let{x:l,y:u}=e(a);this.mouseX=l,this.mouseY=u,this.isMouseOver=!1,this.handleMove(l,u)}},windowMouseUp:o,windowTouchEnd:o,canvasMouseMove:a=>{this.isDragging||i(a)},canvasTouchMove:a=>{this.isDragging||i(a)},canvasMouseLeave:()=>{this.isMouseOver=!1,this.isDragging=!1,this.requestDebouncedRender()},handleWheel:this.handleWheel.bind(this)},this.canvas.addEventListener("mousedown",this.boundHandlers.mousedown),this.canvas.addEventListener("touchstart",this.boundHandlers.touchstart,{passive:!1}),this.canvas.addEventListener("mousemove",this.boundHandlers.canvasMouseMove),this.canvas.addEventListener("touchmove",this.boundHandlers.canvasTouchMove,{passive:!1}),this.canvas.addEventListener("mouseleave",this.boundHandlers.canvasMouseLeave),window.addEventListener("mousemove",this.boundHandlers.windowMouseMove),window.addEventListener("touchmove",this.boundHandlers.windowTouchMove,{passive:!1}),window.addEventListener("mouseup",this.boundHandlers.windowMouseUp),window.addEventListener("touchend",this.boundHandlers.windowTouchEnd),this.canvas.addEventListener("wheel",this.boundHandlers.handleWheel,{passive:!1}),this.initResizeObserver()}initResizeObserver(){typeof ResizeObserver>"u"||(this.resizeObserver=new ResizeObserver(t=>{for(let e of t){let{width:n,height:s}=e.contentRect;(n!==this.config.width||s!==this.config.height)&&(this.config.width=n,this.config.height=s,this.canvas.width=n,this.canvas.height=s,this.sceneNeedsRedraw=!0,this.requestDebouncedRender())}}),this.resizeObserver.observe(this.canvas))}requestDebouncedRender(){this.pendingRender||(this.pendingRender=!0,requestAnimationFrame(()=>{this.render(),this.pendingRender=!1}))}handleWheel(t){t.preventDefault();let e=this.canvas.getBoundingClientRect(),n=t.clientX-e.left,s=t.clientY-e.top,r=.1,i=t.deltaY<0?1+r:1/(1+r),o=this.scale*i;if(o<.01||o>1e3)return;let a=(n-this.offsetX)/this.scale,l=(s-this.offsetY)/this.scale;this.offsetX=n-a*o,this.offsetY=s-l*o,this.scale=o,this.sceneNeedsRedraw=!0,this.requestDebouncedRender()}handleMove(t,e){this.config.splitDirection==="vertical"?this.currentSplitPosition=Math.max(0,Math.min(1,t/this.config.width)):this.currentSplitPosition=Math.max(0,Math.min(1,e/this.config.height)),this.sceneNeedsRedraw=!0,this.requestDebouncedRender(),this.emit("split-change",this.currentSplitPosition)}render(){!this.leftImg||!this.rightImg||((this.offscreenCanvas.width!==this.config.width||this.offscreenCanvas.height!==this.config.height)&&(this.offscreenCanvas.width=this.config.width,this.offscreenCanvas.height=this.config.height,this.sceneNeedsRedraw=!0),this.sceneNeedsRedraw&&(this.sceneNeedsRedraw=(this.offscreenCtx.clearRect(0,0,this.config.width,this.config.height),this.drawSceneToContext(this.offscreenCtx,this.scale,this.offsetX,this.offsetY),!1)),this.ctx.clearRect(0,0,this.config.width,this.config.height),this.ctx.drawImage(this.offscreenCanvas,0,0),this.config.magnifier.enabled&&this.isMouseOver&&this.drawMagnifier())}drawSceneToContext(t,e,n,s){let r=this.config.width,i=this.config.height,o=this.config.splitDirection==="vertical"?r*this.currentSplitPosition:i*this.currentSplitPosition;this.drawTiledImageToContext(t,this.leftImg,r,i,e,n,s),t.save(),t.beginPath(),this.config.splitDirection==="vertical"?t.rect(o,0,r-o,i):t.rect(0,o,r,i-o),t.clip(),this.drawTiledImageToContext(t,this.rightImg,r,i,e,n,s),t.restore(),t.beginPath(),t.strokeStyle="#fff",t.lineWidth=2,this.config.splitDirection==="vertical"?(t.moveTo(o,0),t.lineTo(o,i)):(t.moveTo(0,o),t.lineTo(r,o)),t.stroke()}drawTiledImageToContext(t,e,n,s,r,i,o){let a=(0-i)/r,l=(0-o)/r,u=(n-i)/r,c=(s-o)/r,h=e.width,d=e.height;if(r<.5){let x=t.createPattern(e,"repeat");if(!x)return;t.save(),t.translate(i,o),t.scale(r,r),t.fillStyle=x;let b=a,v=l,y=u-a,C=c-l;t.fillRect(b,v,y,C),t.restore();return}let f=Math.floor(a/h),p=Math.floor(u/h),g=Math.floor(l/d),m=Math.floor(c/d);for(let x=f;x<=p;x++)for(let b=g;b<=m;b++){let v=x*h*r+i,y=b*d*r+o,C=h*r,I=d*r;v+C<0||v>n||y+I<0||y>s||t.drawImage(e,v,y,C,I)}}drawMagnifier(){let{size:t,zoomLevel:e}=this.config.magnifier,n=t/2,s=this.mouseX,r=this.mouseY;this.ctx.save(),this.ctx.beginPath(),this.ctx.arc(s,r,n,0,Math.PI*2),this.ctx.clip(),this.ctx.fillStyle="#fff",this.ctx.fill();let i=t/e,o=s-i/2,a=r-i/2;this.ctx.drawImage(this.offscreenCanvas,o,a,i,i,s-n,r-n,t,t),this.ctx.restore(),this.ctx.beginPath(),this.ctx.arc(s,r,n,0,Math.PI*2),this.ctx.strokeStyle="rgba(255, 255, 255, 0.8)",this.ctx.lineWidth=3,this.ctx.stroke(),this.ctx.shadowColor="rgba(0,0,0,0.3)",this.ctx.shadowBlur=10,this.ctx.stroke()}on(t,e){this.listeners.has(t)||this.listeners.set(t,new Set),this.listeners.get(t).add(e)}off(t,e){var n;(n=this.listeners.get(t))==null||n.delete(e)}setSplitPosition(t){let e=Math.max(0,Math.min(1,t));this.currentSplitPosition!==e&&(this.currentSplitPosition=e,this.sceneNeedsRedraw=!0,this.requestDebouncedRender(),this.emit("split-change",this.currentSplitPosition))}getSplitPosition(){return this.currentSplitPosition}setMagnifierPosition(t,e){this.mouseX=Math.max(0,Math.min(this.config.width,t)),this.mouseY=Math.max(0,Math.min(this.config.height,e)),this.config.magnifier.enabled&&(this.isMouseOver=!0,this.requestDebouncedRender(),this.emit("magnifier-move",this.mouseX,this.mouseY))}getMagnifierPosition(){return{x:this.mouseX,y:this.mouseY}}setZoom(t,e,n){let s=Math.max(.01,Math.min(1e3,t)),r=e===void 0?this.config.width/2:e,i=n===void 0?this.config.height/2:n,o=(r-this.offsetX)/this.scale,a=(i-this.offsetY)/this.scale;this.offsetX=r-o*s,this.offsetY=i-a*s,this.scale=s,this.sceneNeedsRedraw=!0,this.requestDebouncedRender()}getZoom(){return this.scale}setOffset(t,e){this.offsetX=t,this.offsetY=e,this.sceneNeedsRedraw=!0,this.requestDebouncedRender()}getOffset(){return{x:this.offsetX,y:this.offsetY}}resetZoom(){this.scale=1,this.offsetX=0,this.offsetY=0,this.sceneNeedsRedraw=!0,this.requestDebouncedRender()}emit(t,...e){var n;(n=this.listeners.get(t))==null||n.forEach(s=>s(...e))}destroy(){this.boundHandlers.mousedown&&this.canvas.removeEventListener("mousedown",this.boundHandlers.mousedown),this.boundHandlers.touchstart&&this.canvas.removeEventListener("touchstart",this.boundHandlers.touchstart),this.boundHandlers.canvasMouseMove&&this.canvas.removeEventListener("mousemove",this.boundHandlers.canvasMouseMove),this.boundHandlers.canvasTouchMove&&this.canvas.removeEventListener("touchmove",this.boundHandlers.canvasTouchMove),this.boundHandlers.canvasMouseLeave&&this.canvas.removeEventListener("mouseleave",this.boundHandlers.canvasMouseLeave),this.boundHandlers.handleWheel&&this.canvas.removeEventListener("wheel",this.boundHandlers.handleWheel),this.boundHandlers.windowMouseMove&&window.removeEventListener("mousemove",this.boundHandlers.windowMouseMove),this.boundHandlers.windowTouchMove&&window.removeEventListener("touchmove",this.boundHandlers.windowTouchMove),this.boundHandlers.windowMouseUp&&window.removeEventListener("mouseup",this.boundHandlers.windowMouseUp),this.boundHandlers.windowTouchEnd&&window.removeEventListener("touchend",this.boundHandlers.windowTouchEnd),this.resizeObserver&&(this.resizeObserver=(this.resizeObserver.disconnect(),null)),this.listeners.clear(),this.leftImg=null,this.rightImg=null,this.animationFrameId!==null&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=null),this.pendingRender=!1}},aFe=((t,e)=>{let n=t.__vccOpts||t;for(let[s,r]of e)n[s]=r;return n})(We({__name:"SplitViewer",props:{leftImage:{},rightImage:{},width:{},height:{},splitPosition:{default:.5},splitDirection:{default:"vertical"},magnifier:{default:()=>({enabled:!1,size:150,zoomLevel:2,followCursor:!0})}},emits:["split-change","magnifier-move","image-load","mouse-move","webgpu-error"],setup(t,{expose:e,emit:n}){let s=t,r=n,i=ce(null),o=null,a=()=>{if(!i.value)return;let l=c=>_i.isWebGPUSource(c)&&!_i.isWebGPUSupported()?(r("webgpu-error","WebGPU is not supported in this browser"),!1):!0;if(!l(s.leftImage)||!l(s.rightImage))return;let u={leftImage:Dt(s.leftImage),rightImage:Dt(s.rightImage),width:s.width,height:s.height,splitPosition:s.splitPosition,splitDirection:s.splitDirection,magnifier:Dt(s.magnifier)};try{o=new oFe(i.value,u),o.on("split-change",c=>r("split-change",c)),o.on("magnifier-move",(c,h)=>r("magnifier-move",c,h)),o.on("image-load",c=>r("image-load",c)),o.on("mouse-move",(c,h)=>r("mouse-move",c,h))}catch(c){throw(_i.isWebGPUSource(s.leftImage)||_i.isWebGPUSource(s.rightImage))&&r("webgpu-error",`Failed to initialize WebGPU viewer: ${c}`),c}};return _t(()=>s,l=>{if(o){let u=c=>_i.isWebGPUSource(c)&&!_i.isWebGPUSupported()?(r("webgpu-error","WebGPU is not supported in this browser"),!1):!0;if(!u(l.leftImage)||!u(l.rightImage))return;try{o.update({leftImage:Dt(l.leftImage),rightImage:Dt(l.rightImage),width:l.width,height:l.height,splitPosition:l.splitPosition,splitDirection:l.splitDirection,magnifier:Dt(l.magnifier)})}catch(c){throw(_i.isWebGPUSource(l.leftImage)||_i.isWebGPUSource(l.rightImage))&&r("webgpu-error",`Failed to update WebGPU viewer: ${c}`),c}}},{deep:!0}),kr(()=>{a()}),fa(()=>{o&&(o=(o.destroy(),null))}),e({setSplitPosition:l=>{o&&o.setSplitPosition(l)},getSplitPosition:()=>o?o.getSplitPosition():0,setMagnifierPosition:(l,u)=>{o&&o.setMagnifierPosition(l,u)},getMagnifierPosition:()=>o?o.getMagnifierPosition():{x:0,y:0},setZoom:(l,u,c)=>{o&&o.setZoom(l,u,c)},getZoom:()=>o?o.getZoom():1,setOffset:(l,u)=>{o&&o.setOffset(l,u)},getOffset:()=>o?o.getOffset():{x:0,y:0},resetZoom:()=>{o&&o.resetZoom()}}),(l,u)=>(F(),V("div",{class:"split-viewer-container",style:bn({width:t.width+"px",height:t.height+"px"})},[k("canvas",{ref_key:"canvasRef",ref:i},null,512)],4))}}),[["__scopeId","data-v-25f93978"]]);const lFe={key:0,class:"preview-overlay w-full h-full relative"},uFe={key:1,class:"w-full h-full relative"},cFe={key:2,class:"absolute inset-0 z-10 flex-col-center bg-black/50 backdrop-blur-sm text-white"},hFe={key:3,class:"absolute top-4 left-4 right-4 z-20 p-4 bg-red-500/20 border border-red-500/40 rounded-xl backdrop-blur-md text-red-200 flex items-center gap-3 animate-fade-in"},dFe={key:4,class:"flex-col-center text-white/30 gap-4"},I4=We({__name:"Viewer",props:{originalImage:{},processedImage:{},splitPosition:{},magnifierEnabled:{type:Boolean},isProcessing:{type:Boolean},errorMessage:{},zoomLevel:{},previewOverlay:{}},emits:["update:splitPosition","image-load","clear-overlay"],setup(t,{expose:e,emit:n}){const s=t,r=n,i=ce(),o=ce(null),a=ce(0),l=ce(0);let u=null,c=null;const h=ye(()=>({enabled:s.magnifierEnabled,size:150,zoomLevel:2,followCursor:!0})),d=ce("viewer-initial"),f=ce(!1);_t([a,l],([C,I])=>{!f.value&&C>0&&I>0&&(d.value=`viewer-${C}-${I}`,f.value=!0)});const p=C=>{r("update:splitPosition",C)},g=async C=>{if(console.log("Image loaded:",C),C==="all"||C==="left"){if(await tl(),o.value){const I=o.value.querySelector("canvas");I&&(I.width===300||I.height===150)&&(console.log("Fixing canvas size manually",a.value,l.value),I.width=a.value,I.height=l.value)}i.value&&(typeof i.value.resetZoom=="function"&&i.value.resetZoom(),setTimeout(()=>{i.value&&i.value.setZoom(s.zoomLevel)},50))}},m=async()=>{await tl(),i.value&&i.value.setZoom(s.zoomLevel)},x=async()=>{await tl(),i.value&&i.value.resetZoom()},b=()=>{r("clear-overlay")},v=()=>{s.originalImage&&eE(s.originalImage)},y=()=>{s.processedImage&&tE(s.processedImage)};return _t(()=>s.zoomLevel,m),kr(()=>{if(o.value){const C=o.value.getBoundingClientRect();C.width>0&&C.height>0&&(a.value=C.width,l.value=C.height);const I=50;u=new ResizeObserver($=>{for(const T of $){const{width:S,height:E}=T.contentRect;S>0&&E>0&&(c&&clearTimeout(c),c=window.setTimeout(()=>{a.value=S,l.value=E,i.value&&typeof i.value.resetZoom=="function"&&i.value.resetZoom()},I))}}),u.observe(o.value)}}),fa(()=>{u&&u.disconnect(),c&&(clearTimeout(c),c=null)}),e({resetZoom:x}),(C,I)=>(F(),V("div",{ref_key:"containerRef",ref:o,class:"relative w-full h-full flex-center bg-darkglass-100"},[t.previewOverlay?(F(),V("div",lFe,[(F(),st(Lm(t.previewOverlay.component),UM(Tk(t.previewOverlay.data)),null,16)),k("button",{onClick:b,class:"exit-overlay-btn absolute top-4 right-4 z-30 glass-btn p-3 rounded-full bg-black/50 hover:bg-black/70 text-white/80 hover:text-white transition-colors flex items-center gap-2"},[...I[0]||(I[0]=[k("div",{class:"i-carbon-close text-lg"},null,-1),k("span",{class:"text-sm font-medium"},"",-1)])])])):t.originalImage&&a.value>0&&l.value>0?(F(),V("div",uFe,[t.originalImage?(F(),V("button",{key:0,onClick:v,class:"absolute top-4 left-4 z-20 glass-btn p-2 rounded-full bg-black/50 hover:bg-black/70 text-white/80 hover:text-white transition-colors",title:""},[...I[1]||(I[1]=[k("div",{class:"i-carbon-download text-lg"},null,-1)])])):Ue("",!0),t.processedImage?(F(),V("button",{key:1,onClick:y,class:"absolute top-4 right-4 z-20 glass-btn p-2 rounded-full bg-black/50 hover:bg-black/70 text-white/80 hover:text-white transition-colors",title:""},[...I[2]||(I[2]=[k("div",{class:"i-carbon-download text-lg"},null,-1)])])):Ue("",!0),(F(),st(D(aFe),{ref_key:"splitViewerRef",ref:i,key:d.value,leftImage:t.originalImage,rightImage:t.processedImage||t.originalImage,width:a.value,height:l.value,splitPosition:t.splitPosition,magnifier:h.value,onSplitChange:p,onImageLoad:g,class:"w-full h-full"},null,8,["leftImage","rightImage","width","height","splitPosition","magnifier"]))])):Ue("",!0),t.isProcessing?(F(),V("div",cFe,[...I[3]||(I[3]=[k("div",{class:"i-carbon-circle-dash animate-spin text-4xl mb-4 text-blue-400"},null,-1),k("div",{class:"text-lg font-medium tracking-wide"},"Processing Image...",-1)])])):Ue("",!0),t.errorMessage?(F(),V("div",hFe,[I[4]||(I[4]=k("div",{class:"i-carbon-warning-filled text-xl text-red-400"},null,-1)),k("span",null,Le(t.errorMessage),1)])):Ue("",!0),!t.originalImage&&!t.isProcessing&&!t.previewOverlay?(F(),V("div",dFe,[...I[5]||(I[5]=[k("div",{class:"i-carbon-image text-6xl"},null,-1),k("div",{class:"text-lg"},"No Image Selected",-1)])])):Ue("",!0)],512))}});function fFe(t,e){const n=t.length,s=[];for(let i=0;i<n;i++)s.push([...t[i],e[i]]);for(let i=0;i<n;i++){let o=i;for(let l=i+1;l<n;l++)Math.abs(s[l][i])>Math.abs(s[o][i])&&(o=l);[s[i],s[o]]=[s[o],s[i]];const a=s[i][i];if(Math.abs(a)<1e-10)return new Array(n).fill(0);for(let l=i;l<=n;l++)s[i][l]/=a;for(let l=0;l<n;l++)if(i!==l){const u=s[l][i];for(let c=i;c<=n;c++)s[l][c]-=u*s[i][c]}}const r=[];for(let i=0;i<n;i++)r.push(s[i][n]);return r}function pFe(t,e){if(t.length!==4||e.length!==4)throw new Error("Need exactly 4 points for both source and destination");const n=[],s=[];for(let i=0;i<4;i++){const o=t[i],a=e[i];n.push([o.x,o.y,1,0,0,0,-o.x*a.x,-o.y*a.x]),s.push(a.x),n.push([0,0,0,o.x,o.y,1,-o.x*a.y,-o.y*a.y]),s.push(a.y)}return[...fFe(n,s),1]}function mFe(t,e,n,s){const i=pFe([{x:0,y:0},{x:n,y:0},{x:n,y:s},{x:0,y:s}],e),o=new ImageData(n,s),a=t.data,l=o.data,u=t.width,c=t.height;for(let h=0;h<s;h++)for(let d=0;d<n;d++){const f=i[6]*d+i[7]*h+i[8],p=(i[0]*d+i[1]*h+i[2])/f,g=(i[3]*d+i[4]*h+i[5])/f;if(p>=0&&p<u-1&&g>=0&&g<c-1){const m=Math.floor(p),x=Math.floor(g),b=m+1,v=x+1,y=p-m,C=g-x,I=(x*u+m)*4,$=(x*u+b)*4,T=(v*u+m)*4,S=(v*u+b)*4,E=(h*n+d)*4;for(let _=0;_<4;_++){const N=a[I+_],P=a[$+_],M=a[T+_],z=a[S+_],A=N*(1-y)+P*y,B=M*(1-y)+z*y;l[E+_]=A*(1-C)+B*C}}}return o}function $m(t){let e=0,n=0;return t.forEach(s=>{e+=s.x,n+=s.y}),{x:e/t.length,y:n/t.length}}function od(t,e,n){const s=t.x-e.x,r=t.y-e.y;return{x:e.x+s*Math.cos(n)-r*Math.sin(n),y:e.y+s*Math.sin(n)+r*Math.cos(n)}}function ir(t,e){return{x:t.x*Math.cos(e)-t.y*Math.sin(e),y:t.x*Math.sin(e)+t.y*Math.cos(e)}}function Cu(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function Bd(t,e){return{x:(t.x+e.x)/2,y:(t.y+e.y)/2}}function gFe(t){let e=1/0,n=-1/0,s=1/0,r=-1/0;return t.forEach(i=>{e=Math.min(e,i.x),n=Math.max(n,i.x),s=Math.min(s,i.y),r=Math.max(r,i.y)}),{minX:e,maxX:n,minY:s,maxY:r}}function xFe(t,e,n){if(t.length<4)return t;const s=$m(t),r=-n*Math.PI/180,i=t.map(b=>od(b,s,r)),{minX:o,maxX:a,minY:l,maxY:u}=gFe(i),c=a-o,h=u-l,d=c/h;let f=c,p=h;e>d?p=c/e:f=h*e;const g=(o+a)/2,m=(l+u)/2;return[{x:g-f/2,y:m-p/2},{x:g+f/2,y:m-p/2},{x:g+f/2,y:m+p/2},{x:g-f/2,y:m+p/2}].map(b=>od(b,s,-r))}function OT(t,e){const n=Math.sqrt(t*t+e*e)||1;return{nx:e/n,ny:-t/n}}function bFe(t){return t===0?{signX:-1,signY:-1}:t===1?{signX:1,signY:-1}:t===2?{signX:1,signY:1}:{signX:-1,signY:1}}const yFe=[{label:"Perspective",value:0},{label:"Free",value:-2},{label:"Original",value:-1},{label:"1:1",value:1},{label:"4:3",value:4/3},{label:"16:9",value:16/9},{label:"9:16",value:9/16}],FT=.2,UT=40;function vFe(t){const e=ce([]),n=yFe,s=ce(0),r=ce(0);let i=0;const o=()=>{if(!t.value)return;const h=t.value.width,d=t.value.height,f=h*FT,p=d*FT;e.value=[{x:f,y:p},{x:h-f,y:p},{x:h-f,y:d-p},{x:f,y:d-p}],s.value=0,r.value=0,i=0},a=h=>{s.value=h,h===-1&&t.value?l(t.value.width/t.value.height):h!==0&&h!==-2&&l(h)},l=h=>{e.value.length<4||(e.value=xFe(e.value,h,r.value))};return{points:e,ratios:n,currentRatio:s,rotation:r,resetPoints:o,setRatio:a,getLastRotation:()=>i,setLastRotation:h=>{i=h}}}function wFe(t){const{points:e,rotation:n,getLastRotation:s,setLastRotation:r}=t;return{handleRotationInput:()=>{const l=n.value-s();r(n.value);const u=$m(e.value),c=l*Math.PI/180;e.value=e.value.map(h=>od(h,u,c))},resetRotation:()=>{const l=0-n.value;n.value=0,r(0);const u=$m(e.value),c=l*Math.PI/180;e.value=e.value.map(h=>od(h,u,c))},handleRotatorDragMove:l=>{const u=l.target,c=$m(e.value),h=u.x(),d=u.y(),f=h-c.x,p=d-c.y;let m=Math.atan2(p,f)*180/Math.PI+90;for(;m>180;)m-=360;for(;m<-180;)m+=360;const x=m-n.value;n.value=Math.round(m),r(n.value);const b=x*Math.PI/180;e.value=e.value.map(v=>od(v,c,b))}}}function SFe(t){const{points:e,currentRatio:n,rotation:s,imageObj:r}=t,i=(h,d)=>{e.value[d]=h},o=(h,d)=>{const f=(d+2)%4,p=e.value[f],g=-s.value*Math.PI/180,m=ir(h,g),x=ir(p,g),b=m,v=x;let y,C;d%2===0?(y={x:v.x,y:b.y},C={x:b.x,y:v.y}):(y={x:b.x,y:v.y},C={x:v.x,y:b.y});const I=[...e.value];I[d]=ir(b,-g),I[(d+1)%4]=ir(y,-g),I[f]=ir(v,-g),I[(d+3)%4]=ir(C,-g),e.value=I},a=(h,d)=>{const f=(d+2)%4,p=e.value[f],g=-s.value*Math.PI/180,m=ir(h,g),x=ir(p,g);let b=Math.abs(m.x-x.x),v=Math.abs(m.y-x.y),y=n.value;y===-1&&r.value?y=r.value.width/r.value.height:y===-1&&(y=1);const{signX:C,signY:I}=bFe(d);b/v>y?v=b/y:b=v*y;const $={x:x.x+b*C,y:x.y+v*I},T=[...e.value],S=ir($,-g);T[d]=S,T[f]=p;let E,_;d%2===0?(E={x:x.x,y:$.y},_={x:$.x,y:x.y}):(E={x:$.x,y:x.y},_={x:x.x,y:$.y}),T[(d+1)%4]=ir(E,-g),T[(d+3)%4]=ir(_,-g),e.value=T},l=(h,d)=>{const f=h.target,p={x:f.x(),y:f.y()};n.value===0?i(p,d):n.value===-2?o(p,d):a(p,d)},u=ye(()=>e.value.length<4||n.value!==-2?[]:e.value.map((h,d)=>{const f=e.value[(d+1)%4],p=Bd(h,f);return{x:p.x,y:p.y,index:d}}));return{handlePointDragMove:l,midPoints:u,handleMidPointDragMove:(h,d)=>{if(n.value!==-2)return;const f=h.target,p={x:f.x(),y:f.y()},g=-s.value*Math.PI/180,m=ir(p,g),x=e.value.map(b=>ir(b,g));d===0?(x[0].y=m.y,x[1].y=m.y):d===2?(x[2].y=m.y,x[3].y=m.y):d===1?(x[1].x=m.x,x[2].x=m.x):d===3&&(x[3].x=m.x,x[0].x=m.x),e.value=x.map(b=>ir(b,-g))}}}function CFe(t){const{points:e}=t,n=ye(()=>{if(e.value.length<4)return{};const i=e.value;return{points:[i[0].x,i[0].y,i[1].x,i[1].y,i[2].x,i[2].y,i[3].x,i[3].y,i[0].x,i[0].y],stroke:"#00ff00",strokeWidth:2,closed:!0,listening:!1}}),s=ye(()=>{if(e.value.length<4)return{visible:!1};const i=e.value[0],o=e.value[1],a=Bd(i,o),l=o.x-i.x,u=o.y-i.y,{nx:c,ny:h}=OT(l,u),d=UT,f=a.x+c*d,p=a.y+h*d;return{points:[a.x,a.y,f,p],stroke:"white",strokeWidth:1,dash:[4,4],listening:!1}}),r=ye(()=>{if(e.value.length<4)return{visible:!1};const i=e.value[0],o=e.value[1],a=Bd(i,o),l=o.x-i.x,u=o.y-i.y,{nx:c,ny:h}=OT(l,u),d=UT,f=a.x+c*d,p=a.y+h*d;return{x:f,y:p,radius:8,fill:"white",stroke:"#000",strokeWidth:1,draggable:!0,hitStrokeWidth:20}});return{lineConfig:n,rotationLineConfig:s,rotationHandleConfig:r}}function TFe(t){const e=vFe(t),n=wFe({points:e.points,rotation:e.rotation,getLastRotation:e.getLastRotation,setLastRotation:e.setLastRotation}),s=SFe({points:e.points,currentRatio:e.currentRatio,rotation:e.rotation,imageObj:t}),r=CFe({points:e.points});return{points:e.points,ratios:e.ratios,currentRatio:e.currentRatio,rotation:e.rotation,midPoints:s.midPoints,resetPoints:e.resetPoints,setRatio:e.setRatio,handleRotationInput:n.handleRotationInput,resetRotation:n.resetRotation,handlePointDragMove:s.handlePointDragMove,handleRotatorDragMove:n.handleRotatorDragMove,handleMidPointDragMove:s.handleMidPointDragMove,lineConfig:r.lineConfig,rotationLineConfig:r.rotationLineConfig,rotationHandleConfig:r.rotationHandleConfig}}function IFe(){const t=ce(null),e=ce(null),n=ce(null),s=ce(!1),r=ce(null),i=ce({width:typeof window<"u"?window.innerWidth:800,height:typeof window<"u"?window.innerHeight:600,draggable:!0}),o=ce({x:0,y:0,scaleX:1,scaleY:1});return{containerRef:t,stageRef:e,contentGroupRef:n,isProcessing:s,imageObj:r,stageConfig:i,groupConfig:o}}function kFe(t,e,n,s,r){const i=ye(()=>{var u,c;return{image:t.value,width:(u=t.value)==null?void 0:u.width,height:(c=t.value)==null?void 0:c.height}}),o=ye(()=>{const u=n.value;return u.points?{...u,strokeWidth:2/e.value.scaleX}:u}),a=ye(()=>{const u=s.value;return u.visible===!1?u:{...u,strokeWidth:1/e.value.scaleX}}),l=ye(()=>{const u=r.value;return u.visible===!1?u:{...u,radius:8/e.value.scaleX,strokeWidth:1/e.value.scaleX,hitStrokeWidth:20/e.value.scaleX}});return{imageConfig:i,lineConfigWithScale:o,rotationLineConfigWithScale:a,rotationHandleConfigWithScale:l}}function EFe(t,e){let n=null,s=0;return{handleTouchStart:a=>{var c;const u=a.evt.touches;if(u.length===2){const h=(c=t.value)==null?void 0:c.getStage();h==null||h.stopDrag();const d={x:u[0].clientX,y:u[0].clientY},f={x:u[1].clientX,y:u[1].clientY};n=Bd(d,f),s=Cu(d,f)}},handleTouchMove:a=>{const l=a.evt,u=l.touches;if(u.length===2&&n){l.preventDefault();const c={x:u[0].clientX,y:u[0].clientY},h={x:u[1].clientX,y:u[1].clientY},d=Bd(c,h),f=Cu(c,h),p=e.value.scaleX,g=p*(f/s),m={x:(n.x-e.value.x)/p,y:(n.y-e.value.y)/p},x={x:d.x-m.x*g,y:d.y-m.y*g};e.value={...e.value,x:x.x,y:x.y,scaleX:g,scaleY:g},s=f,n=d}},handleTouchEnd:()=>{n=null,s=0}}}function _Fe(t,e,n,s){return{resetView:()=>{if(!n.value||!e.value)return;const o=n.value,a=e.value.clientWidth,l=e.value.clientHeight,u=a/o.width,c=l/o.height,h=Math.min(u,c)*.9;if(s.value={x:0,y:0,scaleX:1,scaleY:1},t.value){const d=t.value.getStage();d.scale({x:h,y:h}),d.position({x:(a-o.width*h)/2,y:(l-o.height*h)/2}),d.batchDraw()}},handleWheel:o=>{if(!t.value)return;const a=o.evt;a.preventDefault();const l=t.value.getStage(),u=l.scaleX(),c=l.getPointerPosition();if(!c)return;const h=1.1,d=a.deltaY>0?u/h:u*h,f={x:(c.x-l.x())/u,y:(c.y-l.y())/u},p={x:c.x-f.x*d,y:c.y-f.y*d};l.scale({x:d,y:d}),l.position(p),l.batchDraw()}}}function $Fe(t,e){const n=()=>{t.value&&(e.value.width=t.value.clientWidth,e.value.height=t.value.clientHeight)};let s=null;return kr(()=>{t.value&&(s=new ResizeObserver(()=>{n()}),s.observe(t.value),n())}),fa(()=>{s&&(s.disconnect(),s=null)}),{updateStageSize:n}}function RFe(t,e,n,s,r,i,o,a,l,u){const{imageConfig:c,lineConfigWithScale:h,rotationLineConfigWithScale:d,rotationHandleConfigWithScale:f}=kFe(n,s,i,o,a),{handleTouchStart:p,handleTouchMove:g,handleTouchEnd:m}=EFe(e,s),{resetView:x,handleWheel:b}=_Fe(e,t,n,s),{updateStageSize:v}=$Fe(t,r);return{updateStageSize:v,resetView:x,loadImage:E=>{const _=new Image;_.onload=()=>{n.value=_,x(),u()},_.src=E},handleWheel:b,handleTouchStart:p,handleTouchMove:g,handleTouchEnd:m,handleMouseEnter:E=>{E.target.getStage().container().style.cursor="pointer"},handleMouseLeave:E=>{E.target.getStage().container().style.cursor="default"},handleDragStart:()=>{},handleDragEnd:()=>{},imageConfig:c,lineConfigWithScale:h,rotationLineConfigWithScale:d,rotationHandleConfigWithScale:f,handlePointDragMoveWithScale:(E,_)=>{l(E,_,s.value.scaleX)}}}function AFe(t,e,n,s){return{confirm:async()=>{t.value&&(s.value=!0,setTimeout(()=>{try{const o=t.value,a=e.value,l=Cu(a[0],a[1]),u=Cu(a[3],a[2]),c=Cu(a[0],a[3]),h=Cu(a[1],a[2]),d=Math.round((l+u)/2),f=Math.round((c+h)/2),p=document.createElement("canvas");p.width=o.width,p.height=o.height;const g=p.getContext("2d");g.drawImage(o,0,0);const m=g.getImageData(0,0,o.width,o.height),x=mFe(m,e.value,d,f),b=document.createElement("canvas");b.width=d,b.height=f,b.getContext("2d").putImageData(x,0,0),n("confirm",b.toDataURL()),n("close")}catch(o){console.error(o),alert("Error processing image")}finally{s.value=!1}},10))},cancel:()=>{n("close")}}}function PFe(t,e){const n=IFe(),s=TFe(n.imageObj),r=RFe(n.containerRef,n.stageRef,n.imageObj,n.groupConfig,n.stageConfig,s.lineConfig,s.rotationLineConfig,s.rotationHandleConfig,s.handlePointDragMove,s.resetPoints),i=AFe(n.imageObj,s.points,e,n.isProcessing);return _t(()=>t.visible,o=>{o&&tl(()=>{r.updateStageSize(),t.originalImage&&r.loadImage(t.originalImage)})}),_t(()=>t.originalImage,o=>{t.visible&&o&&r.loadImage(o)}),{...n,...s,...r,...i}}const DFe={key:0,class:"fixed inset-0 z-50 bg-black flex flex-col"},NFe={class:"absolute top-0 left-0 right-0 p-4 flex justify-between items-center bg-gradient-to-b from-black/80 to-transparent z-10 pointer-events-none"},MFe={class:"flex gap-2 pointer-events-auto"},LFe={key:0,class:"absolute inset-0 flex items-center justify-center bg-black/50 z-20"},OFe={class:"absolute bottom-8 left-1/2 -translate-x-1/2 bg-gray-900/90 backdrop-blur-md p-4 rounded-2xl border border-gray-700 shadow-2xl flex flex-col gap-4 w-[90%] max-w-lg z-40"},FFe={class:"flex items-center justify-between gap-4"},UFe={class:"flex gap-2 bg-gray-800 p-1 rounded-lg overflow-x-auto"},BFe=["onClick"],zFe={class:"flex items-center gap-4"},GFe={class:"flex items-center gap-2 min-w-[60px]"},VFe={class:"text-white text-xs font-mono"},k4=We({__name:"SamplingEditor",props:{visible:{type:Boolean},originalImage:{}},emits:["close","confirm"],setup(t,{emit:e}){const n=t,s=e,{isProcessing:r,containerRef:i,stageRef:o,contentGroupRef:a,stageConfig:l,groupConfig:u,points:c,ratios:h,currentRatio:d,rotation:f,midPoints:p,imageConfig:g,lineConfigWithScale:m,rotationLineConfigWithScale:x,rotationHandleConfigWithScale:b,resetPoints:v,resetView:y,setRatio:C,handleRotationInput:I,resetRotation:$,handlePointDragMoveWithScale:T,handleRotatorDragMove:S,handleMidPointDragMove:E,handleWheel:_,handleDragStart:N,handleDragEnd:P,handleTouchStart:M,handleTouchMove:z,handleTouchEnd:A,handleMouseEnter:B,handleMouseLeave:L,cancel:U,confirm:j}=PFe(n,s);return(Z,J)=>{const se=su("v-image"),fe=su("v-line"),he=su("v-circle"),ve=su("v-group"),Pe=su("v-layer"),Ee=su("v-stage");return t.visible?(F(),V("div",DFe,[k("div",NFe,[J[7]||(J[7]=k("div",{class:"pointer-events-auto"},[k("h2",{class:"text-white text-lg font-bold drop-shadow-md"},"Select Sampling Area"),k("p",{class:"text-gray-300 text-sm drop-shadow-md"},"Drag corners to define area. Scroll/Drag background to zoom/pan.")],-1)),k("div",MFe,[k("button",{onClick:J[0]||(J[0]=(...Se)=>D(y)&&D(y)(...Se)),class:"px-3 py-1.5 md:px-4 md:py-2 bg-gray-700/80 backdrop-blur-sm text-white rounded-lg hover:bg-gray-600 transition-colors text-sm md:text-base"},"Reset View"),k("button",{onClick:J[1]||(J[1]=(...Se)=>D(v)&&D(v)(...Se)),class:"px-3 py-1.5 md:px-4 md:py-2 bg-gray-700/80 backdrop-blur-sm text-white rounded-lg hover:bg-gray-600 transition-colors text-sm md:text-base"},"Reset Points"),k("button",{onClick:J[2]||(J[2]=(...Se)=>D(U)&&D(U)(...Se)),class:"px-3 py-1.5 md:px-4 md:py-2 bg-red-600/80 backdrop-blur-sm text-white rounded-lg hover:bg-red-500 transition-colors text-sm md:text-base"},"Cancel"),k("button",{onClick:J[3]||(J[3]=(...Se)=>D(j)&&D(j)(...Se)),class:"px-3 py-1.5 md:px-4 md:py-2 bg-green-600/80 backdrop-blur-sm text-white rounded-lg hover:bg-green-500 transition-colors text-sm md:text-base font-bold"},"Confirm")])]),k("div",{ref_key:"containerRef",ref:i,class:"w-full h-full bg-gray-900"},[we(Ee,{ref_key:"stageRef",ref:o,config:D(l),onWheel:D(_),onDragstart:D(N),onDragend:D(P),onTouchstart:D(M),onTouchmove:D(z),onTouchend:D(A)},{default:hr(()=>[we(Pe,null,{default:hr(()=>[we(ve,{ref_key:"contentGroupRef",ref:a,config:D(u)},{default:hr(()=>[we(se,{config:D(g)},null,8,["config"]),we(fe,{config:D(m)},null,8,["config"]),we(fe,{config:D(x)},null,8,["config"]),we(he,{config:D(b),onDragmove:D(S),onMouseenter:D(B),onMouseleave:D(L)},null,8,["config","onDragmove","onMouseenter","onMouseleave"]),(F(!0),V(Xe,null,rt(D(c),(Se,ze)=>(F(),st(he,{key:ze,config:{x:Se.x,y:Se.y,radius:10/D(u).scaleX,fill:"rgba(0, 255, 0, 0.5)",stroke:"white",strokeWidth:2/D(u).scaleX,draggable:!0,hitStrokeWidth:20/D(u).scaleX},onDragmove:ke=>D(T)(ke,ze),onMouseenter:D(B),onMouseleave:D(L)},null,8,["config","onDragmove","onMouseenter","onMouseleave"]))),128)),(F(!0),V(Xe,null,rt(D(p),(Se,ze)=>(F(),st(he,{key:"mid-"+ze,config:{x:Se.x,y:Se.y,radius:8/D(u).scaleX,fill:"rgba(255, 255, 0, 0.8)",stroke:"white",strokeWidth:2/D(u).scaleX,draggable:!0,hitStrokeWidth:20/D(u).scaleX},onDragmove:ke=>D(E)(ke,Se.index),onMouseenter:D(B),onMouseleave:D(L)},null,8,["config","onDragmove","onMouseenter","onMouseleave"]))),128))]),_:1},8,["config"])]),_:1})]),_:1},8,["config","onWheel","onDragstart","onDragend","onTouchstart","onTouchmove","onTouchend"])],512),D(r)?(F(),V("div",LFe,[...J[8]||(J[8]=[k("div",{class:"text-white text-xl font-bold animate-pulse"},"Processing...",-1)])])):Ue("",!0),k("div",OFe,[k("div",FFe,[J[9]||(J[9]=k("span",{class:"text-gray-400 text-xs uppercase font-bold tracking-wider"},"Ratio",-1)),k("div",UFe,[(F(!0),V(Xe,null,rt(D(h),Se=>(F(),V("button",{key:Se.label,onClick:ze=>D(C)(Se.value),class:Q(["px-3 py-1.5 rounded-md text-xs font-medium transition-all whitespace-nowrap",D(d)===Se.value?"bg-blue-600 text-white shadow-lg":"text-gray-400 hover:text-white hover:bg-gray-700"])},Le(Se.label),11,BFe))),128))])]),k("div",zFe,[J[11]||(J[11]=k("span",{class:"text-gray-400 text-xs uppercase font-bold tracking-wider w-10"},"Rot",-1)),vt(k("input",{type:"range",min:"-180",max:"180",step:"1","onUpdate:modelValue":J[4]||(J[4]=Se=>Yt(f)?f.value=Se:null),onInput:J[5]||(J[5]=(...Se)=>D(I)&&D(I)(...Se)),class:"flex-1 h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4 [&::-webkit-slider-thumb]:bg-blue-500 [&::-webkit-slider-thumb]:rounded-full hover:[&::-webkit-slider-thumb]:bg-blue-400 transition-all"},null,544),[[Lr,D(f),void 0,{number:!0}]]),k("div",GFe,[k("span",VFe,Le(D(f))+"",1),k("button",{onClick:J[6]||(J[6]=(...Se)=>D($)&&D($)(...Se)),class:"text-gray-500 hover:text-white transition-colors",title:"Reset Rotation"},[...J[10]||(J[10]=[k("svg",{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"12",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[k("path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74-2.74L3 12"})],-1)])])])])])])):Ue("",!0)}}});function WFe(t={}){const{initialMaxResolution:e=4096,initialBorderSize:n=0}=t,s=ce(null),r=ce(null),i=ce(null),o=ce(n),a=ce(e),l=ce(.5),u=ce(!1),c=ce(!1),h=ce(""),d=ce(),f=ce(1),p=ce(!0),g=ce(null);return{originalImage:s,rawOriginalImage:r,processedImage:i,borderSize:o,maxResolution:a,splitPosition:l,isProcessing:u,isSampling:c,errorMessage:h,viewerRef:d,zoomLevel:f,magnifierEnabled:p,previewOverlay:g}}const HFe={omega:.95,t0:.1,windowSize:15,topRatio:.1,adaptiveMode:!1,spatialAdaptiveMode:!1,adaptiveStrength:1,hazeWeight:.5,atmosphericWeight:.3,enableEnhancement:!1,saturationEnhancement:1.2,contrastEnhancement:1.1,brightnessEnhancement:1},KFe={sigma:8,epsilon:.04,radius:8,blockSize:16,detailStrength:2,enhancementStrength:1,macroEnhancement:0,contrastBoost:1.2},jFe={shadows:{brightness:0,contrast:0,saturation:0,red:0,green:0,blue:0},midtones:{brightness:0,contrast:0,saturation:0,red:0,green:0,blue:0},highlights:{brightness:0,contrast:0,saturation:0,red:0,green:0,blue:0},shadowEnd:.33,highlightStart:.66,softness:.1};function XFe(){const t=ce({hue:0,saturation:0,lightness:0}),e=ce([]),n=ce(1),s=ce({exposure:1,contrast:1,gamma:1}),r=ce({...HFe}),i=ce({...KFe}),o=ce({...jFe});return{globalHSL:t,hslLayers:e,exposureStrength:n,exposureManual:s,dehazeParams:r,clarityParams:i,luminanceParams:o}}function qFe(){const t=ce(!1),e=ce(1),n=ce(null),s=ce(null);return{lutEnabled:t,lutIntensity:e,lutFileName:n,lutFile:s,toggleLUT:()=>{t.value=!t.value},clearLUT:()=>{n.value=null,s.value=null},setLUTFile:l=>{s.value=l,n.value=l.name},setLUTIntensity:l=>{e.value=l}}}function YFe(t=!1){const e=ce(!1),n=ce(!1),s=ce(!1);return kr(()=>{e.value=Qy(),t&&(s.value=sF())}),{isMobile:e,cameraActive:n,supportsNativeCamera:s,toggleCameraWrapper:()=>{t&&p5(n.value,a=>{n.value=a})},handlePhotoCapturedWrapper:(a,l,u)=>{t&&f5(a,l,u)},handleCameraErrorWrapper:(a,l)=>{t&&l(a)}}}function ZFe(t,e){return{buildHSLLayers:()=>{const a=[],{hue:l,saturation:u,lightness:c}=t.value;return(l!==0||u!==0||c!==0)&&a.push({id:"global",type:"global",targetColor:"#000000",hue:l,saturation:u,lightness:c,precision:100,range:100}),a.push(...e.value),a},updateGlobalHSL:a=>{t.value={hue:a.hue,saturation:a.saturation,lightness:a.lightness}},addHSLLayer:a=>{e.value.push(a)},updateHSLLayer:(a,l)=>{const u=e.value.find(c=>c.id===a);u&&Object.assign(u,l)},removeHSLLayer:a=>{e.value=e.value.filter(l=>l.id!==a)}}}function QFe(t,e,n,s){_t([t,e],async([r,i])=>{if(!r){n.value=null;return}try{const o=await jj(r),a=RE(o,i);n.value=a.toDataURL()}catch(o){console.error(":",o),s==null||s("")}})}function JFe(t){const{rawOriginalImage:e,originalImage:n,processedImage:s,maxResolution:r,errorMessage:i,viewerRef:o,zoomLevel:a,isSampling:l}=t;return QFe(e,r,n,x=>{i.value=x}),{handleImageUploadWrapper:x=>{J5(x,b=>{e.value=b,s.value=null,i.value=""})},loadSampleImageWrapper:()=>{e.value="https://picsum.photos/seed/texture/512/512.jpg",s.value=null,i.value=""},handleSamplingConfirmWrapper:x=>{n.value=x,s.value=null},resetZoomWrapper:()=>{eU(()=>{a.value=1},o)},saveResultWrapper:()=>{US(s.value,tE)},saveOriginalWrapper:()=>{US(n.value,eE)},openSamplingEditor:()=>{l.value=!0},setImage:x=>{e.value=x,s.value=null,i.value=""}}}function e5e(t){const{state:e,adjustmentParams:n,lutControl:s,cameraSupport:r,hslAdjustment:i,imageHandling:o,maskGenerator:a,enableCamera:l,processImage:u,debouncedProcessImage:c,toggleMagnifierWrapper:h,setPreviewOverlay:d}=t;return x5({onLoadSampleImage:o.loadSampleImageWrapper,onToggleCamera:l?r.toggleCameraWrapper:void 0,onProcessImage:u,onToggleMagnifier:h,onResetZoom:o.resetZoomWrapper,onSaveResult:o.saveResultWrapper,onSaveOriginal:o.saveOriginalWrapper,onOpenSamplingEditor:o.openSamplingEditor,onImageUpload:o.handleImageUploadWrapper,onPhotoCaptured:l?f=>r.handlePhotoCapturedWrapper(f,p=>{e.rawOriginalImage.value=p,e.processedImage.value=null},p=>{e.errorMessage.value=p}):void 0,onCameraError:l?f=>r.handleCameraErrorWrapper(f,p=>{e.errorMessage.value=p}):void 0,onMaxResolution:f=>{e.maxResolution.value=f},onBorderSize:f=>{e.borderSize.value=f},onSplitPosition:f=>{e.splitPosition.value=f},onZoomLevel:f=>{e.zoomLevel.value=f},onToggleLUT:s.toggleLUT,onClearLUT:s.clearLUT,onLUTIntensity:f=>{s.setLUTIntensity(f),e.originalImage.value&&s.lutFile.value&&c()},onLUTFileChange:async f=>{try{s.setLUTFile(f)}catch(p){console.error("Failed to load LUT file:",p),e.errorMessage.value="Failed to load LUT file"}},onMaskUpdate:f=>{a.value=f,e.originalImage.value&&s.lutFile.value&&c()},onSetPreviewOverlay:(f,p)=>d(f,p),onGlobalHSLChange:f=>{i.updateGlobalHSL(f),e.originalImage.value&&c()},onAddHSLLayer:f=>{i.addHSLLayer(f),e.originalImage.value&&c()},onUpdateHSLLayer:(f,p)=>{i.updateHSLLayer(f,p),e.originalImage.value&&c()},onRemoveHSLLayer:f=>{i.removeHSLLayer(f),e.originalImage.value&&c()},onExposureStrength:f=>{n.exposureStrength.value=f,e.originalImage.value&&c()},onExposureManual:f=>{n.exposureManual.value=f,e.originalImage.value&&c()},onDehazeChange:f=>{n.dehazeParams.value=f,e.originalImage.value&&c()},onClarityAdjustment:f=>{n.clarityParams.value=f,e.originalImage.value&&c()},onLuminanceAdjustment:f=>{n.luminanceParams.value=f,e.originalImage.value&&c()},onSetImage:o.setImage})}function E4(t={}){const{enableCamera:e=!1}=t,n=WFe(t),s=XFe(),r=qFe(),i=YFe(e),o=ZFe(s.globalHSL,s.hslLayers),a=JFe({rawOriginalImage:n.rawOriginalImage,originalImage:n.originalImage,processedImage:n.processedImage,maxResolution:n.maxResolution,errorMessage:n.errorMessage,viewerRef:n.viewerRef,zoomLevel:n.zoomLevel,isSampling:n.isSampling}),l=ce(null),u=async()=>{if(n.originalImage.value)try{const m=l.value?await l.value()??void 0:void 0;n.processedImage.value=await LN({originalImage:n.originalImage.value,maxResolution:n.maxResolution.value,borderSize:n.borderSize.value,onProcessingStart:()=>{n.isProcessing.value=!0},onProcessingEnd:()=>{n.isProcessing.value=!1},onError:x=>{n.errorMessage.value=x},lutFile:r.lutFile.value,lutIntensity:r.lutIntensity.value,maskData:m,hslLayers:o.buildHSLLayers(),exposureStrength:s.exposureStrength.value,exposureManual:s.exposureManual.value,dehazeParams:s.dehazeParams.value,clarityParams:s.clarityParams.value,luminanceParams:s.luminanceParams.value})}catch(m){console.error(":",m)}};let c=null;const h=()=>{c&&clearTimeout(c),c=setTimeout(()=>u(),300)},d=()=>{n.magnifierEnabled.value=!n.magnifierEnabled.value},f=(m,x)=>{n.previewOverlay.value=!m||!x?null:{data:m,component:x}},p=()=>{n.previewOverlay.value=null},g=e5e({state:n,adjustmentParams:s,lutControl:r,cameraSupport:i,hslAdjustment:o,imageHandling:a,maskGenerator:l,enableCamera:e,processImage:u,debouncedProcessImage:h,toggleMagnifierWrapper:d,setPreviewOverlay:f});return{...n,...s,...r,maskGenerator:l,isMobile:i.isMobile,cameraActive:i.cameraActive,supportsNativeCamera:i.supportsNativeCamera,handleImageUploadWrapper:a.handleImageUploadWrapper,loadSampleImageWrapper:a.loadSampleImageWrapper,toggleCameraWrapper:i.toggleCameraWrapper,handlePhotoCapturedWrapper:m=>i.handlePhotoCapturedWrapper(m,x=>{n.rawOriginalImage.value=x,n.processedImage.value=null},x=>{n.errorMessage.value=x}),handleCameraErrorWrapper:m=>i.handleCameraErrorWrapper(m,x=>{n.errorMessage.value=x}),handleSamplingConfirmWrapper:a.handleSamplingConfirmWrapper,processImage:u,toggleMagnifierWrapper:d,resetZoomWrapper:a.resetZoomWrapper,saveResultWrapper:a.saveResultWrapper,saveOriginalWrapper:a.saveOriginalWrapper,openSamplingEditor:a.openSamplingEditor,handleControlEvent:g,setPreviewOverlay:f,clearPreviewOverlay:p}}const t5e={class:"mobile-container flex flex-col h-screen w-screen overflow-hidden bg-black"},n5e={class:"flex-1 relative overflow-hidden flex flex-col md:flex-row"},s5e={class:"z-20 m-4 mt-0 md:m-4 md:mr-0 md:w-96 h-[40vh] md:h-auto md:max-h-[calc(100vh-2rem)] flex flex-col order-2 md:order-1 pointer-events-none"},r5e={class:"flex-1 relative z-0 overflow-hidden m-4 mt-0 md:m-4 rounded-3xl shadow-inner bg-darkglass-200 order-1 md:order-2"},i5e=We({__name:"App",setup(t){const{originalImage:e,rawOriginalImage:n,processedImage:s,borderSize:r,maxResolution:i,splitPosition:o,isProcessing:a,isSampling:l,errorMessage:u,viewerRef:c,zoomLevel:h,magnifierEnabled:d,lutEnabled:f,lutIntensity:p,lutFileName:g,lutFile:m,handleSamplingConfirmWrapper:x,handleControlEvent:b,previewOverlay:v,globalHSL:y,hslLayers:C,exposureStrength:I,exposureManual:$,dehazeParams:T,clarityParams:S,luminanceParams:E,clearPreviewOverlay:_}=E4({enableCamera:!1,initialMaxResolution:4096,initialBorderSize:0});return(N,P)=>(F(),V("div",t5e,[k("main",n5e,[k("div",s5e,[we(ZOe,{"is-processing":D(a),"original-image":D(e),"processed-image":D(s),"max-resolution":D(i),"border-size":D(r),"split-position":D(o),"magnifier-enabled":D(d),"zoom-level":D(h),"lut-enabled":D(f),"lut-intensity":D(p),"lut-file-name":D(g),"lut-file":D(m),"global-hsl":D(y),"hsl-layers":D(C),"exposure-strength":D(I),"exposure-manual":D($),"dehaze-params":D(T),"clarity-params":D(S),"luminance-params":D(E),onControlEvent:D(b),class:"pointer-events-auto h-full"},null,8,["is-processing","original-image","processed-image","max-resolution","border-size","split-position","magnifier-enabled","zoom-level","lut-enabled","lut-intensity","lut-file-name","lut-file","global-hsl","hsl-layers","exposure-strength","exposure-manual","dehaze-params","clarity-params","luminance-params","onControlEvent"])]),k("div",r5e,[we(I4,{ref_key:"viewerRef",ref:c,"original-image":D(e),"processed-image":D(s),"split-position":D(o),"onUpdate:splitPosition":P[0]||(P[0]=M=>Yt(o)?o.value=M:null),"magnifier-enabled":D(d),"is-processing":D(a),"error-message":D(u),"zoom-level":D(h),"preview-overlay":D(v),onClearOverlay:D(_),class:"w-full h-full object-contain"},null,8,["original-image","processed-image","split-position","magnifier-enabled","is-processing","error-message","zoom-level","preview-overlay","onClearOverlay"])])]),we(D(k4),{visible:D(l),"original-image":D(n),onClose:P[1]||(P[1]=M=>l.value=!1),onConfirm:D(x)},null,8,["visible","original-image","onConfirm"]),P[2]||(P[2]=k("div",{class:"fixed top-0 right-0 z-50 opacity-50 hover:opacity-100 pointer-events-none"},null,-1))]))}}),_4=t=>typeof t=="boolean",o5e=t=>t===null||typeof t=="string",a5e=t=>Array.isArray(t),l5e=t=>{const e=t.isMobile;return e===void 0?hK.IS_MOBILE:_4(e)?e:!1},u5e=t=>{const e=t.isProcessing;return _4(e)?e:!1},c5e=t=>{const e=t.originalImage;return o5e(e)?e:null},h5e=t=>{const e=t.inputSliderItems;return a5e(e)?e:[]},d5e=t=>nv(SE,{debug:{enableLogging:!1,enablePerformance:!1,enableTypeChecking:!0},propsInterceptor:{intercept:()=>({isMobile:l5e(t.props),isProcessing:u5e(t.props),originalImage:c5e(t.props),inputSliderItems:h5e(t.props)}),validate:e=>typeof e.isProcessing!==eC.BOOLEAN?Eb.IS_PROCESSING_BOOLEAN:e.originalImage!==null&&typeof e.originalImage!==eC.STRING?Eb.ORIGINAL_IMAGE_STRING_OR_NULL:Array.isArray(e.inputSliderItems)?!0:Eb.INPUT_SLIDER_ITEMS_ARRAY},emitInterceptor:{intercept:(e,...n)=>{const s=t.emits[e];return s?(s(...n),!1):!0}}}),f5e={class:"flex flex-row h-full gap-4"},p5e={class:"bg-black/60 flex flex-col items-center py-4 gap-3 backdrop-blur-xl rounded-2xl shrink-0 shadow-2xl glass-panel border-r-black/90"},m5e=["onClick"],g5e={class:"absolute left-full ml-4 px-3 py-1.5 bg-black/90 border border-white/10 text-white text-xs font-medium rounded-lg opacity-0 -translate-x-2 group-hover:opacity-100 group-hover:translate-x-0 transition-all duration-300 whitespace-nowrap pointer-events-none z-50 shadow-xl backdrop-blur-md"},x5e={class:"flex-1 bg-black/60 backdrop-blur-xl border border-white/10 rounded-2xl shadow-2xl overflow-hidden flex flex-col min-w-0"},b5e={class:"flex-1 overflow-y-auto scrollbar-hide p-6"},y5e=We({__name:"DesktopControls",props:{isProcessing:{type:Boolean},originalImage:{},processedImage:{},maxResolution:{},borderSize:{},splitPosition:{},magnifierEnabled:{type:Boolean},zoomLevel:{},lutEnabled:{type:Boolean},lutIntensity:{},lutFileName:{},lutFile:{},globalHSL:{},hslLayers:{},exposureStrength:{},exposureManual:{},dehazeParams:{},clarityParams:{},luminanceParams:{}},emits:["controlEvent"],setup(t,{emit:e}){const n=t,s=e,{activeGroup:r,groups:i,settingsSliderItems:o,viewSliderItems:a,handleImageUpload:l,loadSampleImage:u,handleSliderUpdate:c,processImage:h,toggleMagnifier:d,resetZoom:f,openSamplingEditor:p,saveOriginal:g,saveResult:m,toggleLUT:x,handleLUTFileChange:b,clearLUT:v,handleMaskUpdate:y,setImage:C,handleControlEvent:I}=Pk(n,s),$=d5e({props:{isProcessing:n.isProcessing,originalImage:n.originalImage,inputSliderItems:n.inputSliderItems},emits:{"load-sample":u,"image-upload":l,"slider-update":c,"set-image":C}});return(T,S)=>(F(),V("div",f5e,[k("div",p5e,[(F(!0),V(Xe,null,rt(D(i),E=>(F(),V("button",{key:E.id,onClick:_=>r.value=E.id,class:Q(["glass-btn bg-black/30 relative group w-12 h-12 flex items-center justify-center rounded-xxl transition-all duration-300",D(r)===E.id?"text-blue shadow-[0_0_15px_rgba(255,255,255,0.3)]":"text-white/50 hover:text-white hover:bg-lightBlue/10"])},[k("div",{class:Q([E.icon,"text-2xl transition-transform duration-300",D(r)===E.id?"scale-110":"group-hover:scale-110"])},null,2),k("div",g5e,[Tn(Le(E.label)+" ",1),S[0]||(S[0]=k("div",{class:"absolute right-full top-1/2 -translate-y-1/2 border-4 border-transparent border-r-black/90"},null,-1))])],10,m5e))),128))]),k("div",x5e,[k("div",b5e,[D(r)==="contact"?(F(),st(Mk,{key:0})):Ue("",!0),D(r)==="inputs"?(F(),st(Lm(D($)),{key:1})):Ue("",!0),D(r)==="crop"?(F(),st(CE,{key:2,"original-image":t.originalImage,onOpenSamplingEditor:D(p)},null,8,["original-image","onOpenSamplingEditor"])):D(r)==="lut"?(F(),st(a4,{key:3,"original-image":t.originalImage,"processed-image":t.processedImage,"lut-enabled":t.lutEnabled,"lut-intensity":t.lutIntensity,"lut-file-name":t.lutFileName,"lut-file":t.lutFile,onToggleLut:D(x),onLutFileChange:D(b),onClearLut:D(v),onSliderUpdate:D(c),onMaskUpdate:D(y),onControlEvent:D(I)},null,8,["original-image","processed-image","lut-enabled","lut-intensity","lut-file-name","lut-file","onToggleLut","onLutFileChange","onClearLut","onSliderUpdate","onMaskUpdate","onControlEvent"])):D(r)==="hsl"?(F(),st(c4,{key:4,"original-image":t.originalImage,"processed-image":t.processedImage,"global-hsl":t.globalHSL,"hsl-layers":t.hslLayers,onControlEvent:D(I)},null,8,["original-image","processed-image","global-hsl","hsl-layers","onControlEvent"])):D(r)==="exposure"?(F(),st(h4,{key:5,"original-image":t.originalImage,"exposure-strength":t.exposureStrength,"exposure-manual":t.exposureManual,onControlEvent:D(I)},null,8,["original-image","exposure-strength","exposure-manual","onControlEvent"])):D(r)==="dehaze"?(F(),st(g4,{key:6,"original-image":t.originalImage,"dehaze-params":t.dehazeParams,onControlEvent:D(I)},null,8,["original-image","dehaze-params","onControlEvent"])):D(r)==="clarity"?(F(),st(b4,{key:7,"original-image":t.originalImage,onControlEvent:D(I)},null,8,["original-image","onControlEvent"])):D(r)==="luminance"?(F(),st(y4,{key:8,"original-image":t.originalImage,"luminance-params":t.luminanceParams,onControlEvent:D(I)},null,8,["original-image","luminance-params","onControlEvent"])):D(r)==="tileablesettings"?(F(),st(v4,{key:9,"is-processing":t.isProcessing,"original-image":t.originalImage,"settings-slider-items":D(o),onProcessImage:D(h),onSliderUpdate:D(c)},null,8,["is-processing","original-image","settings-slider-items","onProcessImage","onSliderUpdate"])):D(r)==="view"?(F(),st(w4,{key:10,"original-image":t.originalImage,"processed-image":t.processedImage,"magnifier-enabled":t.magnifierEnabled,"view-slider-items":D(a),onResetZoom:D(f),onToggleMagnifier:D(d),onSliderUpdate:D(c)},null,8,["original-image","processed-image","magnifier-enabled","view-slider-items","onResetZoom","onToggleMagnifier","onSliderUpdate"])):D(r)==="save"?(F(),st(S4,{key:11,"original-image":t.originalImage,"processed-image":t.processedImage,onSaveOriginal:D(g),onSaveResult:D(m)},null,8,["original-image","processed-image","onSaveOriginal","onSaveResult"])):Ue("",!0)])])]))}}),v5e={class:"w-screen h-screen bg-gradient-to-br from-gray-900 to-black text-white font-sans relative overflow-hidden flex flex-row"},w5e={class:"z-20 m-4 mr-0 w-96 min-w-96 overflow-y-auto scrollbar-hide"},S5e={class:"flex-1 relative z-0 overflow-hidden m-4 rounded-3xl shadow-inner bg-darkglass-200"},C5e=We({__name:"Desktop",setup(t){const{originalImage:e,rawOriginalImage:n,processedImage:s,borderSize:r,maxResolution:i,splitPosition:o,isProcessing:a,isSampling:l,errorMessage:u,viewerRef:c,zoomLevel:h,magnifierEnabled:d,lutEnabled:f,lutIntensity:p,lutFileName:g,lutFile:m,previewOverlay:x,globalHSL:b,hslLayers:v,exposureStrength:y,exposureManual:C,dehazeParams:I,clarityParams:$,luminanceParams:T,clearPreviewOverlay:S,handleSamplingConfirmWrapper:E,handleControlEvent:_}=E4({enableCamera:!0,initialMaxResolution:4096,initialBorderSize:0});return(N,P)=>(F(),V("div",v5e,[k("div",w5e,[we(y5e,{"is-processing":D(a),"original-image":D(e),"processed-image":D(s),"max-resolution":D(i),"border-size":D(r),"split-position":D(o),"magnifier-enabled":D(d),"zoom-level":D(h),"lut-enabled":D(f),"lut-intensity":D(p),"lut-file-name":D(g),"lut-file":D(m),"global-hsl":D(b),"hsl-layers":D(v),"exposure-strength":D(y),"exposure-manual":D(C),"dehaze-params":D(I),"clarity-params":D($),"luminance-params":D(T),onControlEvent:D(_)},null,8,["is-processing","original-image","processed-image","max-resolution","border-size","split-position","magnifier-enabled","zoom-level","lut-enabled","lut-intensity","lut-file-name","lut-file","global-hsl","hsl-layers","exposure-strength","exposure-manual","dehaze-params","clarity-params","luminance-params","onControlEvent"])]),k("div",S5e,[we(I4,{ref_key:"viewerRef",ref:c,"original-image":D(e),"processed-image":D(s),"split-position":D(o),"onUpdate:splitPosition":P[0]||(P[0]=M=>Yt(o)?o.value=M:null),"magnifier-enabled":D(d),"is-processing":D(a),"error-message":D(u),"zoom-level":D(h),"preview-overlay":D(x),onClearOverlay:D(S),class:"w-full h-full object-contain"},null,8,["original-image","processed-image","split-position","magnifier-enabled","is-processing","error-message","zoom-level","preview-overlay","onClearOverlay"])]),we(D(k4),{visible:D(l),"original-image":D(n),onClose:P[1]||(P[1]=M=>l.value=!1),onConfirm:D(E)},null,8,["visible","original-image","onConfirm"])]))}}),T5e=Math.PI/180;function I5e(){return typeof window<"u"&&({}.toString.call(window)==="[object Window]"||{}.toString.call(window)==="[object global]")}const Za=typeof global<"u"?global:typeof window<"u"?window:typeof WorkerGlobalScope<"u"?self:{},He={_global:Za,version:"10.0.12",isBrowser:I5e(),isUnminified:/param/.test((function(t){}).toString()),dblClickWindow:400,getAngle(t){return He.angleDeg?t*T5e:t},enableTrace:!1,pointerEventsEnabled:!0,autoDrawEnabled:!0,hitOnDragEnabled:!1,capturePointerEventsEnabled:!1,_mouseListenClick:!1,_touchListenClick:!1,_pointerListenClick:!1,_mouseInDblClickWindow:!1,_touchInDblClickWindow:!1,_pointerInDblClickWindow:!1,_mouseDblClickPointerId:null,_touchDblClickPointerId:null,_pointerDblClickPointerId:null,_renderBackend:"web",legacyTextRendering:!1,pixelRatio:typeof window<"u"&&window.devicePixelRatio||1,dragDistance:3,angleDeg:!0,showWarnings:!0,dragButtons:[0,1],isDragging(){return He.DD.isDragging},isTransforming(){var t,e;return(e=(t=He.Transformer)===null||t===void 0?void 0:t.isTransforming())!==null&&e!==void 0?e:!1},isDragReady(){return!!He.DD.node},releaseCanvasOnDestroy:!0,document:Za.document,_injectGlobal(t){typeof Za.Konva<"u"&&console.error("Several Konva instances detected. It is not recommended to use multiple Konva instances in the same environment."),Za.Konva=t}},Rn=t=>{He[t.prototype.getClassName()]=t};He._injectGlobal(He);const k5e=`Konva.js unsupported environment.

Looks like you are trying to use Konva.js in Node.js environment. because "document" object is undefined.

To use Konva.js in Node.js environment, you need to use the "canvas-backend" or "skia-backend" module.

bash: npm install canvas
js: import "konva/canvas-backend";

or

bash: npm install skia-canvas
js: import "konva/skia-backend";
`,BT=()=>{if(typeof document>"u")throw new Error(k5e)};class vr{constructor(e=[1,0,0,1,0,0]){this.dirty=!1,this.m=e&&e.slice()||[1,0,0,1,0,0]}reset(){this.m[0]=1,this.m[1]=0,this.m[2]=0,this.m[3]=1,this.m[4]=0,this.m[5]=0}copy(){return new vr(this.m)}copyInto(e){e.m[0]=this.m[0],e.m[1]=this.m[1],e.m[2]=this.m[2],e.m[3]=this.m[3],e.m[4]=this.m[4],e.m[5]=this.m[5]}point(e){const n=this.m;return{x:n[0]*e.x+n[2]*e.y+n[4],y:n[1]*e.x+n[3]*e.y+n[5]}}translate(e,n){return this.m[4]+=this.m[0]*e+this.m[2]*n,this.m[5]+=this.m[1]*e+this.m[3]*n,this}scale(e,n){return this.m[0]*=e,this.m[1]*=e,this.m[2]*=n,this.m[3]*=n,this}rotate(e){const n=Math.cos(e),s=Math.sin(e),r=this.m[0]*n+this.m[2]*s,i=this.m[1]*n+this.m[3]*s,o=this.m[0]*-s+this.m[2]*n,a=this.m[1]*-s+this.m[3]*n;return this.m[0]=r,this.m[1]=i,this.m[2]=o,this.m[3]=a,this}getTranslation(){return{x:this.m[4],y:this.m[5]}}skew(e,n){const s=this.m[0]+this.m[2]*n,r=this.m[1]+this.m[3]*n,i=this.m[2]+this.m[0]*e,o=this.m[3]+this.m[1]*e;return this.m[0]=s,this.m[1]=r,this.m[2]=i,this.m[3]=o,this}multiply(e){const n=this.m[0]*e.m[0]+this.m[2]*e.m[1],s=this.m[1]*e.m[0]+this.m[3]*e.m[1],r=this.m[0]*e.m[2]+this.m[2]*e.m[3],i=this.m[1]*e.m[2]+this.m[3]*e.m[3],o=this.m[0]*e.m[4]+this.m[2]*e.m[5]+this.m[4],a=this.m[1]*e.m[4]+this.m[3]*e.m[5]+this.m[5];return this.m[0]=n,this.m[1]=s,this.m[2]=r,this.m[3]=i,this.m[4]=o,this.m[5]=a,this}invert(){const e=1/(this.m[0]*this.m[3]-this.m[1]*this.m[2]),n=this.m[3]*e,s=-this.m[1]*e,r=-this.m[2]*e,i=this.m[0]*e,o=e*(this.m[2]*this.m[5]-this.m[3]*this.m[4]),a=e*(this.m[1]*this.m[4]-this.m[0]*this.m[5]);return this.m[0]=n,this.m[1]=s,this.m[2]=r,this.m[3]=i,this.m[4]=o,this.m[5]=a,this}getMatrix(){return this.m}decompose(){const e=this.m[0],n=this.m[1],s=this.m[2],r=this.m[3],i=this.m[4],o=this.m[5],a=e*r-n*s,l={x:i,y:o,rotation:0,scaleX:0,scaleY:0,skewX:0,skewY:0};if(e!=0||n!=0){const u=Math.sqrt(e*e+n*n);l.rotation=n>0?Math.acos(e/u):-Math.acos(e/u),l.scaleX=u,l.scaleY=a/u,l.skewX=(e*s+n*r)/a,l.skewY=0}else if(s!=0||r!=0){const u=Math.sqrt(s*s+r*r);l.rotation=Math.PI/2-(r>0?Math.acos(-s/u):-Math.acos(s/u)),l.scaleX=a/u,l.scaleY=u,l.skewX=0,l.skewY=(e*s+n*r)/a}return l.rotation=le._getRotation(l.rotation),l}}const E5e="[object Array]",_5e="[object Number]",$5e="[object String]",R5e="[object Boolean]",A5e=Math.PI/180,P5e=180/Math.PI,Ih="#",D5e="",N5e="0",M5e="Konva warning: ",zT="Konva error: ",L5e="rgb(",t1={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,132,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,255,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,203],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[119,128,144],slategrey:[119,128,144],snow:[255,255,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],transparent:[255,255,255,0],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,5]},O5e=/rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;let am=[],kh=null;const F5e=typeof requestAnimationFrame<"u"&&requestAnimationFrame||function(t){setTimeout(t,60)},le={_isElement(t){return!!(t&&t.nodeType==1)},_isFunction(t){return!!(t&&t.constructor&&t.call&&t.apply)},_isPlainObject(t){return!!t&&t.constructor===Object},_isArray(t){return Object.prototype.toString.call(t)===E5e},_isNumber(t){return Object.prototype.toString.call(t)===_5e&&!isNaN(t)&&isFinite(t)},_isString(t){return Object.prototype.toString.call(t)===$5e},_isBoolean(t){return Object.prototype.toString.call(t)===R5e},isObject(t){return t instanceof Object},isValidSelector(t){if(typeof t!="string")return!1;const e=t[0];return e==="#"||e==="."||e===e.toUpperCase()},_sign(t){return t===0||t>0?1:-1},requestAnimFrame(t){am.push(t),am.length===1&&F5e(function(){const e=am;am=[],e.forEach(function(n){n()})})},createCanvasElement(){BT();const t=document.createElement("canvas");try{t.style=t.style||{}}catch{}return t},createImageElement(){return BT(),document.createElement("img")},_isInDocument(t){for(;t=t.parentNode;)if(t==document)return!0;return!1},_urlToImage(t,e){const n=le.createImageElement();n.onload=function(){e(n)},n.src=t},_rgbToHex(t,e,n){return((1<<24)+(t<<16)+(e<<8)+n).toString(16).slice(1)},_hexToRgb(t){t=t.replace(Ih,D5e);const e=parseInt(t,16);return{r:e>>16&255,g:e>>8&255,b:e&255}},getRandomColor(){let t=(Math.random()*16777215<<0).toString(16);for(;t.length<6;)t=N5e+t;return Ih+t},isCanvasFarblingActive(){if(kh!==null)return kh;if(typeof document>"u")return kh=!1,!1;const t=this.createCanvasElement();t.width=10,t.height=10;const e=t.getContext("2d",{willReadFrequently:!0});e.clearRect(0,0,10,10),e.fillStyle="#282828",e.fillRect(0,0,10,10);const n=e.getImageData(0,0,10,10).data;let s=!1;for(let r=0;r<100;r++)if(n[r*4]!==40||n[r*4+1]!==40||n[r*4+2]!==40||n[r*4+3]!==255){s=!0;break}return kh=s,this.releaseCanvas(t),kh},getHitColor(){const t=this.getRandomColor();return this.isCanvasFarblingActive()?this.getSnappedHexColor(t):t},getHitColorKey(t,e,n){return this.isCanvasFarblingActive()&&(t=Math.round(t/5)*5,e=Math.round(e/5)*5,n=Math.round(n/5)*5),Ih+this._rgbToHex(t,e,n)},getSnappedHexColor(t){const e=this._hexToRgb(t);return Ih+this._rgbToHex(Math.round(e.r/5)*5,Math.round(e.g/5)*5,Math.round(e.b/5)*5)},getRGB(t){let e;return t in t1?(e=t1[t],{r:e[0],g:e[1],b:e[2]}):t[0]===Ih?this._hexToRgb(t.substring(1)):t.substr(0,4)===L5e?(e=O5e.exec(t.replace(/ /g,"")),{r:parseInt(e[1],10),g:parseInt(e[2],10),b:parseInt(e[3],10)}):{r:0,g:0,b:0}},colorToRGBA(t){return t=t||"black",le._namedColorToRBA(t)||le._hex3ColorToRGBA(t)||le._hex4ColorToRGBA(t)||le._hex6ColorToRGBA(t)||le._hex8ColorToRGBA(t)||le._rgbColorToRGBA(t)||le._rgbaColorToRGBA(t)||le._hslColorToRGBA(t)},_namedColorToRBA(t){const e=t1[t.toLowerCase()];return e?{r:e[0],g:e[1],b:e[2],a:1}:null},_rgbColorToRGBA(t){if(t.indexOf("rgb(")===0){t=t.match(/rgb\(([^)]+)\)/)[1];const e=t.split(/ *, */).map(Number);return{r:e[0],g:e[1],b:e[2],a:1}}},_rgbaColorToRGBA(t){if(t.indexOf("rgba(")===0){t=t.match(/rgba\(([^)]+)\)/)[1];const e=t.split(/ *, */).map((n,s)=>n.slice(-1)==="%"?s===3?parseInt(n)/100:parseInt(n)/100*255:Number(n));return{r:e[0],g:e[1],b:e[2],a:e[3]}}},_hex8ColorToRGBA(t){if(t[0]==="#"&&t.length===9)return{r:parseInt(t.slice(1,3),16),g:parseInt(t.slice(3,5),16),b:parseInt(t.slice(5,7),16),a:parseInt(t.slice(7,9),16)/255}},_hex6ColorToRGBA(t){if(t[0]==="#"&&t.length===7)return{r:parseInt(t.slice(1,3),16),g:parseInt(t.slice(3,5),16),b:parseInt(t.slice(5,7),16),a:1}},_hex4ColorToRGBA(t){if(t[0]==="#"&&t.length===5)return{r:parseInt(t[1]+t[1],16),g:parseInt(t[2]+t[2],16),b:parseInt(t[3]+t[3],16),a:parseInt(t[4]+t[4],16)/255}},_hex3ColorToRGBA(t){if(t[0]==="#"&&t.length===4)return{r:parseInt(t[1]+t[1],16),g:parseInt(t[2]+t[2],16),b:parseInt(t[3]+t[3],16),a:1}},_hslColorToRGBA(t){if(/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(t)){const[e,...n]=/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(t),s=Number(n[0])/360,r=Number(n[1])/100,i=Number(n[2])/100;let o,a,l;if(r===0)return l=i*255,{r:Math.round(l),g:Math.round(l),b:Math.round(l),a:1};i<.5?o=i*(1+r):o=i+r-i*r;const u=2*i-o,c=[0,0,0];for(let h=0;h<3;h++)a=s+1/3*-(h-1),a<0&&a++,a>1&&a--,6*a<1?l=u+(o-u)*6*a:2*a<1?l=o:3*a<2?l=u+(o-u)*(2/3-a)*6:l=u,c[h]=l*255;return{r:Math.round(c[0]),g:Math.round(c[1]),b:Math.round(c[2]),a:1}}},haveIntersection(t,e){return!(e.x>t.x+t.width||e.x+e.width<t.x||e.y>t.y+t.height||e.y+e.height<t.y)},cloneObject(t){const e={};for(const n in t)this._isPlainObject(t[n])?e[n]=this.cloneObject(t[n]):this._isArray(t[n])?e[n]=this.cloneArray(t[n]):e[n]=t[n];return e},cloneArray(t){return t.slice(0)},degToRad(t){return t*A5e},radToDeg(t){return t*P5e},_degToRad(t){return le.warn("Util._degToRad is removed. Please use public Util.degToRad instead."),le.degToRad(t)},_radToDeg(t){return le.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."),le.radToDeg(t)},_getRotation(t){return He.angleDeg?le.radToDeg(t):t},_capitalize(t){return t.charAt(0).toUpperCase()+t.slice(1)},throw(t){throw new Error(zT+t)},error(t){console.error(zT+t)},warn(t){He.showWarnings&&console.warn(M5e+t)},each(t,e){for(const n in t)e(n,t[n])},_inRange(t,e,n){return e<=t&&t<n},_getProjectionToSegment(t,e,n,s,r,i){let o,a,l;const u=(t-n)*(t-n)+(e-s)*(e-s);if(u==0)o=t,a=e,l=(r-n)*(r-n)+(i-s)*(i-s);else{const c=((r-t)*(n-t)+(i-e)*(s-e))/u;c<0?(o=t,a=e,l=(t-r)*(t-r)+(e-i)*(e-i)):c>1?(o=n,a=s,l=(n-r)*(n-r)+(s-i)*(s-i)):(o=t+c*(n-t),a=e+c*(s-e),l=(o-r)*(o-r)+(a-i)*(a-i))}return[o,a,l]},_getProjectionToLine(t,e,n){const s=le.cloneObject(t);let r=Number.MAX_VALUE;return e.forEach(function(i,o){if(!n&&o===e.length-1)return;const a=e[(o+1)%e.length],l=le._getProjectionToSegment(i.x,i.y,a.x,a.y,t.x,t.y),u=l[0],c=l[1],h=l[2];h<r&&(s.x=u,s.y=c,r=h)}),s},_prepareArrayForTween(t,e,n){const s=[],r=[];if(t.length>e.length){const o=e;e=t,t=o}for(let o=0;o<t.length;o+=2)s.push({x:t[o],y:t[o+1]});for(let o=0;o<e.length;o+=2)r.push({x:e[o],y:e[o+1]});const i=[];return r.forEach(function(o){const a=le._getProjectionToLine(o,s,n);i.push(a.x),i.push(a.y)}),i},_prepareToStringify(t){let e;t.visitedByCircularReferenceRemoval=!0;for(const n in t)if(t.hasOwnProperty(n)&&t[n]&&typeof t[n]=="object"){if(e=Object.getOwnPropertyDescriptor(t,n),t[n].visitedByCircularReferenceRemoval||le._isElement(t[n]))if(e.configurable)delete t[n];else return null;else if(le._prepareToStringify(t[n])===null)if(e.configurable)delete t[n];else return null}return delete t.visitedByCircularReferenceRemoval,t},_assign(t,e){for(const n in e)t[n]=e[n];return t},_getFirstPointerId(t){return t.touches?t.changedTouches[0].identifier:t.pointerId||999},releaseCanvas(...t){He.releaseCanvasOnDestroy&&t.forEach(e=>{e.width=0,e.height=0})},drawRoundedRectPath(t,e,n,s){let r=e<0?e:0,i=n<0?n:0;e=Math.abs(e),n=Math.abs(n);let o=0,a=0,l=0,u=0;typeof s=="number"?o=a=l=u=Math.min(s,e/2,n/2):(o=Math.min(s[0]||0,e/2,n/2),a=Math.min(s[1]||0,e/2,n/2),u=Math.min(s[2]||0,e/2,n/2),l=Math.min(s[3]||0,e/2,n/2)),t.moveTo(r+o,i),t.lineTo(r+e-a,i),t.arc(r+e-a,i+a,a,Math.PI*3/2,0,!1),t.lineTo(r+e,i+n-u),t.arc(r+e-u,i+n-u,u,0,Math.PI/2,!1),t.lineTo(r+l,i+n),t.arc(r+l,i+n-l,l,Math.PI/2,Math.PI,!1),t.lineTo(r,i+o),t.arc(r+o,i+o,o,Math.PI,Math.PI*3/2,!1)},drawRoundedPolygonPath(t,e,n,s,r){s=Math.abs(s);for(let i=0;i<n;i++){const o=e[(i-1+n)%n],a=e[i],l=e[(i+1)%n],u={x:a.x-o.x,y:a.y-o.y},c={x:l.x-a.x,y:l.y-a.y},h=Math.hypot(u.x,u.y),d=Math.hypot(c.x,c.y);let f;typeof r=="number"?f=r:f=i<r.length?r[i]:0,f=s*Math.cos(Math.PI/n)*Math.min(1,f/s*2);const g={x:u.x/h,y:u.y/h},m={x:c.x/d,y:c.y/d},x={x:a.x-g.x*f,y:a.y-g.y*f},b={x:a.x+m.x*f,y:a.y+m.y*f};i===0?t.moveTo(x.x,x.y):t.lineTo(x.x,x.y),t.arcTo(a.x,a.y,b.x,b.y,f)}}};function U5e(t){const e=[],n=t.length,s=le;for(let r=0;r<n;r++){let i=t[r];s._isNumber(i)?i=Math.round(i*1e3)/1e3:s._isString(i)||(i=i+""),e.push(i)}return e}const GT=",",B5e="(",z5e=")",G5e="([",V5e="])",W5e=";",H5e="()",K5e="=",VT=["arc","arcTo","beginPath","bezierCurveTo","clearRect","clip","closePath","createLinearGradient","createPattern","createRadialGradient","drawImage","ellipse","fill","fillText","getImageData","createImageData","lineTo","moveTo","putImageData","quadraticCurveTo","rect","roundRect","restore","rotate","save","scale","setLineDash","setTransform","stroke","strokeText","transform","translate"],j5e=["fillStyle","strokeStyle","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","letterSpacing","lineCap","lineDashOffset","lineJoin","lineWidth","miterLimit","direction","font","textAlign","textBaseline","globalAlpha","globalCompositeOperation","imageSmoothingEnabled","filter"],X5e=100;let lm=null;function WT(){if(lm!==null)return lm;try{const e=le.createCanvasElement().getContext("2d");return e?!!e&&"filter"in e:(lm=!1,!1)}catch{return lm=!1,!1}}class Jx{constructor(e){this.canvas=e,He.enableTrace&&(this.traceArr=[],this._enableTrace())}fillShape(e){e.fillEnabled()&&this._fill(e)}_fill(e){}strokeShape(e){e.hasStroke()&&this._stroke(e)}_stroke(e){}fillStrokeShape(e){e.attrs.fillAfterStrokeEnabled?(this.strokeShape(e),this.fillShape(e)):(this.fillShape(e),this.strokeShape(e))}getTrace(e,n){let s=this.traceArr,r=s.length,i="",o,a,l,u;for(o=0;o<r;o++)a=s[o],l=a.method,l?(u=a.args,i+=l,e?i+=H5e:le._isArray(u[0])?i+=G5e+u.join(GT)+V5e:(n&&(u=u.map(c=>typeof c=="number"?Math.floor(c):c)),i+=B5e+u.join(GT)+z5e)):(i+=a.property,e||(i+=K5e+a.val)),i+=W5e;return i}clearTrace(){this.traceArr=[]}_trace(e){let n=this.traceArr,s;n.push(e),s=n.length,s>=X5e&&n.shift()}reset(){const e=this.getCanvas().getPixelRatio();this.setTransform(1*e,0,0,1*e,0,0)}getCanvas(){return this.canvas}clear(e){const n=this.getCanvas();e?this.clearRect(e.x||0,e.y||0,e.width||0,e.height||0):this.clearRect(0,0,n.getWidth()/n.pixelRatio,n.getHeight()/n.pixelRatio)}_applyLineCap(e){const n=e.attrs.lineCap;n&&this.setAttr("lineCap",n)}_applyOpacity(e){const n=e.getAbsoluteOpacity();n!==1&&this.setAttr("globalAlpha",n)}_applyLineJoin(e){const n=e.attrs.lineJoin;n&&this.setAttr("lineJoin",n)}_applyMiterLimit(e){const n=e.attrs.miterLimit;n!=null&&this.setAttr("miterLimit",n)}setAttr(e,n){this._context[e]=n}arc(e,n,s,r,i,o){this._context.arc(e,n,s,r,i,o)}arcTo(e,n,s,r,i){this._context.arcTo(e,n,s,r,i)}beginPath(){this._context.beginPath()}bezierCurveTo(e,n,s,r,i,o){this._context.bezierCurveTo(e,n,s,r,i,o)}clearRect(e,n,s,r){this._context.clearRect(e,n,s,r)}clip(...e){this._context.clip.apply(this._context,e)}closePath(){this._context.closePath()}createImageData(e,n){const s=arguments;if(s.length===2)return this._context.createImageData(e,n);if(s.length===1)return this._context.createImageData(e)}createLinearGradient(e,n,s,r){return this._context.createLinearGradient(e,n,s,r)}createPattern(e,n){return this._context.createPattern(e,n)}createRadialGradient(e,n,s,r,i,o){return this._context.createRadialGradient(e,n,s,r,i,o)}drawImage(e,n,s,r,i,o,a,l,u){const c=arguments,h=this._context;c.length===3?h.drawImage(e,n,s):c.length===5?h.drawImage(e,n,s,r,i):c.length===9&&h.drawImage(e,n,s,r,i,o,a,l,u)}ellipse(e,n,s,r,i,o,a,l){this._context.ellipse(e,n,s,r,i,o,a,l)}isPointInPath(e,n,s,r){return s?this._context.isPointInPath(s,e,n,r):this._context.isPointInPath(e,n,r)}fill(...e){this._context.fill.apply(this._context,e)}fillRect(e,n,s,r){this._context.fillRect(e,n,s,r)}strokeRect(e,n,s,r){this._context.strokeRect(e,n,s,r)}fillText(e,n,s,r){r?this._context.fillText(e,n,s,r):this._context.fillText(e,n,s)}measureText(e){return this._context.measureText(e)}getImageData(e,n,s,r){return this._context.getImageData(e,n,s,r)}lineTo(e,n){this._context.lineTo(e,n)}moveTo(e,n){this._context.moveTo(e,n)}rect(e,n,s,r){this._context.rect(e,n,s,r)}roundRect(e,n,s,r,i){this._context.roundRect(e,n,s,r,i)}putImageData(e,n,s){this._context.putImageData(e,n,s)}quadraticCurveTo(e,n,s,r){this._context.quadraticCurveTo(e,n,s,r)}restore(){this._context.restore()}rotate(e){this._context.rotate(e)}save(){this._context.save()}scale(e,n){this._context.scale(e,n)}setLineDash(e){this._context.setLineDash?this._context.setLineDash(e):"mozDash"in this._context?this._context.mozDash=e:"webkitLineDash"in this._context&&(this._context.webkitLineDash=e)}getLineDash(){return this._context.getLineDash()}setTransform(e,n,s,r,i,o){this._context.setTransform(e,n,s,r,i,o)}stroke(e){e?this._context.stroke(e):this._context.stroke()}strokeText(e,n,s,r){this._context.strokeText(e,n,s,r)}transform(e,n,s,r,i,o){this._context.transform(e,n,s,r,i,o)}translate(e,n){this._context.translate(e,n)}_enableTrace(){let e=this,n=VT.length,s=this.setAttr,r,i;const o=function(a){let l=e[a],u;e[a]=function(){return i=U5e(Array.prototype.slice.call(arguments,0)),u=l.apply(e,arguments),e._trace({method:a,args:i}),u}};for(r=0;r<n;r++)o(VT[r]);e.setAttr=function(){s.apply(e,arguments);const a=arguments[0];let l=arguments[1];(a==="shadowOffsetX"||a==="shadowOffsetY"||a==="shadowBlur")&&(l=l/this.canvas.getPixelRatio()),e._trace({property:a,val:l})}}_applyGlobalCompositeOperation(e){const n=e.attrs.globalCompositeOperation;!n||n==="source-over"||this.setAttr("globalCompositeOperation",n)}}j5e.forEach(function(t){Object.defineProperty(Jx.prototype,t,{get(){return this._context[t]},set(e){this._context[t]=e}})});class q5e extends Jx{constructor(e,{willReadFrequently:n=!1}={}){super(e),this._context=e._canvas.getContext("2d",{willReadFrequently:n})}_fillColor(e){const n=e.fill();this.setAttr("fillStyle",n),e._fillFunc(this)}_fillPattern(e){this.setAttr("fillStyle",e._getFillPattern()),e._fillFunc(this)}_fillLinearGradient(e){const n=e._getLinearGradient();n&&(this.setAttr("fillStyle",n),e._fillFunc(this))}_fillRadialGradient(e){const n=e._getRadialGradient();n&&(this.setAttr("fillStyle",n),e._fillFunc(this))}_fill(e){const n=e.fill(),s=e.getFillPriority();if(n&&s==="color"){this._fillColor(e);return}const r=e.getFillPatternImage();if(r&&s==="pattern"){this._fillPattern(e);return}const i=e.getFillLinearGradientColorStops();if(i&&s==="linear-gradient"){this._fillLinearGradient(e);return}const o=e.getFillRadialGradientColorStops();if(o&&s==="radial-gradient"){this._fillRadialGradient(e);return}n?this._fillColor(e):r?this._fillPattern(e):i?this._fillLinearGradient(e):o&&this._fillRadialGradient(e)}_strokeLinearGradient(e){const n=e.getStrokeLinearGradientStartPoint(),s=e.getStrokeLinearGradientEndPoint(),r=e.getStrokeLinearGradientColorStops(),i=this.createLinearGradient(n.x,n.y,s.x,s.y);if(r){for(let o=0;o<r.length;o+=2)i.addColorStop(r[o],r[o+1]);this.setAttr("strokeStyle",i)}}_stroke(e){const n=e.dash(),s=e.getStrokeScaleEnabled();if(e.hasStroke()){if(!s){this.save();const i=this.getCanvas().getPixelRatio();this.setTransform(i,0,0,i,0,0)}this._applyLineCap(e),n&&e.dashEnabled()&&(this.setLineDash(n),this.setAttr("lineDashOffset",e.dashOffset())),this.setAttr("lineWidth",e.strokeWidth()),e.getShadowForStrokeEnabled()||this.setAttr("shadowColor","rgba(0,0,0,0)"),e.getStrokeLinearGradientColorStops()?this._strokeLinearGradient(e):this.setAttr("strokeStyle",e.stroke()),e._strokeFunc(this),s||this.restore()}}_applyShadow(e){var n,s,r;const i=(n=e.getShadowRGBA())!==null&&n!==void 0?n:"black",o=(s=e.getShadowBlur())!==null&&s!==void 0?s:5,a=(r=e.getShadowOffset())!==null&&r!==void 0?r:{x:0,y:0},l=e.getAbsoluteScale(),u=this.canvas.getPixelRatio(),c=l.x*u,h=l.y*u;this.setAttr("shadowColor",i),this.setAttr("shadowBlur",o*Math.min(Math.abs(c),Math.abs(h))),this.setAttr("shadowOffsetX",a.x*c),this.setAttr("shadowOffsetY",a.y*h)}}class Y5e extends Jx{constructor(e){super(e),this._context=e._canvas.getContext("2d",{willReadFrequently:!0})}_fill(e){this.save(),this.setAttr("fillStyle",e.colorKey),e._fillFuncHit(this),this.restore()}strokeShape(e){e.hasHitStroke()&&this._stroke(e)}_stroke(e){if(e.hasHitStroke()){const n=e.getStrokeScaleEnabled();if(!n){this.save();const i=this.getCanvas().getPixelRatio();this.setTransform(i,0,0,i,0,0)}this._applyLineCap(e);const s=e.hitStrokeWidth(),r=s==="auto"?e.strokeWidth():s;this.setAttr("lineWidth",r),this.setAttr("strokeStyle",e.colorKey),e._strokeFuncHit(this),n||this.restore()}}}let um;function Z5e(){if(um)return um;const t=le.createCanvasElement(),e=t.getContext("2d");return um=function(){const n=He._global.devicePixelRatio||1,s=e.webkitBackingStorePixelRatio||e.mozBackingStorePixelRatio||e.msBackingStorePixelRatio||e.oBackingStorePixelRatio||e.backingStorePixelRatio||1;return n/s}(),le.releaseCanvas(t),um}class kw{constructor(e){this.pixelRatio=1,this.width=0,this.height=0,this.isCache=!1;const s=(e||{}).pixelRatio||He.pixelRatio||Z5e();this.pixelRatio=s,this._canvas=le.createCanvasElement(),this._canvas.style.padding="0",this._canvas.style.margin="0",this._canvas.style.border="0",this._canvas.style.background="transparent",this._canvas.style.position="absolute",this._canvas.style.top="0",this._canvas.style.left="0"}getContext(){return this.context}getPixelRatio(){return this.pixelRatio}setPixelRatio(e){const n=this.pixelRatio;this.pixelRatio=e,this.setSize(this.getWidth()/n,this.getHeight()/n)}setWidth(e){this.width=this._canvas.width=e*this.pixelRatio,this._canvas.style.width=e+"px";const n=this.pixelRatio;this.getContext()._context.scale(n,n)}setHeight(e){this.height=this._canvas.height=e*this.pixelRatio,this._canvas.style.height=e+"px";const n=this.pixelRatio;this.getContext()._context.scale(n,n)}getWidth(){return this.width}getHeight(){return this.height}setSize(e,n){this.setWidth(e||0),this.setHeight(n||0)}toDataURL(e,n){try{return this._canvas.toDataURL(e,n)}catch{try{return this._canvas.toDataURL()}catch(r){return le.error("Unable to get data URL. "+r.message+" For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."),""}}}}class jo extends kw{constructor(e={width:0,height:0,willReadFrequently:!1}){super(e),this.context=new q5e(this,{willReadFrequently:e.willReadFrequently}),this.setSize(e.width,e.height)}}class Ew extends kw{constructor(e={width:0,height:0}){super(e),this.hitCanvas=!0,this.context=new Y5e(this),this.setSize(e.width,e.height)}}const Kt={get isDragging(){let t=!1;return Kt._dragElements.forEach(e=>{e.dragStatus==="dragging"&&(t=!0)}),t},justDragged:!1,get node(){let t;return Kt._dragElements.forEach(e=>{t=e.node}),t},_dragElements:new Map,_drag(t){const e=[];Kt._dragElements.forEach((n,s)=>{const{node:r}=n,i=r.getStage();i.setPointersPositions(t),n.pointerId===void 0&&(n.pointerId=le._getFirstPointerId(t));const o=i._changedPointerPositions.find(a=>a.id===n.pointerId);if(o){if(n.dragStatus!=="dragging"){const a=r.dragDistance();if(Math.max(Math.abs(o.x-n.startPointerPos.x),Math.abs(o.y-n.startPointerPos.y))<a||(r.startDrag({evt:t}),!r.isDragging()))return}r._setDragPosition(t,n),e.push(r)}}),e.forEach(n=>{n.fire("dragmove",{type:"dragmove",target:n,evt:t},!0)})},_endDragBefore(t){const e=[];Kt._dragElements.forEach(n=>{const{node:s}=n,r=s.getStage();if(t&&r.setPointersPositions(t),!r._changedPointerPositions.find(a=>a.id===n.pointerId))return;(n.dragStatus==="dragging"||n.dragStatus==="stopped")&&(Kt.justDragged=!0,He._mouseListenClick=!1,He._touchListenClick=!1,He._pointerListenClick=!1,n.dragStatus="stopped");const o=n.node.getLayer()||n.node instanceof He.Stage&&n.node;o&&e.indexOf(o)===-1&&e.push(o)}),e.forEach(n=>{n.draw()})},_endDragAfter(t){Kt._dragElements.forEach((e,n)=>{e.dragStatus==="stopped"&&e.node.fire("dragend",{type:"dragend",target:e.node,evt:t},!0),e.dragStatus!=="dragging"&&Kt._dragElements.delete(n)})}};He.isBrowser&&(window.addEventListener("mouseup",Kt._endDragBefore,!0),window.addEventListener("touchend",Kt._endDragBefore,!0),window.addEventListener("touchcancel",Kt._endDragBefore,!0),window.addEventListener("mousemove",Kt._drag),window.addEventListener("touchmove",Kt._drag),window.addEventListener("mouseup",Kt._endDragAfter,!1),window.addEventListener("touchend",Kt._endDragAfter,!1),window.addEventListener("touchcancel",Kt._endDragAfter,!1));function Ia(t){return le._isString(t)?'"'+t+'"':Object.prototype.toString.call(t)==="[object Number]"||le._isBoolean(t)?t:Object.prototype.toString.call(t)}function $4(t){return t>255?255:t<0?0:Math.round(t)}function Be(){if(He.isUnminified)return function(t,e){return le._isNumber(t)||le.warn(Ia(t)+' is a not valid value for "'+e+'" attribute. The value should be a number.'),t}}function eb(t){if(He.isUnminified)return function(e,n){let s=le._isNumber(e),r=le._isArray(e)&&e.length==t;return!s&&!r&&le.warn(Ia(e)+' is a not valid value for "'+n+'" attribute. The value should be a number or Array<number>('+t+")"),e}}function _w(){if(He.isUnminified)return function(t,e){return le._isNumber(t)||t==="auto"||le.warn(Ia(t)+' is a not valid value for "'+e+'" attribute. The value should be a number or "auto".'),t}}function Yl(){if(He.isUnminified)return function(t,e){return le._isString(t)||le.warn(Ia(t)+' is a not valid value for "'+e+'" attribute. The value should be a string.'),t}}function R4(){if(He.isUnminified)return function(t,e){const n=le._isString(t),s=Object.prototype.toString.call(t)==="[object CanvasGradient]"||t&&t.addColorStop;return n||s||le.warn(Ia(t)+' is a not valid value for "'+e+'" attribute. The value should be a string or a native gradient.'),t}}function Q5e(){if(He.isUnminified)return function(t,e){const n=Int8Array?Object.getPrototypeOf(Int8Array):null;return n&&t instanceof n||(le._isArray(t)?t.forEach(function(s){le._isNumber(s)||le.warn('"'+e+'" attribute has non numeric element '+s+". Make sure that all elements are numbers.")}):le.warn(Ia(t)+' is a not valid value for "'+e+'" attribute. The value should be a array of numbers.')),t}}function bi(){if(He.isUnminified)return function(t,e){return t===!0||t===!1||le.warn(Ia(t)+' is a not valid value for "'+e+'" attribute. The value should be a boolean.'),t}}function J5e(t){if(He.isUnminified)return function(e,n){return e==null||le.isObject(e)||le.warn(Ia(e)+' is a not valid value for "'+n+'" attribute. The value should be an object with properties '+t),e}}const Eh="get",_h="set",X={addGetterSetter(t,e,n,s,r){X.addGetter(t,e,n),X.addSetter(t,e,s,r),X.addOverloadedGetterSetter(t,e)},addGetter(t,e,n){const s=Eh+le._capitalize(e);t.prototype[s]=t.prototype[s]||function(){const r=this.attrs[e];return r===void 0?n:r}},addSetter(t,e,n,s){const r=_h+le._capitalize(e);t.prototype[r]||X.overWriteSetter(t,e,n,s)},overWriteSetter(t,e,n,s){const r=_h+le._capitalize(e);t.prototype[r]=function(i){return n&&i!==void 0&&i!==null&&(i=n.call(this,i,e)),this._setAttr(e,i),s&&s.call(this),this}},addComponentsGetterSetter(t,e,n,s,r){const i=n.length,o=le._capitalize,a=Eh+o(e),l=_h+o(e);t.prototype[a]=function(){const c={};for(let h=0;h<i;h++){const d=n[h];c[d]=this.getAttr(e+o(d))}return c};const u=J5e(n);t.prototype[l]=function(c){const h=this.attrs[e];s&&(c=s.call(this,c,e)),u&&u.call(this,c,e);for(const d in c)c.hasOwnProperty(d)&&this._setAttr(e+o(d),c[d]);return c||n.forEach(d=>{this._setAttr(e+o(d),void 0)}),this._fireChangeEvent(e,h,c),r&&r.call(this),this},X.addOverloadedGetterSetter(t,e)},addOverloadedGetterSetter(t,e){const n=le._capitalize(e),s=_h+n,r=Eh+n;t.prototype[e]=function(){return arguments.length?(this[s](arguments[0]),this):this[r]()}},addDeprecatedGetterSetter(t,e,n,s){le.error("Adding deprecated "+e);const r=Eh+le._capitalize(e),i=e+" property is deprecated and will be removed soon. Look at Konva change log for more information.";t.prototype[r]=function(){le.error(i);const o=this.attrs[e];return o===void 0?n:o},X.addSetter(t,e,s,function(){le.error(i)}),X.addOverloadedGetterSetter(t,e)},backCompat(t,e){le.each(e,function(n,s){const r=t.prototype[s],i=Eh+le._capitalize(n),o=_h+le._capitalize(n);function a(){r.apply(this,arguments),le.error('"'+n+'" method is deprecated and will be removed soon. Use ""'+s+'" instead.')}t.prototype[n]=a,t.prototype[i]=a,t.prototype[o]=a})},afterSetFilter(){this._filterUpToDate=!1}};function eUe(t){const e=/(\w+)\(([^)]+)\)/g;let n;for(;(n=e.exec(t))!==null;){const[,s,r]=n;switch(s){case"blur":{const i=parseFloat(r.replace("px",""));return function(o){this.blurRadius(i*.5);const a=He.Filters;a&&a.Blur&&a.Blur.call(this,o)}}case"brightness":{const i=r.includes("%")?parseFloat(r)/100:parseFloat(r);return function(o){this.brightness(i);const a=He.Filters;a&&a.Brightness&&a.Brightness.call(this,o)}}case"contrast":{const i=parseFloat(r);return function(o){const a=100*(Math.sqrt(i)-1);this.contrast(a);const l=He.Filters;l&&l.Contrast&&l.Contrast.call(this,o)}}case"grayscale":return function(i){const o=He.Filters;o&&o.Grayscale&&o.Grayscale.call(this,i)};case"sepia":return function(i){const o=He.Filters;o&&o.Sepia&&o.Sepia.call(this,i)};case"invert":return function(i){const o=He.Filters;o&&o.Invert&&o.Invert.call(this,i)};default:le.warn(`CSS filter "${s}" is not supported in fallback mode. Consider using function filters for better compatibility.`);break}}return()=>{}}const Rm="absoluteOpacity",cm="allEventListeners",lo="absoluteTransform",HT="absoluteScale",Fa="canvas",tUe="Change",nUe="children",sUe="konva",Cy="listening",rUe="mouseenter",iUe="mouseleave",oUe="pointerenter",aUe="pointerleave",lUe="touchenter",uUe="touchleave",KT="set",jT="Shape",Am=" ",XT="stage",Bo="transform",cUe="Stage",Ty="visible",hUe=["xChange.konva","yChange.konva","scaleXChange.konva","scaleYChange.konva","skewXChange.konva","skewYChange.konva","rotationChange.konva","offsetXChange.konva","offsetYChange.konva","transformsEnabledChange.konva"].join(Am);let dUe=1;class Fe{constructor(e){this._id=dUe++,this.eventListeners={},this.attrs={},this.index=0,this._allEventListeners=null,this.parent=null,this._cache=new Map,this._attachedDepsListeners=new Map,this._lastPos=null,this._batchingTransformChange=!1,this._needClearTransformCache=!1,this._filterUpToDate=!1,this._isUnderCache=!1,this._dragEventId=null,this._shouldFireChangeEvents=!1,this.setAttrs(e),this._shouldFireChangeEvents=!0}hasChildren(){return!1}_clearCache(e){(e===Bo||e===lo)&&this._cache.get(e)?this._cache.get(e).dirty=!0:e?this._cache.delete(e):this._cache.clear()}_getCache(e,n){let s=this._cache.get(e);return(s===void 0||(e===Bo||e===lo)&&s.dirty===!0)&&(s=n.call(this),this._cache.set(e,s)),s}_calculate(e,n,s){if(!this._attachedDepsListeners.get(e)){const r=n.map(i=>i+"Change.konva").join(Am);this.on(r,()=>{this._clearCache(e)}),this._attachedDepsListeners.set(e,!0)}return this._getCache(e,s)}_getCanvasCache(){return this._cache.get(Fa)}_clearSelfAndDescendantCache(e){this._clearCache(e),e===lo&&this.fire("absoluteTransformChange")}clearCache(){if(this._cache.has(Fa)){const{scene:e,filter:n,hit:s,buffer:r}=this._cache.get(Fa);le.releaseCanvas(e,n,s,r),this._cache.delete(Fa)}return this._clearSelfAndDescendantCache(),this._requestDraw(),this}cache(e){const n=e||{};let s={};(n.x===void 0||n.y===void 0||n.width===void 0||n.height===void 0)&&(s=this.getClientRect({skipTransform:!0,relativeTo:this.getParent()||void 0}));let r=Math.ceil(n.width||s.width),i=Math.ceil(n.height||s.height),o=n.pixelRatio,a=n.x===void 0?Math.floor(s.x):n.x,l=n.y===void 0?Math.floor(s.y):n.y,u=n.offset||0,c=n.drawBorder||!1,h=n.hitCanvasPixelRatio||1;if(!r||!i){le.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");return}const d=Math.abs(Math.round(s.x)-a)>.5?1:0,f=Math.abs(Math.round(s.y)-l)>.5?1:0;r+=u*2+d,i+=u*2+f,a-=u,l-=u;const p=new jo({pixelRatio:o,width:r,height:i}),g=new jo({pixelRatio:o,width:0,height:0,willReadFrequently:!0}),m=new Ew({pixelRatio:h,width:r,height:i}),x=p.getContext(),b=m.getContext(),v=new jo({width:p.width/p.pixelRatio+Math.abs(a),height:p.height/p.pixelRatio+Math.abs(l),pixelRatio:p.pixelRatio}),y=v.getContext();return m.isCache=!0,p.isCache=!0,this._cache.delete(Fa),this._filterUpToDate=!1,n.imageSmoothingEnabled===!1&&(p.getContext()._context.imageSmoothingEnabled=!1,g.getContext()._context.imageSmoothingEnabled=!1),x.save(),b.save(),y.save(),x.translate(-a,-l),b.translate(-a,-l),y.translate(-a,-l),v.x=a,v.y=l,this._isUnderCache=!0,this._clearSelfAndDescendantCache(Rm),this._clearSelfAndDescendantCache(HT),this.drawScene(p,this,v),this.drawHit(m,this),this._isUnderCache=!1,x.restore(),b.restore(),c&&(x.save(),x.beginPath(),x.rect(0,0,r,i),x.closePath(),x.setAttr("strokeStyle","red"),x.setAttr("lineWidth",5),x.stroke(),x.restore()),this._cache.set(Fa,{scene:p,filter:g,hit:m,buffer:v,x:a,y:l}),this._requestDraw(),this}isCached(){return this._cache.has(Fa)}getClientRect(e){throw new Error('abstract "getClientRect" method call')}_transformedRect(e,n){const s=[{x:e.x,y:e.y},{x:e.x+e.width,y:e.y},{x:e.x+e.width,y:e.y+e.height},{x:e.x,y:e.y+e.height}];let r=1/0,i=1/0,o=-1/0,a=-1/0;const l=this.getAbsoluteTransform(n);return s.forEach(function(u){const c=l.point(u);r===void 0&&(r=o=c.x,i=a=c.y),r=Math.min(r,c.x),i=Math.min(i,c.y),o=Math.max(o,c.x),a=Math.max(a,c.y)}),{x:r,y:i,width:o-r,height:a-i}}_drawCachedSceneCanvas(e){e.save(),e._applyOpacity(this),e._applyGlobalCompositeOperation(this);const n=this._getCanvasCache();e.translate(n.x,n.y);const s=this._getCachedSceneCanvas(),r=s.pixelRatio;e.drawImage(s._canvas,0,0,s.width/r,s.height/r),e.restore()}_drawCachedHitCanvas(e){const n=this._getCanvasCache(),s=n.hit;e.save(),e.translate(n.x,n.y),e.drawImage(s._canvas,0,0,s.width/s.pixelRatio,s.height/s.pixelRatio),e.restore()}_getCachedSceneCanvas(){let e=this.filters(),n=this._getCanvasCache(),s=n.scene,r=n.filter,i=r.getContext(),o,a,l,u;if(!e||e.length===0)return s;if(this._filterUpToDate)return r;let c=!0;for(let d=0;d<e.length;d++)if(typeof e[d]=="string"&&WT(),typeof e[d]!="string"||!WT()){c=!1;break}const h=s.pixelRatio;if(r.setSize(s.width/s.pixelRatio,s.height/s.pixelRatio),c){const d=e.join(" ");return i.save(),i.setAttr("filter",d),i.drawImage(s._canvas,0,0,s.getWidth()/h,s.getHeight()/h),i.restore(),this._filterUpToDate=!0,r}try{for(o=e.length,i.clear(),i.drawImage(s._canvas,0,0,s.getWidth()/h,s.getHeight()/h),a=i.getImageData(0,0,r.getWidth(),r.getHeight()),l=0;l<o;l++)u=e[l],typeof u=="string"&&(u=eUe(u)),u.call(this,a),i.putImageData(a,0,0)}catch(d){le.error("Unable to apply filter. "+d.message+" This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.")}return this._filterUpToDate=!0,r}on(e,n){if(this._cache&&this._cache.delete(cm),arguments.length===3)return this._delegate.apply(this,arguments);const s=e.split(Am);for(let r=0;r<s.length;r++){const o=s[r].split("."),a=o[0],l=o[1]||"";this.eventListeners[a]||(this.eventListeners[a]=[]),this.eventListeners[a].push({name:l,handler:n})}return this}off(e,n){let s=(e||"").split(Am),r=s.length,i,o,a,l,u,c;if(this._cache&&this._cache.delete(cm),!e)for(o in this.eventListeners)this._off(o);for(i=0;i<r;i++)if(a=s[i],l=a.split("."),u=l[0],c=l[1],u)this.eventListeners[u]&&this._off(u,c,n);else for(o in this.eventListeners)this._off(o,c,n);return this}dispatchEvent(e){const n={target:this,type:e.type,evt:e};return this.fire(e.type,n),this}addEventListener(e,n){return this.on(e,function(s){n.call(this,s.evt)}),this}removeEventListener(e){return this.off(e),this}_delegate(e,n,s){const r=this;this.on(e,function(i){const o=i.target.findAncestors(n,!0,r);for(let a=0;a<o.length;a++)i=le.cloneObject(i),i.currentTarget=o[a],s.call(o[a],i)})}remove(){return this.isDragging()&&this.stopDrag(),Kt._dragElements.delete(this._id),this._remove(),this}_clearCaches(){this._clearSelfAndDescendantCache(lo),this._clearSelfAndDescendantCache(Rm),this._clearSelfAndDescendantCache(HT),this._clearSelfAndDescendantCache(XT),this._clearSelfAndDescendantCache(Ty),this._clearSelfAndDescendantCache(Cy)}_remove(){this._clearCaches();const e=this.getParent();e&&e.children&&(e.children.splice(this.index,1),e._setChildrenIndices(),this.parent=null)}destroy(){return this.remove(),this.clearCache(),this}getAttr(e){const n="get"+le._capitalize(e);return le._isFunction(this[n])?this[n]():this.attrs[e]}getAncestors(){let e=this.getParent(),n=[];for(;e;)n.push(e),e=e.getParent();return n}getAttrs(){return this.attrs||{}}setAttrs(e){return this._batchTransformChanges(()=>{let n,s;if(!e)return this;for(n in e)n!==nUe&&(s=KT+le._capitalize(n),le._isFunction(this[s])?this[s](e[n]):this._setAttr(n,e[n]))}),this}isListening(){return this._getCache(Cy,this._isListening)}_isListening(e){if(!this.listening())return!1;const s=this.getParent();return s&&s!==e&&this!==e?s._isListening(e):!0}isVisible(){return this._getCache(Ty,this._isVisible)}_isVisible(e){if(!this.visible())return!1;const s=this.getParent();return s&&s!==e&&this!==e?s._isVisible(e):!0}shouldDrawHit(e,n=!1){if(e)return this._isVisible(e)&&this._isListening(e);const s=this.getLayer();let r=!1;Kt._dragElements.forEach(o=>{o.dragStatus==="dragging"&&(o.node.nodeType==="Stage"||o.node.getLayer()===s)&&(r=!0)});const i=!n&&!He.hitOnDragEnabled&&(r||He.isTransforming());return this.isListening()&&this.isVisible()&&!i}show(){return this.visible(!0),this}hide(){return this.visible(!1),this}getZIndex(){return this.index||0}getAbsoluteZIndex(){let e=this.getDepth(),n=this,s=0,r,i,o,a;function l(c){for(r=[],i=c.length,o=0;o<i;o++)a=c[o],s++,a.nodeType!==jT&&(r=r.concat(a.getChildren().slice())),a._id===n._id&&(o=i);r.length>0&&r[0].getDepth()<=e&&l(r)}const u=this.getStage();return n.nodeType!==cUe&&u&&l(u.getChildren()),s}getDepth(){let e=0,n=this.parent;for(;n;)e++,n=n.parent;return e}_batchTransformChanges(e){this._batchingTransformChange=!0,e(),this._batchingTransformChange=!1,this._needClearTransformCache&&(this._clearCache(Bo),this._clearSelfAndDescendantCache(lo)),this._needClearTransformCache=!1}setPosition(e){return this._batchTransformChanges(()=>{this.x(e.x),this.y(e.y)}),this}getPosition(){return{x:this.x(),y:this.y()}}getRelativePointerPosition(){const e=this.getStage();if(!e)return null;const n=e.getPointerPosition();if(!n)return null;const s=this.getAbsoluteTransform().copy();return s.invert(),s.point(n)}getAbsolutePosition(e){let n=!1,s=this.parent;for(;s;){if(s.isCached()){n=!0;break}s=s.parent}n&&!e&&(e=!0);const r=this.getAbsoluteTransform(e).getMatrix(),i=new vr,o=this.offset();return i.m=r.slice(),i.translate(o.x,o.y),i.getTranslation()}setAbsolutePosition(e){const{x:n,y:s,...r}=this._clearTransform();this.attrs.x=n,this.attrs.y=s,this._clearCache(Bo);const i=this._getAbsoluteTransform().copy();return i.invert(),i.translate(e.x,e.y),e={x:this.attrs.x+i.getTranslation().x,y:this.attrs.y+i.getTranslation().y},this._setTransform(r),this.setPosition({x:e.x,y:e.y}),this._clearCache(Bo),this._clearSelfAndDescendantCache(lo),this}_setTransform(e){let n;for(n in e)this.attrs[n]=e[n]}_clearTransform(){const e={x:this.x(),y:this.y(),rotation:this.rotation(),scaleX:this.scaleX(),scaleY:this.scaleY(),offsetX:this.offsetX(),offsetY:this.offsetY(),skewX:this.skewX(),skewY:this.skewY()};return this.attrs.x=0,this.attrs.y=0,this.attrs.rotation=0,this.attrs.scaleX=1,this.attrs.scaleY=1,this.attrs.offsetX=0,this.attrs.offsetY=0,this.attrs.skewX=0,this.attrs.skewY=0,e}move(e){let n=e.x,s=e.y,r=this.x(),i=this.y();return n!==void 0&&(r+=n),s!==void 0&&(i+=s),this.setPosition({x:r,y:i}),this}_eachAncestorReverse(e,n){let s=[],r=this.getParent(),i,o;if(!(n&&n._id===this._id)){for(s.unshift(this);r&&(!n||r._id!==n._id);)s.unshift(r),r=r.parent;for(i=s.length,o=0;o<i;o++)e(s[o])}}rotate(e){return this.rotation(this.rotation()+e),this}moveToTop(){if(!this.parent)return le.warn("Node has no parent. moveToTop function is ignored."),!1;const e=this.index,n=this.parent.getChildren().length;return e<n-1?(this.parent.children.splice(e,1),this.parent.children.push(this),this.parent._setChildrenIndices(),!0):!1}moveUp(){if(!this.parent)return le.warn("Node has no parent. moveUp function is ignored."),!1;const e=this.index,n=this.parent.getChildren().length;return e<n-1?(this.parent.children.splice(e,1),this.parent.children.splice(e+1,0,this),this.parent._setChildrenIndices(),!0):!1}moveDown(){if(!this.parent)return le.warn("Node has no parent. moveDown function is ignored."),!1;const e=this.index;return e>0?(this.parent.children.splice(e,1),this.parent.children.splice(e-1,0,this),this.parent._setChildrenIndices(),!0):!1}moveToBottom(){if(!this.parent)return le.warn("Node has no parent. moveToBottom function is ignored."),!1;const e=this.index;return e>0?(this.parent.children.splice(e,1),this.parent.children.unshift(this),this.parent._setChildrenIndices(),!0):!1}setZIndex(e){if(!this.parent)return le.warn("Node has no parent. zIndex parameter is ignored."),this;(e<0||e>=this.parent.children.length)&&le.warn("Unexpected value "+e+" for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to "+(this.parent.children.length-1)+".");const n=this.index;return this.parent.children.splice(n,1),this.parent.children.splice(e,0,this),this.parent._setChildrenIndices(),this}getAbsoluteOpacity(){return this._getCache(Rm,this._getAbsoluteOpacity)}_getAbsoluteOpacity(){let e=this.opacity();const n=this.getParent();return n&&!n._isUnderCache&&(e*=n.getAbsoluteOpacity()),e}moveTo(e){return this.getParent()!==e&&(this._remove(),e.add(this)),this}toObject(){let e=this.getAttrs(),n,s,r,i,o;const a={attrs:{},className:this.getClassName()};for(n in e)s=e[n],o=le.isObject(s)&&!le._isPlainObject(s)&&!le._isArray(s),!o&&(r=typeof this[n]=="function"&&this[n],delete e[n],i=r?r.call(this):null,e[n]=s,i!==s&&(a.attrs[n]=s));return le._prepareToStringify(a)}toJSON(){return JSON.stringify(this.toObject())}getParent(){return this.parent}findAncestors(e,n,s){const r=[];n&&this._isMatch(e)&&r.push(this);let i=this.parent;for(;i;){if(i===s)return r;i._isMatch(e)&&r.push(i),i=i.parent}return r}isAncestorOf(e){return!1}findAncestor(e,n,s){return this.findAncestors(e,n,s)[0]}_isMatch(e){if(!e)return!1;if(typeof e=="function")return e(this);let n=e.replace(/ /g,"").split(","),s=n.length,r,i;for(r=0;r<s;r++)if(i=n[r],le.isValidSelector(i)||(le.warn('Selector "'+i+'" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'),le.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'),le.warn("Konva is awesome, right?")),i.charAt(0)==="#"){if(this.id()===i.slice(1))return!0}else if(i.charAt(0)==="."){if(this.hasName(i.slice(1)))return!0}else if(this.className===i||this.nodeType===i)return!0;return!1}getLayer(){const e=this.getParent();return e?e.getLayer():null}getStage(){return this._getCache(XT,this._getStage)}_getStage(){const e=this.getParent();return e?e.getStage():null}fire(e,n={},s){return n.target=n.target||this,s?this._fireAndBubble(e,n):this._fire(e,n),this}getAbsoluteTransform(e){return e?this._getAbsoluteTransform(e):this._getCache(lo,this._getAbsoluteTransform)}_getAbsoluteTransform(e){let n;if(e)return n=new vr,this._eachAncestorReverse(function(s){const r=s.transformsEnabled();r==="all"?n.multiply(s.getTransform()):r==="position"&&n.translate(s.x()-s.offsetX(),s.y()-s.offsetY())},e),n;{n=this._cache.get(lo)||new vr,this.parent?this.parent.getAbsoluteTransform().copyInto(n):n.reset();const s=this.transformsEnabled();if(s==="all")n.multiply(this.getTransform());else if(s==="position"){const r=this.attrs.x||0,i=this.attrs.y||0,o=this.attrs.offsetX||0,a=this.attrs.offsetY||0;n.translate(r-o,i-a)}return n.dirty=!1,n}}getAbsoluteScale(e){let n=this;for(;n;)n._isUnderCache&&(e=n),n=n.getParent();const r=this.getAbsoluteTransform(e).decompose();return{x:r.scaleX,y:r.scaleY}}getAbsoluteRotation(){return this.getAbsoluteTransform().decompose().rotation}getTransform(){return this._getCache(Bo,this._getTransform)}_getTransform(){var e,n;const s=this._cache.get(Bo)||new vr;s.reset();const r=this.x(),i=this.y(),o=He.getAngle(this.rotation()),a=(e=this.attrs.scaleX)!==null&&e!==void 0?e:1,l=(n=this.attrs.scaleY)!==null&&n!==void 0?n:1,u=this.attrs.skewX||0,c=this.attrs.skewY||0,h=this.attrs.offsetX||0,d=this.attrs.offsetY||0;return(r!==0||i!==0)&&s.translate(r,i),o!==0&&s.rotate(o),(u!==0||c!==0)&&s.skew(u,c),(a!==1||l!==1)&&s.scale(a,l),(h!==0||d!==0)&&s.translate(-1*h,-1*d),s.dirty=!1,s}clone(e){let n=le.cloneObject(this.attrs),s,r,i,o,a;for(s in e)n[s]=e[s];const l=new this.constructor(n);for(s in this.eventListeners)for(r=this.eventListeners[s],i=r.length,o=0;o<i;o++)a=r[o],a.name.indexOf(sUe)<0&&(l.eventListeners[s]||(l.eventListeners[s]=[]),l.eventListeners[s].push(a));return l}_toKonvaCanvas(e){e=e||{};const n=this.getClientRect(),s=this.getStage(),r=e.x!==void 0?e.x:Math.floor(n.x),i=e.y!==void 0?e.y:Math.floor(n.y),o=e.pixelRatio||1,a=new jo({width:e.width||Math.ceil(n.width)||(s?s.width():0),height:e.height||Math.ceil(n.height)||(s?s.height():0),pixelRatio:o}),l=a.getContext(),u=new jo({width:a.width/a.pixelRatio+Math.abs(r),height:a.height/a.pixelRatio+Math.abs(i),pixelRatio:a.pixelRatio});return e.imageSmoothingEnabled===!1&&(l._context.imageSmoothingEnabled=!1),l.save(),(r||i)&&l.translate(-1*r,-1*i),this.drawScene(a,void 0,u),l.restore(),a}toCanvas(e){return this._toKonvaCanvas(e)._canvas}toDataURL(e){e=e||{};const n=e.mimeType||null,s=e.quality||null,r=this._toKonvaCanvas(e).toDataURL(n,s);return e.callback&&e.callback(r),r}toImage(e){return new Promise((n,s)=>{try{const r=e==null?void 0:e.callback;r&&delete e.callback,le._urlToImage(this.toDataURL(e),function(i){n(i),r==null||r(i)})}catch(r){s(r)}})}toBlob(e){return new Promise((n,s)=>{try{const r=e==null?void 0:e.callback;r&&delete e.callback,this.toCanvas(e).toBlob(i=>{n(i),r==null||r(i)},e==null?void 0:e.mimeType,e==null?void 0:e.quality)}catch(r){s(r)}})}setSize(e){return this.width(e.width),this.height(e.height),this}getSize(){return{width:this.width(),height:this.height()}}getClassName(){return this.className||this.nodeType}getType(){return this.nodeType}getDragDistance(){return this.attrs.dragDistance!==void 0?this.attrs.dragDistance:this.parent?this.parent.getDragDistance():He.dragDistance}_off(e,n,s){let r=this.eventListeners[e],i,o,a;for(i=0;i<r.length;i++)if(o=r[i].name,a=r[i].handler,(o!=="konva"||n==="konva")&&(!n||o===n)&&(!s||s===a)){if(r.splice(i,1),r.length===0){delete this.eventListeners[e];break}i--}}_fireChangeEvent(e,n,s){this._fire(e+tUe,{oldVal:n,newVal:s})}addName(e){if(!this.hasName(e)){const n=this.name(),s=n?n+" "+e:e;this.name(s)}return this}hasName(e){if(!e)return!1;const n=this.name();return n?(n||"").split(/\s/g).indexOf(e)!==-1:!1}removeName(e){const n=(this.name()||"").split(/\s/g),s=n.indexOf(e);return s!==-1&&(n.splice(s,1),this.name(n.join(" "))),this}setAttr(e,n){const s=this[KT+le._capitalize(e)];return le._isFunction(s)?s.call(this,n):this._setAttr(e,n),this}_requestDraw(){if(He.autoDrawEnabled){const e=this.getLayer()||this.getStage();e==null||e.batchDraw()}}_setAttr(e,n){const s=this.attrs[e];s===n&&!le.isObject(n)||(n==null?delete this.attrs[e]:this.attrs[e]=n,this._shouldFireChangeEvents&&this._fireChangeEvent(e,s,n),this._requestDraw())}_setComponentAttr(e,n,s){let r;s!==void 0&&(r=this.attrs[e],r||(this.attrs[e]=this.getAttr(e)),this.attrs[e][n]=s,this._fireChangeEvent(e,r,s))}_fireAndBubble(e,n,s){n&&this.nodeType===jT&&(n.target=this);const r=[rUe,iUe,oUe,aUe,lUe,uUe];if(!(r.indexOf(e)!==-1&&(s&&(this===s||this.isAncestorOf&&this.isAncestorOf(s))||this.nodeType==="Stage"&&!s))){this._fire(e,n);const o=r.indexOf(e)!==-1&&s&&s.isAncestorOf&&s.isAncestorOf(this)&&!s.isAncestorOf(this.parent);(n&&!n.cancelBubble||!n)&&this.parent&&this.parent.isListening()&&!o&&(s&&s.parent?this._fireAndBubble.call(this.parent,e,n,s):this._fireAndBubble.call(this.parent,e,n))}}_getProtoListeners(e){var n,s,r;const i=(n=this._cache.get(cm))!==null&&n!==void 0?n:{};let o=i==null?void 0:i[e];if(o===void 0){o=[];let a=Object.getPrototypeOf(this);for(;a;){const l=(r=(s=a.eventListeners)===null||s===void 0?void 0:s[e])!==null&&r!==void 0?r:[];o.push(...l),a=Object.getPrototypeOf(a)}i[e]=o,this._cache.set(cm,i)}return o}_fire(e,n){n=n||{},n.currentTarget=this,n.type=e;const s=this._getProtoListeners(e);if(s)for(let i=0;i<s.length;i++)s[i].handler.call(this,n);const r=this.eventListeners[e];if(r)for(let i=0;i<r.length;i++)r[i].handler.call(this,n)}draw(){return this.drawScene(),this.drawHit(),this}_createDragElement(e){const n=e?e.pointerId:void 0,s=this.getStage(),r=this.getAbsolutePosition();if(!s)return;const i=s._getPointerById(n)||s._changedPointerPositions[0]||r;Kt._dragElements.set(this._id,{node:this,startPointerPos:i,offset:{x:i.x-r.x,y:i.y-r.y},dragStatus:"ready",pointerId:n})}startDrag(e,n=!0){Kt._dragElements.has(this._id)||this._createDragElement(e);const s=Kt._dragElements.get(this._id);s.dragStatus="dragging",this.fire("dragstart",{type:"dragstart",target:this,evt:e&&e.evt},n)}_setDragPosition(e,n){const s=this.getStage()._getPointerById(n.pointerId);if(!s)return;let r={x:s.x-n.offset.x,y:s.y-n.offset.y};const i=this.dragBoundFunc();if(i!==void 0){const o=i.call(this,r,e);o?r=o:le.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.")}(!this._lastPos||this._lastPos.x!==r.x||this._lastPos.y!==r.y)&&(this.setAbsolutePosition(r),this._requestDraw()),this._lastPos=r}stopDrag(e){const n=Kt._dragElements.get(this._id);n&&(n.dragStatus="stopped"),Kt._endDragBefore(e),Kt._endDragAfter(e)}setDraggable(e){this._setAttr("draggable",e),this._dragChange()}isDragging(){const e=Kt._dragElements.get(this._id);return e?e.dragStatus==="dragging":!1}_listenDrag(){this._dragCleanup(),this.on("mousedown.konva touchstart.konva",function(e){if(!(!(e.evt.button!==void 0)||He.dragButtons.indexOf(e.evt.button)>=0)||this.isDragging())return;let r=!1;Kt._dragElements.forEach(i=>{this.isAncestorOf(i.node)&&(r=!0)}),r||this._createDragElement(e)})}_dragChange(){if(this.attrs.draggable)this._listenDrag();else{if(this._dragCleanup(),!this.getStage())return;const n=Kt._dragElements.get(this._id),s=n&&n.dragStatus==="dragging",r=n&&n.dragStatus==="ready";s?this.stopDrag():r&&Kt._dragElements.delete(this._id)}}_dragCleanup(){this.off("mousedown.konva"),this.off("touchstart.konva")}isClientRectOnScreen(e={x:0,y:0}){const n=this.getStage();if(!n)return!1;const s={x:-e.x,y:-e.y,width:n.width()+2*e.x,height:n.height()+2*e.y};return le.haveIntersection(s,this.getClientRect())}static create(e,n){return le._isString(e)&&(e=JSON.parse(e)),this._createNode(e,n)}static _createNode(e,n){let s=Fe.prototype.getClassName.call(e),r=e.children,i,o,a;n&&(e.attrs.container=n),He[s]||(le.warn('Can not find a node with class name "'+s+'". Fallback to "Shape".'),s="Shape");const l=He[s];if(i=new l(e.attrs),r)for(o=r.length,a=0;a<o;a++)i.add(Fe._createNode(r[a]));return i}}Fe.prototype.nodeType="Node";Fe.prototype._attrsAffectingSize=[];Fe.prototype.eventListeners={};Fe.prototype.on.call(Fe.prototype,hUe,function(){if(this._batchingTransformChange){this._needClearTransformCache=!0;return}this._clearCache(Bo),this._clearSelfAndDescendantCache(lo)});Fe.prototype.on.call(Fe.prototype,"visibleChange.konva",function(){this._clearSelfAndDescendantCache(Ty)});Fe.prototype.on.call(Fe.prototype,"listeningChange.konva",function(){this._clearSelfAndDescendantCache(Cy)});Fe.prototype.on.call(Fe.prototype,"opacityChange.konva",function(){this._clearSelfAndDescendantCache(Rm)});const ln=X.addGetterSetter;ln(Fe,"zIndex");ln(Fe,"absolutePosition");ln(Fe,"position");ln(Fe,"x",0,Be());ln(Fe,"y",0,Be());ln(Fe,"globalCompositeOperation","source-over",Yl());ln(Fe,"opacity",1,Be());ln(Fe,"name","",Yl());ln(Fe,"id","",Yl());ln(Fe,"rotation",0,Be());X.addComponentsGetterSetter(Fe,"scale",["x","y"]);ln(Fe,"scaleX",1,Be());ln(Fe,"scaleY",1,Be());X.addComponentsGetterSetter(Fe,"skew",["x","y"]);ln(Fe,"skewX",0,Be());ln(Fe,"skewY",0,Be());X.addComponentsGetterSetter(Fe,"offset",["x","y"]);ln(Fe,"offsetX",0,Be());ln(Fe,"offsetY",0,Be());ln(Fe,"dragDistance",void 0,Be());ln(Fe,"width",0,Be());ln(Fe,"height",0,Be());ln(Fe,"listening",!0,bi());ln(Fe,"preventDefault",!0,bi());ln(Fe,"filters",void 0,function(t){return this._filterUpToDate=!1,t});ln(Fe,"visible",!0,bi());ln(Fe,"transformsEnabled","all",Yl());ln(Fe,"size");ln(Fe,"dragBoundFunc");ln(Fe,"draggable",!1,bi());X.backCompat(Fe,{rotateDeg:"rotate",setRotationDeg:"setRotation",getRotationDeg:"getRotation"});class Tr extends Fe{constructor(){super(...arguments),this.children=[]}getChildren(e){const n=this.children||[];return e?n.filter(e):n}hasChildren(){return this.getChildren().length>0}removeChildren(){return this.getChildren().forEach(e=>{e.parent=null,e.index=0,e.remove()}),this.children=[],this._requestDraw(),this}destroyChildren(){return this.getChildren().forEach(e=>{e.parent=null,e.index=0,e.destroy()}),this.children=[],this._requestDraw(),this}add(...e){if(e.length===0)return this;if(e.length>1){for(let s=0;s<e.length;s++)this.add(e[s]);return this}const n=e[0];return n.getParent()?(n.moveTo(this),this):(this._validateAdd(n),n.index=this.getChildren().length,n.parent=this,n._clearCaches(),this.getChildren().push(n),this._fire("add",{child:n}),this._requestDraw(),this)}destroy(){return this.hasChildren()&&this.destroyChildren(),super.destroy(),this}find(e){return this._generalFind(e,!1)}findOne(e){const n=this._generalFind(e,!0);return n.length>0?n[0]:void 0}_generalFind(e,n){const s=[];return this._descendants(r=>{const i=r._isMatch(e);return i&&s.push(r),!!(i&&n)}),s}_descendants(e){let n=!1;const s=this.getChildren();for(const r of s){if(n=e(r),n)return!0;if(r.hasChildren()&&(n=r._descendants(e),n))return!0}return!1}toObject(){const e=Fe.prototype.toObject.call(this);return e.children=[],this.getChildren().forEach(n=>{e.children.push(n.toObject())}),e}isAncestorOf(e){let n=e.getParent();for(;n;){if(n._id===this._id)return!0;n=n.getParent()}return!1}clone(e){const n=Fe.prototype.clone.call(this,e);return this.getChildren().forEach(function(s){n.add(s.clone())}),n}getAllIntersections(e){const n=[];return this.find("Shape").forEach(s=>{s.isVisible()&&s.intersects(e)&&n.push(s)}),n}_clearSelfAndDescendantCache(e){var n;super._clearSelfAndDescendantCache(e),!this.isCached()&&((n=this.children)===null||n===void 0||n.forEach(function(s){s._clearSelfAndDescendantCache(e)}))}_setChildrenIndices(){var e;(e=this.children)===null||e===void 0||e.forEach(function(n,s){n.index=s}),this._requestDraw()}drawScene(e,n,s){const r=this.getLayer(),i=e||r&&r.getCanvas(),o=i&&i.getContext(),a=this._getCanvasCache(),l=a&&a.scene,u=i&&i.isCache;if(!this.isVisible()&&!u)return this;if(l){o.save();const c=this.getAbsoluteTransform(n).getMatrix();o.transform(c[0],c[1],c[2],c[3],c[4],c[5]),this._drawCachedSceneCanvas(o),o.restore()}else this._drawChildren("drawScene",i,n,s);return this}drawHit(e,n){if(!this.shouldDrawHit(n))return this;const s=this.getLayer(),r=e||s&&s.hitCanvas,i=r&&r.getContext(),o=this._getCanvasCache();if(o&&o.hit){i.save();const l=this.getAbsoluteTransform(n).getMatrix();i.transform(l[0],l[1],l[2],l[3],l[4],l[5]),this._drawCachedHitCanvas(i),i.restore()}else this._drawChildren("drawHit",r,n);return this}_drawChildren(e,n,s,r){var i;const o=n&&n.getContext(),a=this.clipWidth(),l=this.clipHeight(),u=this.clipFunc(),c=typeof a=="number"&&typeof l=="number"||u,h=s===this;if(c){o.save();const f=this.getAbsoluteTransform(s);let p=f.getMatrix();o.transform(p[0],p[1],p[2],p[3],p[4],p[5]),o.beginPath();let g;if(u)g=u.call(this,o,this);else{const m=this.clipX(),x=this.clipY();o.rect(m||0,x||0,a,l)}o.clip.apply(o,g),p=f.copy().invert().getMatrix(),o.transform(p[0],p[1],p[2],p[3],p[4],p[5])}const d=!h&&this.globalCompositeOperation()!=="source-over"&&e==="drawScene";d&&(o.save(),o._applyGlobalCompositeOperation(this)),(i=this.children)===null||i===void 0||i.forEach(function(f){f[e](n,s,r)}),d&&o.restore(),c&&o.restore()}getClientRect(e={}){var n;const s=e.skipTransform,r=e.relativeTo;let i,o,a,l,u={x:1/0,y:1/0,width:0,height:0};const c=this;(n=this.children)===null||n===void 0||n.forEach(function(f){if(!f.visible())return;const p=f.getClientRect({relativeTo:c,skipShadow:e.skipShadow,skipStroke:e.skipStroke});p.width===0&&p.height===0||(i===void 0?(i=p.x,o=p.y,a=p.x+p.width,l=p.y+p.height):(i=Math.min(i,p.x),o=Math.min(o,p.y),a=Math.max(a,p.x+p.width),l=Math.max(l,p.y+p.height)))});const h=this.find("Shape");let d=!1;for(let f=0;f<h.length;f++)if(h[f]._isVisible(this)){d=!0;break}return d&&i!==void 0?u={x:i,y:o,width:a-i,height:l-o}:u={x:0,y:0,width:0,height:0},s?u:this._transformedRect(u,r)}}X.addComponentsGetterSetter(Tr,"clip",["x","y","width","height"]);X.addGetterSetter(Tr,"clipX",void 0,Be());X.addGetterSetter(Tr,"clipY",void 0,Be());X.addGetterSetter(Tr,"clipWidth",void 0,Be());X.addGetterSetter(Tr,"clipHeight",void 0,Be());X.addGetterSetter(Tr,"clipFunc");const zd=new Map,A4=He._global.PointerEvent!==void 0;function n1(t){return zd.get(t)}function $w(t){return{evt:t,pointerId:t.pointerId}}function P4(t,e){return zd.get(t)===e}function D4(t,e){ad(t),e.getStage()&&(zd.set(t,e),A4&&e._fire("gotpointercapture",$w(new PointerEvent("gotpointercapture"))))}function ad(t,e){const n=zd.get(t);if(!n)return;const s=n.getStage();s&&s.content,zd.delete(t),A4&&n._fire("lostpointercapture",$w(new PointerEvent("lostpointercapture")))}const fUe="Stage",pUe="string",qT="px",mUe="mouseout",N4="mouseleave",M4="mouseover",L4="mouseenter",O4="mousemove",F4="mousedown",U4="mouseup",zh="pointermove",Gh="pointerdown",Tu="pointerup",Vh="pointercancel",gUe="lostpointercapture",hm="pointerout",Wh="pointerleave",dm="pointerover",fm="pointerenter",Iy="contextmenu",B4="touchstart",z4="touchend",G4="touchmove",V4="touchcancel",ky="wheel",xUe=5,bUe=[[L4,"_pointerenter"],[F4,"_pointerdown"],[O4,"_pointermove"],[U4,"_pointerup"],[N4,"_pointerleave"],[B4,"_pointerdown"],[G4,"_pointermove"],[z4,"_pointerup"],[V4,"_pointercancel"],[M4,"_pointerover"],[ky,"_wheel"],[Iy,"_contextmenu"],[Gh,"_pointerdown"],[zh,"_pointermove"],[Tu,"_pointerup"],[Vh,"_pointercancel"],[Wh,"_pointerleave"],[gUe,"_lostpointercapture"]],s1={mouse:{[hm]:mUe,[Wh]:N4,[dm]:M4,[fm]:L4,[zh]:O4,[Gh]:F4,[Tu]:U4,[Vh]:"mousecancel",pointerclick:"click",pointerdblclick:"dblclick"},touch:{[hm]:"touchout",[Wh]:"touchleave",[dm]:"touchover",[fm]:"touchenter",[zh]:G4,[Gh]:B4,[Tu]:z4,[Vh]:V4,pointerclick:"tap",pointerdblclick:"dbltap"},pointer:{[hm]:hm,[Wh]:Wh,[dm]:dm,[fm]:fm,[zh]:zh,[Gh]:Gh,[Tu]:Tu,[Vh]:Vh,pointerclick:"pointerclick",pointerdblclick:"pointerdblclick"}},Hh=t=>t.indexOf("pointer")>=0?"pointer":t.indexOf("touch")>=0?"touch":"mouse",hu=t=>{const e=Hh(t);if(e==="pointer")return He.pointerEventsEnabled&&s1.pointer;if(e==="touch")return s1.touch;if(e==="mouse")return s1.mouse};function YT(t={}){return(t.clipFunc||t.clipWidth||t.clipHeight)&&le.warn("Stage does not support clipping. Please use clip for Layers or Groups."),t}const yUe="Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);",ld=[];class tb extends Tr{constructor(e){super(YT(e)),this._pointerPositions=[],this._changedPointerPositions=[],this._buildDOM(),this._bindContentEvents(),ld.push(this),this.on("widthChange.konva heightChange.konva",this._resizeDOM),this.on("visibleChange.konva",this._checkVisibility),this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva",()=>{YT(this.attrs)}),this._checkVisibility()}_validateAdd(e){const n=e.getType()==="Layer",s=e.getType()==="FastLayer";n||s||le.throw("You may only add layers to the stage.")}_checkVisibility(){if(!this.content)return;const e=this.visible()?"":"none";this.content.style.display=e}setContainer(e){if(typeof e===pUe){let n;if(e.charAt(0)==="."){const s=e.slice(1);e=document.getElementsByClassName(s)[0]}else e.charAt(0)!=="#"?n=e:n=e.slice(1),e=document.getElementById(n);if(!e)throw"Can not find container in document with id "+n}return this._setAttr("container",e),this.content&&(this.content.parentElement&&this.content.parentElement.removeChild(this.content),e.appendChild(this.content)),this}shouldDrawHit(){return!0}clear(){const e=this.children,n=e.length;for(let s=0;s<n;s++)e[s].clear();return this}clone(e){return e||(e={}),e.container=typeof document<"u"&&document.createElement("div"),Tr.prototype.clone.call(this,e)}destroy(){super.destroy();const e=this.content;e&&le._isInDocument(e)&&this.container().removeChild(e);const n=ld.indexOf(this);return n>-1&&ld.splice(n,1),le.releaseCanvas(this.bufferCanvas._canvas,this.bufferHitCanvas._canvas),this}getPointerPosition(){const e=this._pointerPositions[0]||this._changedPointerPositions[0];return e?{x:e.x,y:e.y}:(le.warn(yUe),null)}_getPointerById(e){return this._pointerPositions.find(n=>n.id===e)}getPointersPositions(){return this._pointerPositions}getStage(){return this}getContent(){return this.content}_toKonvaCanvas(e){e={...e},e.x=e.x||0,e.y=e.y||0,e.width=e.width||this.width(),e.height=e.height||this.height();const n=new jo({width:e.width,height:e.height,pixelRatio:e.pixelRatio||1}),s=n.getContext()._context,r=this.children;return(e.x||e.y)&&s.translate(-1*e.x,-1*e.y),r.forEach(function(i){if(!i.isVisible())return;const o=i._toKonvaCanvas(e);s.drawImage(o._canvas,e.x,e.y,o.getWidth()/o.getPixelRatio(),o.getHeight()/o.getPixelRatio())}),n}getIntersection(e){if(!e)return null;const n=this.children,s=n.length,r=s-1;for(let i=r;i>=0;i--){const o=n[i].getIntersection(e);if(o)return o}return null}_resizeDOM(){const e=this.width(),n=this.height();this.content&&(this.content.style.width=e+qT,this.content.style.height=n+qT),this.bufferCanvas.setSize(e,n),this.bufferHitCanvas.setSize(e,n),this.children.forEach(s=>{s.setSize({width:e,height:n}),s.draw()})}add(e,...n){if(arguments.length>1){for(let r=0;r<arguments.length;r++)this.add(arguments[r]);return this}super.add(e);const s=this.children.length;return s>xUe&&le.warn("The stage has "+s+" layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."),e.setSize({width:this.width(),height:this.height()}),e.draw(),He.isBrowser&&this.content.appendChild(e.canvas._canvas),this}getParent(){return null}getLayer(){return null}hasPointerCapture(e){return P4(e,this)}setPointerCapture(e){D4(e,this)}releaseCapture(e){ad(e)}getLayers(){return this.children}_bindContentEvents(){He.isBrowser&&bUe.forEach(([e,n])=>{this.content.addEventListener(e,s=>{this[n](s)},{passive:!1})})}_pointerenter(e){this.setPointersPositions(e);const n=hu(e.type);n&&this._fire(n.pointerenter,{evt:e,target:this,currentTarget:this})}_pointerover(e){this.setPointersPositions(e);const n=hu(e.type);n&&this._fire(n.pointerover,{evt:e,target:this,currentTarget:this})}_getTargetShape(e){let n=this[e+"targetShape"];return n&&!n.getStage()&&(n=null),n}_pointerleave(e){const n=hu(e.type),s=Hh(e.type);if(!n)return;this.setPointersPositions(e);const r=this._getTargetShape(s),i=!(He.isDragging()||He.isTransforming())||He.hitOnDragEnabled;r&&i?(r._fireAndBubble(n.pointerout,{evt:e}),r._fireAndBubble(n.pointerleave,{evt:e}),this._fire(n.pointerleave,{evt:e,target:this,currentTarget:this}),this[s+"targetShape"]=null):i&&(this._fire(n.pointerleave,{evt:e,target:this,currentTarget:this}),this._fire(n.pointerout,{evt:e,target:this,currentTarget:this})),this.pointerPos=null,this._pointerPositions=[]}_pointerdown(e){const n=hu(e.type),s=Hh(e.type);if(!n)return;this.setPointersPositions(e);let r=!1;this._changedPointerPositions.forEach(i=>{const o=this.getIntersection(i);if(Kt.justDragged=!1,He["_"+s+"ListenClick"]=!0,!o||!o.isListening()){this[s+"ClickStartShape"]=void 0;return}He.capturePointerEventsEnabled&&o.setPointerCapture(i.id),this[s+"ClickStartShape"]=o,o._fireAndBubble(n.pointerdown,{evt:e,pointerId:i.id}),r=!0;const a=e.type.indexOf("touch")>=0;o.preventDefault()&&e.cancelable&&a&&e.preventDefault()}),r||this._fire(n.pointerdown,{evt:e,target:this,currentTarget:this,pointerId:this._pointerPositions[0].id})}_pointermove(e){const n=hu(e.type),s=Hh(e.type);if(!n)return;const r=e.type.indexOf("touch")>=0||e.pointerType==="touch";if(He.isDragging()&&Kt.node.preventDefault()&&e.cancelable&&r&&e.preventDefault(),this.setPointersPositions(e),!(!(He.isDragging()||He.isTransforming())||He.hitOnDragEnabled))return;const o={};let a=!1;const l=this._getTargetShape(s);this._changedPointerPositions.forEach(u=>{const c=n1(u.id)||this.getIntersection(u),h=u.id,d={evt:e,pointerId:h},f=l!==c;if(f&&l&&(l._fireAndBubble(n.pointerout,{...d},c),l._fireAndBubble(n.pointerleave,{...d},c)),c){if(o[c._id])return;o[c._id]=!0}c&&c.isListening()?(a=!0,f&&(c._fireAndBubble(n.pointerover,{...d},l),c._fireAndBubble(n.pointerenter,{...d},l),this[s+"targetShape"]=c),c._fireAndBubble(n.pointermove,{...d})):l&&(this._fire(n.pointerover,{evt:e,target:this,currentTarget:this,pointerId:h}),this[s+"targetShape"]=null)}),a||this._fire(n.pointermove,{evt:e,target:this,currentTarget:this,pointerId:this._changedPointerPositions[0].id})}_pointerup(e){const n=hu(e.type),s=Hh(e.type);if(!n)return;this.setPointersPositions(e);const r=this[s+"ClickStartShape"],i=this[s+"ClickEndShape"],o={};let a=!1;this._changedPointerPositions.forEach(l=>{const u=n1(l.id)||this.getIntersection(l);if(u){if(u.releaseCapture(l.id),o[u._id])return;o[u._id]=!0}const c=l.id,h={evt:e,pointerId:c};let d=!1;He["_"+s+"InDblClickWindow"]?(d=!0,clearTimeout(this[s+"DblTimeout"])):Kt.justDragged||(He["_"+s+"InDblClickWindow"]=!0,clearTimeout(this[s+"DblTimeout"])),this[s+"DblTimeout"]=setTimeout(function(){He["_"+s+"InDblClickWindow"]=!1},He.dblClickWindow),u&&u.isListening()?(a=!0,this[s+"ClickEndShape"]=u,u._fireAndBubble(n.pointerup,{...h}),He["_"+s+"ListenClick"]&&r&&r===u&&(u._fireAndBubble(n.pointerclick,{...h}),d&&i&&i===u&&u._fireAndBubble(n.pointerdblclick,{...h}))):(this[s+"ClickEndShape"]=null,a||(this._fire(n.pointerup,{evt:e,target:this,currentTarget:this,pointerId:this._changedPointerPositions[0].id}),a=!0),He["_"+s+"ListenClick"]&&this._fire(n.pointerclick,{evt:e,target:this,currentTarget:this,pointerId:c}),d&&this._fire(n.pointerdblclick,{evt:e,target:this,currentTarget:this,pointerId:c}))}),a||this._fire(n.pointerup,{evt:e,target:this,currentTarget:this,pointerId:this._changedPointerPositions[0].id}),He["_"+s+"ListenClick"]=!1,e.cancelable&&s!=="touch"&&s!=="pointer"&&e.preventDefault()}_contextmenu(e){this.setPointersPositions(e);const n=this.getIntersection(this.getPointerPosition());n&&n.isListening()?n._fireAndBubble(Iy,{evt:e}):this._fire(Iy,{evt:e,target:this,currentTarget:this})}_wheel(e){this.setPointersPositions(e);const n=this.getIntersection(this.getPointerPosition());n&&n.isListening()?n._fireAndBubble(ky,{evt:e}):this._fire(ky,{evt:e,target:this,currentTarget:this})}_pointercancel(e){this.setPointersPositions(e);const n=n1(e.pointerId)||this.getIntersection(this.getPointerPosition());n&&n._fireAndBubble(Tu,$w(e)),ad(e.pointerId)}_lostpointercapture(e){ad(e.pointerId)}setPointersPositions(e){const n=this._getContentPosition();let s=null,r=null;e=e||window.event,e.touches!==void 0?(this._pointerPositions=[],this._changedPointerPositions=[],Array.prototype.forEach.call(e.touches,i=>{this._pointerPositions.push({id:i.identifier,x:(i.clientX-n.left)/n.scaleX,y:(i.clientY-n.top)/n.scaleY})}),Array.prototype.forEach.call(e.changedTouches||e.touches,i=>{this._changedPointerPositions.push({id:i.identifier,x:(i.clientX-n.left)/n.scaleX,y:(i.clientY-n.top)/n.scaleY})})):(s=(e.clientX-n.left)/n.scaleX,r=(e.clientY-n.top)/n.scaleY,this.pointerPos={x:s,y:r},this._pointerPositions=[{x:s,y:r,id:le._getFirstPointerId(e)}],this._changedPointerPositions=[{x:s,y:r,id:le._getFirstPointerId(e)}])}_setPointerPosition(e){le.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'),this.setPointersPositions(e)}_getContentPosition(){if(!this.content||!this.content.getBoundingClientRect)return{top:0,left:0,scaleX:1,scaleY:1};const e=this.content.getBoundingClientRect();return{top:e.top,left:e.left,scaleX:e.width/this.content.clientWidth||1,scaleY:e.height/this.content.clientHeight||1}}_buildDOM(){if(this.bufferCanvas=new jo({width:this.width(),height:this.height()}),this.bufferHitCanvas=new Ew({pixelRatio:1,width:this.width(),height:this.height()}),!He.isBrowser)return;const e=this.container();if(!e)throw"Stage has no container. A container is required.";e.innerHTML="",this.content=document.createElement("div"),this.content.style.position="relative",this.content.style.userSelect="none",this.content.className="konvajs-content",this.content.setAttribute("role","presentation"),e.appendChild(this.content),this._resizeDOM()}cache(){return le.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."),this}clearCache(){return this}batchDraw(){return this.getChildren().forEach(function(e){e.batchDraw()}),this}}tb.prototype.nodeType=fUe;Rn(tb);X.addGetterSetter(tb,"container");He.isBrowser&&document.addEventListener("visibilitychange",()=>{ld.forEach(t=>{t.batchDraw()})});const W4="hasShadow",H4="shadowRGBA",K4="patternImage",j4="linearGradient",X4="radialGradient";let pm;function r1(){return pm||(pm=le.createCanvasElement().getContext("2d"),pm)}const ud={};function vUe(t){const e=this.attrs.fillRule;e?t.fill(e):t.fill()}function wUe(t){t.stroke()}function SUe(t){const e=this.attrs.fillRule;e?t.fill(e):t.fill()}function CUe(t){t.stroke()}function TUe(){this._clearCache(W4)}function IUe(){this._clearCache(H4)}function kUe(){this._clearCache(K4)}function EUe(){this._clearCache(j4)}function _Ue(){this._clearCache(X4)}class Ne extends Fe{constructor(e){super(e);let n,s=0;for(;n=le.getHitColor(),!(n&&!(n in ud));)if(s++,s>=1e4){le.warn("Failed to find a unique color key for a shape. Konva may work incorrectly. Most likely your browser is using canvas farbling. Consider disabling it."),n=le.getRandomColor();break}this.colorKey=n,ud[n]=this}getContext(){return le.warn("shape.getContext() method is deprecated. Please do not use it."),this.getLayer().getContext()}getCanvas(){return le.warn("shape.getCanvas() method is deprecated. Please do not use it."),this.getLayer().getCanvas()}getSceneFunc(){return this.attrs.sceneFunc||this._sceneFunc}getHitFunc(){return this.attrs.hitFunc||this._hitFunc}hasShadow(){return this._getCache(W4,this._hasShadow)}_hasShadow(){return this.shadowEnabled()&&this.shadowOpacity()!==0&&!!(this.shadowColor()||this.shadowBlur()||this.shadowOffsetX()||this.shadowOffsetY())}_getFillPattern(){return this._getCache(K4,this.__getFillPattern)}__getFillPattern(){if(this.fillPatternImage()){const n=r1().createPattern(this.fillPatternImage(),this.fillPatternRepeat()||"repeat");if(n&&n.setTransform){const s=new vr;s.translate(this.fillPatternX(),this.fillPatternY()),s.rotate(He.getAngle(this.fillPatternRotation())),s.scale(this.fillPatternScaleX(),this.fillPatternScaleY()),s.translate(-1*this.fillPatternOffsetX(),-1*this.fillPatternOffsetY());const r=s.getMatrix(),i=typeof DOMMatrix>"u"?{a:r[0],b:r[1],c:r[2],d:r[3],e:r[4],f:r[5]}:new DOMMatrix(r);n.setTransform(i)}return n}}_getLinearGradient(){return this._getCache(j4,this.__getLinearGradient)}__getLinearGradient(){const e=this.fillLinearGradientColorStops();if(e){const n=r1(),s=this.fillLinearGradientStartPoint(),r=this.fillLinearGradientEndPoint(),i=n.createLinearGradient(s.x,s.y,r.x,r.y);for(let o=0;o<e.length;o+=2)i.addColorStop(e[o],e[o+1]);return i}}_getRadialGradient(){return this._getCache(X4,this.__getRadialGradient)}__getRadialGradient(){const e=this.fillRadialGradientColorStops();if(e){const n=r1(),s=this.fillRadialGradientStartPoint(),r=this.fillRadialGradientEndPoint(),i=n.createRadialGradient(s.x,s.y,this.fillRadialGradientStartRadius(),r.x,r.y,this.fillRadialGradientEndRadius());for(let o=0;o<e.length;o+=2)i.addColorStop(e[o],e[o+1]);return i}}getShadowRGBA(){return this._getCache(H4,this._getShadowRGBA)}_getShadowRGBA(){if(!this.hasShadow())return;const e=le.colorToRGBA(this.shadowColor());if(e)return"rgba("+e.r+","+e.g+","+e.b+","+e.a*(this.shadowOpacity()||1)+")"}hasFill(){return this._calculate("hasFill",["fillEnabled","fill","fillPatternImage","fillLinearGradientColorStops","fillRadialGradientColorStops"],()=>this.fillEnabled()&&!!(this.fill()||this.fillPatternImage()||this.fillLinearGradientColorStops()||this.fillRadialGradientColorStops()))}hasStroke(){return this._calculate("hasStroke",["strokeEnabled","strokeWidth","stroke","strokeLinearGradientColorStops"],()=>this.strokeEnabled()&&this.strokeWidth()&&!!(this.stroke()||this.strokeLinearGradientColorStops()))}hasHitStroke(){const e=this.hitStrokeWidth();return e==="auto"?this.hasStroke():this.strokeEnabled()&&!!e}intersects(e){const n=this.getStage();if(!n)return!1;const s=n.bufferHitCanvas;return s.getContext().clear(),this.drawHit(s,void 0,!0),s.context.getImageData(Math.round(e.x),Math.round(e.y),1,1).data[3]>0}destroy(){return Fe.prototype.destroy.call(this),delete ud[this.colorKey],delete this.colorKey,this}_useBufferCanvas(e){var n;if(!((n=this.attrs.perfectDrawEnabled)!==null&&n!==void 0?n:!0))return!1;const r=e||this.hasFill(),i=this.hasStroke(),o=this.getAbsoluteOpacity()!==1;if(r&&i&&o)return!0;const a=this.hasShadow(),l=this.shadowForStrokeEnabled();return!!(r&&i&&a&&l)}setStrokeHitEnabled(e){le.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."),e?this.hitStrokeWidth("auto"):this.hitStrokeWidth(0)}getStrokeHitEnabled(){return this.hitStrokeWidth()!==0}getSelfRect(){const e=this.size();return{x:this._centroid?-e.width/2:0,y:this._centroid?-e.height/2:0,width:e.width,height:e.height}}getClientRect(e={}){let n=!1,s=this.getParent();for(;s;){if(s.isCached()){n=!0;break}s=s.getParent()}const r=e.skipTransform,i=e.relativeTo||n&&this.getStage()||void 0,o=this.getSelfRect(),l=!e.skipStroke&&this.hasStroke()&&this.strokeWidth()||0,u=o.width+l,c=o.height+l,h=!e.skipShadow&&this.hasShadow(),d=h?this.shadowOffsetX():0,f=h?this.shadowOffsetY():0,p=u+Math.abs(d),g=c+Math.abs(f),m=h&&this.shadowBlur()||0,x=p+m*2,b=g+m*2,v={width:x,height:b,x:-(l/2+m)+Math.min(d,0)+o.x,y:-(l/2+m)+Math.min(f,0)+o.y};return r?v:this._transformedRect(v,i)}drawScene(e,n,s){const r=this.getLayer(),i=e||r.getCanvas(),o=i.getContext(),a=this._getCanvasCache(),l=this.getSceneFunc(),u=this.hasShadow();let c;const h=n===this;if(!this.isVisible()&&!h)return this;if(a){o.save();const d=this.getAbsoluteTransform(n).getMatrix();return o.transform(d[0],d[1],d[2],d[3],d[4],d[5]),this._drawCachedSceneCanvas(o),o.restore(),this}if(!l)return this;if(o.save(),this._useBufferCanvas()){c=this.getStage();const d=s||c.bufferCanvas,f=d.getContext();f.clear(),f.save(),f._applyLineJoin(this),f._applyMiterLimit(this);const p=this.getAbsoluteTransform(n).getMatrix();f.transform(p[0],p[1],p[2],p[3],p[4],p[5]),l.call(this,f,this),f.restore();const g=d.pixelRatio;u&&o._applyShadow(this),h||(o._applyOpacity(this),o._applyGlobalCompositeOperation(this)),o.drawImage(d._canvas,d.x||0,d.y||0,d.width/g,d.height/g)}else{if(o._applyLineJoin(this),o._applyMiterLimit(this),!h){const d=this.getAbsoluteTransform(n).getMatrix();o.transform(d[0],d[1],d[2],d[3],d[4],d[5]),o._applyOpacity(this),o._applyGlobalCompositeOperation(this)}u&&o._applyShadow(this),l.call(this,o,this)}return o.restore(),this}drawHit(e,n,s=!1){if(!this.shouldDrawHit(n,s))return this;const r=this.getLayer(),i=e||r.hitCanvas,o=i&&i.getContext(),a=this.hitFunc()||this.sceneFunc(),l=this._getCanvasCache(),u=l&&l.hit;if(this.colorKey||le.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"),u){o.save();const h=this.getAbsoluteTransform(n).getMatrix();return o.transform(h[0],h[1],h[2],h[3],h[4],h[5]),this._drawCachedHitCanvas(o),o.restore(),this}if(!a)return this;if(o.save(),o._applyLineJoin(this),o._applyMiterLimit(this),!(this===n)){const h=this.getAbsoluteTransform(n).getMatrix();o.transform(h[0],h[1],h[2],h[3],h[4],h[5])}return a.call(this,o,this),o.restore(),this}drawHitFromCache(e=0){const n=this._getCanvasCache(),s=this._getCachedSceneCanvas(),r=n.hit,i=r.getContext(),o=r.getWidth(),a=r.getHeight();i.clear(),i.drawImage(s._canvas,0,0,o,a);try{const l=i.getImageData(0,0,o,a),u=l.data,c=u.length,h=le._hexToRgb(this.colorKey);for(let d=0;d<c;d+=4)u[d+3]>e?(u[d]=h.r,u[d+1]=h.g,u[d+2]=h.b,u[d+3]=255):u[d+3]=0;i.putImageData(l,0,0)}catch(l){le.error("Unable to draw hit graph from cached scene canvas. "+l.message)}return this}hasPointerCapture(e){return P4(e,this)}setPointerCapture(e){D4(e,this)}releaseCapture(e){ad(e)}}Ne.prototype._fillFunc=vUe;Ne.prototype._strokeFunc=wUe;Ne.prototype._fillFuncHit=SUe;Ne.prototype._strokeFuncHit=CUe;Ne.prototype._centroid=!1;Ne.prototype.nodeType="Shape";Rn(Ne);Ne.prototype.eventListeners={};Ne.prototype.on.call(Ne.prototype,"shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva",TUe);Ne.prototype.on.call(Ne.prototype,"shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva",IUe);Ne.prototype.on.call(Ne.prototype,"fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva",kUe);Ne.prototype.on.call(Ne.prototype,"fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva",EUe);Ne.prototype.on.call(Ne.prototype,"fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva",_Ue);X.addGetterSetter(Ne,"stroke",void 0,R4());X.addGetterSetter(Ne,"strokeWidth",2,Be());X.addGetterSetter(Ne,"fillAfterStrokeEnabled",!1);X.addGetterSetter(Ne,"hitStrokeWidth","auto",_w());X.addGetterSetter(Ne,"strokeHitEnabled",!0,bi());X.addGetterSetter(Ne,"perfectDrawEnabled",!0,bi());X.addGetterSetter(Ne,"shadowForStrokeEnabled",!0,bi());X.addGetterSetter(Ne,"lineJoin");X.addGetterSetter(Ne,"lineCap");X.addGetterSetter(Ne,"miterLimit");X.addGetterSetter(Ne,"sceneFunc");X.addGetterSetter(Ne,"hitFunc");X.addGetterSetter(Ne,"dash");X.addGetterSetter(Ne,"dashOffset",0,Be());X.addGetterSetter(Ne,"shadowColor",void 0,Yl());X.addGetterSetter(Ne,"shadowBlur",0,Be());X.addGetterSetter(Ne,"shadowOpacity",1,Be());X.addComponentsGetterSetter(Ne,"shadowOffset",["x","y"]);X.addGetterSetter(Ne,"shadowOffsetX",0,Be());X.addGetterSetter(Ne,"shadowOffsetY",0,Be());X.addGetterSetter(Ne,"fillPatternImage");X.addGetterSetter(Ne,"fill",void 0,R4());X.addGetterSetter(Ne,"fillPatternX",0,Be());X.addGetterSetter(Ne,"fillPatternY",0,Be());X.addGetterSetter(Ne,"fillLinearGradientColorStops");X.addGetterSetter(Ne,"strokeLinearGradientColorStops");X.addGetterSetter(Ne,"fillRadialGradientStartRadius",0);X.addGetterSetter(Ne,"fillRadialGradientEndRadius",0);X.addGetterSetter(Ne,"fillRadialGradientColorStops");X.addGetterSetter(Ne,"fillPatternRepeat","repeat");X.addGetterSetter(Ne,"fillEnabled",!0);X.addGetterSetter(Ne,"strokeEnabled",!0);X.addGetterSetter(Ne,"shadowEnabled",!0);X.addGetterSetter(Ne,"dashEnabled",!0);X.addGetterSetter(Ne,"strokeScaleEnabled",!0);X.addGetterSetter(Ne,"fillPriority","color");X.addComponentsGetterSetter(Ne,"fillPatternOffset",["x","y"]);X.addGetterSetter(Ne,"fillPatternOffsetX",0,Be());X.addGetterSetter(Ne,"fillPatternOffsetY",0,Be());X.addComponentsGetterSetter(Ne,"fillPatternScale",["x","y"]);X.addGetterSetter(Ne,"fillPatternScaleX",1,Be());X.addGetterSetter(Ne,"fillPatternScaleY",1,Be());X.addComponentsGetterSetter(Ne,"fillLinearGradientStartPoint",["x","y"]);X.addComponentsGetterSetter(Ne,"strokeLinearGradientStartPoint",["x","y"]);X.addGetterSetter(Ne,"fillLinearGradientStartPointX",0);X.addGetterSetter(Ne,"strokeLinearGradientStartPointX",0);X.addGetterSetter(Ne,"fillLinearGradientStartPointY",0);X.addGetterSetter(Ne,"strokeLinearGradientStartPointY",0);X.addComponentsGetterSetter(Ne,"fillLinearGradientEndPoint",["x","y"]);X.addComponentsGetterSetter(Ne,"strokeLinearGradientEndPoint",["x","y"]);X.addGetterSetter(Ne,"fillLinearGradientEndPointX",0);X.addGetterSetter(Ne,"strokeLinearGradientEndPointX",0);X.addGetterSetter(Ne,"fillLinearGradientEndPointY",0);X.addGetterSetter(Ne,"strokeLinearGradientEndPointY",0);X.addComponentsGetterSetter(Ne,"fillRadialGradientStartPoint",["x","y"]);X.addGetterSetter(Ne,"fillRadialGradientStartPointX",0);X.addGetterSetter(Ne,"fillRadialGradientStartPointY",0);X.addComponentsGetterSetter(Ne,"fillRadialGradientEndPoint",["x","y"]);X.addGetterSetter(Ne,"fillRadialGradientEndPointX",0);X.addGetterSetter(Ne,"fillRadialGradientEndPointY",0);X.addGetterSetter(Ne,"fillPatternRotation",0);X.addGetterSetter(Ne,"fillRule",void 0,Yl());X.backCompat(Ne,{dashArray:"dash",getDashArray:"getDash",setDashArray:"getDash",drawFunc:"sceneFunc",getDrawFunc:"getSceneFunc",setDrawFunc:"setSceneFunc",drawHitFunc:"hitFunc",getDrawHitFunc:"getHitFunc",setDrawHitFunc:"setHitFunc"});const $Ue="beforeDraw",RUe="draw",q4=[{x:0,y:0},{x:-1,y:-1},{x:1,y:-1},{x:1,y:1},{x:-1,y:1}],AUe=q4.length;class Zl extends Tr{constructor(e){super(e),this.canvas=new jo,this.hitCanvas=new Ew({pixelRatio:1}),this._waitingForDraw=!1,this.on("visibleChange.konva",this._checkVisibility),this._checkVisibility(),this.on("imageSmoothingEnabledChange.konva",this._setSmoothEnabled),this._setSmoothEnabled()}createPNGStream(){return this.canvas._canvas.createPNGStream()}getCanvas(){return this.canvas}getNativeCanvasElement(){return this.canvas._canvas}getHitCanvas(){return this.hitCanvas}getContext(){return this.getCanvas().getContext()}clear(e){return this.getContext().clear(e),this.getHitCanvas().getContext().clear(e),this}setZIndex(e){super.setZIndex(e);const n=this.getStage();return n&&n.content&&(n.content.removeChild(this.getNativeCanvasElement()),e<n.children.length-1?n.content.insertBefore(this.getNativeCanvasElement(),n.children[e+1].getCanvas()._canvas):n.content.appendChild(this.getNativeCanvasElement())),this}moveToTop(){Fe.prototype.moveToTop.call(this);const e=this.getStage();return e&&e.content&&(e.content.removeChild(this.getNativeCanvasElement()),e.content.appendChild(this.getNativeCanvasElement())),!0}moveUp(){if(!Fe.prototype.moveUp.call(this))return!1;const n=this.getStage();return!n||!n.content?!1:(n.content.removeChild(this.getNativeCanvasElement()),this.index<n.children.length-1?n.content.insertBefore(this.getNativeCanvasElement(),n.children[this.index+1].getCanvas()._canvas):n.content.appendChild(this.getNativeCanvasElement()),!0)}moveDown(){if(Fe.prototype.moveDown.call(this)){const e=this.getStage();if(e){const n=e.children;e.content&&(e.content.removeChild(this.getNativeCanvasElement()),e.content.insertBefore(this.getNativeCanvasElement(),n[this.index+1].getCanvas()._canvas))}return!0}return!1}moveToBottom(){if(Fe.prototype.moveToBottom.call(this)){const e=this.getStage();if(e){const n=e.children;e.content&&(e.content.removeChild(this.getNativeCanvasElement()),e.content.insertBefore(this.getNativeCanvasElement(),n[1].getCanvas()._canvas))}return!0}return!1}getLayer(){return this}remove(){const e=this.getNativeCanvasElement();return Fe.prototype.remove.call(this),e&&e.parentNode&&le._isInDocument(e)&&e.parentNode.removeChild(e),this}getStage(){return this.parent}setSize({width:e,height:n}){return this.canvas.setSize(e,n),this.hitCanvas.setSize(e,n),this._setSmoothEnabled(),this}_validateAdd(e){const n=e.getType();n!=="Group"&&n!=="Shape"&&le.throw("You may only add groups and shapes to a layer.")}_toKonvaCanvas(e){return e={...e},e.width=e.width||this.getWidth(),e.height=e.height||this.getHeight(),e.x=e.x!==void 0?e.x:this.x(),e.y=e.y!==void 0?e.y:this.y(),Fe.prototype._toKonvaCanvas.call(this,e)}_checkVisibility(){this.visible()?this.canvas._canvas.style.display="block":this.canvas._canvas.style.display="none"}_setSmoothEnabled(){this.getContext()._context.imageSmoothingEnabled=this.imageSmoothingEnabled()}getWidth(){if(this.parent)return this.parent.width()}setWidth(){le.warn('Can not change width of layer. Use "stage.width(value)" function instead.')}getHeight(){if(this.parent)return this.parent.height()}setHeight(){le.warn('Can not change height of layer. Use "stage.height(value)" function instead.')}batchDraw(){return this._waitingForDraw||(this._waitingForDraw=!0,le.requestAnimFrame(()=>{this.draw(),this._waitingForDraw=!1})),this}getIntersection(e){if(!this.isListening()||!this.isVisible())return null;let n=1,s=!1;for(;;){for(let r=0;r<AUe;r++){const i=q4[r],o=this._getIntersection({x:e.x+i.x*n,y:e.y+i.y*n}),a=o.shape;if(a)return a;if(s=!!o.antialiased,!o.antialiased)break}if(s)n+=1;else return null}}_getIntersection(e){const n=this.hitCanvas.pixelRatio,s=this.hitCanvas.context.getImageData(Math.round(e.x*n),Math.round(e.y*n),1,1).data,r=s[3];if(r===255){const i=le.getHitColorKey(s[0],s[1],s[2]),o=ud[i];return o?{shape:o}:{antialiased:!0}}else if(r>0)return{antialiased:!0};return{}}drawScene(e,n,s){const r=this.getLayer(),i=e||r&&r.getCanvas();return this._fire($Ue,{node:this}),this.clearBeforeDraw()&&i.getContext().clear(),Tr.prototype.drawScene.call(this,i,n,s),this._fire(RUe,{node:this}),this}drawHit(e,n){const s=this.getLayer(),r=e||s&&s.hitCanvas;return s&&s.clearBeforeDraw()&&s.getHitCanvas().getContext().clear(),Tr.prototype.drawHit.call(this,r,n),this}enableHitGraph(){return this.hitGraphEnabled(!0),this}disableHitGraph(){return this.hitGraphEnabled(!1),this}setHitGraphEnabled(e){le.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."),this.listening(e)}getHitGraphEnabled(e){return le.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."),this.listening()}toggleHitCanvas(){if(!this.parent||!this.parent.content)return;const e=this.parent;!!this.hitCanvas._canvas.parentNode?e.content.removeChild(this.hitCanvas._canvas):e.content.appendChild(this.hitCanvas._canvas)}destroy(){return le.releaseCanvas(this.getNativeCanvasElement(),this.getHitCanvas()._canvas),super.destroy()}}Zl.prototype.nodeType="Layer";Rn(Zl);X.addGetterSetter(Zl,"imageSmoothingEnabled",!0);X.addGetterSetter(Zl,"clearBeforeDraw",!0);X.addGetterSetter(Zl,"hitGraphEnabled",!0,bi());class Rw extends Zl{constructor(e){super(e),this.listening(!1),le.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.')}}Rw.prototype.nodeType="FastLayer";Rn(Rw);class Yu extends Tr{_validateAdd(e){const n=e.getType();n!=="Group"&&n!=="Shape"&&le.throw("You may only add groups and shapes to groups.")}}Yu.prototype.nodeType="Group";Rn(Yu);const i1=function(){return Za.performance&&Za.performance.now?function(){return Za.performance.now()}:function(){return new Date().getTime()}}();class Fr{constructor(e,n){this.id=Fr.animIdCounter++,this.frame={time:0,timeDiff:0,lastTime:i1(),frameRate:0},this.func=e,this.setLayers(n)}setLayers(e){let n=[];return e&&(n=Array.isArray(e)?e:[e]),this.layers=n,this}getLayers(){return this.layers}addLayer(e){const n=this.layers,s=n.length;for(let r=0;r<s;r++)if(n[r]._id===e._id)return!1;return this.layers.push(e),!0}isRunning(){const n=Fr.animations,s=n.length;for(let r=0;r<s;r++)if(n[r].id===this.id)return!0;return!1}start(){return this.stop(),this.frame.timeDiff=0,this.frame.lastTime=i1(),Fr._addAnimation(this),this}stop(){return Fr._removeAnimation(this),this}_updateFrameObject(e){this.frame.timeDiff=e-this.frame.lastTime,this.frame.lastTime=e,this.frame.time+=this.frame.timeDiff,this.frame.frameRate=1e3/this.frame.timeDiff}static _addAnimation(e){this.animations.push(e),this._handleAnimation()}static _removeAnimation(e){const n=e.id,s=this.animations,r=s.length;for(let i=0;i<r;i++)if(s[i].id===n){this.animations.splice(i,1);break}}static _runFrames(){const e={},n=this.animations;for(let s=0;s<n.length;s++){const r=n[s],i=r.layers,o=r.func;r._updateFrameObject(i1());const a=i.length;let l;if(o?l=o.call(r,r.frame)!==!1:l=!0,!!l)for(let u=0;u<a;u++){const c=i[u];c._id!==void 0&&(e[c._id]=c)}}for(const s in e)e.hasOwnProperty(s)&&e[s].batchDraw()}static _animationLoop(){const e=Fr;e.animations.length?(e._runFrames(),le.requestAnimFrame(e._animationLoop)):e.animRunning=!1}static _handleAnimation(){this.animRunning||(this.animRunning=!0,le.requestAnimFrame(this._animationLoop))}}Fr.animations=[];Fr.animIdCounter=0;Fr.animRunning=!1;const PUe={node:1,duration:1,easing:1,onFinish:1,yoyo:1},DUe=1,ZT=2,QT=3,JT=["fill","stroke","shadowColor"];let NUe=0;class MUe{constructor(e,n,s,r,i,o,a){this.prop=e,this.propFunc=n,this.begin=r,this._pos=r,this.duration=o,this._change=0,this.prevPos=0,this.yoyo=a,this._time=0,this._position=0,this._startTime=0,this._finish=0,this.func=s,this._change=i-this.begin,this.pause()}fire(e){const n=this[e];n&&n()}setTime(e){e>this.duration?this.yoyo?(this._time=this.duration,this.reverse()):this.finish():e<0?this.yoyo?(this._time=0,this.play()):this.reset():(this._time=e,this.update())}getTime(){return this._time}setPosition(e){this.prevPos=this._pos,this.propFunc(e),this._pos=e}getPosition(e){return e===void 0&&(e=this._time),this.func(e,this.begin,this._change,this.duration)}play(){this.state=ZT,this._startTime=this.getTimer()-this._time,this.onEnterFrame(),this.fire("onPlay")}reverse(){this.state=QT,this._time=this.duration-this._time,this._startTime=this.getTimer()-this._time,this.onEnterFrame(),this.fire("onReverse")}seek(e){this.pause(),this._time=e,this.update(),this.fire("onSeek")}reset(){this.pause(),this._time=0,this.update(),this.fire("onReset")}finish(){this.pause(),this._time=this.duration,this.update(),this.fire("onFinish")}update(){this.setPosition(this.getPosition(this._time)),this.fire("onUpdate")}onEnterFrame(){const e=this.getTimer()-this._startTime;this.state===ZT?this.setTime(e):this.state===QT&&this.setTime(this.duration-e)}pause(){this.state=DUe,this.fire("onPause")}getTimer(){return new Date().getTime()}}class un{constructor(e){const n=this,s=e.node,r=s._id,i=e.easing||cd.Linear,o=!!e.yoyo;let a,l;typeof e.duration>"u"?a=.3:e.duration===0?a=.001:a=e.duration,this.node=s,this._id=NUe++;const u=s.getLayer()||(s instanceof He.Stage?s.getLayers():null);u||le.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."),this.anim=new Fr(function(){n.tween.onEnterFrame()},u),this.tween=new MUe(l,function(c){n._tweenFunc(c)},i,0,1,a*1e3,o),this._addListeners(),un.attrs[r]||(un.attrs[r]={}),un.attrs[r][this._id]||(un.attrs[r][this._id]={}),un.tweens[r]||(un.tweens[r]={});for(l in e)PUe[l]===void 0&&this._addAttr(l,e[l]);this.reset(),this.onFinish=e.onFinish,this.onReset=e.onReset,this.onUpdate=e.onUpdate}_addAttr(e,n){const s=this.node,r=s._id;let i,o,a,l,u;const c=un.tweens[r][e];c&&delete un.attrs[r][c][e];let h=s.getAttr(e);if(le._isArray(n))if(i=[],o=Math.max(n.length,h.length),e==="points"&&n.length!==h.length&&(n.length>h.length?(l=h,h=le._prepareArrayForTween(h,n,s.closed())):(a=n,n=le._prepareArrayForTween(n,h,s.closed()))),e.indexOf("fill")===0)for(let d=0;d<o;d++)if(d%2===0)i.push(n[d]-h[d]);else{const f=le.colorToRGBA(h[d]);u=le.colorToRGBA(n[d]),h[d]=f,i.push({r:u.r-f.r,g:u.g-f.g,b:u.b-f.b,a:u.a-f.a})}else for(let d=0;d<o;d++)i.push(n[d]-h[d]);else JT.indexOf(e)!==-1?(h=le.colorToRGBA(h),u=le.colorToRGBA(n),i={r:u.r-h.r,g:u.g-h.g,b:u.b-h.b,a:u.a-h.a}):i=n-h;un.attrs[r][this._id][e]={start:h,diff:i,end:n,trueEnd:a,trueStart:l},un.tweens[r][e]=this._id}_tweenFunc(e){const n=this.node,s=un.attrs[n._id][this._id];let r,i,o,a,l,u,c,h;for(r in s){if(i=s[r],o=i.start,a=i.diff,h=i.end,le._isArray(o))if(l=[],c=Math.max(o.length,h.length),r.indexOf("fill")===0)for(u=0;u<c;u++)u%2===0?l.push((o[u]||0)+a[u]*e):l.push("rgba("+Math.round(o[u].r+a[u].r*e)+","+Math.round(o[u].g+a[u].g*e)+","+Math.round(o[u].b+a[u].b*e)+","+(o[u].a+a[u].a*e)+")");else for(u=0;u<c;u++)l.push((o[u]||0)+a[u]*e);else JT.indexOf(r)!==-1?l="rgba("+Math.round(o.r+a.r*e)+","+Math.round(o.g+a.g*e)+","+Math.round(o.b+a.b*e)+","+(o.a+a.a*e)+")":l=o+a*e;n.setAttr(r,l)}}_addListeners(){this.tween.onPlay=()=>{this.anim.start()},this.tween.onReverse=()=>{this.anim.start()},this.tween.onPause=()=>{this.anim.stop()},this.tween.onFinish=()=>{const e=this.node,n=un.attrs[e._id][this._id];n.points&&n.points.trueEnd&&e.setAttr("points",n.points.trueEnd),this.onFinish&&this.onFinish.call(this)},this.tween.onReset=()=>{const e=this.node,n=un.attrs[e._id][this._id];n.points&&n.points.trueStart&&e.points(n.points.trueStart),this.onReset&&this.onReset()},this.tween.onUpdate=()=>{this.onUpdate&&this.onUpdate.call(this)}}play(){return this.tween.play(),this}reverse(){return this.tween.reverse(),this}reset(){return this.tween.reset(),this}seek(e){return this.tween.seek(e*1e3),this}pause(){return this.tween.pause(),this}finish(){return this.tween.finish(),this}destroy(){const e=this.node._id,n=this._id,s=un.tweens[e];this.pause(),this.anim&&this.anim.stop();for(const r in s)delete un.tweens[e][r];delete un.attrs[e][n],un.tweens[e]&&(Object.keys(un.tweens[e]).length===0&&delete un.tweens[e],Object.keys(un.attrs[e]).length===0&&delete un.attrs[e])}}un.attrs={};un.tweens={};Fe.prototype.to=function(t){const e=t.onFinish;t.node=this,t.onFinish=function(){this.destroy(),e&&e()},new un(t).play()};const cd={BackEaseIn(t,e,n,s){return n*(t/=s)*t*((1.70158+1)*t-1.70158)+e},BackEaseOut(t,e,n,s){return n*((t=t/s-1)*t*((1.70158+1)*t+1.70158)+1)+e},BackEaseInOut(t,e,n,s){let r=1.70158;return(t/=s/2)<1?n/2*(t*t*(((r*=1.525)+1)*t-r))+e:n/2*((t-=2)*t*(((r*=1.525)+1)*t+r)+2)+e},ElasticEaseIn(t,e,n,s,r,i){let o=0;return t===0?e:(t/=s)===1?e+n:(i||(i=s*.3),!r||r<Math.abs(n)?(r=n,o=i/4):o=i/(2*Math.PI)*Math.asin(n/r),-(r*Math.pow(2,10*(t-=1))*Math.sin((t*s-o)*(2*Math.PI)/i))+e)},ElasticEaseOut(t,e,n,s,r,i){let o=0;return t===0?e:(t/=s)===1?e+n:(i||(i=s*.3),!r||r<Math.abs(n)?(r=n,o=i/4):o=i/(2*Math.PI)*Math.asin(n/r),r*Math.pow(2,-10*t)*Math.sin((t*s-o)*(2*Math.PI)/i)+n+e)},ElasticEaseInOut(t,e,n,s,r,i){let o=0;return t===0?e:(t/=s/2)===2?e+n:(i||(i=s*(.3*1.5)),!r||r<Math.abs(n)?(r=n,o=i/4):o=i/(2*Math.PI)*Math.asin(n/r),t<1?-.5*(r*Math.pow(2,10*(t-=1))*Math.sin((t*s-o)*(2*Math.PI)/i))+e:r*Math.pow(2,-10*(t-=1))*Math.sin((t*s-o)*(2*Math.PI)/i)*.5+n+e)},BounceEaseOut(t,e,n,s){return(t/=s)<1/2.75?n*(7.5625*t*t)+e:t<2/2.75?n*(7.5625*(t-=1.5/2.75)*t+.75)+e:t<2.5/2.75?n*(7.5625*(t-=2.25/2.75)*t+.9375)+e:n*(7.5625*(t-=2.625/2.75)*t+.984375)+e},BounceEaseIn(t,e,n,s){return n-cd.BounceEaseOut(s-t,0,n,s)+e},BounceEaseInOut(t,e,n,s){return t<s/2?cd.BounceEaseIn(t*2,0,n,s)*.5+e:cd.BounceEaseOut(t*2-s,0,n,s)*.5+n*.5+e},EaseIn(t,e,n,s){return n*(t/=s)*t+e},EaseOut(t,e,n,s){return-n*(t/=s)*(t-2)+e},EaseInOut(t,e,n,s){return(t/=s/2)<1?n/2*t*t+e:-n/2*(--t*(t-2)-1)+e},StrongEaseIn(t,e,n,s){return n*(t/=s)*t*t*t*t+e},StrongEaseOut(t,e,n,s){return n*((t=t/s-1)*t*t*t*t+1)+e},StrongEaseInOut(t,e,n,s){return(t/=s/2)<1?n/2*t*t*t*t*t+e:n/2*((t-=2)*t*t*t*t+2)+e},Linear(t,e,n,s){return n*t/s+e}},eI=le._assign(He,{Util:le,Transform:vr,Node:Fe,Container:Tr,Stage:tb,stages:ld,Layer:Zl,FastLayer:Rw,Group:Yu,DD:Kt,Shape:Ne,shapes:ud,Animation:Fr,Tween:un,Easings:cd,Context:Jx,Canvas:kw});class No extends Ne{_sceneFunc(e){const n=He.getAngle(this.angle()),s=this.clockwise();e.beginPath(),e.arc(0,0,this.outerRadius(),0,n,s),e.arc(0,0,this.innerRadius(),n,0,!s),e.closePath(),e.fillStrokeShape(this)}getWidth(){return this.outerRadius()*2}getHeight(){return this.outerRadius()*2}setWidth(e){this.outerRadius(e/2)}setHeight(e){this.outerRadius(e/2)}getSelfRect(){const e=this.innerRadius(),n=this.outerRadius(),s=this.clockwise(),r=He.getAngle(s?360-this.angle():this.angle()),i=Math.cos(Math.min(r,Math.PI)),o=1,a=Math.sin(Math.min(Math.max(Math.PI,r),3*Math.PI/2)),l=Math.sin(Math.min(r,Math.PI/2)),u=i*(i>0?e:n),c=o*n,h=a*(a>0?e:n),d=l*(l>0?n:e);return{x:u,y:s?-1*d:h,width:c-u,height:d-h}}}No.prototype._centroid=!0;No.prototype.className="Arc";No.prototype._attrsAffectingSize=["innerRadius","outerRadius","angle","clockwise"];Rn(No);X.addGetterSetter(No,"innerRadius",0,Be());X.addGetterSetter(No,"outerRadius",0,Be());X.addGetterSetter(No,"angle",0,Be());X.addGetterSetter(No,"clockwise",!1,bi());function Ey(t,e,n,s,r,i,o){const a=Math.sqrt(Math.pow(n-t,2)+Math.pow(s-e,2)),l=Math.sqrt(Math.pow(r-n,2)+Math.pow(i-s,2)),u=o*a/(a+l),c=o*l/(a+l),h=n-u*(r-t),d=s-u*(i-e),f=n+c*(r-t),p=s+c*(i-e);return[h,d,f,p]}function tI(t,e){const n=t.length,s=[];for(let r=2;r<n-2;r+=2){const i=Ey(t[r-2],t[r-1],t[r],t[r+1],t[r+2],t[r+3],e);isNaN(i[0])||(s.push(i[0]),s.push(i[1]),s.push(t[r]),s.push(t[r+1]),s.push(i[2]),s.push(i[3]))}return s}class Mo extends Ne{constructor(e){super(e),this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva",function(){this._clearCache("tensionPoints")})}_sceneFunc(e){const n=this.points(),s=n.length,r=this.tension(),i=this.closed(),o=this.bezier();if(!s)return;let a=0;if(e.beginPath(),e.moveTo(n[0],n[1]),r!==0&&s>4){const l=this.getTensionPoints(),u=l.length;for(a=i?0:4,i||e.quadraticCurveTo(l[0],l[1],l[2],l[3]);a<u-2;)e.bezierCurveTo(l[a++],l[a++],l[a++],l[a++],l[a++],l[a++]);i||e.quadraticCurveTo(l[u-2],l[u-1],n[s-2],n[s-1])}else if(o)for(a=2;a<s;)e.bezierCurveTo(n[a++],n[a++],n[a++],n[a++],n[a++],n[a++]);else for(a=2;a<s;a+=2)e.lineTo(n[a],n[a+1]);i?(e.closePath(),e.fillStrokeShape(this)):e.strokeShape(this)}getTensionPoints(){return this._getCache("tensionPoints",this._getTensionPoints)}_getTensionPoints(){return this.closed()?this._getTensionPointsClosed():tI(this.points(),this.tension())}_getTensionPointsClosed(){const e=this.points(),n=e.length,s=this.tension(),r=Ey(e[n-2],e[n-1],e[0],e[1],e[2],e[3],s),i=Ey(e[n-4],e[n-3],e[n-2],e[n-1],e[0],e[1],s),o=tI(e,s);return[r[2],r[3]].concat(o).concat([i[0],i[1],e[n-2],e[n-1],i[2],i[3],r[0],r[1],e[0],e[1]])}getWidth(){return this.getSelfRect().width}getHeight(){return this.getSelfRect().height}getSelfRect(){let e=this.points();if(e.length<4)return{x:e[0]||0,y:e[1]||0,width:0,height:0};this.tension()!==0?e=[e[0],e[1],...this._getTensionPoints(),e[e.length-2],e[e.length-1]]:e=this.points();let n=e[0],s=e[0],r=e[1],i=e[1],o,a;for(let l=0;l<e.length/2;l++)o=e[l*2],a=e[l*2+1],n=Math.min(n,o),s=Math.max(s,o),r=Math.min(r,a),i=Math.max(i,a);return{x:n,y:r,width:s-n,height:i-r}}}Mo.prototype.className="Line";Mo.prototype._attrsAffectingSize=["points","bezier","tension"];Rn(Mo);X.addGetterSetter(Mo,"closed",!1);X.addGetterSetter(Mo,"bezier",!1);X.addGetterSetter(Mo,"tension",0,Be());X.addGetterSetter(Mo,"points",[],Q5e());const LUe=[[],[],[-.5773502691896257,.5773502691896257],[0,-.7745966692414834,.7745966692414834],[-.33998104358485626,.33998104358485626,-.8611363115940526,.8611363115940526],[0,-.5384693101056831,.5384693101056831,-.906179845938664,.906179845938664],[.6612093864662645,-.6612093864662645,-.2386191860831969,.2386191860831969,-.932469514203152,.932469514203152],[0,.4058451513773972,-.4058451513773972,-.7415311855993945,.7415311855993945,-.9491079123427585,.9491079123427585],[-.1834346424956498,.1834346424956498,-.525532409916329,.525532409916329,-.7966664774136267,.7966664774136267,-.9602898564975363,.9602898564975363],[0,-.8360311073266358,.8360311073266358,-.9681602395076261,.9681602395076261,-.3242534234038089,.3242534234038089,-.6133714327005904,.6133714327005904],[-.14887433898163122,.14887433898163122,-.4333953941292472,.4333953941292472,-.6794095682990244,.6794095682990244,-.8650633666889845,.8650633666889845,-.9739065285171717,.9739065285171717],[0,-.26954315595234496,.26954315595234496,-.5190961292068118,.5190961292068118,-.7301520055740494,.7301520055740494,-.8870625997680953,.8870625997680953,-.978228658146057,.978228658146057],[-.1252334085114689,.1252334085114689,-.3678314989981802,.3678314989981802,-.5873179542866175,.5873179542866175,-.7699026741943047,.7699026741943047,-.9041172563704749,.9041172563704749,-.9815606342467192,.9815606342467192],[0,-.2304583159551348,.2304583159551348,-.44849275103644687,.44849275103644687,-.6423493394403402,.6423493394403402,-.8015780907333099,.8015780907333099,-.9175983992229779,.9175983992229779,-.9841830547185881,.9841830547185881],[-.10805494870734367,.10805494870734367,-.31911236892788974,.31911236892788974,-.5152486363581541,.5152486363581541,-.6872929048116855,.6872929048116855,-.827201315069765,.827201315069765,-.9284348836635735,.9284348836635735,-.9862838086968123,.9862838086968123],[0,-.20119409399743451,.20119409399743451,-.3941513470775634,.3941513470775634,-.5709721726085388,.5709721726085388,-.7244177313601701,.7244177313601701,-.8482065834104272,.8482065834104272,-.937273392400706,.937273392400706,-.9879925180204854,.9879925180204854],[-.09501250983763744,.09501250983763744,-.2816035507792589,.2816035507792589,-.45801677765722737,.45801677765722737,-.6178762444026438,.6178762444026438,-.755404408355003,.755404408355003,-.8656312023878318,.8656312023878318,-.9445750230732326,.9445750230732326,-.9894009349916499,.9894009349916499],[0,-.17848418149584785,.17848418149584785,-.3512317634538763,.3512317634538763,-.5126905370864769,.5126905370864769,-.6576711592166907,.6576711592166907,-.7815140038968014,.7815140038968014,-.8802391537269859,.8802391537269859,-.9506755217687678,.9506755217687678,-.9905754753144174,.9905754753144174],[-.0847750130417353,.0847750130417353,-.2518862256915055,.2518862256915055,-.41175116146284263,.41175116146284263,-.5597708310739475,.5597708310739475,-.6916870430603532,.6916870430603532,-.8037049589725231,.8037049589725231,-.8926024664975557,.8926024664975557,-.9558239495713977,.9558239495713977,-.9915651684209309,.9915651684209309],[0,-.16035864564022537,.16035864564022537,-.31656409996362983,.31656409996362983,-.46457074137596094,.46457074137596094,-.600545304661681,.600545304661681,-.7209661773352294,.7209661773352294,-.8227146565371428,.8227146565371428,-.9031559036148179,.9031559036148179,-.96020815213483,.96020815213483,-.9924068438435844,.9924068438435844],[-.07652652113349734,.07652652113349734,-.22778585114164507,.22778585114164507,-.37370608871541955,.37370608871541955,-.5108670019508271,.5108670019508271,-.636053680726515,.636053680726515,-.7463319064601508,.7463319064601508,-.8391169718222188,.8391169718222188,-.912234428251326,.912234428251326,-.9639719272779138,.9639719272779138,-.9931285991850949,.9931285991850949],[0,-.1455618541608951,.1455618541608951,-.2880213168024011,.2880213168024011,-.4243421202074388,.4243421202074388,-.5516188358872198,.5516188358872198,-.6671388041974123,.6671388041974123,-.7684399634756779,.7684399634756779,-.8533633645833173,.8533633645833173,-.9200993341504008,.9200993341504008,-.9672268385663063,.9672268385663063,-.9937521706203895,.9937521706203895],[-.06973927331972223,.06973927331972223,-.20786042668822127,.20786042668822127,-.34193582089208424,.34193582089208424,-.469355837986757,.469355837986757,-.5876404035069116,.5876404035069116,-.6944872631866827,.6944872631866827,-.7878168059792081,.7878168059792081,-.8658125777203002,.8658125777203002,-.926956772187174,.926956772187174,-.9700604978354287,.9700604978354287,-.9942945854823992,.9942945854823992],[0,-.1332568242984661,.1332568242984661,-.26413568097034495,.26413568097034495,-.3903010380302908,.3903010380302908,-.5095014778460075,.5095014778460075,-.6196098757636461,.6196098757636461,-.7186613631319502,.7186613631319502,-.8048884016188399,.8048884016188399,-.8767523582704416,.8767523582704416,-.9329710868260161,.9329710868260161,-.9725424712181152,.9725424712181152,-.9947693349975522,.9947693349975522],[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213]],OUe=[[],[],[1,1],[.8888888888888888,.5555555555555556,.5555555555555556],[.6521451548625461,.6521451548625461,.34785484513745385,.34785484513745385],[.5688888888888889,.47862867049936647,.47862867049936647,.23692688505618908,.23692688505618908],[.3607615730481386,.3607615730481386,.46791393457269104,.46791393457269104,.17132449237917036,.17132449237917036],[.4179591836734694,.3818300505051189,.3818300505051189,.27970539148927664,.27970539148927664,.1294849661688697,.1294849661688697],[.362683783378362,.362683783378362,.31370664587788727,.31370664587788727,.22238103445337448,.22238103445337448,.10122853629037626,.10122853629037626],[.3302393550012598,.1806481606948574,.1806481606948574,.08127438836157441,.08127438836157441,.31234707704000286,.31234707704000286,.26061069640293544,.26061069640293544],[.29552422471475287,.29552422471475287,.26926671930999635,.26926671930999635,.21908636251598204,.21908636251598204,.1494513491505806,.1494513491505806,.06667134430868814,.06667134430868814],[.2729250867779006,.26280454451024665,.26280454451024665,.23319376459199048,.23319376459199048,.18629021092773426,.18629021092773426,.1255803694649046,.1255803694649046,.05566856711617366,.05566856711617366],[.24914704581340277,.24914704581340277,.2334925365383548,.2334925365383548,.20316742672306592,.20316742672306592,.16007832854334622,.16007832854334622,.10693932599531843,.10693932599531843,.04717533638651183,.04717533638651183],[.2325515532308739,.22628318026289723,.22628318026289723,.2078160475368885,.2078160475368885,.17814598076194574,.17814598076194574,.13887351021978725,.13887351021978725,.09212149983772845,.09212149983772845,.04048400476531588,.04048400476531588],[.2152638534631578,.2152638534631578,.2051984637212956,.2051984637212956,.18553839747793782,.18553839747793782,.15720316715819355,.15720316715819355,.12151857068790319,.12151857068790319,.08015808715976021,.08015808715976021,.03511946033175186,.03511946033175186],[.2025782419255613,.19843148532711158,.19843148532711158,.1861610000155622,.1861610000155622,.16626920581699392,.16626920581699392,.13957067792615432,.13957067792615432,.10715922046717194,.10715922046717194,.07036604748810812,.07036604748810812,.03075324199611727,.03075324199611727],[.1894506104550685,.1894506104550685,.18260341504492358,.18260341504492358,.16915651939500254,.16915651939500254,.14959598881657674,.14959598881657674,.12462897125553388,.12462897125553388,.09515851168249279,.09515851168249279,.062253523938647894,.062253523938647894,.027152459411754096,.027152459411754096],[.17944647035620653,.17656270536699264,.17656270536699264,.16800410215645004,.16800410215645004,.15404576107681028,.15404576107681028,.13513636846852548,.13513636846852548,.11188384719340397,.11188384719340397,.08503614831717918,.08503614831717918,.0554595293739872,.0554595293739872,.02414830286854793,.02414830286854793],[.1691423829631436,.1691423829631436,.16427648374583273,.16427648374583273,.15468467512626524,.15468467512626524,.14064291467065065,.14064291467065065,.12255520671147846,.12255520671147846,.10094204410628717,.10094204410628717,.07642573025488905,.07642573025488905,.0497145488949698,.0497145488949698,.02161601352648331,.02161601352648331],[.1610544498487837,.15896884339395434,.15896884339395434,.15276604206585967,.15276604206585967,.1426067021736066,.1426067021736066,.12875396253933621,.12875396253933621,.11156664554733399,.11156664554733399,.09149002162245,.09149002162245,.06904454273764123,.06904454273764123,.0448142267656996,.0448142267656996,.019461788229726478,.019461788229726478],[.15275338713072584,.15275338713072584,.14917298647260374,.14917298647260374,.14209610931838204,.14209610931838204,.13168863844917664,.13168863844917664,.11819453196151841,.11819453196151841,.10193011981724044,.10193011981724044,.08327674157670475,.08327674157670475,.06267204833410907,.06267204833410907,.04060142980038694,.04060142980038694,.017614007139152118,.017614007139152118],[.14608113364969041,.14452440398997005,.14452440398997005,.13988739479107315,.13988739479107315,.13226893863333747,.13226893863333747,.12183141605372853,.12183141605372853,.10879729916714838,.10879729916714838,.09344442345603386,.09344442345603386,.0761001136283793,.0761001136283793,.057134425426857205,.057134425426857205,.036953789770852494,.036953789770852494,.016017228257774335,.016017228257774335],[.13925187285563198,.13925187285563198,.13654149834601517,.13654149834601517,.13117350478706238,.13117350478706238,.12325237681051242,.12325237681051242,.11293229608053922,.11293229608053922,.10041414444288096,.10041414444288096,.08594160621706773,.08594160621706773,.06979646842452049,.06979646842452049,.052293335152683286,.052293335152683286,.03377490158481415,.03377490158481415,.0146279952982722,.0146279952982722],[.13365457218610619,.1324620394046966,.1324620394046966,.12890572218808216,.12890572218808216,.12304908430672953,.12304908430672953,.11499664022241136,.11499664022241136,.10489209146454141,.10489209146454141,.09291576606003515,.09291576606003515,.07928141177671895,.07928141177671895,.06423242140852585,.06423242140852585,.04803767173108467,.04803767173108467,.030988005856979445,.030988005856979445,.013411859487141771,.013411859487141771],[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872]],FUe=[[1],[1,1],[1,2,1],[1,3,3,1]],nI=(t,e,n)=>{let s,r;const o=n/2;s=0;for(let a=0;a<20;a++)r=o*LUe[20][a]+o,s+=OUe[20][a]*UUe(t,e,r);return o*s},sI=(t,e,n)=>{n===void 0&&(n=1);const s=t[0]-2*t[1]+t[2],r=e[0]-2*e[1]+e[2],i=2*t[1]-2*t[0],o=2*e[1]-2*e[0],a=4*(s*s+r*r),l=4*(s*i+r*o),u=i*i+o*o;if(a===0)return n*Math.sqrt(Math.pow(t[2]-t[0],2)+Math.pow(e[2]-e[0],2));const c=l/(2*a),h=u/a,d=n+c,f=h-c*c,p=d*d+f>0?Math.sqrt(d*d+f):0,g=c*c+f>0?Math.sqrt(c*c+f):0,m=c+Math.sqrt(c*c+f)!==0?f*Math.log(Math.abs((d+p)/(c+g))):0;return Math.sqrt(a)/2*(d*p-c*g+m)};function UUe(t,e,n){const s=_y(1,n,t),r=_y(1,n,e),i=s*s+r*r;return Math.sqrt(i)}const _y=(t,e,n)=>{const s=n.length-1;let r,i;if(s===0)return 0;if(t===0){i=0;for(let o=0;o<=s;o++)i+=FUe[s][o]*Math.pow(1-e,s-o)*Math.pow(e,o)*n[o];return i}else{r=new Array(s);for(let o=0;o<s;o++)r[o]=s*(n[o+1]-n[o]);return _y(t-1,e,r)}},rI=(t,e,n)=>{let s=1,r=t/e,i=(t-n(r))/e,o=0;for(;s>.001;){const a=n(r+i),l=Math.abs(t-a)/e;if(l<s)s=l,r+=i;else{const u=n(r-i),c=Math.abs(t-u)/e;c<s?(s=c,r-=i):i/=2}if(o++,o>500)break}return r};class hn extends Ne{constructor(e){super(e),this.dataArray=[],this.pathLength=0,this._readDataAttribute(),this.on("dataChange.konva",function(){this._readDataAttribute()})}_readDataAttribute(){this.dataArray=hn.parsePathData(this.data()),this.pathLength=hn.getPathLength(this.dataArray)}_sceneFunc(e){const n=this.dataArray;e.beginPath();let s=!1;for(let r=0;r<n.length;r++){const i=n[r].command,o=n[r].points;switch(i){case"L":e.lineTo(o[0],o[1]);break;case"M":e.moveTo(o[0],o[1]);break;case"C":e.bezierCurveTo(o[0],o[1],o[2],o[3],o[4],o[5]);break;case"Q":e.quadraticCurveTo(o[0],o[1],o[2],o[3]);break;case"A":const a=o[0],l=o[1],u=o[2],c=o[3],h=o[4],d=o[5],f=o[6],p=o[7],g=u>c?u:c,m=u>c?1:u/c,x=u>c?c/u:1;e.translate(a,l),e.rotate(f),e.scale(m,x),e.arc(0,0,g,h,h+d,1-p),e.scale(1/m,1/x),e.rotate(-f),e.translate(-a,-l);break;case"z":s=!0,e.closePath();break}}!s&&!this.hasFill()?e.strokeShape(this):e.fillStrokeShape(this)}getSelfRect(){let e=[];this.dataArray.forEach(function(l){if(l.command==="A"){const u=l.points[4],c=l.points[5],h=l.points[4]+c;let d=Math.PI/180;if(Math.abs(u-h)<d&&(d=Math.abs(u-h)),c<0)for(let f=u-d;f>h;f-=d){const p=hn.getPointOnEllipticalArc(l.points[0],l.points[1],l.points[2],l.points[3],f,0);e.push(p.x,p.y)}else for(let f=u+d;f<h;f+=d){const p=hn.getPointOnEllipticalArc(l.points[0],l.points[1],l.points[2],l.points[3],f,0);e.push(p.x,p.y)}}else if(l.command==="C")for(let u=0;u<=1;u+=.01){const c=hn.getPointOnCubicBezier(u,l.start.x,l.start.y,l.points[0],l.points[1],l.points[2],l.points[3],l.points[4],l.points[5]);e.push(c.x,c.y)}else e=e.concat(l.points)});let n=e[0],s=e[0],r=e[1],i=e[1],o,a;for(let l=0;l<e.length/2;l++)o=e[l*2],a=e[l*2+1],isNaN(o)||(n=Math.min(n,o),s=Math.max(s,o)),isNaN(a)||(r=Math.min(r,a),i=Math.max(i,a));return{x:n,y:r,width:s-n,height:i-r}}getLength(){return this.pathLength}getPointAtLength(e){return hn.getPointAtLengthOfDataArray(e,this.dataArray)}static getLineLength(e,n,s,r){return Math.sqrt((s-e)*(s-e)+(r-n)*(r-n))}static getPathLength(e){let n=0;for(let s=0;s<e.length;++s)n+=e[s].pathLength;return n}static getPointAtLengthOfDataArray(e,n){let s,r=0,i=n.length;if(!i)return null;for(;r<i&&e>n[r].pathLength;)e-=n[r].pathLength,++r;if(r===i)return s=n[r-1].points.slice(-2),{x:s[0],y:s[1]};if(e<.01)return n[r].command==="M"?(s=n[r].points.slice(0,2),{x:s[0],y:s[1]}):{x:n[r].start.x,y:n[r].start.y};const o=n[r],a=o.points;switch(o.command){case"L":return hn.getPointOnLine(e,o.start.x,o.start.y,a[0],a[1]);case"C":return hn.getPointOnCubicBezier(rI(e,hn.getPathLength(n),g=>nI([o.start.x,a[0],a[2],a[4]],[o.start.y,a[1],a[3],a[5]],g)),o.start.x,o.start.y,a[0],a[1],a[2],a[3],a[4],a[5]);case"Q":return hn.getPointOnQuadraticBezier(rI(e,hn.getPathLength(n),g=>sI([o.start.x,a[0],a[2]],[o.start.y,a[1],a[3]],g)),o.start.x,o.start.y,a[0],a[1],a[2],a[3]);case"A":const l=a[0],u=a[1],c=a[2],h=a[3],d=a[5],f=a[6];let p=a[4];return p+=d*e/o.pathLength,hn.getPointOnEllipticalArc(l,u,c,h,p,f)}return null}static getPointOnLine(e,n,s,r,i,o,a){o=o??n,a=a??s;const l=this.getLineLength(n,s,r,i);if(l<1e-10)return{x:n,y:s};if(r===n)return{x:o,y:a+(i>s?e:-e)};const u=(i-s)/(r-n),c=Math.sqrt(e*e/(1+u*u))*(r<n?-1:1),h=u*c;if(Math.abs(a-s-u*(o-n))<1e-10)return{x:o+c,y:a+h};const d=((o-n)*(r-n)+(a-s)*(i-s))/(l*l),f=n+d*(r-n),p=s+d*(i-s),g=this.getLineLength(o,a,f,p),m=Math.sqrt(e*e-g*g),x=Math.sqrt(m*m/(1+u*u))*(r<n?-1:1),b=u*x;return{x:f+x,y:p+b}}static getPointOnCubicBezier(e,n,s,r,i,o,a,l,u){function c(m){return m*m*m}function h(m){return 3*m*m*(1-m)}function d(m){return 3*m*(1-m)*(1-m)}function f(m){return(1-m)*(1-m)*(1-m)}const p=l*c(e)+o*h(e)+r*d(e)+n*f(e),g=u*c(e)+a*h(e)+i*d(e)+s*f(e);return{x:p,y:g}}static getPointOnQuadraticBezier(e,n,s,r,i,o,a){function l(f){return f*f}function u(f){return 2*f*(1-f)}function c(f){return(1-f)*(1-f)}const h=o*l(e)+r*u(e)+n*c(e),d=a*l(e)+i*u(e)+s*c(e);return{x:h,y:d}}static getPointOnEllipticalArc(e,n,s,r,i,o){const a=Math.cos(o),l=Math.sin(o),u={x:s*Math.cos(i),y:r*Math.sin(i)};return{x:e+(u.x*a-u.y*l),y:n+(u.x*l+u.y*a)}}static parsePathData(e){if(!e)return[];let n=e;const s=["m","M","l","L","v","V","h","H","z","Z","c","C","q","Q","t","T","s","S","a","A"];n=n.replace(new RegExp(" ","g"),",");for(let h=0;h<s.length;h++)n=n.replace(new RegExp(s[h],"g"),"|"+s[h]);const r=n.split("|"),i=[],o=[];let a=0,l=0;const u=/([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;let c;for(let h=1;h<r.length;h++){let d=r[h],f=d.charAt(0);for(d=d.slice(1),o.length=0;c=u.exec(d);)o.push(c[0]);let p=[],g=f==="A"||f==="a"?0:-1;for(let m=0,x=o.length;m<x;m++){const b=o[m];if(b==="00"){p.push(0,0),g>=0&&(g+=2,g>=7&&(g-=7));continue}if(g>=0){if(g===3){if(/^[01]{2}\d+(?:\.\d+)?$/.test(b)){p.push(parseInt(b[0],10)),p.push(parseInt(b[1],10)),p.push(parseFloat(b.slice(2))),g+=3,g>=7&&(g-=7);continue}if(b==="11"||b==="10"||b==="01"){p.push(parseInt(b[0],10)),p.push(parseInt(b[1],10)),g+=2,g>=7&&(g-=7);continue}if(b==="0"||b==="1"){p.push(parseInt(b,10)),g+=1,g>=7&&(g-=7);continue}}else if(g===4){if(/^[01]\d+(?:\.\d+)?$/.test(b)){p.push(parseInt(b[0],10)),p.push(parseFloat(b.slice(1))),g+=2,g>=7&&(g-=7);continue}if(b==="0"||b==="1"){p.push(parseInt(b,10)),g+=1,g>=7&&(g-=7);continue}}const v=parseFloat(b);isNaN(v)?p.push(0):p.push(v),g+=1,g>=7&&(g-=7)}else{const v=parseFloat(b);isNaN(v)?p.push(0):p.push(v)}}for(;p.length>0&&!isNaN(p[0]);){let m="",x=[];const b=a,v=l;let y,C,I,$,T,S,E,_,N,P;switch(f){case"l":a+=p.shift(),l+=p.shift(),m="L",x.push(a,l);break;case"L":a=p.shift(),l=p.shift(),x.push(a,l);break;case"m":const M=p.shift(),z=p.shift();if(a+=M,l+=z,m="M",i.length>2&&i[i.length-1].command==="z"){for(let A=i.length-2;A>=0;A--)if(i[A].command==="M"){a=i[A].points[0]+M,l=i[A].points[1]+z;break}}x.push(a,l),f="l";break;case"M":a=p.shift(),l=p.shift(),m="M",x.push(a,l),f="L";break;case"h":a+=p.shift(),m="L",x.push(a,l);break;case"H":a=p.shift(),m="L",x.push(a,l);break;case"v":l+=p.shift(),m="L",x.push(a,l);break;case"V":l=p.shift(),m="L",x.push(a,l);break;case"C":x.push(p.shift(),p.shift(),p.shift(),p.shift()),a=p.shift(),l=p.shift(),x.push(a,l);break;case"c":x.push(a+p.shift(),l+p.shift(),a+p.shift(),l+p.shift()),a+=p.shift(),l+=p.shift(),m="C",x.push(a,l);break;case"S":C=a,I=l,y=i[i.length-1],y.command==="C"&&(C=a+(a-y.points[2]),I=l+(l-y.points[3])),x.push(C,I,p.shift(),p.shift()),a=p.shift(),l=p.shift(),m="C",x.push(a,l);break;case"s":C=a,I=l,y=i[i.length-1],y.command==="C"&&(C=a+(a-y.points[2]),I=l+(l-y.points[3])),x.push(C,I,a+p.shift(),l+p.shift()),a+=p.shift(),l+=p.shift(),m="C",x.push(a,l);break;case"Q":x.push(p.shift(),p.shift()),a=p.shift(),l=p.shift(),x.push(a,l);break;case"q":x.push(a+p.shift(),l+p.shift()),a+=p.shift(),l+=p.shift(),m="Q",x.push(a,l);break;case"T":C=a,I=l,y=i[i.length-1],y.command==="Q"&&(C=a+(a-y.points[0]),I=l+(l-y.points[1])),a=p.shift(),l=p.shift(),m="Q",x.push(C,I,a,l);break;case"t":C=a,I=l,y=i[i.length-1],y.command==="Q"&&(C=a+(a-y.points[0]),I=l+(l-y.points[1])),a+=p.shift(),l+=p.shift(),m="Q",x.push(C,I,a,l);break;case"A":$=p.shift(),T=p.shift(),S=p.shift(),E=p.shift(),_=p.shift(),N=a,P=l,a=p.shift(),l=p.shift(),m="A",x=this.convertEndpointToCenterParameterization(N,P,a,l,E,_,$,T,S);break;case"a":$=p.shift(),T=p.shift(),S=p.shift(),E=p.shift(),_=p.shift(),N=a,P=l,a+=p.shift(),l+=p.shift(),m="A",x=this.convertEndpointToCenterParameterization(N,P,a,l,E,_,$,T,S);break}i.push({command:m||f,points:x,start:{x:b,y:v},pathLength:this.calcLength(b,v,m||f,x)})}(f==="z"||f==="Z")&&i.push({command:"z",points:[],start:void 0,pathLength:0})}return i}static calcLength(e,n,s,r){let i,o,a,l;const u=hn;switch(s){case"L":return u.getLineLength(e,n,r[0],r[1]);case"C":return nI([e,r[0],r[2],r[4]],[n,r[1],r[3],r[5]],1);case"Q":return sI([e,r[0],r[2]],[n,r[1],r[3]],1);case"A":i=0;const c=r[4],h=r[5],d=r[4]+h;let f=Math.PI/180;if(Math.abs(c-d)<f&&(f=Math.abs(c-d)),o=u.getPointOnEllipticalArc(r[0],r[1],r[2],r[3],c,0),h<0)for(l=c-f;l>d;l-=f)a=u.getPointOnEllipticalArc(r[0],r[1],r[2],r[3],l,0),i+=u.getLineLength(o.x,o.y,a.x,a.y),o=a;else for(l=c+f;l<d;l+=f)a=u.getPointOnEllipticalArc(r[0],r[1],r[2],r[3],l,0),i+=u.getLineLength(o.x,o.y,a.x,a.y),o=a;return a=u.getPointOnEllipticalArc(r[0],r[1],r[2],r[3],d,0),i+=u.getLineLength(o.x,o.y,a.x,a.y),i}return 0}static convertEndpointToCenterParameterization(e,n,s,r,i,o,a,l,u){const c=u*(Math.PI/180),h=Math.cos(c)*(e-s)/2+Math.sin(c)*(n-r)/2,d=-1*Math.sin(c)*(e-s)/2+Math.cos(c)*(n-r)/2,f=h*h/(a*a)+d*d/(l*l);f>1&&(a*=Math.sqrt(f),l*=Math.sqrt(f));let p=Math.sqrt((a*a*(l*l)-a*a*(d*d)-l*l*(h*h))/(a*a*(d*d)+l*l*(h*h)));i===o&&(p*=-1),isNaN(p)&&(p=0);const g=p*a*d/l,m=p*-l*h/a,x=(e+s)/2+Math.cos(c)*g-Math.sin(c)*m,b=(n+r)/2+Math.sin(c)*g+Math.cos(c)*m,v=function(E){return Math.sqrt(E[0]*E[0]+E[1]*E[1])},y=function(E,_){return(E[0]*_[0]+E[1]*_[1])/(v(E)*v(_))},C=function(E,_){return(E[0]*_[1]<E[1]*_[0]?-1:1)*Math.acos(y(E,_))},I=C([1,0],[(h-g)/a,(d-m)/l]),$=[(h-g)/a,(d-m)/l],T=[(-1*h-g)/a,(-1*d-m)/l];let S=C($,T);return y($,T)<=-1&&(S=Math.PI),y($,T)>=1&&(S=0),o===0&&S>0&&(S=S-2*Math.PI),o===1&&S<0&&(S=S+2*Math.PI),[x,b,a,l,I,S,c,o]}}hn.prototype.className="Path";hn.prototype._attrsAffectingSize=["data"];Rn(hn);X.addGetterSetter(hn,"data");class Ql extends Mo{_sceneFunc(e){super._sceneFunc(e);const n=Math.PI*2,s=this.points();let r=s;const i=this.tension()!==0&&s.length>4;i&&(r=this.getTensionPoints());const o=this.pointerLength(),a=s.length;let l,u;if(i){const d=[r[r.length-4],r[r.length-3],r[r.length-2],r[r.length-1],s[a-2],s[a-1]],f=hn.calcLength(r[r.length-4],r[r.length-3],"C",d),p=hn.getPointOnQuadraticBezier(Math.min(1,1-o/f),d[0],d[1],d[2],d[3],d[4],d[5]);l=s[a-2]-p.x,u=s[a-1]-p.y}else l=s[a-2]-s[a-4],u=s[a-1]-s[a-3];const c=(Math.atan2(u,l)+n)%n,h=this.pointerWidth();this.pointerAtEnding()&&(e.save(),e.beginPath(),e.translate(s[a-2],s[a-1]),e.rotate(c),e.moveTo(0,0),e.lineTo(-o,h/2),e.lineTo(-o,-h/2),e.closePath(),e.restore(),this.__fillStroke(e)),this.pointerAtBeginning()&&(e.save(),e.beginPath(),e.translate(s[0],s[1]),i?(l=(r[0]+r[2])/2-s[0],u=(r[1]+r[3])/2-s[1]):(l=s[2]-s[0],u=s[3]-s[1]),e.rotate((Math.atan2(-u,-l)+n)%n),e.moveTo(0,0),e.lineTo(-o,h/2),e.lineTo(-o,-h/2),e.closePath(),e.restore(),this.__fillStroke(e))}__fillStroke(e){const n=this.dashEnabled();n&&(this.attrs.dashEnabled=!1,e.setLineDash([])),e.fillStrokeShape(this),n&&(this.attrs.dashEnabled=!0)}getSelfRect(){const e=super.getSelfRect(),n=this.pointerWidth()/2;return{x:e.x,y:e.y-n,width:e.width,height:e.height+n*2}}}Ql.prototype.className="Arrow";Rn(Ql);X.addGetterSetter(Ql,"pointerLength",10,Be());X.addGetterSetter(Ql,"pointerWidth",10,Be());X.addGetterSetter(Ql,"pointerAtBeginning",!1);X.addGetterSetter(Ql,"pointerAtEnding",!0);class ph extends Ne{_sceneFunc(e){e.beginPath(),e.arc(0,0,this.attrs.radius||0,0,Math.PI*2,!1),e.closePath(),e.fillStrokeShape(this)}getWidth(){return this.radius()*2}getHeight(){return this.radius()*2}setWidth(e){this.radius()!==e/2&&this.radius(e/2)}setHeight(e){this.radius()!==e/2&&this.radius(e/2)}}ph.prototype._centroid=!0;ph.prototype.className="Circle";ph.prototype._attrsAffectingSize=["radius"];Rn(ph);X.addGetterSetter(ph,"radius",0,Be());class ka extends Ne{_sceneFunc(e){const n=this.radiusX(),s=this.radiusY();e.beginPath(),e.save(),n!==s&&e.scale(1,s/n),e.arc(0,0,n,0,Math.PI*2,!1),e.restore(),e.closePath(),e.fillStrokeShape(this)}getWidth(){return this.radiusX()*2}getHeight(){return this.radiusY()*2}setWidth(e){this.radiusX(e/2)}setHeight(e){this.radiusY(e/2)}}ka.prototype.className="Ellipse";ka.prototype._centroid=!0;ka.prototype._attrsAffectingSize=["radiusX","radiusY"];Rn(ka);X.addComponentsGetterSetter(ka,"radius",["x","y"]);X.addGetterSetter(ka,"radiusX",0,Be());X.addGetterSetter(ka,"radiusY",0,Be());let yi=class Y4 extends Ne{constructor(e){super(e),this._loadListener=()=>{this._requestDraw()},this.on("imageChange.konva",n=>{this._removeImageLoad(n.oldVal),this._setImageLoad()}),this._setImageLoad()}_setImageLoad(){const e=this.image();e&&e.complete||e&&e.readyState===4||e&&e.addEventListener&&e.addEventListener("load",this._loadListener)}_removeImageLoad(e){e&&e.removeEventListener&&e.removeEventListener("load",this._loadListener)}destroy(){return this._removeImageLoad(this.image()),super.destroy(),this}_useBufferCanvas(){const e=!!this.cornerRadius(),n=this.hasShadow();return e&&n?!0:super._useBufferCanvas(!0)}_sceneFunc(e){const n=this.getWidth(),s=this.getHeight(),r=this.cornerRadius(),i=this.attrs.image;let o;if(i){const a=this.attrs.cropWidth,l=this.attrs.cropHeight;a&&l?o=[i,this.cropX(),this.cropY(),a,l,0,0,n,s]:o=[i,0,0,n,s]}(this.hasFill()||this.hasStroke()||r)&&(e.beginPath(),r?le.drawRoundedRectPath(e,n,s,r):e.rect(0,0,n,s),e.closePath(),e.fillStrokeShape(this)),i&&(r&&e.clip(),e.drawImage.apply(e,o))}_hitFunc(e){const n=this.width(),s=this.height(),r=this.cornerRadius();e.beginPath(),r?le.drawRoundedRectPath(e,n,s,r):e.rect(0,0,n,s),e.closePath(),e.fillStrokeShape(this)}getWidth(){var e,n,s;return(s=(e=this.attrs.width)!==null&&e!==void 0?e:(n=this.image())===null||n===void 0?void 0:n.width)!==null&&s!==void 0?s:0}getHeight(){var e,n,s;return(s=(e=this.attrs.height)!==null&&e!==void 0?e:(n=this.image())===null||n===void 0?void 0:n.height)!==null&&s!==void 0?s:0}static fromURL(e,n,s=null){const r=le.createImageElement();r.onload=function(){const i=new Y4({image:r});n(i)},r.onerror=s,r.crossOrigin="Anonymous",r.src=e}};yi.prototype.className="Image";yi.prototype._attrsAffectingSize=["image"];Rn(yi);X.addGetterSetter(yi,"cornerRadius",0,eb(4));X.addGetterSetter(yi,"image");X.addComponentsGetterSetter(yi,"crop",["x","y","width","height"]);X.addGetterSetter(yi,"cropX",0,Be());X.addGetterSetter(yi,"cropY",0,Be());X.addGetterSetter(yi,"cropWidth",0,Be());X.addGetterSetter(yi,"cropHeight",0,Be());const Z4=["fontFamily","fontSize","fontStyle","padding","lineHeight","text","width","height","pointerDirection","pointerWidth","pointerHeight"],BUe="Change.konva",zUe="none",$y="up",Ry="right",Ay="down",Py="left",GUe=Z4.length;class Aw extends Yu{constructor(e){super(e),this.on("add.konva",function(n){this._addListeners(n.child),this._sync()})}getText(){return this.find("Text")[0]}getTag(){return this.find("Tag")[0]}_addListeners(e){let n=this,s;const r=function(){n._sync()};for(s=0;s<GUe;s++)e.on(Z4[s]+BUe,r)}getWidth(){return this.getText().width()}getHeight(){return this.getText().height()}_sync(){let e=this.getText(),n=this.getTag(),s,r,i,o,a,l,u;if(e&&n){switch(s=e.width(),r=e.height(),i=n.pointerDirection(),o=n.pointerWidth(),u=n.pointerHeight(),a=0,l=0,i){case $y:a=s/2,l=-1*u;break;case Ry:a=s+o,l=r/2;break;case Ay:a=s/2,l=r+u;break;case Py:a=-1*o,l=r/2;break}n.setAttrs({x:-1*a,y:-1*l,width:s,height:r}),e.setAttrs({x:-1*a,y:-1*l})}}}Aw.prototype.className="Label";Rn(Aw);class Jl extends Ne{_sceneFunc(e){const n=this.width(),s=this.height(),r=this.pointerDirection(),i=this.pointerWidth(),o=this.pointerHeight(),a=this.cornerRadius();let l=0,u=0,c=0,h=0;typeof a=="number"?l=u=c=h=Math.min(a,n/2,s/2):(l=Math.min(a[0]||0,n/2,s/2),u=Math.min(a[1]||0,n/2,s/2),h=Math.min(a[2]||0,n/2,s/2),c=Math.min(a[3]||0,n/2,s/2)),e.beginPath(),e.moveTo(l,0),r===$y&&(e.lineTo((n-i)/2,0),e.lineTo(n/2,-1*o),e.lineTo((n+i)/2,0)),e.lineTo(n-u,0),e.arc(n-u,u,u,Math.PI*3/2,0,!1),r===Ry&&(e.lineTo(n,(s-o)/2),e.lineTo(n+i,s/2),e.lineTo(n,(s+o)/2)),e.lineTo(n,s-h),e.arc(n-h,s-h,h,0,Math.PI/2,!1),r===Ay&&(e.lineTo((n+i)/2,s),e.lineTo(n/2,s+o),e.lineTo((n-i)/2,s)),e.lineTo(c,s),e.arc(c,s-c,c,Math.PI/2,Math.PI,!1),r===Py&&(e.lineTo(0,(s+o)/2),e.lineTo(-1*i,s/2),e.lineTo(0,(s-o)/2)),e.lineTo(0,l),e.arc(l,l,l,Math.PI,Math.PI*3/2,!1),e.closePath(),e.fillStrokeShape(this)}getSelfRect(){let e=0,n=0,s=this.pointerWidth(),r=this.pointerHeight(),i=this.pointerDirection(),o=this.width(),a=this.height();return i===$y?(n-=r,a+=r):i===Ay?a+=r:i===Py?(e-=s*1.5,o+=s):i===Ry&&(o+=s*1.5),{x:e,y:n,width:o,height:a}}}Jl.prototype.className="Tag";Rn(Jl);X.addGetterSetter(Jl,"pointerDirection",zUe);X.addGetterSetter(Jl,"pointerWidth",0,Be());X.addGetterSetter(Jl,"pointerHeight",0,Be());X.addGetterSetter(Jl,"cornerRadius",0,eb(4));class yp extends Ne{_sceneFunc(e){const n=this.cornerRadius(),s=this.width(),r=this.height();e.beginPath(),n?le.drawRoundedRectPath(e,s,r,n):e.rect(0,0,s,r),e.closePath(),e.fillStrokeShape(this)}}yp.prototype.className="Rect";Rn(yp);X.addGetterSetter(yp,"cornerRadius",0,eb(4));class Ea extends Ne{_sceneFunc(e){const n=this._getPoints(),s=this.radius(),r=this.sides(),i=this.cornerRadius();if(e.beginPath(),i)le.drawRoundedPolygonPath(e,n,r,s,i);else{e.moveTo(n[0].x,n[0].y);for(let o=1;o<n.length;o++)e.lineTo(n[o].x,n[o].y)}e.closePath(),e.fillStrokeShape(this)}_getPoints(){const e=this.attrs.sides,n=this.attrs.radius||0,s=[];for(let r=0;r<e;r++)s.push({x:n*Math.sin(r*2*Math.PI/e),y:-1*n*Math.cos(r*2*Math.PI/e)});return s}getSelfRect(){const e=this._getPoints();let n=e[0].x,s=e[0].x,r=e[0].y,i=e[0].y;return e.forEach(o=>{n=Math.min(n,o.x),s=Math.max(s,o.x),r=Math.min(r,o.y),i=Math.max(i,o.y)}),{x:n,y:r,width:s-n,height:i-r}}getWidth(){return this.radius()*2}getHeight(){return this.radius()*2}setWidth(e){this.radius(e/2)}setHeight(e){this.radius(e/2)}}Ea.prototype.className="RegularPolygon";Ea.prototype._centroid=!0;Ea.prototype._attrsAffectingSize=["radius"];Rn(Ea);X.addGetterSetter(Ea,"radius",0,Be());X.addGetterSetter(Ea,"sides",0,Be());X.addGetterSetter(Ea,"cornerRadius",0,eb(4));const iI=Math.PI*2;class eu extends Ne{_sceneFunc(e){e.beginPath(),e.arc(0,0,this.innerRadius(),0,iI,!1),e.moveTo(this.outerRadius(),0),e.arc(0,0,this.outerRadius(),iI,0,!0),e.closePath(),e.fillStrokeShape(this)}getWidth(){return this.outerRadius()*2}getHeight(){return this.outerRadius()*2}setWidth(e){this.outerRadius(e/2)}setHeight(e){this.outerRadius(e/2)}}eu.prototype.className="Ring";eu.prototype._centroid=!0;eu.prototype._attrsAffectingSize=["innerRadius","outerRadius"];Rn(eu);X.addGetterSetter(eu,"innerRadius",0,Be());X.addGetterSetter(eu,"outerRadius",0,Be());class to extends Ne{constructor(e){super(e),this._updated=!0,this.anim=new Fr(()=>{const n=this._updated;return this._updated=!1,n}),this.on("animationChange.konva",function(){this.frameIndex(0)}),this.on("frameIndexChange.konva",function(){this._updated=!0}),this.on("frameRateChange.konva",function(){this.anim.isRunning()&&(clearInterval(this.interval),this._setInterval())})}_sceneFunc(e){const n=this.animation(),s=this.frameIndex(),r=s*4,i=this.animations()[n],o=this.frameOffsets(),a=i[r+0],l=i[r+1],u=i[r+2],c=i[r+3],h=this.image();if((this.hasFill()||this.hasStroke())&&(e.beginPath(),e.rect(0,0,u,c),e.closePath(),e.fillStrokeShape(this)),h)if(o){const d=o[n],f=s*2;e.drawImage(h,a,l,u,c,d[f+0],d[f+1],u,c)}else e.drawImage(h,a,l,u,c,0,0,u,c)}_hitFunc(e){const n=this.animation(),s=this.frameIndex(),r=s*4,i=this.animations()[n],o=this.frameOffsets(),a=i[r+2],l=i[r+3];if(e.beginPath(),o){const u=o[n],c=s*2;e.rect(u[c+0],u[c+1],a,l)}else e.rect(0,0,a,l);e.closePath(),e.fillShape(this)}_useBufferCanvas(){return super._useBufferCanvas(!0)}_setInterval(){const e=this;this.interval=setInterval(function(){e._updateIndex()},1e3/this.frameRate())}start(){if(this.isRunning())return;const e=this.getLayer();this.anim.setLayers(e),this._setInterval(),this.anim.start()}stop(){this.anim.stop(),clearInterval(this.interval)}isRunning(){return this.anim.isRunning()}_updateIndex(){const e=this.frameIndex(),n=this.animation(),s=this.animations(),r=s[n],i=r.length/4;e<i-1?this.frameIndex(e+1):this.frameIndex(0)}}to.prototype.className="Sprite";Rn(to);X.addGetterSetter(to,"animation");X.addGetterSetter(to,"animations");X.addGetterSetter(to,"frameOffsets");X.addGetterSetter(to,"image");X.addGetterSetter(to,"frameIndex",0,Be());X.addGetterSetter(to,"frameRate",17,Be());X.backCompat(to,{index:"frameIndex",getIndex:"getFrameIndex",setIndex:"setFrameIndex"});class _a extends Ne{_sceneFunc(e){const n=this.innerRadius(),s=this.outerRadius(),r=this.numPoints();e.beginPath(),e.moveTo(0,0-s);for(let i=1;i<r*2;i++){const o=i%2===0?s:n,a=o*Math.sin(i*Math.PI/r),l=-1*o*Math.cos(i*Math.PI/r);e.lineTo(a,l)}e.closePath(),e.fillStrokeShape(this)}getWidth(){return this.outerRadius()*2}getHeight(){return this.outerRadius()*2}setWidth(e){this.outerRadius(e/2)}setHeight(e){this.outerRadius(e/2)}}_a.prototype.className="Star";_a.prototype._centroid=!0;_a.prototype._attrsAffectingSize=["innerRadius","outerRadius"];Rn(_a);X.addGetterSetter(_a,"numPoints",5,Be());X.addGetterSetter(_a,"innerRadius",0,Be());X.addGetterSetter(_a,"outerRadius",0,Be());function zo(t){return[...t].reduce((e,n,s,r)=>{if(new RegExp("\\p{Emoji}","u").test(n)){const i=r[s+1];i&&new RegExp("\\p{Emoji_Modifier}|\\u200D","u").test(i)?(e.push(n+i),r[s+1]=""):e.push(n)}else new RegExp("\\p{Regional_Indicator}{2}","u").test(n+(r[s+1]||""))?e.push(n+r[s+1]):s>0&&new RegExp("\\p{Mn}|\\p{Me}|\\p{Mc}","u").test(n)?e[e.length-1]+=n:n&&e.push(n);return e},[])}const du="auto",VUe="center",Q4="inherit",$h="justify",WUe="Change.konva",HUe="2d",oI="-",J4="left",KUe="text",jUe="Text",XUe="top",qUe="bottom",aI="middle",eM="normal",YUe="px ",mm=" ",ZUe="right",lI="rtl",QUe="word",JUe="char",uI="none",o1="",tM=["direction","fontFamily","fontSize","fontStyle","fontVariant","padding","align","verticalAlign","lineHeight","text","width","height","wrap","ellipsis","letterSpacing"],eBe=tM.length;function tBe(t){return t.split(",").map(e=>{e=e.trim();const n=e.indexOf(" ")>=0,s=e.indexOf('"')>=0||e.indexOf("'")>=0;return n&&!s&&(e=`"${e}"`),e}).join(", ")}let gm;function a1(){return gm||(gm=le.createCanvasElement().getContext(HUe),gm)}function nBe(t){t.fillText(this._partialText,this._partialTextX,this._partialTextY)}function sBe(t){t.setAttr("miterLimit",2),t.strokeText(this._partialText,this._partialTextX,this._partialTextY)}function rBe(t){return t=t||{},!t.fillLinearGradientColorStops&&!t.fillRadialGradientColorStops&&!t.fillPatternImage&&(t.fill=t.fill||"black"),t}class wn extends Ne{constructor(e){super(rBe(e)),this._partialTextX=0,this._partialTextY=0;for(let n=0;n<eBe;n++)this.on(tM[n]+WUe,this._setTextData);this._setTextData()}_sceneFunc(e){var n,s;const r=this.textArr,i=r.length;if(!this.text())return;let o=this.padding(),a=this.fontSize(),l=this.lineHeight()*a,u=this.verticalAlign(),c=this.direction(),h=0,d=this.align(),f=this.getWidth(),p=this.letterSpacing(),g=this.charRenderFunc(),m=this.fill(),x=this.textDecoration(),b=x.indexOf("underline")!==-1,v=x.indexOf("line-through")!==-1,y;c=c===Q4?e.direction:c;let C=l/2,I=aI;if(!He.legacyTextRendering){const $=this.measureSize("M");I="alphabetic";const T=(n=$.fontBoundingBoxAscent)!==null&&n!==void 0?n:$.actualBoundingBoxAscent,S=(s=$.fontBoundingBoxDescent)!==null&&s!==void 0?s:$.actualBoundingBoxDescent;C=(T-S)/2+l/2}for(c===lI&&e.setAttr("direction",c),e.setAttr("font",this._getContextFont()),e.setAttr("textBaseline",I),e.setAttr("textAlign",J4),u===aI?h=(this.getHeight()-i*l-o*2)/2:u===qUe&&(h=this.getHeight()-i*l-o*2),e.translate(o,h+o),y=0;y<i;y++){let $=0,T=0;const S=r[y],E=S.text,_=S.width,N=S.lastInParagraph;if(e.save(),d===ZUe?$+=f-_-o*2:d===VUe&&($+=(f-_-o*2)/2),b){e.save(),e.beginPath();const M=He.legacyTextRendering?Math.round(a/2):Math.round(a/4),z=$,A=C+T+M;e.moveTo(z,A);const B=d===$h&&!N?f-o*2:_;e.lineTo(z+Math.round(B),A),e.lineWidth=a/15;const L=this._getLinearGradient();e.strokeStyle=L||m,e.stroke(),e.restore()}const P=$;if(c!==lI&&(p!==0||d===$h||g)){const M=E.split(" ").length-1,z=zo(E);for(let A=0;A<z.length;A++){const B=z[A];if(B===" "&&!N&&d===$h&&($+=(f-o*2-_)/M),this._partialTextX=$,this._partialTextY=C+T,this._partialText=B,g){e.save();const U=r.slice(0,y).reduce((Z,J)=>Z+zo(J.text).length,0),j=A+U;g({char:B,index:j,x:$,y:C+T,lineIndex:y,column:A,isLastInLine:N,width:this.measureSize(B).width,context:e})}e.fillStrokeShape(this),g&&e.restore(),$+=this.measureSize(B).width+p}}else p!==0&&e.setAttr("letterSpacing",`${p}px`),this._partialTextX=$,this._partialTextY=C+T,this._partialText=E,e.fillStrokeShape(this);if(v){e.save(),e.beginPath();const M=He.legacyTextRendering?0:-Math.round(a/4),z=P;e.moveTo(z,C+T+M);const A=d===$h&&!N?f-o*2:_;e.lineTo(z+Math.round(A),C+T+M),e.lineWidth=a/15;const B=this._getLinearGradient();e.strokeStyle=B||m,e.stroke(),e.restore()}e.restore(),i>1&&(C+=l)}}_hitFunc(e){const n=this.getWidth(),s=this.getHeight();e.beginPath(),e.rect(0,0,n,s),e.closePath(),e.fillStrokeShape(this)}setText(e){const n=le._isString(e)?e:e==null?"":e+"";return this._setAttr(KUe,n),this}getWidth(){return this.attrs.width===du||this.attrs.width===void 0?this.getTextWidth()+this.padding()*2:this.attrs.width}getHeight(){return this.attrs.height===du||this.attrs.height===void 0?this.fontSize()*this.textArr.length*this.lineHeight()+this.padding()*2:this.attrs.height}getTextWidth(){return this.textWidth}getTextHeight(){return le.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."),this.textHeight}measureSize(e){var n,s,r,i,o,a,l,u,c,h,d;let f=a1(),p=this.fontSize(),g;f.save(),f.font=this._getContextFont(),g=f.measureText(e),f.restore();const m=p/100;return{actualBoundingBoxAscent:(n=g.actualBoundingBoxAscent)!==null&&n!==void 0?n:71.58203125*m,actualBoundingBoxDescent:(s=g.actualBoundingBoxDescent)!==null&&s!==void 0?s:0,actualBoundingBoxLeft:(r=g.actualBoundingBoxLeft)!==null&&r!==void 0?r:-7.421875*m,actualBoundingBoxRight:(i=g.actualBoundingBoxRight)!==null&&i!==void 0?i:75.732421875*m,alphabeticBaseline:(o=g.alphabeticBaseline)!==null&&o!==void 0?o:0,emHeightAscent:(a=g.emHeightAscent)!==null&&a!==void 0?a:100*m,emHeightDescent:(l=g.emHeightDescent)!==null&&l!==void 0?l:-20*m,fontBoundingBoxAscent:(u=g.fontBoundingBoxAscent)!==null&&u!==void 0?u:91*m,fontBoundingBoxDescent:(c=g.fontBoundingBoxDescent)!==null&&c!==void 0?c:21*m,hangingBaseline:(h=g.hangingBaseline)!==null&&h!==void 0?h:72.80000305175781*m,ideographicBaseline:(d=g.ideographicBaseline)!==null&&d!==void 0?d:-21*m,width:g.width,height:p}}_getContextFont(){return this.fontStyle()+mm+this.fontVariant()+mm+(this.fontSize()+YUe)+tBe(this.fontFamily())}_addTextLine(e){this.align()===$h&&(e=e.trim());const s=this._getTextWidth(e);return this.textArr.push({text:e,width:s,lastInParagraph:!1})}_getTextWidth(e){const n=this.letterSpacing(),s=e.length;return a1().measureText(e).width+n*s}_setTextData(){let e=this.text().split(`
`),n=+this.fontSize(),s=0,r=this.lineHeight()*n,i=this.attrs.width,o=this.attrs.height,a=i!==du&&i!==void 0,l=o!==du&&o!==void 0,u=this.padding(),c=i-u*2,h=o-u*2,d=0,f=this.wrap(),p=f!==uI,g=f!==JUe&&p,m=this.ellipsis();this.textArr=[],a1().font=this._getContextFont();const x=m?this._getTextWidth(o1):0;for(let b=0,v=e.length;b<v;++b){let y=e[b],C=this._getTextWidth(y);if(a&&C>c)for(;y.length>0;){let I=0,$=zo(y).length,T="",S=0;for(;I<$;){const E=I+$>>>1,_=zo(y),N=_.slice(0,E+1).join(""),P=this._getTextWidth(N);(m&&l&&d+r>h?P+x:P)<=c?(I=E+1,T=N,S=P):$=E}if(T){if(g){const N=zo(y),P=zo(T),M=N[P.length],z=M===mm||M===oI;let A;if(z&&S<=c)A=P.length;else{const B=P.lastIndexOf(mm),L=P.lastIndexOf(oI);A=Math.max(B,L)+1}A>0&&(I=A,T=N.slice(0,I).join(""),S=this._getTextWidth(T))}if(T=T.trimRight(),this._addTextLine(T),s=Math.max(s,S),d+=r,this._shouldHandleEllipsis(d)){this._tryToAddEllipsisToLastLine();break}if(y=zo(y).slice(I).join("").trimLeft(),y.length>0&&(C=this._getTextWidth(y),C<=c)){this._addTextLine(y),d+=r,s=Math.max(s,C);break}}else break}else this._addTextLine(y),d+=r,s=Math.max(s,C),this._shouldHandleEllipsis(d)&&b<v-1&&this._tryToAddEllipsisToLastLine();if(this.textArr[this.textArr.length-1]&&(this.textArr[this.textArr.length-1].lastInParagraph=!0),l&&d+r>h)break}this.textHeight=n,this.textWidth=s}_shouldHandleEllipsis(e){const n=+this.fontSize(),s=this.lineHeight()*n,r=this.attrs.height,i=r!==du&&r!==void 0,o=this.padding(),a=r-o*2;return!(this.wrap()!==uI)||i&&e+s>a}_tryToAddEllipsisToLastLine(){const e=this.attrs.width,n=e!==du&&e!==void 0,s=this.padding(),r=e-s*2,i=this.ellipsis(),o=this.textArr[this.textArr.length-1];!o||!i||(n&&(this._getTextWidth(o.text+o1)<r||(o.text=o.text.slice(0,o.text.length-3))),this.textArr.splice(this.textArr.length-1,1),this._addTextLine(o.text+o1))}getStrokeScaleEnabled(){return!0}_useBufferCanvas(){const e=this.textDecoration().indexOf("underline")!==-1||this.textDecoration().indexOf("line-through")!==-1,n=this.hasShadow();return e&&n?!0:super._useBufferCanvas()}}wn.prototype._fillFunc=nBe;wn.prototype._strokeFunc=sBe;wn.prototype.className=jUe;wn.prototype._attrsAffectingSize=["text","fontSize","padding","wrap","lineHeight","letterSpacing"];Rn(wn);X.overWriteSetter(wn,"width",_w());X.overWriteSetter(wn,"height",_w());X.addGetterSetter(wn,"direction",Q4);X.addGetterSetter(wn,"fontFamily","Arial");X.addGetterSetter(wn,"fontSize",12,Be());X.addGetterSetter(wn,"fontStyle",eM);X.addGetterSetter(wn,"fontVariant",eM);X.addGetterSetter(wn,"padding",0,Be());X.addGetterSetter(wn,"align",J4);X.addGetterSetter(wn,"verticalAlign",XUe);X.addGetterSetter(wn,"lineHeight",1,Be());X.addGetterSetter(wn,"wrap",QUe);X.addGetterSetter(wn,"ellipsis",!1,bi());X.addGetterSetter(wn,"letterSpacing",0,Be());X.addGetterSetter(wn,"text","",Yl());X.addGetterSetter(wn,"textDecoration","");X.addGetterSetter(wn,"charRenderFunc",void 0);const iBe="",nM="normal";function sM(t){t.fillText(this.partialText,0,0)}function rM(t){t.strokeText(this.partialText,0,0)}class ps extends Ne{constructor(e){super(e),this.dummyCanvas=le.createCanvasElement(),this.dataArray=[],this._readDataAttribute(),this.on("dataChange.konva",function(){this._readDataAttribute(),this._setTextData()}),this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva",this._setTextData),this._setTextData()}_getTextPathLength(){return hn.getPathLength(this.dataArray)}_getPointAtLength(e){if(!this.attrs.data)return null;const n=this.pathLength;return e>n?null:hn.getPointAtLengthOfDataArray(e,this.dataArray)}_readDataAttribute(){this.dataArray=hn.parsePathData(this.attrs.data),this.pathLength=this._getTextPathLength()}_sceneFunc(e){e.setAttr("font",this._getContextFont()),e.setAttr("textBaseline",this.textBaseline()),e.setAttr("textAlign","left"),e.save();const n=this.textDecoration(),s=this.fill(),r=this.fontSize(),i=this.glyphInfo,o=n.indexOf("underline")!==-1,a=n.indexOf("line-through")!==-1;o&&e.beginPath();for(let l=0;l<i.length;l++){e.save();const u=i[l].p0;e.translate(u.x,u.y),e.rotate(i[l].rotation),this.partialText=i[l].text,e.fillStrokeShape(this),o&&(l===0&&e.moveTo(0,r/2+1),e.lineTo(i[l].width,r/2+1)),e.restore()}if(o&&(e.strokeStyle=s,e.lineWidth=r/20,e.stroke()),a){e.beginPath();for(let l=0;l<i.length;l++){e.save();const u=i[l].p0;e.translate(u.x,u.y),e.rotate(i[l].rotation),l===0&&e.moveTo(0,0),e.lineTo(i[l].width,0),e.restore()}e.strokeStyle=s,e.lineWidth=r/20,e.stroke()}e.restore()}_hitFunc(e){e.beginPath();const n=this.glyphInfo;if(n.length>=1){const s=n[0].p0;e.moveTo(s.x,s.y)}for(let s=0;s<n.length;s++){const r=n[s].p1;e.lineTo(r.x,r.y)}e.setAttr("lineWidth",this.fontSize()),e.setAttr("strokeStyle",this.colorKey),e.stroke()}getTextWidth(){return this.textWidth}getTextHeight(){return le.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."),this.textHeight}setText(e){return wn.prototype.setText.call(this,e)}_getContextFont(){return wn.prototype._getContextFont.call(this)}_getTextSize(e){const s=this.dummyCanvas.getContext("2d");s.save(),s.font=this._getContextFont();const r=s.measureText(e);return s.restore(),{width:r.width,height:parseInt(`${this.fontSize()}`,10)}}_setTextData(){const e=zo(this.text()),n=[];let s=0;for(let h=0;h<e.length;h++)n.push({char:e[h],width:this._getTextSize(e[h]).width}),s+=n[h].width;const{height:r}=this._getTextSize(this.attrs.text);if(this.textWidth=s,this.textHeight=r,this.glyphInfo=[],!this.attrs.data)return null;const i=this.letterSpacing(),o=this.align(),a=this.kerningFunc(),l=Math.max(this.textWidth+((this.attrs.text||"").length-1)*i,0);let u=0;o==="center"&&(u=Math.max(0,this.pathLength/2-l/2)),o==="right"&&(u=Math.max(0,this.pathLength-l));let c=u;for(let h=0;h<n.length;h++){const d=this._getPointAtLength(c);if(!d)return;const f=n[h].char;let p=n[h].width+i;if(f===" "&&o==="justify"){const y=this.text().split(" ").length-1;p+=(this.pathLength-l)/y}const g=this._getPointAtLength(c+p);if(!g)return;const m=hn.getLineLength(d.x,d.y,g.x,g.y);let x=0;if(a)try{x=a(n[h-1].char,f)*this.fontSize()}catch{x=0}d.x+=x,g.x+=x,this.textWidth+=x;const b=hn.getPointOnLine(x+m/2,d.x,d.y,g.x,g.y),v=Math.atan2(g.y-d.y,g.x-d.x);this.glyphInfo.push({transposeX:b.x,transposeY:b.y,text:e[h],rotation:v,p0:d,p1:g,width:m}),c+=p}}getSelfRect(){if(!this.glyphInfo.length)return{x:0,y:0,width:0,height:0};const e=[];this.glyphInfo.forEach(function(u){e.push(u.p0.x),e.push(u.p0.y),e.push(u.p1.x),e.push(u.p1.y)});let n=e[0]||0,s=e[0]||0,r=e[1]||0,i=e[1]||0,o,a;for(let u=0;u<e.length/2;u++)o=e[u*2],a=e[u*2+1],n=Math.min(n,o),s=Math.max(s,o),r=Math.min(r,a),i=Math.max(i,a);const l=this.fontSize();return{x:n-l/2,y:r-l/2,width:s-n+l,height:i-r+l}}destroy(){return le.releaseCanvas(this.dummyCanvas),super.destroy()}}ps.prototype._fillFunc=sM;ps.prototype._strokeFunc=rM;ps.prototype._fillFuncHit=sM;ps.prototype._strokeFuncHit=rM;ps.prototype.className="TextPath";ps.prototype._attrsAffectingSize=["text","fontSize","data"];Rn(ps);X.addGetterSetter(ps,"data");X.addGetterSetter(ps,"fontFamily","Arial");X.addGetterSetter(ps,"fontSize",12,Be());X.addGetterSetter(ps,"fontStyle",nM);X.addGetterSetter(ps,"align","left");X.addGetterSetter(ps,"letterSpacing",0,Be());X.addGetterSetter(ps,"textBaseline","middle");X.addGetterSetter(ps,"fontVariant",nM);X.addGetterSetter(ps,"text",iBe);X.addGetterSetter(ps,"textDecoration","");X.addGetterSetter(ps,"kerningFunc",void 0);const iM="tr-konva",oBe=["resizeEnabledChange","rotateAnchorOffsetChange","rotateEnabledChange","enabledAnchorsChange","anchorSizeChange","borderEnabledChange","borderStrokeChange","borderStrokeWidthChange","borderDashChange","anchorStrokeChange","anchorStrokeWidthChange","anchorFillChange","anchorCornerRadiusChange","ignoreStrokeChange","anchorStyleFuncChange"].map(t=>t+`.${iM}`).join(" "),cI="nodesRect",aBe=["widthChange","heightChange","scaleXChange","scaleYChange","skewXChange","skewYChange","rotationChange","offsetXChange","offsetYChange","transformsEnabledChange","strokeWidthChange","draggableChange"],lBe={"top-left":-45,"top-center":0,"top-right":45,"middle-right":-90,"middle-left":90,"bottom-left":-135,"bottom-center":180,"bottom-right":135},uBe="ontouchstart"in He._global;function cBe(t,e,n){if(t==="rotater")return n;e+=le.degToRad(lBe[t]||0);const s=(le.radToDeg(e)%360+360)%360;return le._inRange(s,315+22.5,360)||le._inRange(s,0,22.5)?"ns-resize":le._inRange(s,45-22.5,45+22.5)?"nesw-resize":le._inRange(s,90-22.5,90+22.5)?"ew-resize":le._inRange(s,135-22.5,135+22.5)?"nwse-resize":le._inRange(s,180-22.5,180+22.5)?"ns-resize":le._inRange(s,225-22.5,225+22.5)?"nesw-resize":le._inRange(s,270-22.5,270+22.5)?"ew-resize":le._inRange(s,315-22.5,315+22.5)?"nwse-resize":(le.error("Transformer has unknown angle for cursor detection: "+s),"pointer")}const $g=["top-left","top-center","top-right","middle-right","middle-left","bottom-left","bottom-center","bottom-right"];function hBe(t){return{x:t.x+t.width/2*Math.cos(t.rotation)+t.height/2*Math.sin(-t.rotation),y:t.y+t.height/2*Math.cos(t.rotation)+t.width/2*Math.sin(t.rotation)}}function oM(t,e,n){const s=n.x+(t.x-n.x)*Math.cos(e)-(t.y-n.y)*Math.sin(e),r=n.y+(t.x-n.x)*Math.sin(e)+(t.y-n.y)*Math.cos(e);return{...t,rotation:t.rotation+e,x:s,y:r}}function dBe(t,e){const n=hBe(t);return oM(t,e,n)}function fBe(t,e,n){let s=e;for(let r=0;r<t.length;r++){const i=He.getAngle(t[r]),o=Math.abs(i-e)%(Math.PI*2);Math.min(o,Math.PI*2-o)<n&&(s=i)}return s}let Dy=0;class zt extends Yu{constructor(e){super(e),this._movingAnchorName=null,this._transforming=!1,this._createElements(),this._handleMouseMove=this._handleMouseMove.bind(this),this._handleMouseUp=this._handleMouseUp.bind(this),this.update=this.update.bind(this),this.on(oBe,this.update),this.getNode()&&this.update()}attachTo(e){return this.setNode(e),this}setNode(e){return le.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead."),this.setNodes([e])}getNode(){return this._nodes&&this._nodes[0]}_getEventNamespace(){return iM+this._id}setNodes(e=[]){this._nodes&&this._nodes.length&&this.detach();const n=e.filter(r=>r.isAncestorOf(this)?(le.error("Konva.Transformer cannot be an a child of the node you are trying to attach"),!1):!0);return this._nodes=e=n,e.length===1&&this.useSingleNodeRotation()?this.rotation(e[0].getAbsoluteRotation()):this.rotation(0),this._nodes.forEach(r=>{const i=()=>{this.nodes().length===1&&this.useSingleNodeRotation()&&this.rotation(this.nodes()[0].getAbsoluteRotation()),this._resetTransformCache(),!this._transforming&&!this.isDragging()&&this.update()};if(r._attrsAffectingSize.length){const o=r._attrsAffectingSize.map(a=>a+"Change."+this._getEventNamespace()).join(" ");r.on(o,i)}r.on(aBe.map(o=>o+`.${this._getEventNamespace()}`).join(" "),i),r.on(`absoluteTransformChange.${this._getEventNamespace()}`,i),this._proxyDrag(r)}),this._resetTransformCache(),!!this.findOne(".top-left")&&this.update(),this}_proxyDrag(e){let n;e.on(`dragstart.${this._getEventNamespace()}`,s=>{n=e.getAbsolutePosition(),!this.isDragging()&&e!==this.findOne(".back")&&this.startDrag(s,!1)}),e.on(`dragmove.${this._getEventNamespace()}`,s=>{if(!n)return;const r=e.getAbsolutePosition(),i=r.x-n.x,o=r.y-n.y;this.nodes().forEach(a=>{if(a===e||a.isDragging())return;const l=a.getAbsolutePosition();a.setAbsolutePosition({x:l.x+i,y:l.y+o}),a.startDrag(s)}),n=null})}getNodes(){return this._nodes||[]}getActiveAnchor(){return this._movingAnchorName}detach(){this._nodes&&this._nodes.forEach(e=>{e.off("."+this._getEventNamespace())}),this._nodes=[],this._resetTransformCache()}_resetTransformCache(){this._clearCache(cI),this._clearCache("transform"),this._clearSelfAndDescendantCache("absoluteTransform")}_getNodeRect(){return this._getCache(cI,this.__getNodeRect)}__getNodeShape(e,n=this.rotation(),s){const r=e.getClientRect({skipTransform:!0,skipShadow:!0,skipStroke:this.ignoreStroke()}),i=e.getAbsoluteScale(s),o=e.getAbsolutePosition(s),a=r.x*i.x-e.offsetX()*i.x,l=r.y*i.y-e.offsetY()*i.y,u=(He.getAngle(e.getAbsoluteRotation())+Math.PI*2)%(Math.PI*2),c={x:o.x+a*Math.cos(u)+l*Math.sin(-u),y:o.y+l*Math.cos(u)+a*Math.sin(u),width:r.width*i.x,height:r.height*i.y,rotation:u};return oM(c,-He.getAngle(n),{x:0,y:0})}__getNodeRect(){if(!this.getNode())return{x:-1e8,y:-1e8,width:0,height:0,rotation:0};const n=[];this.nodes().map(u=>{const c=u.getClientRect({skipTransform:!0,skipShadow:!0,skipStroke:this.ignoreStroke()}),h=[{x:c.x,y:c.y},{x:c.x+c.width,y:c.y},{x:c.x+c.width,y:c.y+c.height},{x:c.x,y:c.y+c.height}],d=u.getAbsoluteTransform();h.forEach(function(f){const p=d.point(f);n.push(p)})});const s=new vr;s.rotate(-He.getAngle(this.rotation()));let r=1/0,i=1/0,o=-1/0,a=-1/0;n.forEach(function(u){const c=s.point(u);r===void 0&&(r=o=c.x,i=a=c.y),r=Math.min(r,c.x),i=Math.min(i,c.y),o=Math.max(o,c.x),a=Math.max(a,c.y)}),s.invert();const l=s.point({x:r,y:i});return{x:l.x,y:l.y,width:o-r,height:a-i,rotation:He.getAngle(this.rotation())}}getX(){return this._getNodeRect().x}getY(){return this._getNodeRect().y}getWidth(){return this._getNodeRect().width}getHeight(){return this._getNodeRect().height}_createElements(){this._createBack(),$g.forEach(e=>{this._createAnchor(e)}),this._createAnchor("rotater")}_createAnchor(e){const n=new yp({stroke:"rgb(0, 161, 255)",fill:"white",strokeWidth:1,name:e+" _anchor",dragDistance:0,draggable:!0,hitStrokeWidth:uBe?10:"auto"}),s=this;n.on("mousedown touchstart",function(r){s._handleMouseDown(r)}),n.on("dragstart",r=>{n.stopDrag(),r.cancelBubble=!0}),n.on("dragend",r=>{r.cancelBubble=!0}),n.on("mouseenter",()=>{const r=He.getAngle(this.rotation()),i=this.rotateAnchorCursor(),o=cBe(e,r,i);n.getStage().content&&(n.getStage().content.style.cursor=o),this._cursorChange=!0}),n.on("mouseout",()=>{n.getStage().content&&(n.getStage().content.style.cursor=""),this._cursorChange=!1}),this.add(n)}_createBack(){const e=new Ne({name:"back",width:0,height:0,sceneFunc(n,s){const r=s.getParent(),i=r.padding();n.beginPath(),n.rect(-i,-i,s.width()+i*2,s.height()+i*2),n.moveTo(s.width()/2,-i),r.rotateEnabled()&&r.rotateLineVisible()&&n.lineTo(s.width()/2,-r.rotateAnchorOffset()*le._sign(s.height())-i),n.fillStrokeShape(s)},hitFunc:(n,s)=>{if(!this.shouldOverdrawWholeArea())return;const r=this.padding();n.beginPath(),n.rect(-r,-r,s.width()+r*2,s.height()+r*2),n.fillStrokeShape(s)}});this.add(e),this._proxyDrag(e),e.on("dragstart",n=>{n.cancelBubble=!0}),e.on("dragmove",n=>{n.cancelBubble=!0}),e.on("dragend",n=>{n.cancelBubble=!0}),this.on("dragmove",n=>{this.update()})}_handleMouseDown(e){if(this._transforming)return;this._movingAnchorName=e.target.name().split(" ")[0];const n=this._getNodeRect(),s=n.width,r=n.height,i=Math.sqrt(Math.pow(s,2)+Math.pow(r,2));this.sin=Math.abs(r/i),this.cos=Math.abs(s/i),typeof window<"u"&&(window.addEventListener("mousemove",this._handleMouseMove),window.addEventListener("touchmove",this._handleMouseMove),window.addEventListener("mouseup",this._handleMouseUp,!0),window.addEventListener("touchend",this._handleMouseUp,!0)),this._transforming=!0;const o=e.target.getAbsolutePosition(),a=e.target.getStage().getPointerPosition();this._anchorDragOffset={x:a.x-o.x,y:a.y-o.y},Dy++,this._fire("transformstart",{evt:e.evt,target:this.getNode()}),this._nodes.forEach(l=>{l._fire("transformstart",{evt:e.evt,target:l})})}_handleMouseMove(e){let n,s,r;const i=this.findOne("."+this._movingAnchorName),o=i.getStage();o.setPointersPositions(e);const a=o.getPointerPosition();let l={x:a.x-this._anchorDragOffset.x,y:a.y-this._anchorDragOffset.y};const u=i.getAbsolutePosition();this.anchorDragBoundFunc()&&(l=this.anchorDragBoundFunc()(u,l,e)),i.setAbsolutePosition(l);const c=i.getAbsolutePosition();if(u.x===c.x&&u.y===c.y)return;if(this._movingAnchorName==="rotater"){const b=this._getNodeRect();n=i.x()-b.width/2,s=-i.y()+b.height/2;let v=Math.atan2(-s,n)+Math.PI/2;b.height<0&&(v-=Math.PI);const C=He.getAngle(this.rotation())+v,I=He.getAngle(this.rotationSnapTolerance()),T=fBe(this.rotationSnaps(),C,I)-b.rotation,S=dBe(b,T);this._fitNodesInto(S,e);return}const h=this.shiftBehavior();let d;h==="inverted"?d=this.keepRatio()&&!e.shiftKey:h==="none"?d=this.keepRatio():d=this.keepRatio()||e.shiftKey;let f=this.centeredScaling()||e.altKey;if(this._movingAnchorName==="top-left"){if(d){const b=f?{x:this.width()/2,y:this.height()/2}:{x:this.findOne(".bottom-right").x(),y:this.findOne(".bottom-right").y()};r=Math.sqrt(Math.pow(b.x-i.x(),2)+Math.pow(b.y-i.y(),2));const v=this.findOne(".top-left").x()>b.x?-1:1,y=this.findOne(".top-left").y()>b.y?-1:1;n=r*this.cos*v,s=r*this.sin*y,this.findOne(".top-left").x(b.x-n),this.findOne(".top-left").y(b.y-s)}}else if(this._movingAnchorName==="top-center")this.findOne(".top-left").y(i.y());else if(this._movingAnchorName==="top-right"){if(d){const b=f?{x:this.width()/2,y:this.height()/2}:{x:this.findOne(".bottom-left").x(),y:this.findOne(".bottom-left").y()};r=Math.sqrt(Math.pow(i.x()-b.x,2)+Math.pow(b.y-i.y(),2));const v=this.findOne(".top-right").x()<b.x?-1:1,y=this.findOne(".top-right").y()>b.y?-1:1;n=r*this.cos*v,s=r*this.sin*y,this.findOne(".top-right").x(b.x+n),this.findOne(".top-right").y(b.y-s)}var p=i.position();this.findOne(".top-left").y(p.y),this.findOne(".bottom-right").x(p.x)}else if(this._movingAnchorName==="middle-left")this.findOne(".top-left").x(i.x());else if(this._movingAnchorName==="middle-right")this.findOne(".bottom-right").x(i.x());else if(this._movingAnchorName==="bottom-left"){if(d){const b=f?{x:this.width()/2,y:this.height()/2}:{x:this.findOne(".top-right").x(),y:this.findOne(".top-right").y()};r=Math.sqrt(Math.pow(b.x-i.x(),2)+Math.pow(i.y()-b.y,2));const v=b.x<i.x()?-1:1,y=i.y()<b.y?-1:1;n=r*this.cos*v,s=r*this.sin*y,i.x(b.x-n),i.y(b.y+s)}p=i.position(),this.findOne(".top-left").x(p.x),this.findOne(".bottom-right").y(p.y)}else if(this._movingAnchorName==="bottom-center")this.findOne(".bottom-right").y(i.y());else if(this._movingAnchorName==="bottom-right"){if(d){const b=f?{x:this.width()/2,y:this.height()/2}:{x:this.findOne(".top-left").x(),y:this.findOne(".top-left").y()};r=Math.sqrt(Math.pow(i.x()-b.x,2)+Math.pow(i.y()-b.y,2));const v=this.findOne(".bottom-right").x()<b.x?-1:1,y=this.findOne(".bottom-right").y()<b.y?-1:1;n=r*this.cos*v,s=r*this.sin*y,this.findOne(".bottom-right").x(b.x+n),this.findOne(".bottom-right").y(b.y+s)}}else console.error(new Error("Wrong position argument of selection resizer: "+this._movingAnchorName));if(f=this.centeredScaling()||e.altKey,f){const b=this.findOne(".top-left"),v=this.findOne(".bottom-right"),y=b.x(),C=b.y(),I=this.getWidth()-v.x(),$=this.getHeight()-v.y();v.move({x:-y,y:-C}),b.move({x:I,y:$})}const g=this.findOne(".top-left").getAbsolutePosition();n=g.x,s=g.y;const m=this.findOne(".bottom-right").x()-this.findOne(".top-left").x(),x=this.findOne(".bottom-right").y()-this.findOne(".top-left").y();this._fitNodesInto({x:n,y:s,width:m,height:x,rotation:He.getAngle(this.rotation())},e)}_handleMouseUp(e){this._removeEvents(e)}getAbsoluteTransform(){return this.getTransform()}_removeEvents(e){var n;if(this._transforming){this._transforming=!1,typeof window<"u"&&(window.removeEventListener("mousemove",this._handleMouseMove),window.removeEventListener("touchmove",this._handleMouseMove),window.removeEventListener("mouseup",this._handleMouseUp,!0),window.removeEventListener("touchend",this._handleMouseUp,!0));const s=this.getNode();Dy--,this._fire("transformend",{evt:e,target:s}),(n=this.getLayer())===null||n===void 0||n.batchDraw(),s&&this._nodes.forEach(r=>{var i;r._fire("transformend",{evt:e,target:r}),(i=r.getLayer())===null||i===void 0||i.batchDraw()}),this._movingAnchorName=null}}_fitNodesInto(e,n){const s=this._getNodeRect(),r=1;if(le._inRange(e.width,-this.padding()*2-r,r)){this.update();return}if(le._inRange(e.height,-this.padding()*2-r,r)){this.update();return}const i=new vr;if(i.rotate(He.getAngle(this.rotation())),this._movingAnchorName&&e.width<0&&this._movingAnchorName.indexOf("left")>=0){const d=i.point({x:-this.padding()*2,y:0});e.x+=d.x,e.y+=d.y,e.width+=this.padding()*2,this._movingAnchorName=this._movingAnchorName.replace("left","right"),this._anchorDragOffset.x-=d.x,this._anchorDragOffset.y-=d.y}else if(this._movingAnchorName&&e.width<0&&this._movingAnchorName.indexOf("right")>=0){const d=i.point({x:this.padding()*2,y:0});this._movingAnchorName=this._movingAnchorName.replace("right","left"),this._anchorDragOffset.x-=d.x,this._anchorDragOffset.y-=d.y,e.width+=this.padding()*2}if(this._movingAnchorName&&e.height<0&&this._movingAnchorName.indexOf("top")>=0){const d=i.point({x:0,y:-this.padding()*2});e.x+=d.x,e.y+=d.y,this._movingAnchorName=this._movingAnchorName.replace("top","bottom"),this._anchorDragOffset.x-=d.x,this._anchorDragOffset.y-=d.y,e.height+=this.padding()*2}else if(this._movingAnchorName&&e.height<0&&this._movingAnchorName.indexOf("bottom")>=0){const d=i.point({x:0,y:this.padding()*2});this._movingAnchorName=this._movingAnchorName.replace("bottom","top"),this._anchorDragOffset.x-=d.x,this._anchorDragOffset.y-=d.y,e.height+=this.padding()*2}if(this.boundBoxFunc()){const d=this.boundBoxFunc()(s,e);d?e=d:le.warn("boundBoxFunc returned falsy. You should return new bound rect from it!")}const o=1e7,a=new vr;a.translate(s.x,s.y),a.rotate(s.rotation),a.scale(s.width/o,s.height/o);const l=new vr,u=e.width/o,c=e.height/o;this.flipEnabled()===!1?(l.translate(e.x,e.y),l.rotate(e.rotation),l.translate(e.width<0?e.width:0,e.height<0?e.height:0),l.scale(Math.abs(u),Math.abs(c))):(l.translate(e.x,e.y),l.rotate(e.rotation),l.scale(u,c));const h=l.multiply(a.invert());this._nodes.forEach(d=>{var f;if(!d.getStage())return;const p=d.getParent().getAbsoluteTransform(),g=d.getTransform().copy();g.translate(d.offsetX(),d.offsetY());const m=new vr;m.multiply(p.copy().invert()).multiply(h).multiply(p).multiply(g);const x=m.decompose();d.setAttrs(x),(f=d.getLayer())===null||f===void 0||f.batchDraw()}),this.rotation(le._getRotation(e.rotation)),this._nodes.forEach(d=>{this._fire("transform",{evt:n,target:d}),d._fire("transform",{evt:n,target:d})}),this._resetTransformCache(),this.update(),this.getLayer().batchDraw()}forceUpdate(){this._resetTransformCache(),this.update()}_batchChangeChild(e,n){this.findOne(e).setAttrs(n)}update(){var e;const n=this._getNodeRect();this.rotation(le._getRotation(n.rotation));const s=n.width,r=n.height,i=this.enabledAnchors(),o=this.resizeEnabled(),a=this.padding(),l=this.anchorSize(),u=this.find("._anchor");u.forEach(h=>{h.setAttrs({width:l,height:l,offsetX:l/2,offsetY:l/2,stroke:this.anchorStroke(),strokeWidth:this.anchorStrokeWidth(),fill:this.anchorFill(),cornerRadius:this.anchorCornerRadius()})}),this._batchChangeChild(".top-left",{x:0,y:0,offsetX:l/2+a,offsetY:l/2+a,visible:o&&i.indexOf("top-left")>=0}),this._batchChangeChild(".top-center",{x:s/2,y:0,offsetY:l/2+a,visible:o&&i.indexOf("top-center")>=0}),this._batchChangeChild(".top-right",{x:s,y:0,offsetX:l/2-a,offsetY:l/2+a,visible:o&&i.indexOf("top-right")>=0}),this._batchChangeChild(".middle-left",{x:0,y:r/2,offsetX:l/2+a,visible:o&&i.indexOf("middle-left")>=0}),this._batchChangeChild(".middle-right",{x:s,y:r/2,offsetX:l/2-a,visible:o&&i.indexOf("middle-right")>=0}),this._batchChangeChild(".bottom-left",{x:0,y:r,offsetX:l/2+a,offsetY:l/2-a,visible:o&&i.indexOf("bottom-left")>=0}),this._batchChangeChild(".bottom-center",{x:s/2,y:r,offsetY:l/2-a,visible:o&&i.indexOf("bottom-center")>=0}),this._batchChangeChild(".bottom-right",{x:s,y:r,offsetX:l/2-a,offsetY:l/2-a,visible:o&&i.indexOf("bottom-right")>=0}),this._batchChangeChild(".rotater",{x:s/2,y:-this.rotateAnchorOffset()*le._sign(r)-a,visible:this.rotateEnabled()}),this._batchChangeChild(".back",{width:s,height:r,visible:this.borderEnabled(),stroke:this.borderStroke(),strokeWidth:this.borderStrokeWidth(),dash:this.borderDash(),draggable:this.nodes().some(h=>h.draggable()),x:0,y:0});const c=this.anchorStyleFunc();c&&u.forEach(h=>{c(h)}),(e=this.getLayer())===null||e===void 0||e.batchDraw()}isTransforming(){return this._transforming}stopTransform(){if(this._transforming){this._removeEvents();const e=this.findOne("."+this._movingAnchorName);e&&e.stopDrag()}}destroy(){return this.getStage()&&this._cursorChange&&this.getStage().content&&(this.getStage().content.style.cursor=""),Yu.prototype.destroy.call(this),this.detach(),this._removeEvents(),this}toObject(){return Fe.prototype.toObject.call(this)}clone(e){return Fe.prototype.clone.call(this,e)}getClientRect(){return this.nodes().length>0?super.getClientRect():{x:0,y:0,width:0,height:0}}}zt.isTransforming=()=>Dy>0;function pBe(t){return t instanceof Array||le.warn("enabledAnchors value should be an array"),t instanceof Array&&t.forEach(function(e){$g.indexOf(e)===-1&&le.warn("Unknown anchor name: "+e+". Available names are: "+$g.join(", "))}),t||[]}zt.prototype.className="Transformer";Rn(zt);X.addGetterSetter(zt,"enabledAnchors",$g,pBe);X.addGetterSetter(zt,"flipEnabled",!0,bi());X.addGetterSetter(zt,"resizeEnabled",!0);X.addGetterSetter(zt,"anchorSize",10,Be());X.addGetterSetter(zt,"rotateEnabled",!0);X.addGetterSetter(zt,"rotateLineVisible",!0);X.addGetterSetter(zt,"rotationSnaps",[]);X.addGetterSetter(zt,"rotateAnchorOffset",50,Be());X.addGetterSetter(zt,"rotateAnchorCursor","crosshair");X.addGetterSetter(zt,"rotationSnapTolerance",5,Be());X.addGetterSetter(zt,"borderEnabled",!0);X.addGetterSetter(zt,"anchorStroke","rgb(0, 161, 255)");X.addGetterSetter(zt,"anchorStrokeWidth",1,Be());X.addGetterSetter(zt,"anchorFill","white");X.addGetterSetter(zt,"anchorCornerRadius",0,Be());X.addGetterSetter(zt,"borderStroke","rgb(0, 161, 255)");X.addGetterSetter(zt,"borderStrokeWidth",1,Be());X.addGetterSetter(zt,"borderDash");X.addGetterSetter(zt,"keepRatio",!0);X.addGetterSetter(zt,"shiftBehavior","default");X.addGetterSetter(zt,"centeredScaling",!1);X.addGetterSetter(zt,"ignoreStroke",!1);X.addGetterSetter(zt,"padding",0,Be());X.addGetterSetter(zt,"nodes");X.addGetterSetter(zt,"node");X.addGetterSetter(zt,"boundBoxFunc");X.addGetterSetter(zt,"anchorDragBoundFunc");X.addGetterSetter(zt,"anchorStyleFunc");X.addGetterSetter(zt,"shouldOverdrawWholeArea",!1);X.addGetterSetter(zt,"useSingleNodeRotation",!0);X.backCompat(zt,{lineEnabled:"borderEnabled",rotateHandlerOffset:"rotateAnchorOffset",enabledHandlers:"enabledAnchors"});class Lo extends Ne{_sceneFunc(e){e.beginPath(),e.arc(0,0,this.radius(),0,He.getAngle(this.angle()),this.clockwise()),e.lineTo(0,0),e.closePath(),e.fillStrokeShape(this)}getWidth(){return this.radius()*2}getHeight(){return this.radius()*2}setWidth(e){this.radius(e/2)}setHeight(e){this.radius(e/2)}}Lo.prototype.className="Wedge";Lo.prototype._centroid=!0;Lo.prototype._attrsAffectingSize=["radius"];Rn(Lo);X.addGetterSetter(Lo,"radius",0,Be());X.addGetterSetter(Lo,"angle",0,Be());X.addGetterSetter(Lo,"clockwise",!1);X.backCompat(Lo,{angleDeg:"angle",getAngleDeg:"getAngle",setAngleDeg:"setAngle"});function hI(){this.r=0,this.g=0,this.b=0,this.a=0,this.next=null}const mBe=[512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,289,287,285,282,280,278,275,273,271,269,267,265,263,261,259],gBe=[9,11,12,13,13,14,14,15,15,15,15,16,16,16,16,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24];function xBe(t,e){const n=t.data,s=t.width,r=t.height;let i,o,a,l,u,c,h,d,f,p,g,m,x,b,v,y,C,I,$,T;const S=e+e+1,E=s-1,_=r-1,N=e+1,P=N*(N+1)/2,M=new hI,z=mBe[e],A=gBe[e];let B=null,L=M,U=null,j=null;for(let Z=1;Z<S;Z++)L=L.next=new hI,Z===N&&(B=L);L.next=M,a=o=0;for(let Z=0;Z<r;Z++){m=x=b=v=l=u=c=h=0,d=N*(y=n[o]),f=N*(C=n[o+1]),p=N*(I=n[o+2]),g=N*($=n[o+3]),l+=P*y,u+=P*C,c+=P*I,h+=P*$,L=M;for(let J=0;J<N;J++)L.r=y,L.g=C,L.b=I,L.a=$,L=L.next;for(let J=1;J<N;J++)i=o+((E<J?E:J)<<2),l+=(L.r=y=n[i])*(T=N-J),u+=(L.g=C=n[i+1])*T,c+=(L.b=I=n[i+2])*T,h+=(L.a=$=n[i+3])*T,m+=y,x+=C,b+=I,v+=$,L=L.next;U=M,j=B;for(let J=0;J<s;J++)n[o+3]=$=h*z>>A,$!==0?($=255/$,n[o]=(l*z>>A)*$,n[o+1]=(u*z>>A)*$,n[o+2]=(c*z>>A)*$):n[o]=n[o+1]=n[o+2]=0,l-=d,u-=f,c-=p,h-=g,d-=U.r,f-=U.g,p-=U.b,g-=U.a,i=a+((i=J+e+1)<E?i:E)<<2,m+=U.r=n[i],x+=U.g=n[i+1],b+=U.b=n[i+2],v+=U.a=n[i+3],l+=m,u+=x,c+=b,h+=v,U=U.next,d+=y=j.r,f+=C=j.g,p+=I=j.b,g+=$=j.a,m-=y,x-=C,b-=I,v-=$,j=j.next,o+=4;a+=s}for(let Z=0;Z<s;Z++){x=b=v=m=u=c=h=l=0,o=Z<<2,d=N*(y=n[o]),f=N*(C=n[o+1]),p=N*(I=n[o+2]),g=N*($=n[o+3]),l+=P*y,u+=P*C,c+=P*I,h+=P*$,L=M;for(let se=0;se<N;se++)L.r=y,L.g=C,L.b=I,L.a=$,L=L.next;let J=s;for(let se=1;se<=e;se++)o=J+Z<<2,l+=(L.r=y=n[o])*(T=N-se),u+=(L.g=C=n[o+1])*T,c+=(L.b=I=n[o+2])*T,h+=(L.a=$=n[o+3])*T,m+=y,x+=C,b+=I,v+=$,L=L.next,se<_&&(J+=s);o=Z,U=M,j=B;for(let se=0;se<r;se++)i=o<<2,n[i+3]=$=h*z>>A,$>0?($=255/$,n[i]=(l*z>>A)*$,n[i+1]=(u*z>>A)*$,n[i+2]=(c*z>>A)*$):n[i]=n[i+1]=n[i+2]=0,l-=d,u-=f,c-=p,h-=g,d-=U.r,f-=U.g,p-=U.b,g-=U.a,i=Z+((i=se+N)<_?i:_)*s<<2,l+=m+=U.r=n[i],u+=x+=U.g=n[i+1],c+=b+=U.b=n[i+2],h+=v+=U.a=n[i+3],U=U.next,d+=y=j.r,f+=C=j.g,p+=I=j.b,g+=$=j.a,m-=y,x-=C,b-=I,v-=$,j=j.next,o+=s}}const bBe=function(e){const n=Math.round(this.blurRadius());n>0&&xBe(e,n)};X.addGetterSetter(Fe,"blurRadius",0,Be(),X.afterSetFilter);const yBe=function(t){const e=this.brightness()*255,n=t.data,s=n.length;for(let r=0;r<s;r+=4)n[r]+=e,n[r+1]+=e,n[r+2]+=e};X.addGetterSetter(Fe,"brightness",0,Be(),X.afterSetFilter);const vBe=function(t){const e=this.brightness(),n=t.data,s=n.length;for(let r=0;r<s;r+=4)n[r]=Math.min(255,n[r]*e),n[r+1]=Math.min(255,n[r+1]*e),n[r+2]=Math.min(255,n[r+2]*e)},wBe=function(t){const e=Math.pow((this.contrast()+100)/100,2),n=t.data,s=n.length;let r=150,i=150,o=150;for(let a=0;a<s;a+=4)r=n[a],i=n[a+1],o=n[a+2],r/=255,r-=.5,r*=e,r+=.5,r*=255,i/=255,i-=.5,i*=e,i+=.5,i*=255,o/=255,o-=.5,o*=e,o+=.5,o*=255,r=r<0?0:r>255?255:r,i=i<0?0:i>255?255:i,o=o<0?0:o>255?255:o,n[a]=r,n[a+1]=i,n[a+2]=o};X.addGetterSetter(Fe,"contrast",0,Be(),X.afterSetFilter);const SBe=function(t){var e,n,s,r,i,o,a,l,u;const c=t.data,h=t.width,d=t.height,f=Math.min(1,Math.max(0,(n=(e=this.embossStrength)===null||e===void 0?void 0:e.call(this))!==null&&n!==void 0?n:.5)),p=Math.min(1,Math.max(0,(r=(s=this.embossWhiteLevel)===null||s===void 0?void 0:s.call(this))!==null&&r!==void 0?r:.5)),m=(a={"top-left":315,top:270,"top-right":225,right:180,"bottom-right":135,bottom:90,"bottom-left":45,left:0}[(o=(i=this.embossDirection)===null||i===void 0?void 0:i.call(this))!==null&&o!==void 0?o:"top-left"])!==null&&a!==void 0?a:315,x=!!((u=(l=this.embossBlend)===null||l===void 0?void 0:l.call(this))!==null&&u!==void 0&&u),b=f*10,v=p*255,y=m*Math.PI/180,C=Math.cos(y),I=Math.sin(y),$=128/1020*b,T=new Uint8ClampedArray(c),S=new Float32Array(h*d);for(let M=0,z=0;z<c.length;z+=4,M++)S[M]=.2126*T[z]+.7152*T[z+1]+.0722*T[z+2];const E=[-1,0,1,-2,0,2,-1,0,1],_=[-1,-2,-1,0,0,0,1,2,1],N=[-h-1,-h,-h+1,-1,0,1,h-1,h,h+1],P=M=>M<0?0:M>255?255:M;for(let M=1;M<d-1;M++)for(let z=1;z<h-1;z++){const A=M*h+z;let B=0,L=0;B+=S[A+N[0]]*E[0],L+=S[A+N[0]]*_[0],B+=S[A+N[1]]*E[1],L+=S[A+N[1]]*_[1],B+=S[A+N[2]]*E[2],L+=S[A+N[2]]*_[2],B+=S[A+N[3]]*E[3],L+=S[A+N[3]]*_[3],B+=S[A+N[5]]*E[5],L+=S[A+N[5]]*_[5],B+=S[A+N[6]]*E[6],L+=S[A+N[6]]*_[6],B+=S[A+N[7]]*E[7],L+=S[A+N[7]]*_[7],B+=S[A+N[8]]*E[8],L+=S[A+N[8]]*_[8];const U=C*B+I*L,j=P(v+U*$),Z=A*4;if(x){const J=j-v;c[Z]=P(T[Z]+J),c[Z+1]=P(T[Z+1]+J),c[Z+2]=P(T[Z+2]+J),c[Z+3]=T[Z+3]}else c[Z]=c[Z+1]=c[Z+2]=j,c[Z+3]=T[Z+3]}for(let M=0;M<h;M++){let z=M*4,A=((d-1)*h+M)*4;c[z]=T[z],c[z+1]=T[z+1],c[z+2]=T[z+2],c[z+3]=T[z+3],c[A]=T[A],c[A+1]=T[A+1],c[A+2]=T[A+2],c[A+3]=T[A+3]}for(let M=1;M<d-1;M++){let z=M*h*4,A=(M*h+(h-1))*4;c[z]=T[z],c[z+1]=T[z+1],c[z+2]=T[z+2],c[z+3]=T[z+3],c[A]=T[A],c[A+1]=T[A+1],c[A+2]=T[A+2],c[A+3]=T[A+3]}return t};X.addGetterSetter(Fe,"embossStrength",.5,Be(),X.afterSetFilter);X.addGetterSetter(Fe,"embossWhiteLevel",.5,Be(),X.afterSetFilter);X.addGetterSetter(Fe,"embossDirection","top-left",void 0,X.afterSetFilter);X.addGetterSetter(Fe,"embossBlend",!1,void 0,X.afterSetFilter);function l1(t,e,n,s,r){const i=n-e,o=r-s;if(i===0)return s+o/2;if(o===0)return s;let a=(t-e)/i;return a=o*a+s,a}const CBe=function(t){const e=t.data,n=e.length;let s=e[0],r=s,i,o=e[1],a=o,l,u=e[2],c=u,h;const d=this.enhance();if(d===0)return;for(let v=0;v<n;v+=4)i=e[v+0],i<s?s=i:i>r&&(r=i),l=e[v+1],l<o?o=l:l>a&&(a=l),h=e[v+2],h<u?u=h:h>c&&(c=h);r===s&&(r=255,s=0),a===o&&(a=255,o=0),c===u&&(c=255,u=0);let f,p,g,m,x,b;if(d>0)f=r+d*(255-r),p=s-d*(s-0),g=a+d*(255-a),m=o-d*(o-0),x=c+d*(255-c),b=u-d*(u-0);else{const v=(r+s)*.5;f=r+d*(r-v),p=s+d*(s-v);const y=(a+o)*.5;g=a+d*(a-y),m=o+d*(o-y);const C=(c+u)*.5;x=c+d*(c-C),b=u+d*(u-C)}for(let v=0;v<n;v+=4)e[v+0]=l1(e[v+0],s,r,p,f),e[v+1]=l1(e[v+1],o,a,m,g),e[v+2]=l1(e[v+2],u,c,b,x)};X.addGetterSetter(Fe,"enhance",0,Be(),X.afterSetFilter);const TBe=function(t){const e=t.data,n=e.length;for(let s=0;s<n;s+=4){const r=.34*e[s]+.5*e[s+1]+.16*e[s+2];e[s]=r,e[s+1]=r,e[s+2]=r}};X.addGetterSetter(Fe,"hue",0,Be(),X.afterSetFilter);X.addGetterSetter(Fe,"saturation",0,Be(),X.afterSetFilter);X.addGetterSetter(Fe,"luminance",0,Be(),X.afterSetFilter);const IBe=function(t){const e=t.data,n=e.length,s=1,r=Math.pow(2,this.saturation()),i=Math.abs(this.hue()+360)%360,o=this.luminance()*127,a=s*r*Math.cos(i*Math.PI/180),l=s*r*Math.sin(i*Math.PI/180),u=.299*s+.701*a+.167*l,c=.587*s-.587*a+.33*l,h=.114*s-.114*a-.497*l,d=.299*s-.299*a-.328*l,f=.587*s+.413*a+.035*l,p=.114*s-.114*a+.293*l,g=.299*s-.3*a+1.25*l,m=.587*s-.586*a-1.05*l,x=.114*s+.886*a-.2*l;let b,v,y,C;for(let I=0;I<n;I+=4)b=e[I+0],v=e[I+1],y=e[I+2],C=e[I+3],e[I+0]=u*b+c*v+h*y+o,e[I+1]=d*b+f*v+p*y+o,e[I+2]=g*b+m*v+x*y+o,e[I+3]=C},kBe=function(t){const e=t.data,n=e.length,s=Math.pow(2,this.value()),r=Math.pow(2,this.saturation()),i=Math.abs(this.hue()+360)%360,o=s*r*Math.cos(i*Math.PI/180),a=s*r*Math.sin(i*Math.PI/180),l=.299*s+.701*o+.167*a,u=.587*s-.587*o+.33*a,c=.114*s-.114*o-.497*a,h=.299*s-.299*o-.328*a,d=.587*s+.413*o+.035*a,f=.114*s-.114*o+.293*a,p=.299*s-.3*o+1.25*a,g=.587*s-.586*o-1.05*a,m=.114*s+.886*o-.2*a;for(let x=0;x<n;x+=4){const b=e[x+0],v=e[x+1],y=e[x+2],C=e[x+3];e[x+0]=l*b+u*v+c*y,e[x+1]=h*b+d*v+f*y,e[x+2]=p*b+g*v+m*y,e[x+3]=C}};X.addGetterSetter(Fe,"hue",0,Be(),X.afterSetFilter);X.addGetterSetter(Fe,"saturation",0,Be(),X.afterSetFilter);X.addGetterSetter(Fe,"value",0,Be(),X.afterSetFilter);const EBe=function(t){const e=t.data,n=e.length;for(let s=0;s<n;s+=4)e[s]=255-e[s],e[s+1]=255-e[s+1],e[s+2]=255-e[s+2]},_Be=function(t,e,n){const s=t.data,r=e.data,i=t.width,o=t.height,a=n.polarCenterX||i/2,l=n.polarCenterY||o/2;let u=Math.sqrt(a*a+l*l),c=i-a,h=o-l;const d=Math.sqrt(c*c+h*h);u=d>u?d:u;const f=o,p=i,g=360/p*Math.PI/180;for(let m=0;m<p;m+=1){const x=Math.sin(m*g),b=Math.cos(m*g);for(let v=0;v<f;v+=1){c=Math.floor(a+u*v/f*b),h=Math.floor(l+u*v/f*x);let y=(h*i+c)*4;const C=s[y+0],I=s[y+1],$=s[y+2],T=s[y+3];y=(m+v*i)*4,r[y+0]=C,r[y+1]=I,r[y+2]=$,r[y+3]=T}}},$Be=function(t,e,n){const s=t.data,r=e.data,i=t.width,o=t.height,a=n.polarCenterX||i/2,l=n.polarCenterY||o/2;let u=Math.sqrt(a*a+l*l),c=i-a,h=o-l;const d=Math.sqrt(c*c+h*h);u=d>u?d:u;const f=o,p=i,g=0;let m,x;for(c=0;c<i;c+=1)for(h=0;h<o;h+=1){const b=c-a,v=h-l,y=Math.sqrt(b*b+v*v)*f/u;let C=(Math.atan2(v,b)*180/Math.PI+360+g)%360;C=C*p/360,m=Math.floor(C),x=Math.floor(y);let I=(x*i+m)*4;const $=s[I+0],T=s[I+1],S=s[I+2],E=s[I+3];I=(h*i+c)*4,r[I+0]=$,r[I+1]=T,r[I+2]=S,r[I+3]=E}},RBe=function(t){const e=t.width,n=t.height;let s,r,i,o,a,l,u,c,h,d,f=Math.round(this.kaleidoscopePower());const p=Math.round(this.kaleidoscopeAngle()),g=Math.floor(e*(p%360)/360);if(f<1)return;const m=le.createCanvasElement();m.width=e,m.height=n;const x=m.getContext("2d").getImageData(0,0,e,n);le.releaseCanvas(m),_Be(t,x,{polarCenterX:e/2,polarCenterY:n/2});let b=e/Math.pow(2,f);for(;b<=8;)b=b*2,f-=1;b=Math.ceil(b);let v=b,y=0,C=v,I=1;for(g+b>e&&(y=v,C=0,I=-1),r=0;r<n;r+=1)for(s=y;s!==C;s+=I)i=Math.round(s+g)%e,h=(e*r+i)*4,a=x.data[h+0],l=x.data[h+1],u=x.data[h+2],c=x.data[h+3],d=(e*r+s)*4,x.data[d+0]=a,x.data[d+1]=l,x.data[d+2]=u,x.data[d+3]=c;for(r=0;r<n;r+=1)for(v=Math.floor(b),o=0;o<f;o+=1){for(s=0;s<v+1;s+=1)h=(e*r+s)*4,a=x.data[h+0],l=x.data[h+1],u=x.data[h+2],c=x.data[h+3],d=(e*r+v*2-s-1)*4,x.data[d+0]=a,x.data[d+1]=l,x.data[d+2]=u,x.data[d+3]=c;v*=2}$Be(x,t,{})};X.addGetterSetter(Fe,"kaleidoscopePower",2,Be(),X.afterSetFilter);X.addGetterSetter(Fe,"kaleidoscopeAngle",0,Be(),X.afterSetFilter);function xm(t,e,n){let s=(n*t.width+e)*4;const r=[];return r.push(t.data[s++],t.data[s++],t.data[s++],t.data[s++]),r}function Rh(t,e){return Math.sqrt(Math.pow(t[0]-e[0],2)+Math.pow(t[1]-e[1],2)+Math.pow(t[2]-e[2],2))}function ABe(t){const e=[0,0,0];for(let n=0;n<t.length;n++)e[0]+=t[n][0],e[1]+=t[n][1],e[2]+=t[n][2];return e[0]/=t.length,e[1]/=t.length,e[2]/=t.length,e}function PBe(t,e){const n=xm(t,0,0),s=xm(t,t.width-1,0),r=xm(t,0,t.height-1),i=xm(t,t.width-1,t.height-1),o=e||10;if(Rh(n,s)<o&&Rh(s,i)<o&&Rh(i,r)<o&&Rh(r,n)<o){const a=ABe([s,n,i,r]),l=[];for(let u=0;u<t.width*t.height;u++){const c=Rh(a,[t.data[u*4],t.data[u*4+1],t.data[u*4+2]]);l[u]=c<o?0:255}return l}}function DBe(t,e){for(let n=0;n<t.width*t.height;n++)t.data[4*n+3]=e[n]}function NBe(t,e,n){const s=[1,1,1,1,0,1,1,1,1],r=Math.round(Math.sqrt(s.length)),i=Math.floor(r/2),o=[];for(let a=0;a<n;a++)for(let l=0;l<e;l++){const u=a*e+l;let c=0;for(let h=0;h<r;h++)for(let d=0;d<r;d++){const f=a+h-i,p=l+d-i;if(f>=0&&f<n&&p>=0&&p<e){const g=f*e+p,m=s[h*r+d];c+=t[g]*m}}o[u]=c===255*8?255:0}return o}function MBe(t,e,n){const s=[1,1,1,1,1,1,1,1,1],r=Math.round(Math.sqrt(s.length)),i=Math.floor(r/2),o=[];for(let a=0;a<n;a++)for(let l=0;l<e;l++){const u=a*e+l;let c=0;for(let h=0;h<r;h++)for(let d=0;d<r;d++){const f=a+h-i,p=l+d-i;if(f>=0&&f<n&&p>=0&&p<e){const g=f*e+p,m=s[h*r+d];c+=t[g]*m}}o[u]=c>=255*4?255:0}return o}function LBe(t,e,n){const s=[.1111111111111111,.1111111111111111,.1111111111111111,.1111111111111111,.1111111111111111,.1111111111111111,.1111111111111111,.1111111111111111,.1111111111111111],r=Math.round(Math.sqrt(s.length)),i=Math.floor(r/2),o=[];for(let a=0;a<n;a++)for(let l=0;l<e;l++){const u=a*e+l;let c=0;for(let h=0;h<r;h++)for(let d=0;d<r;d++){const f=a+h-i,p=l+d-i;if(f>=0&&f<n&&p>=0&&p<e){const g=f*e+p,m=s[h*r+d];c+=t[g]*m}}o[u]=c}return o}const OBe=function(t){const e=this.threshold();let n=PBe(t,e);return n&&(n=NBe(n,t.width,t.height),n=MBe(n,t.width,t.height),n=LBe(n,t.width,t.height),DBe(t,n)),t};X.addGetterSetter(Fe,"threshold",0,Be(),X.afterSetFilter);const FBe=function(t){const e=this.noise()*255,n=t.data,s=n.length,r=e/2;for(let i=0;i<s;i+=4)n[i+0]+=r-2*r*Math.random(),n[i+1]+=r-2*r*Math.random(),n[i+2]+=r-2*r*Math.random()};X.addGetterSetter(Fe,"noise",.2,Be(),X.afterSetFilter);const UBe=function(t){let e=Math.ceil(this.pixelSize()),n=t.width,s=t.height,r=Math.ceil(n/e),i=Math.ceil(s/e),o=t.data;if(e<=0){le.error("pixelSize value can not be <= 0");return}for(let a=0;a<r;a+=1)for(let l=0;l<i;l+=1){let u=0,c=0,h=0,d=0;const f=a*e,p=f+e,g=l*e,m=g+e;let x=0;for(let b=f;b<p;b+=1)if(!(b>=n))for(let v=g;v<m;v+=1){if(v>=s)continue;const y=(n*v+b)*4;u+=o[y+0],c+=o[y+1],h+=o[y+2],d+=o[y+3],x+=1}u=u/x,c=c/x,h=h/x,d=d/x;for(let b=f;b<p;b+=1)if(!(b>=n))for(let v=g;v<m;v+=1){if(v>=s)continue;const y=(n*v+b)*4;o[y+0]=u,o[y+1]=c,o[y+2]=h,o[y+3]=d}}};X.addGetterSetter(Fe,"pixelSize",8,Be(),X.afterSetFilter);const BBe=function(t){const e=Math.round(this.levels()*254)+1,n=t.data,s=n.length,r=255/e;for(let i=0;i<s;i+=1)n[i]=Math.floor(n[i]/r)*r};X.addGetterSetter(Fe,"levels",.5,Be(),X.afterSetFilter);const zBe=function(t){const e=t.data,n=e.length,s=this.red(),r=this.green(),i=this.blue();for(let o=0;o<n;o+=4){const a=(.34*e[o]+.5*e[o+1]+.16*e[o+2])/255;e[o]=a*s,e[o+1]=a*r,e[o+2]=a*i,e[o+3]=e[o+3]}};X.addGetterSetter(Fe,"red",0,function(t){return this._filterUpToDate=!1,t>255?255:t<0?0:Math.round(t)});X.addGetterSetter(Fe,"green",0,function(t){return this._filterUpToDate=!1,t>255?255:t<0?0:Math.round(t)});X.addGetterSetter(Fe,"blue",0,$4,X.afterSetFilter);const GBe=function(t){const e=t.data,n=e.length,s=this.red(),r=this.green(),i=this.blue(),o=this.alpha();for(let a=0;a<n;a+=4){const l=1-o;e[a]=s*o+e[a]*l,e[a+1]=r*o+e[a+1]*l,e[a+2]=i*o+e[a+2]*l}};X.addGetterSetter(Fe,"red",0,function(t){return this._filterUpToDate=!1,t>255?255:t<0?0:Math.round(t)});X.addGetterSetter(Fe,"green",0,function(t){return this._filterUpToDate=!1,t>255?255:t<0?0:Math.round(t)});X.addGetterSetter(Fe,"blue",0,$4,X.afterSetFilter);X.addGetterSetter(Fe,"alpha",1,function(t){return this._filterUpToDate=!1,t>1?1:t<0?0:t});const VBe=function(t){const e=t.data,n=e.length;for(let s=0;s<n;s+=4){const r=e[s+0],i=e[s+1],o=e[s+2];e[s+0]=Math.min(255,r*.393+i*.769+o*.189),e[s+1]=Math.min(255,r*.349+i*.686+o*.168),e[s+2]=Math.min(255,r*.272+i*.534+o*.131)}},WBe=function(t){const n=t.data;for(let s=0;s<n.length;s+=4){const r=n[s],i=n[s+1],o=n[s+2];.2126*r+.7152*i+.0722*o>=128&&(n[s]=255-r,n[s+1]=255-i,n[s+2]=255-o)}return t},HBe=function(t){const e=this.threshold()*255,n=t.data,s=n.length;for(let r=0;r<s;r+=1)n[r]=n[r]<e?0:255};X.addGetterSetter(Fe,"threshold",.5,Be(),X.afterSetFilter);const Gd=eI.Util._assign(eI,{Arc:No,Arrow:Ql,Circle:ph,Ellipse:ka,Image:yi,Label:Aw,Tag:Jl,Line:Mo,Path:hn,Rect:yp,RegularPolygon:Ea,Ring:eu,Sprite:to,Star:_a,Text:wn,TextPath:ps,Transformer:zt,Wedge:Lo,Filters:{Blur:bBe,Brightness:vBe,Brighten:yBe,Contrast:wBe,Emboss:SBe,Enhance:CBe,Grayscale:TBe,HSL:IBe,HSV:kBe,Invert:EBe,Kaleidoscope:RBe,Mask:OBe,Noise:FBe,Pixelate:UBe,Posterize:BBe,RGB:zBe,RGBA:GBe,Sepia:VBe,Solarize:WBe,Threshold:HBe}});function Rg(t){if(!Gd.autoDrawEnabled){const e=t.getLayer()||t.getStage();e&&e.batchDraw()}}const dI={key:!0,style:!0,elm:!0,isRootInsert:!0},u1=".vue-konva-event";function aM(t,e,n,s){const r=t.__konvaNode,i={};let o=!1;for(let a in n){if(dI.hasOwnProperty(a))continue;const l=a.slice(0,2)==="on",u=n[a]!==e[a];if(l&&u){let c=a.slice(2).toLowerCase();c.slice(0,7)==="content"&&(c="content"+c.slice(7,1).toUpperCase()+c.slice(8)),r==null||r.off(c+u1,n[a])}!e.hasOwnProperty(a)&&(r==null||r.setAttr(a,void 0))}for(let a in e){if(dI.hasOwnProperty(a))continue;let l=a.slice(0,2)==="on";const u=n[a]!==e[a];if(l&&u){let c=a.slice(2).toLowerCase();c.slice(0,7)==="content"&&(c="content"+c.slice(7,1).toUpperCase()+c.slice(8)),e[a]&&(r==null||r.off(c+u1),r==null||r.on(c+u1,e[a]))}!l&&(e[a]!==n[a]||s&&e[a]!==(r==null?void 0:r.getAttr(a)))&&(o=!0,i[a]=e[a])}o&&r&&(r.setAttrs(i),Rg(r))}const KBe="v";function jBe(t){function e(n){return n!=null&&n.__konvaNode?n:n!=null&&n.parent?e(n.parent):(console.error("vue-konva error: Can not find parent node"),null)}return e(t.parent)}function lM(t){return t.component?t.component.__konvaNode||lM(t.component.subTree):null}function XBe(t){const{el:e,component:n}=t,s=lM(t);if(e!=null&&e.tagName&&n&&!s){const r=e.tagName.toLowerCase();return console.error(`vue-konva error: You are trying to render "${r}" inside your component tree. Looks like it is not a Konva node. You can render only Konva components inside the Stage.`),null}return s}function qBe(t){const e=r=>!!r&&typeof r=="object"&&"component"in r,n=r=>Array.isArray(r),s=r=>e(r)?[r,...s(r.children)]:n(r)?r.flatMap(s):[];return s(t.children)}function uM(t,e){const n=qBe(t),s=[];n.forEach(i=>{const o=XBe(i);o&&s.push(o)});let r=!1;s.forEach((i,o)=>{i.getZIndex()!==o&&(i.setZIndex(o),r=!0)}),r&&Rg(e)}var fI;const YBe=((fI=Gd.default)==null?void 0:fI.Stage)||Gd.Stage,ZBe=We({name:"Stage",props:{config:{type:Object,default:function(){return{}}},__useStrictMode:{type:Boolean}},inheritAttrs:!1,setup(t,{attrs:e,slots:n,expose:s}){const r=Hg();if(!r)return;const i=pi({}),o=ce(null),a=new YBe({width:t.config.width,height:t.config.height,container:document.createElement("div")});r.__konvaNode=a,c();function l(){return r==null?void 0:r.__konvaNode}function u(){return r==null?void 0:r.__konvaNode}function c(){if(!r)return;const h=i||{},d={...e,...t.config};aM(r,d,h,t.__useStrictMode),Object.assign(i,d)}return kr(()=>{o.value&&(o.value.innerHTML="",a.container(o.value)),c()}),zg(()=>{c(),uM(r.subTree,a)}),Gg(()=>{a.destroy()}),_t(()=>t.config,c,{deep:!0}),s({getStage:u,getNode:l}),()=>{var h;return bd("div",{ref:o,style:e==null?void 0:e.style},(h=n.default)==null?void 0:h.call(n))}}}),QBe=".vue-konva-event",JBe={Group:!0,Layer:!0,FastLayer:!0,Label:!0};function eze(t,e){return We({name:t,props:{config:{type:Object,default:function(){return{}}},__useStrictMode:{type:Boolean}},setup(n,{attrs:s,slots:r,expose:i}){const o=Hg();if(!o)return;const a=pi({}),l=new e;o.__konvaNode=l,o.vnode.__konvaNode=l,h();function u(){return o==null?void 0:o.__konvaNode}function c(){return o==null?void 0:o.__konvaNode}function h(){if(!o)return;const f={};for(const m in o==null?void 0:o.vnode.props)m.slice(0,2)==="on"&&(f[m]=o.vnode.props[m]);const p=a||{},g={...s,...n.config,...f};aM(o,g,p,n.__useStrictMode),Object.assign(a,g)}kr(()=>{var p;const f=(p=jBe(o))==null?void 0:p.__konvaNode;f&&"add"in f&&f.add(l),Rg(l)}),fa(()=>{Rg(l),l.destroy(),l.off(QBe)}),zg(()=>{h(),uM(o.subTree,l)}),_t(()=>n.config,h,{deep:!0}),i({getStage:c,getNode:u});const d=JBe.hasOwnProperty(t);return()=>{var f;return d?bd("template",{},(f=r.default)==null?void 0:f.call(r)):null}}})}const tze={install:(t,e)=>{const n=(e==null?void 0:e.prefix)||KBe,s=Gd.default||Gd,r={Arc:s.Arc,Arrow:s.Arrow,Circle:s.Circle,Ellipse:s.Ellipse,FastLayer:s.FastLayer,Group:s.Group,Image:s.Image,Label:s.Label,Layer:s.Layer,Line:s.Line,Path:s.Path,Rect:s.Rect,RegularPolygon:s.RegularPolygon,Ring:s.Ring,Shape:s.Shape,Sprite:s.Sprite,Star:s.Star,Tag:s.Tag,Text:s.Text,TextPath:s.TextPath,Transformer:s.Transformer,Wedge:s.Wedge,...e==null?void 0:e.customNodes};[ZBe,...Object.entries(r).map(([i,o])=>eze(i,o))].forEach(i=>{t.component(`${n}${i.name}`,i)})}},nze=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),sze=nze?i5e:C5e,cM=QO(sze);cM.use(tze);cM.mount("#app");
//# sourceMappingURL=index-D_F0sq2n.js.map
