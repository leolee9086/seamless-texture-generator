var Yk=n=>{throw TypeError(n)};var Bb=(n,e,t)=>e.has(n)?Yk("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t);function Zk(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=t(r);fetch(r.href,i)}})();/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Jm(n){const e=Object.create(null);for(const t of n.split(","))e[t]=1;return t=>t in e}const At={},na=[],br=()=>{},$1=()=>!1,Sd=n=>n.charCodeAt(0)===111&&n.charCodeAt(1)===110&&(n.charCodeAt(2)>122||n.charCodeAt(2)<97),eg=n=>n.startsWith("onUpdate:"),Mn=Object.assign,tg=(n,e)=>{const t=n.indexOf(e);t>-1&&n.splice(t,1)},Qk=Object.prototype.hasOwnProperty,St=(n,e)=>Qk.call(n,e),rt=Array.isArray,sa=n=>Id(n)==="[object Map]",k1=n=>Id(n)==="[object Set]",it=n=>typeof n=="function",en=n=>typeof n=="string",Si=n=>typeof n=="symbol",Gt=n=>n!==null&&typeof n=="object",T1=n=>(Gt(n)||it(n))&&it(n.then)&&it(n.catch),E1=Object.prototype.toString,Id=n=>E1.call(n),Jk=n=>Id(n).slice(8,-1),R1=n=>Id(n)==="[object Object]",ng=n=>en(n)&&n!=="NaN"&&n[0]!=="-"&&""+parseInt(n,10)===n,Zu=Jm(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),$d=n=>{const e=Object.create(null);return t=>e[t]||(e[t]=n(t))},eT=/-\w/g,mi=$d(n=>n.replace(eT,e=>e.slice(1).toUpperCase())),tT=/\B([A-Z])/g,wo=$d(n=>n.replace(tT,"-$1").toLowerCase()),N1=$d(n=>n.charAt(0).toUpperCase()+n.slice(1)),Sf=$d(n=>n?`on${N1(n)}`:""),hi=(n,e)=>!Object.is(n,e),If=(n,...e)=>{for(let t=0;t<n.length;t++)n[t](...e)},_1=(n,e,t,s=!1)=>{Object.defineProperty(n,e,{configurable:!0,enumerable:!1,writable:s,value:t})},nT=n=>{const e=parseFloat(n);return isNaN(e)?n:e};let Vb;const kd=()=>Vb||(Vb=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function lr(n){if(rt(n)){const e={};for(let t=0;t<n.length;t++){const s=n[t],r=en(s)?oT(s):lr(s);if(r)for(const i in r)e[i]=r[i]}return e}else if(en(n)||Gt(n))return n}const sT=/;(?![^(]*\))/g,rT=/:([^]+)/,iT=/\/\*[^]*?\*\//g;function oT(n){const e={};return n.replace(iT,"").split(sT).forEach(t=>{if(t){const s=t.split(rT);s.length>1&&(e[s[0].trim()]=s[1].trim())}}),e}function In(n){let e="";if(en(n))e=n;else if(rt(n))for(let t=0;t<n.length;t++){const s=In(n[t]);s&&(e+=s+" ")}else if(Gt(n))for(const t in n)n[t]&&(e+=t+" ");return e.trim()}const aT="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",uT=Jm(aT);function D1(n){return!!n||n===""}const A1=n=>!!(n&&n.__v_isRef===!0),mr=n=>en(n)?n:n==null?"":rt(n)||Gt(n)&&(n.toString===E1||!it(n.toString))?A1(n)?mr(n.value):JSON.stringify(n,F1,2):String(n),F1=(n,e)=>A1(e)?F1(n,e.value):sa(e)?{[`Map(${e.size})`]:[...e.entries()].reduce((t,[s,r],i)=>(t[$f(s,i)+" =>"]=r,t),{})}:k1(e)?{[`Set(${e.size})`]:[...e.values()].map(t=>$f(t))}:Si(e)?$f(e):Gt(e)&&!rt(e)&&!R1(e)?String(e):e,$f=(n,e="")=>{var t;return Si(n)?`Symbol(${(t=n.description)!=null?t:e})`:n};/**
* @vue/reactivity v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let ss;class lT{constructor(e=!1){this.detached=e,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=ss,!e&&ss&&(this.index=(ss.scopes||(ss.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let e,t;if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].pause();for(e=0,t=this.effects.length;e<t;e++)this.effects[e].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let e,t;if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].resume();for(e=0,t=this.effects.length;e<t;e++)this.effects[e].resume()}}run(e){if(this._active){const t=ss;try{return ss=this,e()}finally{ss=t}}}on(){++this._on===1&&(this.prevScope=ss,ss=this)}off(){this._on>0&&--this._on===0&&(ss=this.prevScope,this.prevScope=void 0)}stop(e){if(this._active){this._active=!1;let t,s;for(t=0,s=this.effects.length;t<s;t++)this.effects[t].stop();for(this.effects.length=0,t=0,s=this.cleanups.length;t<s;t++)this.cleanups[t]();if(this.cleanups.length=0,this.scopes){for(t=0,s=this.scopes.length;t<s;t++)this.scopes[t].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!e){const r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0}}}function cT(){return ss}let Dt;const kf=new WeakSet;class P1{constructor(e){this.fn=e,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,ss&&ss.active&&ss.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,kf.has(this)&&(kf.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||O1(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,Ub(this),M1(this);const e=Dt,t=Gs;Dt=this,Gs=!0;try{return this.fn()}finally{z1(this),Dt=e,Gs=t,this.flags&=-3}}stop(){if(this.flags&1){for(let e=this.deps;e;e=e.nextDep)ig(e);this.deps=this.depsTail=void 0,Ub(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?kf.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){em(this)&&this.run()}get dirty(){return em(this)}}let L1=0,Qu,Ju;function O1(n,e=!1){if(n.flags|=8,e){n.next=Ju,Ju=n;return}n.next=Qu,Qu=n}function sg(){L1++}function rg(){if(--L1>0)return;if(Ju){let e=Ju;for(Ju=void 0;e;){const t=e.next;e.next=void 0,e.flags&=-9,e=t}}let n;for(;Qu;){let e=Qu;for(Qu=void 0;e;){const t=e.next;if(e.next=void 0,e.flags&=-9,e.flags&1)try{e.trigger()}catch(s){n||(n=s)}e=t}}if(n)throw n}function M1(n){for(let e=n.deps;e;e=e.nextDep)e.version=-1,e.prevActiveLink=e.dep.activeLink,e.dep.activeLink=e}function z1(n){let e,t=n.depsTail,s=t;for(;s;){const r=s.prevDep;s.version===-1?(s===t&&(t=r),ig(s),hT(s)):e=s,s.dep.activeLink=s.prevActiveLink,s.prevActiveLink=void 0,s=r}n.deps=e,n.depsTail=t}function em(n){for(let e=n.deps;e;e=e.nextDep)if(e.dep.version!==e.version||e.dep.computed&&(B1(e.dep.computed)||e.dep.version!==e.version))return!0;return!!n._dirty}function B1(n){if(n.flags&4&&!(n.flags&16)||(n.flags&=-17,n.globalVersion===ll)||(n.globalVersion=ll,!n.isSSR&&n.flags&128&&(!n.deps&&!n._dirty||!em(n))))return;n.flags|=2;const e=n.dep,t=Dt,s=Gs;Dt=n,Gs=!0;try{M1(n);const r=n.fn(n._value);(e.version===0||hi(r,n._value))&&(n.flags|=128,n._value=r,e.version++)}catch(r){throw e.version++,r}finally{Dt=t,Gs=s,z1(n),n.flags&=-3}}function ig(n,e=!1){const{dep:t,prevSub:s,nextSub:r}=n;if(s&&(s.nextSub=r,n.prevSub=void 0),r&&(r.prevSub=s,n.nextSub=void 0),t.subs===n&&(t.subs=s,!s&&t.computed)){t.computed.flags&=-5;for(let i=t.computed.deps;i;i=i.nextDep)ig(i,!0)}!e&&!--t.sc&&t.map&&t.map.delete(t.key)}function hT(n){const{prevDep:e,nextDep:t}=n;e&&(e.nextDep=t,n.prevDep=void 0),t&&(t.prevDep=e,n.nextDep=void 0)}let Gs=!0;const V1=[];function Hr(){V1.push(Gs),Gs=!1}function Kr(){const n=V1.pop();Gs=n===void 0?!0:n}function Ub(n){const{cleanup:e}=n;if(n.cleanup=void 0,e){const t=Dt;Dt=void 0;try{e()}finally{Dt=t}}}let ll=0;class dT{constructor(e,t){this.sub=e,this.dep=t,this.version=t.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class og{constructor(e){this.computed=e,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(e){if(!Dt||!Gs||Dt===this.computed)return;let t=this.activeLink;if(t===void 0||t.sub!==Dt)t=this.activeLink=new dT(Dt,this),Dt.deps?(t.prevDep=Dt.depsTail,Dt.depsTail.nextDep=t,Dt.depsTail=t):Dt.deps=Dt.depsTail=t,U1(t);else if(t.version===-1&&(t.version=this.version,t.nextDep)){const s=t.nextDep;s.prevDep=t.prevDep,t.prevDep&&(t.prevDep.nextDep=s),t.prevDep=Dt.depsTail,t.nextDep=void 0,Dt.depsTail.nextDep=t,Dt.depsTail=t,Dt.deps===t&&(Dt.deps=s)}return t}trigger(e){this.version++,ll++,this.notify(e)}notify(e){sg();try{for(let t=this.subs;t;t=t.prevSub)t.sub.notify()&&t.sub.dep.notify()}finally{rg()}}}function U1(n){if(n.dep.sc++,n.sub.flags&4){const e=n.dep.computed;if(e&&!n.dep.subs){e.flags|=20;for(let s=e.deps;s;s=s.nextDep)U1(s)}const t=n.dep.subs;t!==n&&(n.prevSub=t,t&&(t.nextSub=n)),n.dep.subs=n}}const tm=new WeakMap,Ji=Symbol(""),nm=Symbol(""),cl=Symbol("");function Dn(n,e,t){if(Gs&&Dt){let s=tm.get(n);s||tm.set(n,s=new Map);let r=s.get(t);r||(s.set(t,r=new og),r.map=s,r.key=t),r.track()}}function Mr(n,e,t,s,r,i){const o=tm.get(n);if(!o){ll++;return}const a=u=>{u&&u.trigger()};if(sg(),e==="clear")o.forEach(a);else{const u=rt(n),l=u&&ng(t);if(u&&t==="length"){const h=Number(s);o.forEach((c,d)=>{(d==="length"||d===cl||!Si(d)&&d>=h)&&a(c)})}else switch((t!==void 0||o.has(void 0))&&a(o.get(t)),l&&a(o.get(cl)),e){case"add":u?l&&a(o.get("length")):(a(o.get(Ji)),sa(n)&&a(o.get(nm)));break;case"delete":u||(a(o.get(Ji)),sa(n)&&a(o.get(nm)));break;case"set":sa(n)&&a(o.get(Ji));break}}rg()}function Wo(n){const e=ht(n);return e===n?e:(Dn(e,"iterate",cl),As(n)?e:e.map(js))}function Td(n){return Dn(n=ht(n),"iterate",cl),n}function ni(n,e){return jr(n)?eo(n)?ca(js(e)):ca(e):js(e)}const pT={__proto__:null,[Symbol.iterator](){return Tf(this,Symbol.iterator,n=>ni(this,n))},concat(...n){return Wo(this).concat(...n.map(e=>rt(e)?Wo(e):e))},entries(){return Tf(this,"entries",n=>(n[1]=ni(this,n[1]),n))},every(n,e){return Pr(this,"every",n,e,void 0,arguments)},filter(n,e){return Pr(this,"filter",n,e,t=>t.map(s=>ni(this,s)),arguments)},find(n,e){return Pr(this,"find",n,e,t=>ni(this,t),arguments)},findIndex(n,e){return Pr(this,"findIndex",n,e,void 0,arguments)},findLast(n,e){return Pr(this,"findLast",n,e,t=>ni(this,t),arguments)},findLastIndex(n,e){return Pr(this,"findLastIndex",n,e,void 0,arguments)},forEach(n,e){return Pr(this,"forEach",n,e,void 0,arguments)},includes(...n){return Ef(this,"includes",n)},indexOf(...n){return Ef(this,"indexOf",n)},join(n){return Wo(this).join(n)},lastIndexOf(...n){return Ef(this,"lastIndexOf",n)},map(n,e){return Pr(this,"map",n,e,void 0,arguments)},pop(){return Ou(this,"pop")},push(...n){return Ou(this,"push",n)},reduce(n,...e){return Gb(this,"reduce",n,e)},reduceRight(n,...e){return Gb(this,"reduceRight",n,e)},shift(){return Ou(this,"shift")},some(n,e){return Pr(this,"some",n,e,void 0,arguments)},splice(...n){return Ou(this,"splice",n)},toReversed(){return Wo(this).toReversed()},toSorted(n){return Wo(this).toSorted(n)},toSpliced(...n){return Wo(this).toSpliced(...n)},unshift(...n){return Ou(this,"unshift",n)},values(){return Tf(this,"values",n=>ni(this,n))}};function Tf(n,e,t){const s=Td(n),r=s[e]();return s!==n&&!As(n)&&(r._next=r.next,r.next=()=>{const i=r._next();return i.done||(i.value=t(i.value)),i}),r}const fT=Array.prototype;function Pr(n,e,t,s,r,i){const o=Td(n),a=o!==n&&!As(n),u=o[e];if(u!==fT[e]){const c=u.apply(n,i);return a?js(c):c}let l=t;o!==n&&(a?l=function(c,d){return t.call(this,ni(n,c),d,n)}:t.length>2&&(l=function(c,d){return t.call(this,c,d,n)}));const h=u.call(o,l,s);return a&&r?r(h):h}function Gb(n,e,t,s){const r=Td(n);let i=t;return r!==n&&(As(n)?t.length>3&&(i=function(o,a,u){return t.call(this,o,a,u,n)}):i=function(o,a,u){return t.call(this,o,ni(n,a),u,n)}),r[e](i,...s)}function Ef(n,e,t){const s=ht(n);Dn(s,"iterate",cl);const r=s[e](...t);return(r===-1||r===!1)&&cg(t[0])?(t[0]=ht(t[0]),s[e](...t)):r}function Ou(n,e,t=[]){Hr(),sg();const s=ht(n)[e].apply(n,t);return rg(),Kr(),s}const mT=Jm("__proto__,__v_isRef,__isVue"),G1=new Set(Object.getOwnPropertyNames(Symbol).filter(n=>n!=="arguments"&&n!=="caller").map(n=>Symbol[n]).filter(Si));function gT(n){Si(n)||(n=String(n));const e=ht(this);return Dn(e,"has",n),e.hasOwnProperty(n)}class W1{constructor(e=!1,t=!1){this._isReadonly=e,this._isShallow=t}get(e,t,s){if(t==="__v_skip")return e.__v_skip;const r=this._isReadonly,i=this._isShallow;if(t==="__v_isReactive")return!r;if(t==="__v_isReadonly")return r;if(t==="__v_isShallow")return i;if(t==="__v_raw")return s===(r?i?kT:X1:i?j1:K1).get(e)||Object.getPrototypeOf(e)===Object.getPrototypeOf(s)?e:void 0;const o=rt(e);if(!r){let u;if(o&&(u=pT[t]))return u;if(t==="hasOwnProperty")return gT}const a=Reflect.get(e,t,Pn(e)?e:s);if((Si(t)?G1.has(t):mT(t))||(r||Dn(e,"get",t),i))return a;if(Pn(a)){const u=o&&ng(t)?a:a.value;return r&&Gt(u)?rm(u):u}return Gt(a)?r?rm(a):ug(a):a}}class H1 extends W1{constructor(e=!1){super(!1,e)}set(e,t,s,r){let i=e[t];const o=rt(e)&&ng(t);if(!this._isShallow){const l=jr(i);if(!As(s)&&!jr(s)&&(i=ht(i),s=ht(s)),!o&&Pn(i)&&!Pn(s))return l||(i.value=s),!0}const a=o?Number(t)<e.length:St(e,t),u=Reflect.set(e,t,s,Pn(e)?e:r);return e===ht(r)&&(a?hi(s,i)&&Mr(e,"set",t,s):Mr(e,"add",t,s)),u}deleteProperty(e,t){const s=St(e,t);e[t];const r=Reflect.deleteProperty(e,t);return r&&s&&Mr(e,"delete",t,void 0),r}has(e,t){const s=Reflect.has(e,t);return(!Si(t)||!G1.has(t))&&Dn(e,"has",t),s}ownKeys(e){return Dn(e,"iterate",rt(e)?"length":Ji),Reflect.ownKeys(e)}}class xT extends W1{constructor(e=!1){super(!0,e)}set(e,t){return!0}deleteProperty(e,t){return!0}}const bT=new H1,yT=new xT,wT=new H1(!0);const sm=n=>n,hh=n=>Reflect.getPrototypeOf(n);function vT(n,e,t){return function(...s){const r=this.__v_raw,i=ht(r),o=sa(i),a=n==="entries"||n===Symbol.iterator&&o,u=n==="keys"&&o,l=r[n](...s),h=t?sm:e?ca:js;return!e&&Dn(i,"iterate",u?nm:Ji),{next(){const{value:c,done:d}=l.next();return d?{value:c,done:d}:{value:a?[h(c[0]),h(c[1])]:h(c),done:d}},[Symbol.iterator](){return this}}}}function dh(n){return function(...e){return n==="delete"?!1:n==="clear"?void 0:this}}function CT(n,e){const t={get(r){const i=this.__v_raw,o=ht(i),a=ht(r);n||(hi(r,a)&&Dn(o,"get",r),Dn(o,"get",a));const{has:u}=hh(o),l=e?sm:n?ca:js;if(u.call(o,r))return l(i.get(r));if(u.call(o,a))return l(i.get(a));i!==o&&i.get(r)},get size(){const r=this.__v_raw;return!n&&Dn(ht(r),"iterate",Ji),r.size},has(r){const i=this.__v_raw,o=ht(i),a=ht(r);return n||(hi(r,a)&&Dn(o,"has",r),Dn(o,"has",a)),r===a?i.has(r):i.has(r)||i.has(a)},forEach(r,i){const o=this,a=o.__v_raw,u=ht(a),l=e?sm:n?ca:js;return!n&&Dn(u,"iterate",Ji),a.forEach((h,c)=>r.call(i,l(h),l(c),o))}};return Mn(t,n?{add:dh("add"),set:dh("set"),delete:dh("delete"),clear:dh("clear")}:{add(r){!e&&!As(r)&&!jr(r)&&(r=ht(r));const i=ht(this);return hh(i).has.call(i,r)||(i.add(r),Mr(i,"add",r,r)),this},set(r,i){!e&&!As(i)&&!jr(i)&&(i=ht(i));const o=ht(this),{has:a,get:u}=hh(o);let l=a.call(o,r);l||(r=ht(r),l=a.call(o,r));const h=u.call(o,r);return o.set(r,i),l?hi(i,h)&&Mr(o,"set",r,i):Mr(o,"add",r,i),this},delete(r){const i=ht(this),{has:o,get:a}=hh(i);let u=o.call(i,r);u||(r=ht(r),u=o.call(i,r)),a&&a.call(i,r);const l=i.delete(r);return u&&Mr(i,"delete",r,void 0),l},clear(){const r=ht(this),i=r.size!==0,o=r.clear();return i&&Mr(r,"clear",void 0,void 0),o}}),["keys","values","entries",Symbol.iterator].forEach(r=>{t[r]=vT(r,n,e)}),t}function ag(n,e){const t=CT(n,e);return(s,r,i)=>r==="__v_isReactive"?!n:r==="__v_isReadonly"?n:r==="__v_raw"?s:Reflect.get(St(t,r)&&r in s?t:s,r,i)}const ST={get:ag(!1,!1)},IT={get:ag(!1,!0)},$T={get:ag(!0,!1)};const K1=new WeakMap,j1=new WeakMap,X1=new WeakMap,kT=new WeakMap;function TT(n){switch(n){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function ET(n){return n.__v_skip||!Object.isExtensible(n)?0:TT(Jk(n))}function ug(n){return jr(n)?n:lg(n,!1,bT,ST,K1)}function RT(n){return lg(n,!1,wT,IT,j1)}function rm(n){return lg(n,!0,yT,$T,X1)}function lg(n,e,t,s,r){if(!Gt(n)||n.__v_raw&&!(e&&n.__v_isReactive))return n;const i=ET(n);if(i===0)return n;const o=r.get(n);if(o)return o;const a=new Proxy(n,i===2?s:t);return r.set(n,a),a}function eo(n){return jr(n)?eo(n.__v_raw):!!(n&&n.__v_isReactive)}function jr(n){return!!(n&&n.__v_isReadonly)}function As(n){return!!(n&&n.__v_isShallow)}function cg(n){return n?!!n.__v_raw:!1}function ht(n){const e=n&&n.__v_raw;return e?ht(e):n}function NT(n){return!St(n,"__v_skip")&&Object.isExtensible(n)&&_1(n,"__v_skip",!0),n}const js=n=>Gt(n)?ug(n):n,ca=n=>Gt(n)?rm(n):n;function Pn(n){return n?n.__v_isRef===!0:!1}function tt(n){return _T(n,!1)}function _T(n,e){return Pn(n)?n:new DT(n,e)}class DT{constructor(e,t){this.dep=new og,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=t?e:ht(e),this._value=t?e:js(e),this.__v_isShallow=t}get value(){return this.dep.track(),this._value}set value(e){const t=this._rawValue,s=this.__v_isShallow||As(e)||jr(e);e=s?e:ht(e),hi(e,t)&&(this._rawValue=e,this._value=s?e:js(e),this.dep.trigger())}}function hg(n){return Pn(n)?n.value:n}const AT={get:(n,e,t)=>e==="__v_raw"?n:hg(Reflect.get(n,e,t)),set:(n,e,t,s)=>{const r=n[e];return Pn(r)&&!Pn(t)?(r.value=t,!0):Reflect.set(n,e,t,s)}};function q1(n){return eo(n)?n:new Proxy(n,AT)}class FT{constructor(e,t,s){this.fn=e,this.setter=t,this._value=void 0,this.dep=new og(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=ll-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!t,this.isSSR=s}notify(){if(this.flags|=16,!(this.flags&8)&&Dt!==this)return O1(this,!0),!0}get value(){const e=this.dep.track();return B1(this),e&&(e.version=this.dep.version),this._value}set value(e){this.setter&&this.setter(e)}}function PT(n,e,t=!1){let s,r;return it(n)?s=n:(s=n.get,r=n.set),new FT(s,r,t)}const ph={},Mh=new WeakMap;let Ui;function LT(n,e=!1,t=Ui){if(t){let s=Mh.get(t);s||Mh.set(t,s=[]),s.push(n)}}function OT(n,e,t=At){const{immediate:s,deep:r,once:i,scheduler:o,augmentJob:a,call:u}=t,l=w=>r?w:As(w)||r===!1||r===0?oi(w,1):oi(w);let h,c,d,p,f=!1,g=!1;if(Pn(n)?(c=()=>n.value,f=As(n)):eo(n)?(c=()=>l(n),f=!0):rt(n)?(g=!0,f=n.some(w=>eo(w)||As(w)),c=()=>n.map(w=>{if(Pn(w))return w.value;if(eo(w))return l(w);if(it(w))return u?u(w,2):w()})):it(n)?e?c=u?()=>u(n,2):n:c=()=>{if(d){Hr();try{d()}finally{Kr()}}const w=Ui;Ui=h;try{return u?u(n,3,[p]):n(p)}finally{Ui=w}}:c=br,e&&r){const w=c,S=r===!0?1/0:r;c=()=>oi(w(),S)}const m=cT(),b=()=>{h.stop(),m&&m.active&&tg(m.effects,h)};if(i&&e){const w=e;e=(...S)=>{w(...S),b()}}let x=g?new Array(n.length).fill(ph):ph;const v=w=>{if(!(!(h.flags&1)||!h.dirty&&!w))if(e){const S=h.run();if(r||f||(g?S.some((k,E)=>hi(k,x[E])):hi(S,x))){d&&d();const k=Ui;Ui=h;try{const E=[S,x===ph?void 0:g&&x[0]===ph?[]:x,p];x=S,u?u(e,3,E):e(...E)}finally{Ui=k}}}else h.run()};return a&&a(v),h=new P1(c),h.scheduler=o?()=>o(v,!1):v,p=w=>LT(w,!1,h),d=h.onStop=()=>{const w=Mh.get(h);if(w){if(u)u(w,4);else for(const S of w)S();Mh.delete(h)}},e?s?v(!0):x=h.run():o?o(v.bind(null,!0),!0):h.run(),b.pause=h.pause.bind(h),b.resume=h.resume.bind(h),b.stop=b,b}function oi(n,e=1/0,t){if(e<=0||!Gt(n)||n.__v_skip||(t=t||new Map,(t.get(n)||0)>=e))return n;if(t.set(n,e),e--,Pn(n))oi(n.value,e,t);else if(rt(n))for(let s=0;s<n.length;s++)oi(n[s],e,t);else if(k1(n)||sa(n))n.forEach(s=>{oi(s,e,t)});else if(R1(n)){for(const s in n)oi(n[s],e,t);for(const s of Object.getOwnPropertySymbols(n))Object.prototype.propertyIsEnumerable.call(n,s)&&oi(n[s],e,t)}return n}/**
* @vue/runtime-core v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Dl(n,e,t,s){try{return s?n(...s):n()}catch(r){Ed(r,e,t)}}function Sr(n,e,t,s){if(it(n)){const r=Dl(n,e,t,s);return r&&T1(r)&&r.catch(i=>{Ed(i,e,t)}),r}if(rt(n)){const r=[];for(let i=0;i<n.length;i++)r.push(Sr(n[i],e,t,s));return r}}function Ed(n,e,t,s=!0){const r=e?e.vnode:null,{errorHandler:i,throwUnhandledErrorInProduction:o}=e&&e.appContext.config||At;if(e){let a=e.parent;const u=e.proxy,l=`https://vuejs.org/error-reference/#runtime-${t}`;for(;a;){const h=a.ec;if(h){for(let c=0;c<h.length;c++)if(h[c](n,u,l)===!1)return}a=a.parent}if(i){Hr(),Dl(i,null,10,[n,u,l]),Kr();return}}MT(n,t,r,s,o)}function MT(n,e,t,s=!0,r=!1){if(r)throw n;console.error(n)}const Wn=[];let rr=-1;const ra=[];let si=null,Zo=0;const Y1=Promise.resolve();let zh=null;function Rh(n){const e=zh||Y1;return n?e.then(this?n.bind(this):n):e}function zT(n){let e=rr+1,t=Wn.length;for(;e<t;){const s=e+t>>>1,r=Wn[s],i=hl(r);i<n||i===n&&r.flags&2?e=s+1:t=s}return e}function dg(n){if(!(n.flags&1)){const e=hl(n),t=Wn[Wn.length-1];!t||!(n.flags&2)&&e>=hl(t)?Wn.push(n):Wn.splice(zT(e),0,n),n.flags|=1,Z1()}}function Z1(){zh||(zh=Y1.then(J1))}function BT(n){rt(n)?ra.push(...n):si&&n.id===-1?si.splice(Zo+1,0,n):n.flags&1||(ra.push(n),n.flags|=1),Z1()}function Wb(n,e,t=rr+1){for(;t<Wn.length;t++){const s=Wn[t];if(s&&s.flags&2){if(n&&s.id!==n.uid)continue;Wn.splice(t,1),t--,s.flags&4&&(s.flags&=-2),s(),s.flags&4||(s.flags&=-2)}}}function Q1(n){if(ra.length){const e=[...new Set(ra)].sort((t,s)=>hl(t)-hl(s));if(ra.length=0,si){si.push(...e);return}for(si=e,Zo=0;Zo<si.length;Zo++){const t=si[Zo];t.flags&4&&(t.flags&=-2),t.flags&8||t(),t.flags&=-2}si=null,Zo=0}}const hl=n=>n.id==null?n.flags&2?-1:1/0:n.id;function J1(n){try{for(rr=0;rr<Wn.length;rr++){const e=Wn[rr];e&&!(e.flags&8)&&(e.flags&4&&(e.flags&=-2),Dl(e,e.i,e.i?15:14),e.flags&4||(e.flags&=-2))}}finally{for(;rr<Wn.length;rr++){const e=Wn[rr];e&&(e.flags&=-2)}rr=-1,Wn.length=0,Q1(),zh=null,(Wn.length||ra.length)&&J1()}}let gr=null,ew=null;function Bh(n){const e=gr;return gr=n,ew=n&&n.type.__scopeId||null,e}function VT(n,e=gr,t){if(!e||n._n)return n;const s=(...r)=>{s._d&&ry(-1);const i=Bh(e);let o;try{o=n(...r)}finally{Bh(i),s._d&&ry(1)}return o};return s._n=!0,s._c=!0,s._d=!0,s}function Oi(n,e,t,s){const r=n.dirs,i=e&&e.dirs;for(let o=0;o<r.length;o++){const a=r[o];i&&(a.oldValue=i[o].value);let u=a.dir[s];u&&(Hr(),Sr(u,t,8,[n.el,a,n,e]),Kr())}}const tw=Symbol("_vte"),UT=n=>n.__isTeleport,el=n=>n&&(n.disabled||n.disabled===""),Hb=n=>n&&(n.defer||n.defer===""),Kb=n=>typeof SVGElement<"u"&&n instanceof SVGElement,jb=n=>typeof MathMLElement=="function"&&n instanceof MathMLElement,im=(n,e)=>{const t=n&&n.to;return en(t)?e?e(t):null:t},nw={name:"Teleport",__isTeleport:!0,process(n,e,t,s,r,i,o,a,u,l){const{mc:h,pc:c,pbc:d,o:{insert:p,querySelector:f,createText:g,createComment:m}}=l,b=el(e.props);let{shapeFlag:x,children:v,dynamicChildren:w}=e;if(n==null){const S=e.el=g(""),k=e.anchor=g("");p(S,t,s),p(k,t,s);const E=(C,T)=>{x&16&&h(v,C,T,r,i,o,a,u)},I=()=>{const C=e.target=im(e.props,f),T=sw(C,e,g,p);C&&(o!=="svg"&&Kb(C)?o="svg":o!=="mathml"&&jb(C)&&(o="mathml"),r&&r.isCE&&(r.ce._teleportTargets||(r.ce._teleportTargets=new Set)).add(C),b||(E(C,T),Nh(e,!1)))};b&&(E(t,k),Nh(e,!0)),Hb(e.props)?(e.el.__isMounted=!1,Un(()=>{I(),delete e.el.__isMounted},i)):I()}else{if(Hb(e.props)&&n.el.__isMounted===!1){Un(()=>{nw.process(n,e,t,s,r,i,o,a,u,l)},i);return}e.el=n.el,e.targetStart=n.targetStart;const S=e.anchor=n.anchor,k=e.target=n.target,E=e.targetAnchor=n.targetAnchor,I=el(n.props),C=I?t:k,T=I?S:E;if(o==="svg"||Kb(k)?o="svg":(o==="mathml"||jb(k))&&(o="mathml"),w?(d(n.dynamicChildren,w,C,r,i,o,a),gg(n,e,!0)):u||c(n,e,C,T,r,i,o,a,!1),b)I?e.props&&n.props&&e.props.to!==n.props.to&&(e.props.to=n.props.to):fh(e,t,S,l,1);else if((e.props&&e.props.to)!==(n.props&&n.props.to)){const R=e.target=im(e.props,f);R&&fh(e,R,null,l,0)}else I&&fh(e,k,E,l,1);Nh(e,b)}},remove(n,e,t,{um:s,o:{remove:r}},i){const{shapeFlag:o,children:a,anchor:u,targetStart:l,targetAnchor:h,target:c,props:d}=n;if(c&&(r(l),r(h)),i&&r(u),o&16){const p=i||!el(d);for(let f=0;f<a.length;f++){const g=a[f];s(g,e,t,p,!!g.dynamicChildren)}}},move:fh,hydrate:GT};function fh(n,e,t,{o:{insert:s},m:r},i=2){i===0&&s(n.targetAnchor,e,t);const{el:o,anchor:a,shapeFlag:u,children:l,props:h}=n,c=i===2;if(c&&s(o,e,t),(!c||el(h))&&u&16)for(let d=0;d<l.length;d++)r(l[d],e,t,2);c&&s(a,e,t)}function GT(n,e,t,s,r,i,{o:{nextSibling:o,parentNode:a,querySelector:u,insert:l,createText:h}},c){function d(g,m,b,x){m.anchor=c(o(g),m,a(g),t,s,r,i),m.targetStart=b,m.targetAnchor=x}const p=e.target=im(e.props,u),f=el(e.props);if(p){const g=p._lpa||p.firstChild;if(e.shapeFlag&16)if(f)d(n,e,g,g&&o(g));else{e.anchor=o(n);let m=g;for(;m;){if(m&&m.nodeType===8){if(m.data==="teleport start anchor")e.targetStart=m;else if(m.data==="teleport anchor"){e.targetAnchor=m,p._lpa=e.targetAnchor&&o(e.targetAnchor);break}}m=o(m)}e.targetAnchor||sw(p,e,h,l),c(g&&o(g),e,p,t,s,r,i)}Nh(e,f)}else f&&e.shapeFlag&16&&d(n,e,n,o(n));return e.anchor&&o(e.anchor)}const WT=nw;function Nh(n,e){const t=n.ctx;if(t&&t.ut){let s,r;for(e?(s=n.el,r=n.anchor):(s=n.targetStart,r=n.targetAnchor);s&&s!==r;)s.nodeType===1&&s.setAttribute("data-v-owner",t.uid),s=s.nextSibling;t.ut()}}function sw(n,e,t,s){const r=e.targetStart=t(""),i=e.targetAnchor=t("");return r[tw]=i,n&&(s(r,n),s(i,n)),i}const HT=Symbol("_leaveCb");function pg(n,e){n.shapeFlag&6&&n.component?(n.transition=e,pg(n.component.subTree,e)):n.shapeFlag&128?(n.ssContent.transition=e.clone(n.ssContent),n.ssFallback.transition=e.clone(n.ssFallback)):n.transition=e}function vo(n,e){return it(n)?Mn({name:n.name},e,{setup:n}):n}function rw(n){n.ids=[n.ids[0]+n.ids[2]+++"-",0,0]}const Vh=new WeakMap;function tl(n,e,t,s,r=!1){if(rt(n)){n.forEach((f,g)=>tl(f,e&&(rt(e)?e[g]:e),t,s,r));return}if(nl(s)&&!r){s.shapeFlag&512&&s.type.__asyncResolved&&s.component.subTree.component&&tl(n,e,t,s.component.subTree);return}const i=s.shapeFlag&4?bg(s.component):s.el,o=r?null:i,{i:a,r:u}=n,l=e&&e.r,h=a.refs===At?a.refs={}:a.refs,c=a.setupState,d=ht(c),p=c===At?$1:f=>St(d,f);if(l!=null&&l!==u){if(Xb(e),en(l))h[l]=null,p(l)&&(c[l]=null);else if(Pn(l)){l.value=null;const f=e;f.k&&(h[f.k]=null)}}if(it(u))Dl(u,a,12,[o,h]);else{const f=en(u),g=Pn(u);if(f||g){const m=()=>{if(n.f){const b=f?p(u)?c[u]:h[u]:u.value;if(r)rt(b)&&tg(b,i);else if(rt(b))b.includes(i)||b.push(i);else if(f)h[u]=[i],p(u)&&(c[u]=h[u]);else{const x=[i];u.value=x,n.k&&(h[n.k]=x)}}else f?(h[u]=o,p(u)&&(c[u]=o)):g&&(u.value=o,n.k&&(h[n.k]=o))};if(o){const b=()=>{m(),Vh.delete(n)};b.id=-1,Vh.set(n,b),Un(b,t)}else Xb(n),m()}}}function Xb(n){const e=Vh.get(n);e&&(e.flags|=8,Vh.delete(n))}kd().requestIdleCallback;kd().cancelIdleCallback;const nl=n=>!!n.type.__asyncLoader,iw=n=>n.type.__isKeepAlive;function KT(n,e){ow(n,"a",e)}function jT(n,e){ow(n,"da",e)}function ow(n,e,t=jn){const s=n.__wdc||(n.__wdc=()=>{let r=t;for(;r;){if(r.isDeactivated)return;r=r.parent}return n()});if(Rd(e,s,t),t){let r=t.parent;for(;r&&r.parent;)iw(r.parent.vnode)&&XT(s,e,t,r),r=r.parent}}function XT(n,e,t,s){const r=Rd(e,n,s,!0);Fl(()=>{tg(s[e],r)},t)}function Rd(n,e,t=jn,s=!1){if(t){const r=t[n]||(t[n]=[]),i=e.__weh||(e.__weh=(...o)=>{Hr();const a=Pl(t),u=Sr(e,t,n,o);return a(),Kr(),u});return s?r.unshift(i):r.push(i),i}}const Zr=n=>(e,t=jn)=>{(!pl||n==="sp")&&Rd(n,(...s)=>e(...s),t)},qT=Zr("bm"),Al=Zr("m"),YT=Zr("bu"),ZT=Zr("u"),QT=Zr("bum"),Fl=Zr("um"),JT=Zr("sp"),eE=Zr("rtg"),tE=Zr("rtc");function nE(n,e=jn){Rd("ec",n,e)}const sE=Symbol.for("v-ndc");function qb(n,e,t,s){let r;const i=t,o=rt(n);if(o||en(n)){const a=o&&eo(n);let u=!1,l=!1;a&&(u=!As(n),l=jr(n),n=Td(n)),r=new Array(n.length);for(let h=0,c=n.length;h<c;h++)r[h]=e(u?l?ca(js(n[h])):js(n[h]):n[h],h,void 0,i)}else if(typeof n=="number"){r=new Array(n);for(let a=0;a<n;a++)r[a]=e(a+1,a,void 0,i)}else if(Gt(n))if(n[Symbol.iterator])r=Array.from(n,(a,u)=>e(a,u,void 0,i));else{const a=Object.keys(n);r=new Array(a.length);for(let u=0,l=a.length;u<l;u++){const h=a[u];r[u]=e(n[h],h,u,i)}}else r=[];return r}const om=n=>n?Tw(n)?bg(n):om(n.parent):null,sl=Mn(Object.create(null),{$:n=>n,$el:n=>n.vnode.el,$data:n=>n.data,$props:n=>n.props,$attrs:n=>n.attrs,$slots:n=>n.slots,$refs:n=>n.refs,$parent:n=>om(n.parent),$root:n=>om(n.root),$host:n=>n.ce,$emit:n=>n.emit,$options:n=>uw(n),$forceUpdate:n=>n.f||(n.f=()=>{dg(n.update)}),$nextTick:n=>n.n||(n.n=Rh.bind(n.proxy)),$watch:n=>mE.bind(n)}),Rf=(n,e)=>n!==At&&!n.__isScriptSetup&&St(n,e),rE={get({_:n},e){if(e==="__v_skip")return!0;const{ctx:t,setupState:s,data:r,props:i,accessCache:o,type:a,appContext:u}=n;if(e[0]!=="$"){const d=o[e];if(d!==void 0)switch(d){case 1:return s[e];case 2:return r[e];case 4:return t[e];case 3:return i[e]}else{if(Rf(s,e))return o[e]=1,s[e];if(r!==At&&St(r,e))return o[e]=2,r[e];if(St(i,e))return o[e]=3,i[e];if(t!==At&&St(t,e))return o[e]=4,t[e];am&&(o[e]=0)}}const l=sl[e];let h,c;if(l)return e==="$attrs"&&Dn(n.attrs,"get",""),l(n);if((h=a.__cssModules)&&(h=h[e]))return h;if(t!==At&&St(t,e))return o[e]=4,t[e];if(c=u.config.globalProperties,St(c,e))return c[e]},set({_:n},e,t){const{data:s,setupState:r,ctx:i}=n;return Rf(r,e)?(r[e]=t,!0):s!==At&&St(s,e)?(s[e]=t,!0):St(n.props,e)||e[0]==="$"&&e.slice(1)in n?!1:(i[e]=t,!0)},has({_:{data:n,setupState:e,accessCache:t,ctx:s,appContext:r,props:i,type:o}},a){let u;return!!(t[a]||n!==At&&a[0]!=="$"&&St(n,a)||Rf(e,a)||St(i,a)||St(s,a)||St(sl,a)||St(r.config.globalProperties,a)||(u=o.__cssModules)&&u[a])},defineProperty(n,e,t){return t.get!=null?n._.accessCache[e]=0:St(t,"value")&&this.set(n,e,t.value,null),Reflect.defineProperty(n,e,t)}};function Yb(n){return rt(n)?n.reduce((e,t)=>(e[t]=null,e),{}):n}let am=!0;function iE(n){const e=uw(n),t=n.proxy,s=n.ctx;am=!1,e.beforeCreate&&Zb(e.beforeCreate,n,"bc");const{data:r,computed:i,methods:o,watch:a,provide:u,inject:l,created:h,beforeMount:c,mounted:d,beforeUpdate:p,updated:f,activated:g,deactivated:m,beforeDestroy:b,beforeUnmount:x,destroyed:v,unmounted:w,render:S,renderTracked:k,renderTriggered:E,errorCaptured:I,serverPrefetch:C,expose:T,inheritAttrs:R,components:P,directives:D,filters:F}=e;if(l&&oE(l,s,null),o)for(const B in o){const N=o[B];it(N)&&(s[B]=N.bind(t))}if(r){const B=r.call(t,t);Gt(B)&&(n.data=ug(B))}if(am=!0,i)for(const B in i){const N=i[B],O=it(N)?N.bind(t,t):it(N.get)?N.get.bind(t,t):br,K=!it(N)&&it(N.set)?N.set.bind(t):br,U=fl({get:O,set:K});Object.defineProperty(s,B,{enumerable:!0,configurable:!0,get:()=>U.value,set:X=>U.value=X})}if(a)for(const B in a)aw(a[B],s,t,B);if(u){const B=it(u)?u.call(t):u;Reflect.ownKeys(B).forEach(N=>{dE(N,B[N])})}h&&Zb(h,n,"c");function _(B,N){rt(N)?N.forEach(O=>B(O.bind(t))):N&&B(N.bind(t))}if(_(qT,c),_(Al,d),_(YT,p),_(ZT,f),_(KT,g),_(jT,m),_(nE,I),_(tE,k),_(eE,E),_(QT,x),_(Fl,w),_(JT,C),rt(T))if(T.length){const B=n.exposed||(n.exposed={});T.forEach(N=>{Object.defineProperty(B,N,{get:()=>t[N],set:O=>t[N]=O,enumerable:!0})})}else n.exposed||(n.exposed={});S&&n.render===br&&(n.render=S),R!=null&&(n.inheritAttrs=R),P&&(n.components=P),D&&(n.directives=D),C&&rw(n)}function oE(n,e,t=br){rt(n)&&(n=um(n));for(const s in n){const r=n[s];let i;Gt(r)?"default"in r?i=_h(r.from||s,r.default,!0):i=_h(r.from||s):i=_h(r),Pn(i)?Object.defineProperty(e,s,{enumerable:!0,configurable:!0,get:()=>i.value,set:o=>i.value=o}):e[s]=i}}function Zb(n,e,t){Sr(rt(n)?n.map(s=>s.bind(e.proxy)):n.bind(e.proxy),e,t)}function aw(n,e,t,s){let r=s.includes(".")?hw(t,s):()=>t[s];if(en(n)){const i=e[n];it(i)&&Vr(r,i)}else if(it(n))Vr(r,n.bind(t));else if(Gt(n))if(rt(n))n.forEach(i=>aw(i,e,t,s));else{const i=it(n.handler)?n.handler.bind(t):e[n.handler];it(i)&&Vr(r,i,n)}}function uw(n){const e=n.type,{mixins:t,extends:s}=e,{mixins:r,optionsCache:i,config:{optionMergeStrategies:o}}=n.appContext,a=i.get(e);let u;return a?u=a:!r.length&&!t&&!s?u=e:(u={},r.length&&r.forEach(l=>Uh(u,l,o,!0)),Uh(u,e,o)),Gt(e)&&i.set(e,u),u}function Uh(n,e,t,s=!1){const{mixins:r,extends:i}=e;i&&Uh(n,i,t,!0),r&&r.forEach(o=>Uh(n,o,t,!0));for(const o in e)if(!(s&&o==="expose")){const a=aE[o]||t&&t[o];n[o]=a?a(n[o],e[o]):e[o]}return n}const aE={data:Qb,props:Jb,emits:Jb,methods:Gu,computed:Gu,beforeCreate:Vn,created:Vn,beforeMount:Vn,mounted:Vn,beforeUpdate:Vn,updated:Vn,beforeDestroy:Vn,beforeUnmount:Vn,destroyed:Vn,unmounted:Vn,activated:Vn,deactivated:Vn,errorCaptured:Vn,serverPrefetch:Vn,components:Gu,directives:Gu,watch:lE,provide:Qb,inject:uE};function Qb(n,e){return e?n?function(){return Mn(it(n)?n.call(this,this):n,it(e)?e.call(this,this):e)}:e:n}function uE(n,e){return Gu(um(n),um(e))}function um(n){if(rt(n)){const e={};for(let t=0;t<n.length;t++)e[n[t]]=n[t];return e}return n}function Vn(n,e){return n?[...new Set([].concat(n,e))]:e}function Gu(n,e){return n?Mn(Object.create(null),n,e):e}function Jb(n,e){return n?rt(n)&&rt(e)?[...new Set([...n,...e])]:Mn(Object.create(null),Yb(n),Yb(e??{})):e}function lE(n,e){if(!n)return e;if(!e)return n;const t=Mn(Object.create(null),n);for(const s in e)t[s]=Vn(n[s],e[s]);return t}function lw(){return{app:null,config:{isNativeTag:$1,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let cE=0;function hE(n,e){return function(s,r=null){it(s)||(s=Mn({},s)),r!=null&&!Gt(r)&&(r=null);const i=lw(),o=new WeakSet,a=[];let u=!1;const l=i.app={_uid:cE++,_component:s,_props:r,_container:null,_context:i,_instance:null,version:XE,get config(){return i.config},set config(h){},use(h,...c){return o.has(h)||(h&&it(h.install)?(o.add(h),h.install(l,...c)):it(h)&&(o.add(h),h(l,...c))),l},mixin(h){return i.mixins.includes(h)||i.mixins.push(h),l},component(h,c){return c?(i.components[h]=c,l):i.components[h]},directive(h,c){return c?(i.directives[h]=c,l):i.directives[h]},mount(h,c,d){if(!u){const p=l._ceVNode||Ln(s,r);return p.appContext=i,d===!0?d="svg":d===!1&&(d=void 0),n(p,h,d),u=!0,l._container=h,h.__vue_app__=l,bg(p.component)}},onUnmount(h){a.push(h)},unmount(){u&&(Sr(a,l._instance,16),n(null,l._container),delete l._container.__vue_app__)},provide(h,c){return i.provides[h]=c,l},runWithContext(h){const c=ia;ia=l;try{return h()}finally{ia=c}}};return l}}let ia=null;function dE(n,e){if(jn){let t=jn.provides;const s=jn.parent&&jn.parent.provides;s===t&&(t=jn.provides=Object.create(s)),t[n]=e}}function _h(n,e,t=!1){const s=UE();if(s||ia){let r=ia?ia._context.provides:s?s.parent==null||s.ce?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides:void 0;if(r&&n in r)return r[n];if(arguments.length>1)return t&&it(e)?e.call(s&&s.proxy):e}}const pE=Symbol.for("v-scx"),fE=()=>_h(pE);function Vr(n,e,t){return cw(n,e,t)}function cw(n,e,t=At){const{immediate:s,deep:r,flush:i,once:o}=t,a=Mn({},t),u=e&&s||!e&&i!=="post";let l;if(pl){if(i==="sync"){const p=fE();l=p.__watcherHandles||(p.__watcherHandles=[])}else if(!u){const p=()=>{};return p.stop=br,p.resume=br,p.pause=br,p}}const h=jn;a.call=(p,f,g)=>Sr(p,h,f,g);let c=!1;i==="post"?a.scheduler=p=>{Un(p,h&&h.suspense)}:i!=="sync"&&(c=!0,a.scheduler=(p,f)=>{f?p():dg(p)}),a.augmentJob=p=>{e&&(p.flags|=4),c&&(p.flags|=2,h&&(p.id=h.uid,p.i=h))};const d=OT(n,e,a);return pl&&(l?l.push(d):u&&d()),d}function mE(n,e,t){const s=this.proxy,r=en(n)?n.includes(".")?hw(s,n):()=>s[n]:n.bind(s,s);let i;it(e)?i=e:(i=e.handler,t=e);const o=Pl(this),a=cw(r,i.bind(s),t);return o(),a}function hw(n,e){const t=e.split(".");return()=>{let s=n;for(let r=0;r<t.length&&s;r++)s=s[t[r]];return s}}const gE=(n,e)=>e==="modelValue"||e==="model-value"?n.modelModifiers:n[`${e}Modifiers`]||n[`${mi(e)}Modifiers`]||n[`${wo(e)}Modifiers`];function xE(n,e,...t){if(n.isUnmounted)return;const s=n.vnode.props||At;let r=t;const i=e.startsWith("update:"),o=i&&gE(s,e.slice(7));o&&(o.trim&&(r=t.map(h=>en(h)?h.trim():h)),o.number&&(r=t.map(nT)));let a,u=s[a=Sf(e)]||s[a=Sf(mi(e))];!u&&i&&(u=s[a=Sf(wo(e))]),u&&Sr(u,n,6,r);const l=s[a+"Once"];if(l){if(!n.emitted)n.emitted={};else if(n.emitted[a])return;n.emitted[a]=!0,Sr(l,n,6,r)}}const bE=new WeakMap;function dw(n,e,t=!1){const s=t?bE:e.emitsCache,r=s.get(n);if(r!==void 0)return r;const i=n.emits;let o={},a=!1;if(!it(n)){const u=l=>{const h=dw(l,e,!0);h&&(a=!0,Mn(o,h))};!t&&e.mixins.length&&e.mixins.forEach(u),n.extends&&u(n.extends),n.mixins&&n.mixins.forEach(u)}return!i&&!a?(Gt(n)&&s.set(n,null),null):(rt(i)?i.forEach(u=>o[u]=null):Mn(o,i),Gt(n)&&s.set(n,o),o)}function Nd(n,e){return!n||!Sd(e)?!1:(e=e.slice(2).replace(/Once$/,""),St(n,e[0].toLowerCase()+e.slice(1))||St(n,wo(e))||St(n,e))}function ey(n){const{type:e,vnode:t,proxy:s,withProxy:r,propsOptions:[i],slots:o,attrs:a,emit:u,render:l,renderCache:h,props:c,data:d,setupState:p,ctx:f,inheritAttrs:g}=n,m=Bh(n);let b,x;try{if(t.shapeFlag&4){const w=r||s,S=w;b=cr(l.call(S,w,h,c,p,d,f)),x=a}else{const w=e;b=cr(w.length>1?w(c,{attrs:a,slots:o,emit:u}):w(c,null)),x=e.props?a:yE(a)}}catch(w){rl.length=0,Ed(w,n,1),b=Ln(gi)}let v=b;if(x&&g!==!1){const w=Object.keys(x),{shapeFlag:S}=v;w.length&&S&7&&(i&&w.some(eg)&&(x=wE(x,i)),v=ha(v,x,!1,!0))}return t.dirs&&(v=ha(v,null,!1,!0),v.dirs=v.dirs?v.dirs.concat(t.dirs):t.dirs),t.transition&&pg(v,t.transition),b=v,Bh(m),b}const yE=n=>{let e;for(const t in n)(t==="class"||t==="style"||Sd(t))&&((e||(e={}))[t]=n[t]);return e},wE=(n,e)=>{const t={};for(const s in n)(!eg(s)||!(s.slice(9)in e))&&(t[s]=n[s]);return t};function vE(n,e,t){const{props:s,children:r,component:i}=n,{props:o,children:a,patchFlag:u}=e,l=i.emitsOptions;if(e.dirs||e.transition)return!0;if(t&&u>=0){if(u&1024)return!0;if(u&16)return s?ty(s,o,l):!!o;if(u&8){const h=e.dynamicProps;for(let c=0;c<h.length;c++){const d=h[c];if(o[d]!==s[d]&&!Nd(l,d))return!0}}}else return(r||a)&&(!a||!a.$stable)?!0:s===o?!1:s?o?ty(s,o,l):!0:!!o;return!1}function ty(n,e,t){const s=Object.keys(e);if(s.length!==Object.keys(n).length)return!0;for(let r=0;r<s.length;r++){const i=s[r];if(e[i]!==n[i]&&!Nd(t,i))return!0}return!1}function CE({vnode:n,parent:e},t){for(;e;){const s=e.subTree;if(s.suspense&&s.suspense.activeBranch===n&&(s.el=n.el),s===n)(n=e.vnode).el=t,e=e.parent;else break}}const pw={},fw=()=>Object.create(pw),mw=n=>Object.getPrototypeOf(n)===pw;function SE(n,e,t,s=!1){const r={},i=fw();n.propsDefaults=Object.create(null),gw(n,e,r,i);for(const o in n.propsOptions[0])o in r||(r[o]=void 0);t?n.props=s?r:RT(r):n.type.props?n.props=r:n.props=i,n.attrs=i}function IE(n,e,t,s){const{props:r,attrs:i,vnode:{patchFlag:o}}=n,a=ht(r),[u]=n.propsOptions;let l=!1;if((s||o>0)&&!(o&16)){if(o&8){const h=n.vnode.dynamicProps;for(let c=0;c<h.length;c++){let d=h[c];if(Nd(n.emitsOptions,d))continue;const p=e[d];if(u)if(St(i,d))p!==i[d]&&(i[d]=p,l=!0);else{const f=mi(d);r[f]=lm(u,a,f,p,n,!1)}else p!==i[d]&&(i[d]=p,l=!0)}}}else{gw(n,e,r,i)&&(l=!0);let h;for(const c in a)(!e||!St(e,c)&&((h=wo(c))===c||!St(e,h)))&&(u?t&&(t[c]!==void 0||t[h]!==void 0)&&(r[c]=lm(u,a,c,void 0,n,!0)):delete r[c]);if(i!==a)for(const c in i)(!e||!St(e,c))&&(delete i[c],l=!0)}l&&Mr(n.attrs,"set","")}function gw(n,e,t,s){const[r,i]=n.propsOptions;let o=!1,a;if(e)for(let u in e){if(Zu(u))continue;const l=e[u];let h;r&&St(r,h=mi(u))?!i||!i.includes(h)?t[h]=l:(a||(a={}))[h]=l:Nd(n.emitsOptions,u)||(!(u in s)||l!==s[u])&&(s[u]=l,o=!0)}if(i){const u=ht(t),l=a||At;for(let h=0;h<i.length;h++){const c=i[h];t[c]=lm(r,u,c,l[c],n,!St(l,c))}}return o}function lm(n,e,t,s,r,i){const o=n[t];if(o!=null){const a=St(o,"default");if(a&&s===void 0){const u=o.default;if(o.type!==Function&&!o.skipFactory&&it(u)){const{propsDefaults:l}=r;if(t in l)s=l[t];else{const h=Pl(r);s=l[t]=u.call(null,e),h()}}else s=u;r.ce&&r.ce._setProp(t,s)}o[0]&&(i&&!a?s=!1:o[1]&&(s===""||s===wo(t))&&(s=!0))}return s}const $E=new WeakMap;function xw(n,e,t=!1){const s=t?$E:e.propsCache,r=s.get(n);if(r)return r;const i=n.props,o={},a=[];let u=!1;if(!it(n)){const h=c=>{u=!0;const[d,p]=xw(c,e,!0);Mn(o,d),p&&a.push(...p)};!t&&e.mixins.length&&e.mixins.forEach(h),n.extends&&h(n.extends),n.mixins&&n.mixins.forEach(h)}if(!i&&!u)return Gt(n)&&s.set(n,na),na;if(rt(i))for(let h=0;h<i.length;h++){const c=mi(i[h]);ny(c)&&(o[c]=At)}else if(i)for(const h in i){const c=mi(h);if(ny(c)){const d=i[h],p=o[c]=rt(d)||it(d)?{type:d}:Mn({},d),f=p.type;let g=!1,m=!0;if(rt(f))for(let b=0;b<f.length;++b){const x=f[b],v=it(x)&&x.name;if(v==="Boolean"){g=!0;break}else v==="String"&&(m=!1)}else g=it(f)&&f.name==="Boolean";p[0]=g,p[1]=m,(g||St(p,"default"))&&a.push(c)}}const l=[o,a];return Gt(n)&&s.set(n,l),l}function ny(n){return n[0]!=="$"&&!Zu(n)}const fg=n=>n==="_"||n==="_ctx"||n==="$stable",mg=n=>rt(n)?n.map(cr):[cr(n)],kE=(n,e,t)=>{if(e._n)return e;const s=VT((...r)=>mg(e(...r)),t);return s._c=!1,s},bw=(n,e,t)=>{const s=n._ctx;for(const r in n){if(fg(r))continue;const i=n[r];if(it(i))e[r]=kE(r,i,s);else if(i!=null){const o=mg(i);e[r]=()=>o}}},yw=(n,e)=>{const t=mg(e);n.slots.default=()=>t},ww=(n,e,t)=>{for(const s in e)(t||!fg(s))&&(n[s]=e[s])},TE=(n,e,t)=>{const s=n.slots=fw();if(n.vnode.shapeFlag&32){const r=e._;r?(ww(s,e,t),t&&_1(s,"_",r,!0)):bw(e,s)}else e&&yw(n,e)},EE=(n,e,t)=>{const{vnode:s,slots:r}=n;let i=!0,o=At;if(s.shapeFlag&32){const a=e._;a?t&&a===1?i=!1:ww(r,e,t):(i=!e.$stable,bw(e,r)),o=e}else e&&(yw(n,e),o={default:1});if(i)for(const a in r)!fg(a)&&o[a]==null&&delete r[a]},Un=AE;function RE(n){return NE(n)}function NE(n,e){const t=kd();t.__VUE__=!0;const{insert:s,remove:r,patchProp:i,createElement:o,createText:a,createComment:u,setText:l,setElementText:h,parentNode:c,nextSibling:d,setScopeId:p=br,insertStaticContent:f}=n,g=(V,G,ee,ue=null,ae=null,ce=null,me=void 0,ye=null,ge=!!G.dynamicChildren)=>{if(V===G)return;V&&!Mu(V,G)&&(ue=Se(V),X(V,ae,ce,!0),V=null),G.patchFlag===-2&&(ge=!1,G.dynamicChildren=null);const{type:pe,ref:Le,shapeFlag:be}=G;switch(pe){case _d:m(V,G,ee,ue);break;case gi:b(V,G,ee,ue);break;case _f:V==null&&x(G,ee,ue,me);break;case ks:P(V,G,ee,ue,ae,ce,me,ye,ge);break;default:be&1?S(V,G,ee,ue,ae,ce,me,ye,ge):be&6?D(V,G,ee,ue,ae,ce,me,ye,ge):(be&64||be&128)&&pe.process(V,G,ee,ue,ae,ce,me,ye,ge,De)}Le!=null&&ae?tl(Le,V&&V.ref,ce,G||V,!G):Le==null&&V&&V.ref!=null&&tl(V.ref,null,ce,V,!0)},m=(V,G,ee,ue)=>{if(V==null)s(G.el=a(G.children),ee,ue);else{const ae=G.el=V.el;G.children!==V.children&&l(ae,G.children)}},b=(V,G,ee,ue)=>{V==null?s(G.el=u(G.children||""),ee,ue):G.el=V.el},x=(V,G,ee,ue)=>{[V.el,V.anchor]=f(V.children,G,ee,ue,V.el,V.anchor)},v=({el:V,anchor:G},ee,ue)=>{let ae;for(;V&&V!==G;)ae=d(V),s(V,ee,ue),V=ae;s(G,ee,ue)},w=({el:V,anchor:G})=>{let ee;for(;V&&V!==G;)ee=d(V),r(V),V=ee;r(G)},S=(V,G,ee,ue,ae,ce,me,ye,ge)=>{if(G.type==="svg"?me="svg":G.type==="math"&&(me="mathml"),V==null)k(G,ee,ue,ae,ce,me,ye,ge);else{const pe=V.el&&V.el._isVueCE?V.el:null;try{pe&&pe._beginPatch(),C(V,G,ae,ce,me,ye,ge)}finally{pe&&pe._endPatch()}}},k=(V,G,ee,ue,ae,ce,me,ye)=>{let ge,pe;const{props:Le,shapeFlag:be,transition:Ae,dirs:Pe}=V;if(ge=V.el=o(V.type,ce,Le&&Le.is,Le),be&8?h(ge,V.children):be&16&&I(V.children,ge,null,ue,ae,Nf(V,ce),me,ye),Pe&&Oi(V,null,ue,"created"),E(ge,V,V.scopeId,me,ue),Le){for(const ot in Le)ot!=="value"&&!Zu(ot)&&i(ge,ot,null,Le[ot],ce,ue);"value"in Le&&i(ge,"value",null,Le.value,ce),(pe=Le.onVnodeBeforeMount)&&sr(pe,ue,V)}Pe&&Oi(V,null,ue,"beforeMount");const et=_E(ae,Ae);et&&Ae.beforeEnter(ge),s(ge,G,ee),((pe=Le&&Le.onVnodeMounted)||et||Pe)&&Un(()=>{pe&&sr(pe,ue,V),et&&Ae.enter(ge),Pe&&Oi(V,null,ue,"mounted")},ae)},E=(V,G,ee,ue,ae)=>{if(ee&&p(V,ee),ue)for(let ce=0;ce<ue.length;ce++)p(V,ue[ce]);if(ae){let ce=ae.subTree;if(G===ce||Cw(ce.type)&&(ce.ssContent===G||ce.ssFallback===G)){const me=ae.vnode;E(V,me,me.scopeId,me.slotScopeIds,ae.parent)}}},I=(V,G,ee,ue,ae,ce,me,ye,ge=0)=>{for(let pe=ge;pe<V.length;pe++){const Le=V[pe]=ye?ri(V[pe]):cr(V[pe]);g(null,Le,G,ee,ue,ae,ce,me,ye)}},C=(V,G,ee,ue,ae,ce,me)=>{const ye=G.el=V.el;let{patchFlag:ge,dynamicChildren:pe,dirs:Le}=G;ge|=V.patchFlag&16;const be=V.props||At,Ae=G.props||At;let Pe;if(ee&&Mi(ee,!1),(Pe=Ae.onVnodeBeforeUpdate)&&sr(Pe,ee,G,V),Le&&Oi(G,V,ee,"beforeUpdate"),ee&&Mi(ee,!0),(be.innerHTML&&Ae.innerHTML==null||be.textContent&&Ae.textContent==null)&&h(ye,""),pe?T(V.dynamicChildren,pe,ye,ee,ue,Nf(G,ae),ce):me||N(V,G,ye,null,ee,ue,Nf(G,ae),ce,!1),ge>0){if(ge&16)R(ye,be,Ae,ee,ae);else if(ge&2&&be.class!==Ae.class&&i(ye,"class",null,Ae.class,ae),ge&4&&i(ye,"style",be.style,Ae.style,ae),ge&8){const et=G.dynamicProps;for(let ot=0;ot<et.length;ot++){const ke=et[ot],Vt=be[ke],nn=Ae[ke];(nn!==Vt||ke==="value")&&i(ye,ke,Vt,nn,ae,ee)}}ge&1&&V.children!==G.children&&h(ye,G.children)}else!me&&pe==null&&R(ye,be,Ae,ee,ae);((Pe=Ae.onVnodeUpdated)||Le)&&Un(()=>{Pe&&sr(Pe,ee,G,V),Le&&Oi(G,V,ee,"updated")},ue)},T=(V,G,ee,ue,ae,ce,me)=>{for(let ye=0;ye<G.length;ye++){const ge=V[ye],pe=G[ye],Le=ge.el&&(ge.type===ks||!Mu(ge,pe)||ge.shapeFlag&198)?c(ge.el):ee;g(ge,pe,Le,null,ue,ae,ce,me,!0)}},R=(V,G,ee,ue,ae)=>{if(G!==ee){if(G!==At)for(const ce in G)!Zu(ce)&&!(ce in ee)&&i(V,ce,G[ce],null,ae,ue);for(const ce in ee){if(Zu(ce))continue;const me=ee[ce],ye=G[ce];me!==ye&&ce!=="value"&&i(V,ce,ye,me,ae,ue)}"value"in ee&&i(V,"value",G.value,ee.value,ae)}},P=(V,G,ee,ue,ae,ce,me,ye,ge)=>{const pe=G.el=V?V.el:a(""),Le=G.anchor=V?V.anchor:a("");let{patchFlag:be,dynamicChildren:Ae,slotScopeIds:Pe}=G;Pe&&(ye=ye?ye.concat(Pe):Pe),V==null?(s(pe,ee,ue),s(Le,ee,ue),I(G.children||[],ee,Le,ae,ce,me,ye,ge)):be>0&&be&64&&Ae&&V.dynamicChildren?(T(V.dynamicChildren,Ae,ee,ae,ce,me,ye),(G.key!=null||ae&&G===ae.subTree)&&gg(V,G,!0)):N(V,G,ee,Le,ae,ce,me,ye,ge)},D=(V,G,ee,ue,ae,ce,me,ye,ge)=>{G.slotScopeIds=ye,V==null?G.shapeFlag&512?ae.ctx.activate(G,ee,ue,me,ge):F(G,ee,ue,ae,ce,me,ge):z(V,G,ge)},F=(V,G,ee,ue,ae,ce,me)=>{const ye=V.component=VE(V,ue,ae);if(iw(V)&&(ye.ctx.renderer=De),GE(ye,!1,me),ye.asyncDep){if(ae&&ae.registerDep(ye,_,me),!V.el){const ge=ye.subTree=Ln(gi);b(null,ge,G,ee),V.placeholder=ge.el}}else _(ye,V,G,ee,ae,ce,me)},z=(V,G,ee)=>{const ue=G.component=V.component;if(vE(V,G,ee))if(ue.asyncDep&&!ue.asyncResolved){B(ue,G,ee);return}else ue.next=G,ue.update();else G.el=V.el,ue.vnode=G},_=(V,G,ee,ue,ae,ce,me)=>{const ye=()=>{if(V.isMounted){let{next:be,bu:Ae,u:Pe,parent:et,vnode:ot}=V;{const bn=vw(V);if(bn){be&&(be.el=ot.el,B(V,be,me)),bn.asyncDep.then(()=>{V.isUnmounted||ye()});return}}let ke=be,Vt;Mi(V,!1),be?(be.el=ot.el,B(V,be,me)):be=ot,Ae&&If(Ae),(Vt=be.props&&be.props.onVnodeBeforeUpdate)&&sr(Vt,et,be,ot),Mi(V,!0);const nn=ey(V),Rn=V.subTree;V.subTree=nn,g(Rn,nn,c(Rn.el),Se(Rn),V,ae,ce),be.el=nn.el,ke===null&&CE(V,nn.el),Pe&&Un(Pe,ae),(Vt=be.props&&be.props.onVnodeUpdated)&&Un(()=>sr(Vt,et,be,ot),ae)}else{let be;const{el:Ae,props:Pe}=G,{bm:et,m:ot,parent:ke,root:Vt,type:nn}=V,Rn=nl(G);Mi(V,!1),et&&If(et),!Rn&&(be=Pe&&Pe.onVnodeBeforeMount)&&sr(be,ke,G),Mi(V,!0);{Vt.ce&&Vt.ce._def.shadowRoot!==!1&&Vt.ce._injectChildStyle(nn);const bn=V.subTree=ey(V);g(null,bn,ee,ue,V,ae,ce),G.el=bn.el}if(ot&&Un(ot,ae),!Rn&&(be=Pe&&Pe.onVnodeMounted)){const bn=G;Un(()=>sr(be,ke,bn),ae)}(G.shapeFlag&256||ke&&nl(ke.vnode)&&ke.vnode.shapeFlag&256)&&V.a&&Un(V.a,ae),V.isMounted=!0,G=ee=ue=null}};V.scope.on();const ge=V.effect=new P1(ye);V.scope.off();const pe=V.update=ge.run.bind(ge),Le=V.job=ge.runIfDirty.bind(ge);Le.i=V,Le.id=V.uid,ge.scheduler=()=>dg(Le),Mi(V,!0),pe()},B=(V,G,ee)=>{G.component=V;const ue=V.vnode.props;V.vnode=G,V.next=null,IE(V,G.props,ue,ee),EE(V,G.children,ee),Hr(),Wb(V),Kr()},N=(V,G,ee,ue,ae,ce,me,ye,ge=!1)=>{const pe=V&&V.children,Le=V?V.shapeFlag:0,be=G.children,{patchFlag:Ae,shapeFlag:Pe}=G;if(Ae>0){if(Ae&128){K(pe,be,ee,ue,ae,ce,me,ye,ge);return}else if(Ae&256){O(pe,be,ee,ue,ae,ce,me,ye,ge);return}}Pe&8?(Le&16&&he(pe,ae,ce),be!==pe&&h(ee,be)):Le&16?Pe&16?K(pe,be,ee,ue,ae,ce,me,ye,ge):he(pe,ae,ce,!0):(Le&8&&h(ee,""),Pe&16&&I(be,ee,ue,ae,ce,me,ye,ge))},O=(V,G,ee,ue,ae,ce,me,ye,ge)=>{V=V||na,G=G||na;const pe=V.length,Le=G.length,be=Math.min(pe,Le);let Ae;for(Ae=0;Ae<be;Ae++){const Pe=G[Ae]=ge?ri(G[Ae]):cr(G[Ae]);g(V[Ae],Pe,ee,null,ae,ce,me,ye,ge)}pe>Le?he(V,ae,ce,!0,!1,be):I(G,ee,ue,ae,ce,me,ye,ge,be)},K=(V,G,ee,ue,ae,ce,me,ye,ge)=>{let pe=0;const Le=G.length;let be=V.length-1,Ae=Le-1;for(;pe<=be&&pe<=Ae;){const Pe=V[pe],et=G[pe]=ge?ri(G[pe]):cr(G[pe]);if(Mu(Pe,et))g(Pe,et,ee,null,ae,ce,me,ye,ge);else break;pe++}for(;pe<=be&&pe<=Ae;){const Pe=V[be],et=G[Ae]=ge?ri(G[Ae]):cr(G[Ae]);if(Mu(Pe,et))g(Pe,et,ee,null,ae,ce,me,ye,ge);else break;be--,Ae--}if(pe>be){if(pe<=Ae){const Pe=Ae+1,et=Pe<Le?G[Pe].el:ue;for(;pe<=Ae;)g(null,G[pe]=ge?ri(G[pe]):cr(G[pe]),ee,et,ae,ce,me,ye,ge),pe++}}else if(pe>Ae)for(;pe<=be;)X(V[pe],ae,ce,!0),pe++;else{const Pe=pe,et=pe,ot=new Map;for(pe=et;pe<=Ae;pe++){const Mt=G[pe]=ge?ri(G[pe]):cr(G[pe]);Mt.key!=null&&ot.set(Mt.key,pe)}let ke,Vt=0;const nn=Ae-et+1;let Rn=!1,bn=0;const es=new Array(nn);for(pe=0;pe<nn;pe++)es[pe]=0;for(pe=Pe;pe<=be;pe++){const Mt=V[pe];if(Vt>=nn){X(Mt,ae,ce,!0);continue}let Ze;if(Mt.key!=null)Ze=ot.get(Mt.key);else for(ke=et;ke<=Ae;ke++)if(es[ke-et]===0&&Mu(Mt,G[ke])){Ze=ke;break}Ze===void 0?X(Mt,ae,ce,!0):(es[Ze-et]=pe+1,Ze>=bn?bn=Ze:Rn=!0,g(Mt,G[Ze],ee,null,ae,ce,me,ye,ge),Vt++)}const Fi=Rn?DE(es):na;for(ke=Fi.length-1,pe=nn-1;pe>=0;pe--){const Mt=et+pe,Ze=G[Mt],rh=G[Mt+1],Pi=Mt+1<Le?rh.el||rh.placeholder:ue;es[pe]===0?g(null,Ze,ee,Pi,ae,ce,me,ye,ge):Rn&&(ke<0||pe!==Fi[ke]?U(Ze,ee,Pi,2):ke--)}}},U=(V,G,ee,ue,ae=null)=>{const{el:ce,type:me,transition:ye,children:ge,shapeFlag:pe}=V;if(pe&6){U(V.component.subTree,G,ee,ue);return}if(pe&128){V.suspense.move(G,ee,ue);return}if(pe&64){me.move(V,G,ee,De);return}if(me===ks){s(ce,G,ee);for(let be=0;be<ge.length;be++)U(ge[be],G,ee,ue);s(V.anchor,G,ee);return}if(me===_f){v(V,G,ee);return}if(ue!==2&&pe&1&&ye)if(ue===0)ye.beforeEnter(ce),s(ce,G,ee),Un(()=>ye.enter(ce),ae);else{const{leave:be,delayLeave:Ae,afterLeave:Pe}=ye,et=()=>{V.ctx.isUnmounted?r(ce):s(ce,G,ee)},ot=()=>{ce._isLeaving&&ce[HT](!0),be(ce,()=>{et(),Pe&&Pe()})};Ae?Ae(ce,et,ot):ot()}else s(ce,G,ee)},X=(V,G,ee,ue=!1,ae=!1)=>{const{type:ce,props:me,ref:ye,children:ge,dynamicChildren:pe,shapeFlag:Le,patchFlag:be,dirs:Ae,cacheIndex:Pe}=V;if(be===-2&&(ae=!1),ye!=null&&(Hr(),tl(ye,null,ee,V,!0),Kr()),Pe!=null&&(G.renderCache[Pe]=void 0),Le&256){G.ctx.deactivate(V);return}const et=Le&1&&Ae,ot=!nl(V);let ke;if(ot&&(ke=me&&me.onVnodeBeforeUnmount)&&sr(ke,G,V),Le&6)re(V.component,ee,ue);else{if(Le&128){V.suspense.unmount(ee,ue);return}et&&Oi(V,null,G,"beforeUnmount"),Le&64?V.type.remove(V,G,ee,De,ue):pe&&!pe.hasOnce&&(ce!==ks||be>0&&be&64)?he(pe,G,ee,!1,!0):(ce===ks&&be&384||!ae&&Le&16)&&he(ge,G,ee),ue&&te(V)}(ot&&(ke=me&&me.onVnodeUnmounted)||et)&&Un(()=>{ke&&sr(ke,G,V),et&&Oi(V,null,G,"unmounted")},ee)},te=V=>{const{type:G,el:ee,anchor:ue,transition:ae}=V;if(G===ks){ie(ee,ue);return}if(G===_f){w(V);return}const ce=()=>{r(ee),ae&&!ae.persisted&&ae.afterLeave&&ae.afterLeave()};if(V.shapeFlag&1&&ae&&!ae.persisted){const{leave:me,delayLeave:ye}=ae,ge=()=>me(ee,ce);ye?ye(V.el,ce,ge):ge()}else ce()},ie=(V,G)=>{let ee;for(;V!==G;)ee=d(V),r(V),V=ee;r(G)},re=(V,G,ee)=>{const{bum:ue,scope:ae,job:ce,subTree:me,um:ye,m:ge,a:pe}=V;sy(ge),sy(pe),ue&&If(ue),ae.stop(),ce&&(ce.flags|=8,X(me,V,G,ee)),ye&&Un(ye,G),Un(()=>{V.isUnmounted=!0},G)},he=(V,G,ee,ue=!1,ae=!1,ce=0)=>{for(let me=ce;me<V.length;me++)X(V[me],G,ee,ue,ae)},Se=V=>{if(V.shapeFlag&6)return Se(V.component.subTree);if(V.shapeFlag&128)return V.suspense.next();const G=d(V.anchor||V.el),ee=G&&G[tw];return ee?d(ee):G};let xe=!1;const Ce=(V,G,ee)=>{V==null?G._vnode&&X(G._vnode,null,null,!0):g(G._vnode||null,V,G,null,null,null,ee),G._vnode=V,xe||(xe=!0,Wb(),Q1(),xe=!1)},De={p:g,um:X,m:U,r:te,mt:F,mc:I,pc:N,pbc:T,n:Se,o:n};return{render:Ce,hydrate:void 0,createApp:hE(Ce)}}function Nf({type:n,props:e},t){return t==="svg"&&n==="foreignObject"||t==="mathml"&&n==="annotation-xml"&&e&&e.encoding&&e.encoding.includes("html")?void 0:t}function Mi({effect:n,job:e},t){t?(n.flags|=32,e.flags|=4):(n.flags&=-33,e.flags&=-5)}function _E(n,e){return(!n||n&&!n.pendingBranch)&&e&&!e.persisted}function gg(n,e,t=!1){const s=n.children,r=e.children;if(rt(s)&&rt(r))for(let i=0;i<s.length;i++){const o=s[i];let a=r[i];a.shapeFlag&1&&!a.dynamicChildren&&((a.patchFlag<=0||a.patchFlag===32)&&(a=r[i]=ri(r[i]),a.el=o.el),!t&&a.patchFlag!==-2&&gg(o,a)),a.type===_d&&a.patchFlag!==-1&&(a.el=o.el),a.type===gi&&!a.el&&(a.el=o.el)}}function DE(n){const e=n.slice(),t=[0];let s,r,i,o,a;const u=n.length;for(s=0;s<u;s++){const l=n[s];if(l!==0){if(r=t[t.length-1],n[r]<l){e[s]=r,t.push(s);continue}for(i=0,o=t.length-1;i<o;)a=i+o>>1,n[t[a]]<l?i=a+1:o=a;l<n[t[i]]&&(i>0&&(e[s]=t[i-1]),t[i]=s)}}for(i=t.length,o=t[i-1];i-- >0;)t[i]=o,o=e[o];return t}function vw(n){const e=n.subTree.component;if(e)return e.asyncDep&&!e.asyncResolved?e:vw(e)}function sy(n){if(n)for(let e=0;e<n.length;e++)n[e].flags|=8}const Cw=n=>n.__isSuspense;function AE(n,e){e&&e.pendingBranch?rt(n)?e.effects.push(...n):e.effects.push(n):BT(n)}const ks=Symbol.for("v-fgt"),_d=Symbol.for("v-txt"),gi=Symbol.for("v-cmt"),_f=Symbol.for("v-stc"),rl=[];let fs=null;function lt(n=!1){rl.push(fs=n?null:[])}function FE(){rl.pop(),fs=rl[rl.length-1]||null}let dl=1;function ry(n,e=!1){dl+=n,n<0&&fs&&e&&(fs.hasOnce=!0)}function Sw(n){return n.dynamicChildren=dl>0?fs||na:null,FE(),dl>0&&fs&&fs.push(n),n}function dt(n,e,t,s,r,i){return Sw(Ve(n,e,t,s,r,i,!0))}function Iw(n,e,t,s,r){return Sw(Ln(n,e,t,s,r,!0))}function $w(n){return n?n.__v_isVNode===!0:!1}function Mu(n,e){return n.type===e.type&&n.key===e.key}const kw=({key:n})=>n??null,Dh=({ref:n,ref_key:e,ref_for:t})=>(typeof n=="number"&&(n=""+n),n!=null?en(n)||Pn(n)||it(n)?{i:gr,r:n,k:e,f:!!t}:n:null);function Ve(n,e=null,t=null,s=0,r=null,i=n===ks?0:1,o=!1,a=!1){const u={__v_isVNode:!0,__v_skip:!0,type:n,props:e,key:e&&kw(e),ref:e&&Dh(e),scopeId:ew,slotScopeIds:null,children:t,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:i,patchFlag:s,dynamicProps:r,dynamicChildren:null,appContext:null,ctx:gr};return a?(xg(u,t),i&128&&n.normalize(u)):t&&(u.shapeFlag|=en(t)?8:16),dl>0&&!o&&fs&&(u.patchFlag>0||i&6)&&u.patchFlag!==32&&fs.push(u),u}const Ln=PE;function PE(n,e=null,t=null,s=0,r=null,i=!1){if((!n||n===sE)&&(n=gi),$w(n)){const a=ha(n,e,!0);return t&&xg(a,t),dl>0&&!i&&fs&&(a.shapeFlag&6?fs[fs.indexOf(n)]=a:fs.push(a)),a.patchFlag=-2,a}if(jE(n)&&(n=n.__vccOpts),e){e=LE(e);let{class:a,style:u}=e;a&&!en(a)&&(e.class=In(a)),Gt(u)&&(cg(u)&&!rt(u)&&(u=Mn({},u)),e.style=lr(u))}const o=en(n)?1:Cw(n)?128:UT(n)?64:Gt(n)?4:it(n)?2:0;return Ve(n,e,t,s,r,o,i,!0)}function LE(n){return n?cg(n)||mw(n)?Mn({},n):n:null}function ha(n,e,t=!1,s=!1){const{props:r,ref:i,patchFlag:o,children:a,transition:u}=n,l=e?ME(r||{},e):r,h={__v_isVNode:!0,__v_skip:!0,type:n.type,props:l,key:l&&kw(l),ref:e&&e.ref?t&&i?rt(i)?i.concat(Dh(e)):[i,Dh(e)]:Dh(e):i,scopeId:n.scopeId,slotScopeIds:n.slotScopeIds,children:a,target:n.target,targetStart:n.targetStart,targetAnchor:n.targetAnchor,staticCount:n.staticCount,shapeFlag:n.shapeFlag,patchFlag:e&&n.type!==ks?o===-1?16:o|16:o,dynamicProps:n.dynamicProps,dynamicChildren:n.dynamicChildren,appContext:n.appContext,dirs:n.dirs,transition:u,component:n.component,suspense:n.suspense,ssContent:n.ssContent&&ha(n.ssContent),ssFallback:n.ssFallback&&ha(n.ssFallback),placeholder:n.placeholder,el:n.el,anchor:n.anchor,ctx:n.ctx,ce:n.ce};return u&&s&&pg(h,u.clone(h)),h}function OE(n=" ",e=0){return Ln(_d,null,n,e)}function yn(n="",e=!1){return e?(lt(),Iw(gi,null,n)):Ln(gi,null,n)}function cr(n){return n==null||typeof n=="boolean"?Ln(gi):rt(n)?Ln(ks,null,n.slice()):$w(n)?ri(n):Ln(_d,null,String(n))}function ri(n){return n.el===null&&n.patchFlag!==-1||n.memo?n:ha(n)}function xg(n,e){let t=0;const{shapeFlag:s}=n;if(e==null)e=null;else if(rt(e))t=16;else if(typeof e=="object")if(s&65){const r=e.default;r&&(r._c&&(r._d=!1),xg(n,r()),r._c&&(r._d=!0));return}else{t=32;const r=e._;!r&&!mw(e)?e._ctx=gr:r===3&&gr&&(gr.slots._===1?e._=1:(e._=2,n.patchFlag|=1024))}else it(e)?(e={default:e,_ctx:gr},t=32):(e=String(e),s&64?(t=16,e=[OE(e)]):t=8);n.children=e,n.shapeFlag|=t}function ME(...n){const e={};for(let t=0;t<n.length;t++){const s=n[t];for(const r in s)if(r==="class")e.class!==s.class&&(e.class=In([e.class,s.class]));else if(r==="style")e.style=lr([e.style,s.style]);else if(Sd(r)){const i=e[r],o=s[r];o&&i!==o&&!(rt(i)&&i.includes(o))&&(e[r]=i?[].concat(i,o):o)}else r!==""&&(e[r]=s[r])}return e}function sr(n,e,t,s=null){Sr(n,e,7,[t,s])}const zE=lw();let BE=0;function VE(n,e,t){const s=n.type,r=(e?e.appContext:n.appContext)||zE,i={uid:BE++,vnode:n,type:s,parent:e,appContext:r,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new lT(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:e?e.provides:Object.create(r.provides),ids:e?e.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:xw(s,r),emitsOptions:dw(s,r),emit:null,emitted:null,propsDefaults:At,inheritAttrs:s.inheritAttrs,ctx:At,data:At,props:At,attrs:At,slots:At,refs:At,setupState:At,setupContext:null,suspense:t,suspenseId:t?t.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return i.ctx={_:i},i.root=e?e.root:i,i.emit=xE.bind(null,i),n.ce&&n.ce(i),i}let jn=null;const UE=()=>jn||gr;let Gh,cm;{const n=kd(),e=(t,s)=>{let r;return(r=n[t])||(r=n[t]=[]),r.push(s),i=>{r.length>1?r.forEach(o=>o(i)):r[0](i)}};Gh=e("__VUE_INSTANCE_SETTERS__",t=>jn=t),cm=e("__VUE_SSR_SETTERS__",t=>pl=t)}const Pl=n=>{const e=jn;return Gh(n),n.scope.on(),()=>{n.scope.off(),Gh(e)}},iy=()=>{jn&&jn.scope.off(),Gh(null)};function Tw(n){return n.vnode.shapeFlag&4}let pl=!1;function GE(n,e=!1,t=!1){e&&cm(e);const{props:s,children:r}=n.vnode,i=Tw(n);SE(n,s,i,e),TE(n,r,t||e);const o=i?WE(n,e):void 0;return e&&cm(!1),o}function WE(n,e){const t=n.type;n.accessCache=Object.create(null),n.proxy=new Proxy(n.ctx,rE);const{setup:s}=t;if(s){Hr();const r=n.setupContext=s.length>1?KE(n):null,i=Pl(n),o=Dl(s,n,0,[n.props,r]),a=T1(o);if(Kr(),i(),(a||n.sp)&&!nl(n)&&rw(n),a){if(o.then(iy,iy),e)return o.then(u=>{oy(n,u)}).catch(u=>{Ed(u,n,0)});n.asyncDep=o}else oy(n,o)}else Ew(n)}function oy(n,e,t){it(e)?n.type.__ssrInlineRender?n.ssrRender=e:n.render=e:Gt(e)&&(n.setupState=q1(e)),Ew(n)}function Ew(n,e,t){const s=n.type;n.render||(n.render=s.render||br);{const r=Pl(n);Hr();try{iE(n)}finally{Kr(),r()}}}const HE={get(n,e){return Dn(n,"get",""),n[e]}};function KE(n){const e=t=>{n.exposed=t||{}};return{attrs:new Proxy(n.attrs,HE),slots:n.slots,emit:n.emit,expose:e}}function bg(n){return n.exposed?n.exposeProxy||(n.exposeProxy=new Proxy(q1(NT(n.exposed)),{get(e,t){if(t in e)return e[t];if(t in sl)return sl[t](n)},has(e,t){return t in e||t in sl}})):n.proxy}function jE(n){return it(n)&&"__vccOpts"in n}const fl=(n,e)=>PT(n,e,pl),XE="3.5.25";/**
* @vue/runtime-dom v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let hm;const ay=typeof window<"u"&&window.trustedTypes;if(ay)try{hm=ay.createPolicy("vue",{createHTML:n=>n})}catch{}const Rw=hm?n=>hm.createHTML(n):n=>n,qE="http://www.w3.org/2000/svg",YE="http://www.w3.org/1998/Math/MathML",Lr=typeof document<"u"?document:null,uy=Lr&&Lr.createElement("template"),ZE={insert:(n,e,t)=>{e.insertBefore(n,t||null)},remove:n=>{const e=n.parentNode;e&&e.removeChild(n)},createElement:(n,e,t,s)=>{const r=e==="svg"?Lr.createElementNS(qE,n):e==="mathml"?Lr.createElementNS(YE,n):t?Lr.createElement(n,{is:t}):Lr.createElement(n);return n==="select"&&s&&s.multiple!=null&&r.setAttribute("multiple",s.multiple),r},createText:n=>Lr.createTextNode(n),createComment:n=>Lr.createComment(n),setText:(n,e)=>{n.nodeValue=e},setElementText:(n,e)=>{n.textContent=e},parentNode:n=>n.parentNode,nextSibling:n=>n.nextSibling,querySelector:n=>Lr.querySelector(n),setScopeId(n,e){n.setAttribute(e,"")},insertStaticContent(n,e,t,s,r,i){const o=t?t.previousSibling:e.lastChild;if(r&&(r===i||r.nextSibling))for(;e.insertBefore(r.cloneNode(!0),t),!(r===i||!(r=r.nextSibling)););else{uy.innerHTML=Rw(s==="svg"?`<svg>${n}</svg>`:s==="mathml"?`<math>${n}</math>`:n);const a=uy.content;if(s==="svg"||s==="mathml"){const u=a.firstChild;for(;u.firstChild;)a.appendChild(u.firstChild);a.removeChild(u)}e.insertBefore(a,t)}return[o?o.nextSibling:e.firstChild,t?t.previousSibling:e.lastChild]}},QE=Symbol("_vtc");function JE(n,e,t){const s=n[QE];s&&(e=(e?[e,...s]:[...s]).join(" ")),e==null?n.removeAttribute("class"):t?n.setAttribute("class",e):n.className=e}const ly=Symbol("_vod"),eR=Symbol("_vsh"),tR=Symbol(""),nR=/(?:^|;)\s*display\s*:/;function sR(n,e,t){const s=n.style,r=en(t);let i=!1;if(t&&!r){if(e)if(en(e))for(const o of e.split(";")){const a=o.slice(0,o.indexOf(":")).trim();t[a]==null&&Ah(s,a,"")}else for(const o in e)t[o]==null&&Ah(s,o,"");for(const o in t)o==="display"&&(i=!0),Ah(s,o,t[o])}else if(r){if(e!==t){const o=s[tR];o&&(t+=";"+o),s.cssText=t,i=nR.test(t)}}else e&&n.removeAttribute("style");ly in n&&(n[ly]=i?s.display:"",n[eR]&&(s.display="none"))}const cy=/\s*!important$/;function Ah(n,e,t){if(rt(t))t.forEach(s=>Ah(n,e,s));else if(t==null&&(t=""),e.startsWith("--"))n.setProperty(e,t);else{const s=rR(n,e);cy.test(t)?n.setProperty(wo(s),t.replace(cy,""),"important"):n[s]=t}}const hy=["Webkit","Moz","ms"],Df={};function rR(n,e){const t=Df[e];if(t)return t;let s=mi(e);if(s!=="filter"&&s in n)return Df[e]=s;s=N1(s);for(let r=0;r<hy.length;r++){const i=hy[r]+s;if(i in n)return Df[e]=i}return e}const dy="http://www.w3.org/1999/xlink";function py(n,e,t,s,r,i=uT(e)){s&&e.startsWith("xlink:")?t==null?n.removeAttributeNS(dy,e.slice(6,e.length)):n.setAttributeNS(dy,e,t):t==null||i&&!D1(t)?n.removeAttribute(e):n.setAttribute(e,i?"":Si(t)?String(t):t)}function fy(n,e,t,s,r){if(e==="innerHTML"||e==="textContent"){t!=null&&(n[e]=e==="innerHTML"?Rw(t):t);return}const i=n.tagName;if(e==="value"&&i!=="PROGRESS"&&!i.includes("-")){const a=i==="OPTION"?n.getAttribute("value")||"":n.value,u=t==null?n.type==="checkbox"?"on":"":String(t);(a!==u||!("_value"in n))&&(n.value=u),t==null&&n.removeAttribute(e),n._value=t;return}let o=!1;if(t===""||t==null){const a=typeof n[e];a==="boolean"?t=D1(t):t==null&&a==="string"?(t="",o=!0):a==="number"&&(t=0,o=!0)}try{n[e]=t}catch{}o&&n.removeAttribute(r||e)}function iR(n,e,t,s){n.addEventListener(e,t,s)}function oR(n,e,t,s){n.removeEventListener(e,t,s)}const my=Symbol("_vei");function aR(n,e,t,s,r=null){const i=n[my]||(n[my]={}),o=i[e];if(s&&o)o.value=s;else{const[a,u]=uR(e);if(s){const l=i[e]=hR(s,r);iR(n,a,l,u)}else o&&(oR(n,a,o,u),i[e]=void 0)}}const gy=/(?:Once|Passive|Capture)$/;function uR(n){let e;if(gy.test(n)){e={};let s;for(;s=n.match(gy);)n=n.slice(0,n.length-s[0].length),e[s[0].toLowerCase()]=!0}return[n[2]===":"?n.slice(3):wo(n.slice(2)),e]}let Af=0;const lR=Promise.resolve(),cR=()=>Af||(lR.then(()=>Af=0),Af=Date.now());function hR(n,e){const t=s=>{if(!s._vts)s._vts=Date.now();else if(s._vts<=t.attached)return;Sr(dR(s,t.value),e,5,[s])};return t.value=n,t.attached=cR(),t}function dR(n,e){if(rt(e)){const t=n.stopImmediatePropagation;return n.stopImmediatePropagation=()=>{t.call(n),n._stopped=!0},e.map(s=>r=>!r._stopped&&s&&s(r))}else return e}const xy=n=>n.charCodeAt(0)===111&&n.charCodeAt(1)===110&&n.charCodeAt(2)>96&&n.charCodeAt(2)<123,pR=(n,e,t,s,r,i)=>{const o=r==="svg";e==="class"?JE(n,s,o):e==="style"?sR(n,t,s):Sd(e)?eg(e)||aR(n,e,t,s,i):(e[0]==="."?(e=e.slice(1),!0):e[0]==="^"?(e=e.slice(1),!1):fR(n,e,s,o))?(fy(n,e,s),!n.tagName.includes("-")&&(e==="value"||e==="checked"||e==="selected")&&py(n,e,s,o,i,e!=="value")):n._isVueCE&&(/[A-Z]/.test(e)||!en(s))?fy(n,mi(e),s,i,e):(e==="true-value"?n._trueValue=s:e==="false-value"&&(n._falseValue=s),py(n,e,s,o))};function fR(n,e,t,s){if(s)return!!(e==="innerHTML"||e==="textContent"||e in n&&xy(e)&&it(t));if(e==="spellcheck"||e==="draggable"||e==="translate"||e==="autocorrect"||e==="sandbox"&&n.tagName==="IFRAME"||e==="form"||e==="list"&&n.tagName==="INPUT"||e==="type"&&n.tagName==="TEXTAREA")return!1;if(e==="width"||e==="height"){const r=n.tagName;if(r==="IMG"||r==="VIDEO"||r==="CANVAS"||r==="SOURCE")return!1}return xy(e)&&en(t)?!1:e in n}const mR=Mn({patchProp:pR},ZE);let by;function gR(){return by||(by=RE(mR))}const xR=(...n)=>{const e=gR().createApp(...n),{mount:t}=e;return e.mount=s=>{const r=yR(s);if(!r)return;const i=e._component;!it(i)&&!i.render&&!i.template&&(i.template=r.innerHTML),r.nodeType===1&&(r.textContent="");const o=t(r,!1,bR(r));return r instanceof Element&&(r.removeAttribute("v-cloak"),r.setAttribute("data-v-app","")),o},e};function bR(n){if(n instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&n instanceof MathMLElement)return"mathml"}function yR(n){return en(n)?document.querySelector(n):n}const yy=n=>({data:Array.from(n.data),width:n.width,height:n.height});function wR(n,e){const t=[],s=n*e;for(let r=0;r<s;r++)t.push(0),t.push(0),t.push(0),t.push(255);return{data:t,width:n,height:e}}const vR=new Map;function ai(n){return function(...e){const t=performance.now();let s=n(...e);const r=()=>{const o=(performance.now()-t).toFixed(2);vR.set(n,o),console.log(`Function ${n.name||"anonymous"} took ${o} milliseconds.n/${new Error().stack}`)};return s instanceof Promise?s.then(i=>(r(),i)).catch(i=>{throw r(),i}):(r(),s)}}const CR=`struct Uniforms {\r
  width: u32,\r
  height: u32,\r
};\r
\r
@group(0) @binding(0) var<storage, read> dataRGBA: array<f32>;\r
@group(0) @binding(1) var<storage, read> eigenVectors: array<f32>;\r
@group(0) @binding(2) var<storage, read_write> outputValues: array<f32>;  // RGB\r
@group(0) @binding(3) var<storage, read_write> outputOffsets: array<u32>; // \r
@group(0) @binding(4) var<uniform> uniforms: Uniforms;\r
\r
// \r
fn dotProduct(px: f32, py: f32, pz: f32, ev0: f32, ev1: f32, ev2: f32) -> f32 {\r
  return px * ev0 + py * ev1 + pz * ev2;\r
}\r
\r
@compute @workgroup_size(16, 16)\r
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r
  let width = uniforms.width;\r
  let height = uniforms.height;\r
  \r
  let i = global_id.x;\r
  let j = global_id.y;\r
  \r
  // \r
  if (i >= width || j >= height) {\r
    return;\r
  }\r
  \r
  let pixelIndex = j * width + i;\r
  let rgbaIndex = pixelIndex * 4u; // 4(RGBA)\r
  \r
  // RGBARGB\r
  let pixelR = dataRGBA[rgbaIndex];\r
  let pixelG = dataRGBA[rgbaIndex + 1u];\r
  let pixelB = dataRGBA[rgbaIndex + 2u];\r
  \r
  // \r
  let valueR = dotProduct(pixelR, pixelG, pixelB, eigenVectors[0], eigenVectors[1], eigenVectors[2]);\r
  let valueG = dotProduct(pixelR, pixelG, pixelB, eigenVectors[3], eigenVectors[4], eigenVectors[5]);\r
  let valueB = dotProduct(pixelR, pixelG, pixelB, eigenVectors[6], eigenVectors[7], eigenVectors[8]);\r
  \r
  // \r
  let pixelOffset = pixelIndex;\r
  outputValues[pixelIndex * 3u] = valueR;\r
  outputValues[pixelIndex * 3u + 1u] = valueG;\r
  outputValues[pixelIndex * 3u + 2u] = valueB;\r
  outputOffsets[pixelIndex * 3u] = pixelOffset;\r
  outputOffsets[pixelIndex * 3u + 1u] = pixelOffset;\r
  outputOffsets[pixelIndex * 3u + 2u] = pixelOffset;\r
}`,Ff=Symbol.for("webgpu_cache"),Dd=async()=>{const n=window;n[Ff]||(n[Ff]={:null,:null});const e=n[Ff];if(e.)return e.;if(!navigator.gpu)throw new Error("WebGPU ");if(e.=await navigator.gpu.requestAdapter(),!e.)throw new Error(" WebGPU ");const t=e..limits,s=Math.min(t.maxStorageBufferBindingSize||134217728,2147483644);if(e.=await e..requestDevice({requiredLimits:{maxStorageBufferBindingSize:s}}),!e.)throw new Error(" WebGPU ");return e.},wy=(n,e,t,s)=>{if(!e||e.length===0)throw new Error(": 0");const r=n.createBuffer({size:e.byteLength,usage:t,mappedAtCreation:!0,label:s});return new Float32Array(r.getMappedRange()).set(e),r.unmap(),r},SR=`@group(0) @binding(0) var<storage, read_write> channelValues: array<f32>;\r
@group(0) @binding(1) var<storage, read_write> channelPixelOffsets: array<u32>;\r
@group(0) @binding(2) var<uniform> params: Params;\r
\r
struct Params {\r
    k: u32,\r
    j: u32,\r
    element_count: u32,\r
    total_invocations: u32,\r
    channel_count: u32,\r
};\r
\r
@compute @workgroup_size(256)\r
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r
    let thread_index = global_id.x;\r
    let element_count = params.element_count;\r
    let k = params.k;\r
    let j = params.j;\r
    let total_invocations = params.total_invocations;\r
    let channel_count = params.channel_count;\r
\r
    for (var i = thread_index; i < element_count; i = i + total_invocations) {\r
        let ix = i;\r
        let jx = ix ^ j;\r
        \r
        if (jx >= element_count || jx < ix) {\r
            continue;\r
        }\r
        \r
        let direction = ((ix & k) == 0u);\r
        \r
        // \r
        for (var channel = 0u; channel < channel_count; channel = channel + 1u) {\r
            let val_i = channelValues[ix * channel_count + channel];\r
            let val_j = channelValues[jx * channel_count + channel];\r
            \r
            if (direction == (val_i > val_j)) {\r
                // \r
                let temp_val = channelValues[ix * channel_count + channel];\r
                channelValues[ix * channel_count + channel] = channelValues[jx * channel_count + channel];\r
                channelValues[jx * channel_count + channel] = temp_val;\r
\r
                // \r
                let temp_offset = channelPixelOffsets[ix * channel_count + channel];\r
                channelPixelOffsets[ix * channel_count + channel] = channelPixelOffsets[jx * channel_count + channel];\r
                channelPixelOffsets[jx * channel_count + channel] = temp_offset;\r
            }\r
        }\r
    }\r
}`,IR=n=>(n&n-1)===0&&n!==0,$R=n=>{if(n<=0)return 1;let e=1;for(;e<n;)e<<=1;return e},vy=(n,e,t,s,r)=>{for(let i=e;i<t;i++)for(let o=0;o<r;o++)n[i*r+o]=s},kR=async(n,e,t)=>{const s=await Dd(),r=n.length/t;let i=r;IR(r)||(i=$R(r));const o=i!==r,a=new Float32Array(i*t),u=new Uint32Array(i*t);a.set(n),u.set(e),o&&(vy(a,r,i,1/0,t),vy(u,r,i,0,t));const l=s.createShaderModule({code:SR}),h=s.createComputePipeline({layout:s.createPipelineLayout({bindGroupLayouts:[s.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]})]}),compute:{module:l,entryPoint:"main"}}),c=s.createBuffer({size:a.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),d=s.createBuffer({size:u.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(c,0,a),s.queue.writeBuffer(d,0,u),await s.queue.onSubmittedWorkDone();const p=s.createCommandEncoder(),f=Math.ceil(i/256)*256;for(let x=2;x<=i;x<<=1)for(let v=x>>1;v>0;v=v>>1){const w=s.createBuffer({size:20,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:`params_k${x}_j${v}`});s.queue.writeBuffer(w,0,new Uint32Array([x,v,i,f,t]));const S=s.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:c}},{binding:1,resource:{buffer:d}},{binding:2,resource:{buffer:w}}],label:`bindGroup_k${x}_j${v}`}),k=p.beginComputePass();k.setPipeline(h),k.setBindGroup(0,S),k.dispatchWorkgroups(Math.ceil(i/256)),k.end()}s.queue.submit([p.finish()]),await s.queue.onSubmittedWorkDone();const g=s.createBuffer({size:u.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),m=s.createCommandEncoder();m.copyBufferToBuffer(d,0,g,0,u.byteLength),s.queue.submit([m.finish()]),await g.mapAsync(GPUMapMode.READ);const b=new Uint32Array(g.getMappedRange().slice(0));return g.unmap(),b},Cy=16,TR=async(n,e,t)=>{const{width:s,height:r}=e,i=s*r,o=new Float32Array(e.data),a=new Float32Array(t.flat()),u=n.createShaderModule({code:CR,label:""}),l=new Uint32Array([s,r]),h=n.createBuffer({size:l.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0,label:"Uniform"});new Uint32Array(h.getMappedRange()).set(l),h.unmap();const c=wy(n,o,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,"RGBA"),d=wy(n,a,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,""),p=n.createBuffer({size:i*3*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,label:""}),f=n.createBuffer({size:i*3*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,label:""}),g=n.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}],label:""}),m=n.createBindGroup({layout:g,entries:[{binding:0,resource:{buffer:c}},{binding:1,resource:{buffer:d}},{binding:2,resource:{buffer:p}},{binding:3,resource:{buffer:f}},{binding:4,resource:{buffer:h}}],label:""}),b=n.createComputePipeline({layout:n.createPipelineLayout({bindGroupLayouts:[g],label:""}),compute:{module:u,entryPoint:"main"},label:""}),x=n.createCommandEncoder({label:""}),v=x.beginComputePass({label:""});v.setPipeline(b),v.setBindGroup(0,m);const w=Math.ceil(s/Cy),S=Math.ceil(r/Cy);v.dispatchWorkgroups(w,S),v.end(),n.queue.submit([x.finish()]),await n.queue.onSubmittedWorkDone();const k=n.createBuffer({size:i*3*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:""}),E=n.createBuffer({size:i*3*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:""}),I=n.createCommandEncoder({label:""});I.copyBufferToBuffer(p,0,k,0,i*3*4),I.copyBufferToBuffer(f,0,E,0,i*3*4),n.queue.submit([I.finish()]),await n.queue.onSubmittedWorkDone(),await Promise.all([k.mapAsync(GPUMapMode.READ),E.mapAsync(GPUMapMode.READ)]);const C=k.getMappedRange(),T=E.getMappedRange(),R=new Float32Array(C.slice(0)),P=new Uint32Array(T.slice(0));return k.unmap(),E.unmap(),await kR(R,P,3)},ER=async(n,e)=>{const t=await Dd();return TR(t,n,e)};var Co=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function RR(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function NR(n){if(n.__esModule)return n;var e=n.default;if(typeof e=="function"){var t=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}function mh(n){throw new Error('Could not dynamically require "'+n+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var Nw={exports:{}};/**
 * gpu.js
 * http://gpu.rocks/
 *
 * GPU Accelerated JavaScript
 *
 * @version 2.16.0
 * @date Wed Nov 16 2022 15:48:37 GMT-0500 (Eastern Standard Time)
 *
 * @license MIT
 * The MIT License
 *
 * Copyright (c) 2022 gpu.js Team
 */(function(n,e){(function(t){n.exports=t()})(function(){return function(){function t(s,r,i){function o(l,h){if(!r[l]){if(!s[l]){var c=typeof mh=="function"&&mh;if(!h&&c)return c(l,!0);if(a)return a(l,!0);var d=new Error("Cannot find module '"+l+"'");throw d.code="MODULE_NOT_FOUND",d}var p=r[l]={exports:{}};s[l][0].call(p.exports,function(f){var g=s[l][1][f];return o(g||f)},p,p.exports,t,s,r,i)}return r[l].exports}for(var a=typeof mh=="function"&&mh,u=0;u<i.length;u++)o(i[u]);return o}return t}()({1:[function(t,s,r){(function(i,o){typeof r=="object"&&typeof s<"u"?o(r):(i=i||self,o(i.acorn={}))})(this,function(i){var o={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"},a="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",u={5:a,"5module":a+" export import",6:a+" const class extends export import super"},l=/^in(stanceof)?$/,h="---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",c="--------------------------------------------------------------------------------------------------------------------------------------------------",d=new RegExp("["+h+"]"),p=new RegExp("["+h+c+"]");h=c=null;var f=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541],g=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];function m(y,$){for(var A=65536,M=0;M<$.length;M+=2){if(A+=$[M],A>y)return!1;if(A+=$[M+1],A>=y)return!0}}function b(y,$){return y<65?y===36:y<91?!0:y<97?y===95:y<123?!0:y<=65535?y>=170&&d.test(String.fromCharCode(y)):$===!1?!1:m(y,f)}function x(y,$){return y<48?y===36:y<58?!0:y<65?!1:y<91?!0:y<97?y===95:y<123?!0:y<=65535?y>=170&&p.test(String.fromCharCode(y)):$===!1?!1:m(y,f)||m(y,g)}var v=function($,A){A===void 0&&(A={}),this.label=$,this.keyword=A.keyword,this.beforeExpr=!!A.beforeExpr,this.startsExpr=!!A.startsExpr,this.isLoop=!!A.isLoop,this.isAssign=!!A.isAssign,this.prefix=!!A.prefix,this.postfix=!!A.postfix,this.binop=A.binop||null,this.updateContext=null};function w(y,$){return new v(y,{beforeExpr:!0,binop:$})}var S={beforeExpr:!0},k={startsExpr:!0},E={};function I(y,$){return $===void 0&&($={}),$.keyword=y,E[y]=new v(y,$)}var C={num:new v("num",k),regexp:new v("regexp",k),string:new v("string",k),name:new v("name",k),eof:new v("eof"),bracketL:new v("[",{beforeExpr:!0,startsExpr:!0}),bracketR:new v("]"),braceL:new v("{",{beforeExpr:!0,startsExpr:!0}),braceR:new v("}"),parenL:new v("(",{beforeExpr:!0,startsExpr:!0}),parenR:new v(")"),comma:new v(",",S),semi:new v(";",S),colon:new v(":",S),dot:new v("."),question:new v("?",S),arrow:new v("=>",S),template:new v("template"),invalidTemplate:new v("invalidTemplate"),ellipsis:new v("...",S),backQuote:new v("`",k),dollarBraceL:new v("${",{beforeExpr:!0,startsExpr:!0}),eq:new v("=",{beforeExpr:!0,isAssign:!0}),assign:new v("_=",{beforeExpr:!0,isAssign:!0}),incDec:new v("++/--",{prefix:!0,postfix:!0,startsExpr:!0}),prefix:new v("!/~",{beforeExpr:!0,prefix:!0,startsExpr:!0}),logicalOR:w("||",1),logicalAND:w("&&",2),bitwiseOR:w("|",3),bitwiseXOR:w("^",4),bitwiseAND:w("&",5),equality:w("==/!=/===/!==",6),relational:w("</>/<=/>=",7),bitShift:w("<</>>/>>>",8),plusMin:new v("+/-",{beforeExpr:!0,binop:9,prefix:!0,startsExpr:!0}),modulo:w("%",10),star:w("*",10),slash:w("/",10),starstar:new v("**",{beforeExpr:!0}),_break:I("break"),_case:I("case",S),_catch:I("catch"),_continue:I("continue"),_debugger:I("debugger"),_default:I("default",S),_do:I("do",{isLoop:!0,beforeExpr:!0}),_else:I("else",S),_finally:I("finally"),_for:I("for",{isLoop:!0}),_function:I("function",k),_if:I("if"),_return:I("return",S),_switch:I("switch"),_throw:I("throw",S),_try:I("try"),_var:I("var"),_const:I("const"),_while:I("while",{isLoop:!0}),_with:I("with"),_new:I("new",{beforeExpr:!0,startsExpr:!0}),_this:I("this",k),_super:I("super",k),_class:I("class",k),_extends:I("extends",S),_export:I("export"),_import:I("import",k),_null:I("null",k),_true:I("true",k),_false:I("false",k),_in:I("in",{beforeExpr:!0,binop:7}),_instanceof:I("instanceof",{beforeExpr:!0,binop:7}),_typeof:I("typeof",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_void:I("void",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_delete:I("delete",{beforeExpr:!0,prefix:!0,startsExpr:!0})},T=/\r\n?|\n|\u2028|\u2029/,R=new RegExp(T.source,"g");function P(y,$){return y===10||y===13||!$&&(y===8232||y===8233)}var D=/[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,F=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,z=Object.prototype,_=z.hasOwnProperty,B=z.toString;function N(y,$){return _.call(y,$)}var O=Array.isArray||function(y){return B.call(y)==="[object Array]"};function K(y){return new RegExp("^(?:"+y.replace(/ /g,"|")+")$")}var U=function($,A){this.line=$,this.column=A};U.prototype.offset=function($){return new U(this.line,this.column+$)};var X=function($,A,M){this.start=A,this.end=M,$.sourceFile!==null&&(this.source=$.sourceFile)};function te(y,$){for(var A=1,M=0;;){R.lastIndex=M;var H=R.exec(y);if(H&&H.index<$)++A,M=H.index+H[0].length;else return new U(A,$-M)}}var ie={ecmaVersion:10,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowAwaitOutsideFunction:!1,allowHashBang:!1,locations:!1,onToken:null,onComment:null,ranges:!1,program:null,sourceFile:null,directSourceFile:null,preserveParens:!1};function re(y){var $={};for(var A in ie)$[A]=y&&N(y,A)?y[A]:ie[A];if($.ecmaVersion>=2015&&($.ecmaVersion-=2009),$.allowReserved==null&&($.allowReserved=$.ecmaVersion<5),O($.onToken)){var M=$.onToken;$.onToken=function(H){return M.push(H)}}return O($.onComment)&&($.onComment=he($,$.onComment)),$}function he(y,$){return function(A,M,H,oe,de,Fe){var Xe={type:A?"Block":"Line",value:M,start:H,end:oe};y.locations&&(Xe.loc=new X(this,de,Fe)),y.ranges&&(Xe.range=[H,oe]),$.push(Xe)}}var Se=1,xe=2,Ce=Se|xe,De=4,Ue=8,V=16,G=32,ee=64,ue=128;function ae(y,$){return xe|(y?De:0)|($?Ue:0)}var ce=0,me=1,ye=2,ge=3,pe=4,Le=5,be=function($,A,M){this.options=$=re($),this.sourceFile=$.sourceFile,this.keywords=K(u[$.ecmaVersion>=6?6:$.sourceType==="module"?"5module":5]);var H="";if($.allowReserved!==!0){for(var oe=$.ecmaVersion;!(H=o[oe]);oe--);$.sourceType==="module"&&(H+=" await")}this.reservedWords=K(H);var de=(H?H+" ":"")+o.strict;this.reservedWordsStrict=K(de),this.reservedWordsStrictBind=K(de+" "+o.strictBind),this.input=String(A),this.containsEsc=!1,M?(this.pos=M,this.lineStart=this.input.lastIndexOf(`
`,M-1)+1,this.curLine=this.input.slice(0,this.lineStart).split(T).length):(this.pos=this.lineStart=0,this.curLine=1),this.type=C.eof,this.value=null,this.start=this.end=this.pos,this.startLoc=this.endLoc=this.curPosition(),this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,this.context=this.initialContext(),this.exprAllowed=!0,this.inModule=$.sourceType==="module",this.strict=this.inModule||this.strictDirective(this.pos),this.potentialArrowAt=-1,this.yieldPos=this.awaitPos=this.awaitIdentPos=0,this.labels=[],this.undefinedExports={},this.pos===0&&$.allowHashBang&&this.input.slice(0,2)==="#!"&&this.skipLineComment(2),this.scopeStack=[],this.enterScope(Se),this.regexpState=null},Ae={inFunction:{configurable:!0},inGenerator:{configurable:!0},inAsync:{configurable:!0},allowSuper:{configurable:!0},allowDirectSuper:{configurable:!0},treatFunctionsAsVar:{configurable:!0}};be.prototype.parse=function(){var $=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel($)},Ae.inFunction.get=function(){return(this.currentVarScope().flags&xe)>0},Ae.inGenerator.get=function(){return(this.currentVarScope().flags&Ue)>0},Ae.inAsync.get=function(){return(this.currentVarScope().flags&De)>0},Ae.allowSuper.get=function(){return(this.currentThisScope().flags&ee)>0},Ae.allowDirectSuper.get=function(){return(this.currentThisScope().flags&ue)>0},Ae.treatFunctionsAsVar.get=function(){return this.treatFunctionsAsVarInScope(this.currentScope())},be.prototype.inNonArrowFunction=function(){return(this.currentThisScope().flags&xe)>0},be.extend=function(){for(var $=[],A=arguments.length;A--;)$[A]=arguments[A];for(var M=this,H=0;H<$.length;H++)M=$[H](M);return M},be.parse=function($,A){return new this(A,$).parse()},be.parseExpressionAt=function($,A,M){var H=new this(M,$,A);return H.nextToken(),H.parseExpression()},be.tokenizer=function($,A){return new this(A,$)},Object.defineProperties(be.prototype,Ae);var Pe=be.prototype,et=/^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;Pe.strictDirective=function(y){for(;;){F.lastIndex=y,y+=F.exec(this.input)[0].length;var $=et.exec(this.input.slice(y));if(!$)return!1;if(($[1]||$[2])==="use strict")return!0;y+=$[0].length,F.lastIndex=y,y+=F.exec(this.input)[0].length,this.input[y]===";"&&y++}},Pe.eat=function(y){return this.type===y?(this.next(),!0):!1},Pe.isContextual=function(y){return this.type===C.name&&this.value===y&&!this.containsEsc},Pe.eatContextual=function(y){return this.isContextual(y)?(this.next(),!0):!1},Pe.expectContextual=function(y){this.eatContextual(y)||this.unexpected()},Pe.canInsertSemicolon=function(){return this.type===C.eof||this.type===C.braceR||T.test(this.input.slice(this.lastTokEnd,this.start))},Pe.insertSemicolon=function(){if(this.canInsertSemicolon())return this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),!0},Pe.semicolon=function(){!this.eat(C.semi)&&!this.insertSemicolon()&&this.unexpected()},Pe.afterTrailingComma=function(y,$){if(this.type===y)return this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),$||this.next(),!0},Pe.expect=function(y){this.eat(y)||this.unexpected()},Pe.unexpected=function(y){this.raise(y??this.start,"Unexpected token")};function ot(){this.shorthandAssign=this.trailingComma=this.parenthesizedAssign=this.parenthesizedBind=this.doubleProto=-1}Pe.checkPatternErrors=function(y,$){if(y){y.trailingComma>-1&&this.raiseRecoverable(y.trailingComma,"Comma is not permitted after the rest element");var A=$?y.parenthesizedAssign:y.parenthesizedBind;A>-1&&this.raiseRecoverable(A,"Parenthesized pattern")}},Pe.checkExpressionErrors=function(y,$){if(!y)return!1;var A=y.shorthandAssign,M=y.doubleProto;if(!$)return A>=0||M>=0;A>=0&&this.raise(A,"Shorthand property assignments are valid only in destructuring patterns"),M>=0&&this.raiseRecoverable(M,"Redefinition of __proto__ property")},Pe.checkYieldAwaitInDefaultParams=function(){this.yieldPos&&(!this.awaitPos||this.yieldPos<this.awaitPos)&&this.raise(this.yieldPos,"Yield expression cannot be a default value"),this.awaitPos&&this.raise(this.awaitPos,"Await expression cannot be a default value")},Pe.isSimpleAssignTarget=function(y){return y.type==="ParenthesizedExpression"?this.isSimpleAssignTarget(y.expression):y.type==="Identifier"||y.type==="MemberExpression"};var ke=be.prototype;ke.parseTopLevel=function(y){var $={};for(y.body||(y.body=[]);this.type!==C.eof;){var A=this.parseStatement(null,!0,$);y.body.push(A)}if(this.inModule)for(var M=0,H=Object.keys(this.undefinedExports);M<H.length;M+=1){var oe=H[M];this.raiseRecoverable(this.undefinedExports[oe].start,"Export '"+oe+"' is not defined")}return this.adaptDirectivePrologue(y.body),this.next(),y.sourceType=this.options.sourceType,this.finishNode(y,"Program")};var Vt={kind:"loop"},nn={kind:"switch"};ke.isLet=function(y){if(this.options.ecmaVersion<6||!this.isContextual("let"))return!1;F.lastIndex=this.pos;var $=F.exec(this.input),A=this.pos+$[0].length,M=this.input.charCodeAt(A);if(M===91)return!0;if(y)return!1;if(M===123)return!0;if(b(M,!0)){for(var H=A+1;x(this.input.charCodeAt(H),!0);)++H;var oe=this.input.slice(A,H);if(!l.test(oe))return!0}return!1},ke.isAsyncFunction=function(){if(this.options.ecmaVersion<8||!this.isContextual("async"))return!1;F.lastIndex=this.pos;var y=F.exec(this.input),$=this.pos+y[0].length;return!T.test(this.input.slice(this.pos,$))&&this.input.slice($,$+8)==="function"&&($+8===this.input.length||!x(this.input.charAt($+8)))},ke.parseStatement=function(y,$,A){var M=this.type,H=this.startNode(),oe;switch(this.isLet(y)&&(M=C._var,oe="let"),M){case C._break:case C._continue:return this.parseBreakContinueStatement(H,M.keyword);case C._debugger:return this.parseDebuggerStatement(H);case C._do:return this.parseDoStatement(H);case C._for:return this.parseForStatement(H);case C._function:return y&&(this.strict||y!=="if"&&y!=="label")&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(H,!1,!y);case C._class:return y&&this.unexpected(),this.parseClass(H,!0);case C._if:return this.parseIfStatement(H);case C._return:return this.parseReturnStatement(H);case C._switch:return this.parseSwitchStatement(H);case C._throw:return this.parseThrowStatement(H);case C._try:return this.parseTryStatement(H);case C._const:case C._var:return oe=oe||this.value,y&&oe!=="var"&&this.unexpected(),this.parseVarStatement(H,oe);case C._while:return this.parseWhileStatement(H);case C._with:return this.parseWithStatement(H);case C.braceL:return this.parseBlock(!0,H);case C.semi:return this.parseEmptyStatement(H);case C._export:case C._import:if(this.options.ecmaVersion>10&&M===C._import){F.lastIndex=this.pos;var de=F.exec(this.input),Fe=this.pos+de[0].length,Xe=this.input.charCodeAt(Fe);if(Xe===40)return this.parseExpressionStatement(H,this.parseExpression())}return this.options.allowImportExportEverywhere||($||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),M===C._import?this.parseImport(H):this.parseExport(H,A);default:if(this.isAsyncFunction())return y&&this.unexpected(),this.next(),this.parseFunctionStatement(H,!0,!y);var vt=this.value,ts=this.parseExpression();return M===C.name&&ts.type==="Identifier"&&this.eat(C.colon)?this.parseLabeledStatement(H,vt,ts,y):this.parseExpressionStatement(H,ts)}},ke.parseBreakContinueStatement=function(y,$){var A=$==="break";this.next(),this.eat(C.semi)||this.insertSemicolon()?y.label=null:this.type!==C.name?this.unexpected():(y.label=this.parseIdent(),this.semicolon());for(var M=0;M<this.labels.length;++M){var H=this.labels[M];if((y.label==null||H.name===y.label.name)&&(H.kind!=null&&(A||H.kind==="loop")||y.label&&A))break}return M===this.labels.length&&this.raise(y.start,"Unsyntactic "+$),this.finishNode(y,A?"BreakStatement":"ContinueStatement")},ke.parseDebuggerStatement=function(y){return this.next(),this.semicolon(),this.finishNode(y,"DebuggerStatement")},ke.parseDoStatement=function(y){return this.next(),this.labels.push(Vt),y.body=this.parseStatement("do"),this.labels.pop(),this.expect(C._while),y.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(C.semi):this.semicolon(),this.finishNode(y,"DoWhileStatement")},ke.parseForStatement=function(y){this.next();var $=this.options.ecmaVersion>=9&&(this.inAsync||!this.inFunction&&this.options.allowAwaitOutsideFunction)&&this.eatContextual("await")?this.lastTokStart:-1;if(this.labels.push(Vt),this.enterScope(0),this.expect(C.parenL),this.type===C.semi)return $>-1&&this.unexpected($),this.parseFor(y,null);var A=this.isLet();if(this.type===C._var||this.type===C._const||A){var M=this.startNode(),H=A?"let":this.value;return this.next(),this.parseVar(M,!0,H),this.finishNode(M,"VariableDeclaration"),(this.type===C._in||this.options.ecmaVersion>=6&&this.isContextual("of"))&&M.declarations.length===1?(this.options.ecmaVersion>=9&&(this.type===C._in?$>-1&&this.unexpected($):y.await=$>-1),this.parseForIn(y,M)):($>-1&&this.unexpected($),this.parseFor(y,M))}var oe=new ot,de=this.parseExpression(!0,oe);return this.type===C._in||this.options.ecmaVersion>=6&&this.isContextual("of")?(this.options.ecmaVersion>=9&&(this.type===C._in?$>-1&&this.unexpected($):y.await=$>-1),this.toAssignable(de,!1,oe),this.checkLVal(de),this.parseForIn(y,de)):(this.checkExpressionErrors(oe,!0),$>-1&&this.unexpected($),this.parseFor(y,de))},ke.parseFunctionStatement=function(y,$,A){return this.next(),this.parseFunction(y,bn|(A?0:es),!1,$)},ke.parseIfStatement=function(y){return this.next(),y.test=this.parseParenExpression(),y.consequent=this.parseStatement("if"),y.alternate=this.eat(C._else)?this.parseStatement("if"):null,this.finishNode(y,"IfStatement")},ke.parseReturnStatement=function(y){return!this.inFunction&&!this.options.allowReturnOutsideFunction&&this.raise(this.start,"'return' outside of function"),this.next(),this.eat(C.semi)||this.insertSemicolon()?y.argument=null:(y.argument=this.parseExpression(),this.semicolon()),this.finishNode(y,"ReturnStatement")},ke.parseSwitchStatement=function(y){this.next(),y.discriminant=this.parseParenExpression(),y.cases=[],this.expect(C.braceL),this.labels.push(nn),this.enterScope(0);for(var $,A=!1;this.type!==C.braceR;)if(this.type===C._case||this.type===C._default){var M=this.type===C._case;$&&this.finishNode($,"SwitchCase"),y.cases.push($=this.startNode()),$.consequent=[],this.next(),M?$.test=this.parseExpression():(A&&this.raiseRecoverable(this.lastTokStart,"Multiple default clauses"),A=!0,$.test=null),this.expect(C.colon)}else $||this.unexpected(),$.consequent.push(this.parseStatement(null));return this.exitScope(),$&&this.finishNode($,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(y,"SwitchStatement")},ke.parseThrowStatement=function(y){return this.next(),T.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),y.argument=this.parseExpression(),this.semicolon(),this.finishNode(y,"ThrowStatement")};var Rn=[];ke.parseTryStatement=function(y){if(this.next(),y.block=this.parseBlock(),y.handler=null,this.type===C._catch){var $=this.startNode();if(this.next(),this.eat(C.parenL)){$.param=this.parseBindingAtom();var A=$.param.type==="Identifier";this.enterScope(A?G:0),this.checkLVal($.param,A?pe:ye),this.expect(C.parenR)}else this.options.ecmaVersion<10&&this.unexpected(),$.param=null,this.enterScope(0);$.body=this.parseBlock(!1),this.exitScope(),y.handler=this.finishNode($,"CatchClause")}return y.finalizer=this.eat(C._finally)?this.parseBlock():null,!y.handler&&!y.finalizer&&this.raise(y.start,"Missing catch or finally clause"),this.finishNode(y,"TryStatement")},ke.parseVarStatement=function(y,$){return this.next(),this.parseVar(y,!1,$),this.semicolon(),this.finishNode(y,"VariableDeclaration")},ke.parseWhileStatement=function(y){return this.next(),y.test=this.parseParenExpression(),this.labels.push(Vt),y.body=this.parseStatement("while"),this.labels.pop(),this.finishNode(y,"WhileStatement")},ke.parseWithStatement=function(y){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),y.object=this.parseParenExpression(),y.body=this.parseStatement("with"),this.finishNode(y,"WithStatement")},ke.parseEmptyStatement=function(y){return this.next(),this.finishNode(y,"EmptyStatement")},ke.parseLabeledStatement=function(y,$,A,M){for(var H=0,oe=this.labels;H<oe.length;H+=1){var de=oe[H];de.name===$&&this.raise(A.start,"Label '"+$+"' is already declared")}for(var Fe=this.type.isLoop?"loop":this.type===C._switch?"switch":null,Xe=this.labels.length-1;Xe>=0;Xe--){var vt=this.labels[Xe];if(vt.statementStart===y.start)vt.statementStart=this.start,vt.kind=Fe;else break}return this.labels.push({name:$,kind:Fe,statementStart:this.start}),y.body=this.parseStatement(M?M.indexOf("label")===-1?M+"label":M:"label"),this.labels.pop(),y.label=A,this.finishNode(y,"LabeledStatement")},ke.parseExpressionStatement=function(y,$){return y.expression=$,this.semicolon(),this.finishNode(y,"ExpressionStatement")},ke.parseBlock=function(y,$){for(y===void 0&&(y=!0),$===void 0&&($=this.startNode()),$.body=[],this.expect(C.braceL),y&&this.enterScope(0);!this.eat(C.braceR);){var A=this.parseStatement(null);$.body.push(A)}return y&&this.exitScope(),this.finishNode($,"BlockStatement")},ke.parseFor=function(y,$){return y.init=$,this.expect(C.semi),y.test=this.type===C.semi?null:this.parseExpression(),this.expect(C.semi),y.update=this.type===C.parenR?null:this.parseExpression(),this.expect(C.parenR),y.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(y,"ForStatement")},ke.parseForIn=function(y,$){var A=this.type===C._in;return this.next(),$.type==="VariableDeclaration"&&$.declarations[0].init!=null&&(!A||this.options.ecmaVersion<8||this.strict||$.kind!=="var"||$.declarations[0].id.type!=="Identifier")?this.raise($.start,(A?"for-in":"for-of")+" loop variable declaration may not have an initializer"):$.type==="AssignmentPattern"&&this.raise($.start,"Invalid left-hand side in for-loop"),y.left=$,y.right=A?this.parseExpression():this.parseMaybeAssign(),this.expect(C.parenR),y.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(y,A?"ForInStatement":"ForOfStatement")},ke.parseVar=function(y,$,A){for(y.declarations=[],y.kind=A;;){var M=this.startNode();if(this.parseVarId(M,A),this.eat(C.eq)?M.init=this.parseMaybeAssign($):A==="const"&&!(this.type===C._in||this.options.ecmaVersion>=6&&this.isContextual("of"))?this.unexpected():M.id.type!=="Identifier"&&!($&&(this.type===C._in||this.isContextual("of")))?this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value"):M.init=null,y.declarations.push(this.finishNode(M,"VariableDeclarator")),!this.eat(C.comma))break}return y},ke.parseVarId=function(y,$){y.id=this.parseBindingAtom(),this.checkLVal(y.id,$==="var"?me:ye,!1)};var bn=1,es=2,Fi=4;ke.parseFunction=function(y,$,A,M){this.initFunction(y),(this.options.ecmaVersion>=9||this.options.ecmaVersion>=6&&!M)&&(this.type===C.star&&$&es&&this.unexpected(),y.generator=this.eat(C.star)),this.options.ecmaVersion>=8&&(y.async=!!M),$&bn&&(y.id=$&Fi&&this.type!==C.name?null:this.parseIdent(),y.id&&!($&es)&&this.checkLVal(y.id,this.strict||y.generator||y.async?this.treatFunctionsAsVar?me:ye:ge));var H=this.yieldPos,oe=this.awaitPos,de=this.awaitIdentPos;return this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(ae(y.async,y.generator)),$&bn||(y.id=this.type===C.name?this.parseIdent():null),this.parseFunctionParams(y),this.parseFunctionBody(y,A,!1),this.yieldPos=H,this.awaitPos=oe,this.awaitIdentPos=de,this.finishNode(y,$&bn?"FunctionDeclaration":"FunctionExpression")},ke.parseFunctionParams=function(y){this.expect(C.parenL),y.params=this.parseBindingList(C.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams()},ke.parseClass=function(y,$){this.next();var A=this.strict;this.strict=!0,this.parseClassId(y,$),this.parseClassSuper(y);var M=this.startNode(),H=!1;for(M.body=[],this.expect(C.braceL);!this.eat(C.braceR);){var oe=this.parseClassElement(y.superClass!==null);oe&&(M.body.push(oe),oe.type==="MethodDefinition"&&oe.kind==="constructor"&&(H&&this.raise(oe.start,"Duplicate constructor in the same class"),H=!0))}return y.body=this.finishNode(M,"ClassBody"),this.strict=A,this.finishNode(y,$?"ClassDeclaration":"ClassExpression")},ke.parseClassElement=function(y){var $=this;if(this.eat(C.semi))return null;var A=this.startNode(),M=function(Xe,vt){vt===void 0&&(vt=!1);var ts=$.start,Fr=$.startLoc;return $.eatContextual(Xe)?$.type!==C.parenL&&(!vt||!$.canInsertSemicolon())?!0:(A.key&&$.unexpected(),A.computed=!1,A.key=$.startNodeAt(ts,Fr),A.key.name=Xe,$.finishNode(A.key,"Identifier"),!1):!1};A.kind="method",A.static=M("static");var H=this.eat(C.star),oe=!1;H||(this.options.ecmaVersion>=8&&M("async",!0)?(oe=!0,H=this.options.ecmaVersion>=9&&this.eat(C.star)):M("get")?A.kind="get":M("set")&&(A.kind="set")),A.key||this.parsePropertyName(A);var de=A.key,Fe=!1;return!A.computed&&!A.static&&(de.type==="Identifier"&&de.name==="constructor"||de.type==="Literal"&&de.value==="constructor")?(A.kind!=="method"&&this.raise(de.start,"Constructor can't have get/set modifier"),H&&this.raise(de.start,"Constructor can't be a generator"),oe&&this.raise(de.start,"Constructor can't be an async method"),A.kind="constructor",Fe=y):A.static&&de.type==="Identifier"&&de.name==="prototype"&&this.raise(de.start,"Classes may not have a static property named prototype"),this.parseClassMethod(A,H,oe,Fe),A.kind==="get"&&A.value.params.length!==0&&this.raiseRecoverable(A.value.start,"getter should have no params"),A.kind==="set"&&A.value.params.length!==1&&this.raiseRecoverable(A.value.start,"setter should have exactly one param"),A.kind==="set"&&A.value.params[0].type==="RestElement"&&this.raiseRecoverable(A.value.params[0].start,"Setter cannot use rest params"),A},ke.parseClassMethod=function(y,$,A,M){return y.value=this.parseMethod($,A,M),this.finishNode(y,"MethodDefinition")},ke.parseClassId=function(y,$){this.type===C.name?(y.id=this.parseIdent(),$&&this.checkLVal(y.id,ye,!1)):($===!0&&this.unexpected(),y.id=null)},ke.parseClassSuper=function(y){y.superClass=this.eat(C._extends)?this.parseExprSubscripts():null},ke.parseExport=function(y,$){if(this.next(),this.eat(C.star))return this.expectContextual("from"),this.type!==C.string&&this.unexpected(),y.source=this.parseExprAtom(),this.semicolon(),this.finishNode(y,"ExportAllDeclaration");if(this.eat(C._default)){this.checkExport($,"default",this.lastTokStart);var A;if(this.type===C._function||(A=this.isAsyncFunction())){var M=this.startNode();this.next(),A&&this.next(),y.declaration=this.parseFunction(M,bn|Fi,!1,A)}else if(this.type===C._class){var H=this.startNode();y.declaration=this.parseClass(H,"nullableID")}else y.declaration=this.parseMaybeAssign(),this.semicolon();return this.finishNode(y,"ExportDefaultDeclaration")}if(this.shouldParseExportStatement())y.declaration=this.parseStatement(null),y.declaration.type==="VariableDeclaration"?this.checkVariableExport($,y.declaration.declarations):this.checkExport($,y.declaration.id.name,y.declaration.id.start),y.specifiers=[],y.source=null;else{if(y.declaration=null,y.specifiers=this.parseExportSpecifiers($),this.eatContextual("from"))this.type!==C.string&&this.unexpected(),y.source=this.parseExprAtom();else{for(var oe=0,de=y.specifiers;oe<de.length;oe+=1){var Fe=de[oe];this.checkUnreserved(Fe.local),this.checkLocalExport(Fe.local)}y.source=null}this.semicolon()}return this.finishNode(y,"ExportNamedDeclaration")},ke.checkExport=function(y,$,A){y&&(N(y,$)&&this.raiseRecoverable(A,"Duplicate export '"+$+"'"),y[$]=!0)},ke.checkPatternExport=function(y,$){var A=$.type;if(A==="Identifier")this.checkExport(y,$.name,$.start);else if(A==="ObjectPattern")for(var M=0,H=$.properties;M<H.length;M+=1){var oe=H[M];this.checkPatternExport(y,oe)}else if(A==="ArrayPattern")for(var de=0,Fe=$.elements;de<Fe.length;de+=1){var Xe=Fe[de];Xe&&this.checkPatternExport(y,Xe)}else A==="Property"?this.checkPatternExport(y,$.value):A==="AssignmentPattern"?this.checkPatternExport(y,$.left):A==="RestElement"?this.checkPatternExport(y,$.argument):A==="ParenthesizedExpression"&&this.checkPatternExport(y,$.expression)},ke.checkVariableExport=function(y,$){if(y)for(var A=0,M=$;A<M.length;A+=1){var H=M[A];this.checkPatternExport(y,H.id)}},ke.shouldParseExportStatement=function(){return this.type.keyword==="var"||this.type.keyword==="const"||this.type.keyword==="class"||this.type.keyword==="function"||this.isLet()||this.isAsyncFunction()},ke.parseExportSpecifiers=function(y){var $=[],A=!0;for(this.expect(C.braceL);!this.eat(C.braceR);){if(A)A=!1;else if(this.expect(C.comma),this.afterTrailingComma(C.braceR))break;var M=this.startNode();M.local=this.parseIdent(!0),M.exported=this.eatContextual("as")?this.parseIdent(!0):M.local,this.checkExport(y,M.exported.name,M.exported.start),$.push(this.finishNode(M,"ExportSpecifier"))}return $},ke.parseImport=function(y){return this.next(),this.type===C.string?(y.specifiers=Rn,y.source=this.parseExprAtom()):(y.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),y.source=this.type===C.string?this.parseExprAtom():this.unexpected()),this.semicolon(),this.finishNode(y,"ImportDeclaration")},ke.parseImportSpecifiers=function(){var y=[],$=!0;if(this.type===C.name){var A=this.startNode();if(A.local=this.parseIdent(),this.checkLVal(A.local,ye),y.push(this.finishNode(A,"ImportDefaultSpecifier")),!this.eat(C.comma))return y}if(this.type===C.star){var M=this.startNode();return this.next(),this.expectContextual("as"),M.local=this.parseIdent(),this.checkLVal(M.local,ye),y.push(this.finishNode(M,"ImportNamespaceSpecifier")),y}for(this.expect(C.braceL);!this.eat(C.braceR);){if($)$=!1;else if(this.expect(C.comma),this.afterTrailingComma(C.braceR))break;var H=this.startNode();H.imported=this.parseIdent(!0),this.eatContextual("as")?H.local=this.parseIdent():(this.checkUnreserved(H.imported),H.local=H.imported),this.checkLVal(H.local,ye),y.push(this.finishNode(H,"ImportSpecifier"))}return y},ke.adaptDirectivePrologue=function(y){for(var $=0;$<y.length&&this.isDirectiveCandidate(y[$]);++$)y[$].directive=y[$].expression.raw.slice(1,-1)},ke.isDirectiveCandidate=function(y){return y.type==="ExpressionStatement"&&y.expression.type==="Literal"&&typeof y.expression.value=="string"&&(this.input[y.start]==='"'||this.input[y.start]==="'")};var Mt=be.prototype;Mt.toAssignable=function(y,$,A){if(this.options.ecmaVersion>=6&&y)switch(y.type){case"Identifier":this.inAsync&&y.name==="await"&&this.raise(y.start,"Cannot use 'await' as identifier inside an async function");break;case"ObjectPattern":case"ArrayPattern":case"RestElement":break;case"ObjectExpression":y.type="ObjectPattern",A&&this.checkPatternErrors(A,!0);for(var M=0,H=y.properties;M<H.length;M+=1){var oe=H[M];this.toAssignable(oe,$),oe.type==="RestElement"&&(oe.argument.type==="ArrayPattern"||oe.argument.type==="ObjectPattern")&&this.raise(oe.argument.start,"Unexpected token")}break;case"Property":y.kind!=="init"&&this.raise(y.key.start,"Object pattern can't contain getter or setter"),this.toAssignable(y.value,$);break;case"ArrayExpression":y.type="ArrayPattern",A&&this.checkPatternErrors(A,!0),this.toAssignableList(y.elements,$);break;case"SpreadElement":y.type="RestElement",this.toAssignable(y.argument,$),y.argument.type==="AssignmentPattern"&&this.raise(y.argument.start,"Rest elements cannot have a default value");break;case"AssignmentExpression":y.operator!=="="&&this.raise(y.left.end,"Only '=' operator can be used for specifying default value."),y.type="AssignmentPattern",delete y.operator,this.toAssignable(y.left,$);case"AssignmentPattern":break;case"ParenthesizedExpression":this.toAssignable(y.expression,$,A);break;case"MemberExpression":if(!$)break;default:this.raise(y.start,"Assigning to rvalue")}else A&&this.checkPatternErrors(A,!0);return y},Mt.toAssignableList=function(y,$){for(var A=y.length,M=0;M<A;M++){var H=y[M];H&&this.toAssignable(H,$)}if(A){var oe=y[A-1];this.options.ecmaVersion===6&&$&&oe&&oe.type==="RestElement"&&oe.argument.type!=="Identifier"&&this.unexpected(oe.argument.start)}return y},Mt.parseSpread=function(y){var $=this.startNode();return this.next(),$.argument=this.parseMaybeAssign(!1,y),this.finishNode($,"SpreadElement")},Mt.parseRestBinding=function(){var y=this.startNode();return this.next(),this.options.ecmaVersion===6&&this.type!==C.name&&this.unexpected(),y.argument=this.parseBindingAtom(),this.finishNode(y,"RestElement")},Mt.parseBindingAtom=function(){if(this.options.ecmaVersion>=6)switch(this.type){case C.bracketL:var y=this.startNode();return this.next(),y.elements=this.parseBindingList(C.bracketR,!0,!0),this.finishNode(y,"ArrayPattern");case C.braceL:return this.parseObj(!0)}return this.parseIdent()},Mt.parseBindingList=function(y,$,A){for(var M=[],H=!0;!this.eat(y);)if(H?H=!1:this.expect(C.comma),$&&this.type===C.comma)M.push(null);else{if(A&&this.afterTrailingComma(y))break;if(this.type===C.ellipsis){var oe=this.parseRestBinding();this.parseBindingListItem(oe),M.push(oe),this.type===C.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.expect(y);break}else{var de=this.parseMaybeDefault(this.start,this.startLoc);this.parseBindingListItem(de),M.push(de)}}return M},Mt.parseBindingListItem=function(y){return y},Mt.parseMaybeDefault=function(y,$,A){if(A=A||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(C.eq))return A;var M=this.startNodeAt(y,$);return M.left=A,M.right=this.parseMaybeAssign(),this.finishNode(M,"AssignmentPattern")},Mt.checkLVal=function(y,$,A){switch($===void 0&&($=ce),y.type){case"Identifier":$===ye&&y.name==="let"&&this.raiseRecoverable(y.start,"let is disallowed as a lexically bound name"),this.strict&&this.reservedWordsStrictBind.test(y.name)&&this.raiseRecoverable(y.start,($?"Binding ":"Assigning to ")+y.name+" in strict mode"),A&&(N(A,y.name)&&this.raiseRecoverable(y.start,"Argument name clash"),A[y.name]=!0),$!==ce&&$!==Le&&this.declareName(y.name,$,y.start);break;case"MemberExpression":$&&this.raiseRecoverable(y.start,"Binding member expression");break;case"ObjectPattern":for(var M=0,H=y.properties;M<H.length;M+=1){var oe=H[M];this.checkLVal(oe,$,A)}break;case"Property":this.checkLVal(y.value,$,A);break;case"ArrayPattern":for(var de=0,Fe=y.elements;de<Fe.length;de+=1){var Xe=Fe[de];Xe&&this.checkLVal(Xe,$,A)}break;case"AssignmentPattern":this.checkLVal(y.left,$,A);break;case"RestElement":this.checkLVal(y.argument,$,A);break;case"ParenthesizedExpression":this.checkLVal(y.expression,$,A);break;default:this.raise(y.start,($?"Binding":"Assigning to")+" rvalue")}};var Ze=be.prototype;Ze.checkPropClash=function(y,$,A){if(!(this.options.ecmaVersion>=9&&y.type==="SpreadElement")&&!(this.options.ecmaVersion>=6&&(y.computed||y.method||y.shorthand))){var M=y.key,H;switch(M.type){case"Identifier":H=M.name;break;case"Literal":H=String(M.value);break;default:return}var oe=y.kind;if(this.options.ecmaVersion>=6){H==="__proto__"&&oe==="init"&&($.proto&&(A?A.doubleProto<0&&(A.doubleProto=M.start):this.raiseRecoverable(M.start,"Redefinition of __proto__ property")),$.proto=!0);return}H="$"+H;var de=$[H];if(de){var Fe;oe==="init"?Fe=this.strict&&de.init||de.get||de.set:Fe=de.init||de[oe],Fe&&this.raiseRecoverable(M.start,"Redefinition of property")}else de=$[H]={init:!1,get:!1,set:!1};de[oe]=!0}},Ze.parseExpression=function(y,$){var A=this.start,M=this.startLoc,H=this.parseMaybeAssign(y,$);if(this.type===C.comma){var oe=this.startNodeAt(A,M);for(oe.expressions=[H];this.eat(C.comma);)oe.expressions.push(this.parseMaybeAssign(y,$));return this.finishNode(oe,"SequenceExpression")}return H},Ze.parseMaybeAssign=function(y,$,A){if(this.isContextual("yield")){if(this.inGenerator)return this.parseYield(y);this.exprAllowed=!1}var M=!1,H=-1,oe=-1;$?(H=$.parenthesizedAssign,oe=$.trailingComma,$.parenthesizedAssign=$.trailingComma=-1):($=new ot,M=!0);var de=this.start,Fe=this.startLoc;(this.type===C.parenL||this.type===C.name)&&(this.potentialArrowAt=this.start);var Xe=this.parseMaybeConditional(y,$);if(A&&(Xe=A.call(this,Xe,de,Fe)),this.type.isAssign){var vt=this.startNodeAt(de,Fe);return vt.operator=this.value,vt.left=this.type===C.eq?this.toAssignable(Xe,!1,$):Xe,M||($.parenthesizedAssign=$.trailingComma=$.doubleProto=-1),$.shorthandAssign>=vt.left.start&&($.shorthandAssign=-1),this.checkLVal(Xe),this.next(),vt.right=this.parseMaybeAssign(y),this.finishNode(vt,"AssignmentExpression")}else M&&this.checkExpressionErrors($,!0);return H>-1&&($.parenthesizedAssign=H),oe>-1&&($.trailingComma=oe),Xe},Ze.parseMaybeConditional=function(y,$){var A=this.start,M=this.startLoc,H=this.parseExprOps(y,$);if(this.checkExpressionErrors($))return H;if(this.eat(C.question)){var oe=this.startNodeAt(A,M);return oe.test=H,oe.consequent=this.parseMaybeAssign(),this.expect(C.colon),oe.alternate=this.parseMaybeAssign(y),this.finishNode(oe,"ConditionalExpression")}return H},Ze.parseExprOps=function(y,$){var A=this.start,M=this.startLoc,H=this.parseMaybeUnary($,!1);return this.checkExpressionErrors($)||H.start===A&&H.type==="ArrowFunctionExpression"?H:this.parseExprOp(H,A,M,-1,y)},Ze.parseExprOp=function(y,$,A,M,H){var oe=this.type.binop;if(oe!=null&&(!H||this.type!==C._in)&&oe>M){var de=this.type===C.logicalOR||this.type===C.logicalAND,Fe=this.value;this.next();var Xe=this.start,vt=this.startLoc,ts=this.parseExprOp(this.parseMaybeUnary(null,!1),Xe,vt,oe,H),Fr=this.buildBinary($,A,y,ts,Fe,de);return this.parseExprOp(Fr,$,A,M,H)}return y},Ze.buildBinary=function(y,$,A,M,H,oe){var de=this.startNodeAt(y,$);return de.left=A,de.operator=H,de.right=M,this.finishNode(de,oe?"LogicalExpression":"BinaryExpression")},Ze.parseMaybeUnary=function(y,$){var A=this.start,M=this.startLoc,H;if(this.isContextual("await")&&(this.inAsync||!this.inFunction&&this.options.allowAwaitOutsideFunction))H=this.parseAwait(),$=!0;else if(this.type.prefix){var oe=this.startNode(),de=this.type===C.incDec;oe.operator=this.value,oe.prefix=!0,this.next(),oe.argument=this.parseMaybeUnary(null,!0),this.checkExpressionErrors(y,!0),de?this.checkLVal(oe.argument):this.strict&&oe.operator==="delete"&&oe.argument.type==="Identifier"?this.raiseRecoverable(oe.start,"Deleting local variable in strict mode"):$=!0,H=this.finishNode(oe,de?"UpdateExpression":"UnaryExpression")}else{if(H=this.parseExprSubscripts(y),this.checkExpressionErrors(y))return H;for(;this.type.postfix&&!this.canInsertSemicolon();){var Fe=this.startNodeAt(A,M);Fe.operator=this.value,Fe.prefix=!1,Fe.argument=H,this.checkLVal(H),this.next(),H=this.finishNode(Fe,"UpdateExpression")}}return!$&&this.eat(C.starstar)?this.buildBinary(A,M,H,this.parseMaybeUnary(null,!1),"**",!1):H},Ze.parseExprSubscripts=function(y){var $=this.start,A=this.startLoc,M=this.parseExprAtom(y);if(M.type==="ArrowFunctionExpression"&&this.input.slice(this.lastTokStart,this.lastTokEnd)!==")")return M;var H=this.parseSubscripts(M,$,A);return y&&H.type==="MemberExpression"&&(y.parenthesizedAssign>=H.start&&(y.parenthesizedAssign=-1),y.parenthesizedBind>=H.start&&(y.parenthesizedBind=-1)),H},Ze.parseSubscripts=function(y,$,A,M){for(var H=this.options.ecmaVersion>=8&&y.type==="Identifier"&&y.name==="async"&&this.lastTokEnd===y.end&&!this.canInsertSemicolon()&&this.input.slice(y.start,y.end)==="async";;){var oe=this.parseSubscript(y,$,A,M,H);if(oe===y||oe.type==="ArrowFunctionExpression")return oe;y=oe}},Ze.parseSubscript=function(y,$,A,M,H){var oe=this.eat(C.bracketL);if(oe||this.eat(C.dot)){var de=this.startNodeAt($,A);de.object=y,de.property=oe?this.parseExpression():this.parseIdent(this.options.allowReserved!=="never"),de.computed=!!oe,oe&&this.expect(C.bracketR),y=this.finishNode(de,"MemberExpression")}else if(!M&&this.eat(C.parenL)){var Fe=new ot,Xe=this.yieldPos,vt=this.awaitPos,ts=this.awaitIdentPos;this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0;var Fr=this.parseExprList(C.parenR,this.options.ecmaVersion>=8,!1,Fe);if(H&&!this.canInsertSemicolon()&&this.eat(C.arrow))return this.checkPatternErrors(Fe,!1),this.checkYieldAwaitInDefaultParams(),this.awaitIdentPos>0&&this.raise(this.awaitIdentPos,"Cannot use 'await' as identifier inside an async function"),this.yieldPos=Xe,this.awaitPos=vt,this.awaitIdentPos=ts,this.parseArrowExpression(this.startNodeAt($,A),Fr,!0);this.checkExpressionErrors(Fe,!0),this.yieldPos=Xe||this.yieldPos,this.awaitPos=vt||this.awaitPos,this.awaitIdentPos=ts||this.awaitIdentPos;var Go=this.startNodeAt($,A);Go.callee=y,Go.arguments=Fr,y=this.finishNode(Go,"CallExpression")}else if(this.type===C.backQuote){var Li=this.startNodeAt($,A);Li.tag=y,Li.quasi=this.parseTemplate({isTagged:!0}),y=this.finishNode(Li,"TaggedTemplateExpression")}return y},Ze.parseExprAtom=function(y){this.type===C.slash&&this.readRegexp();var $,A=this.potentialArrowAt===this.start;switch(this.type){case C._super:return this.allowSuper||this.raise(this.start,"'super' keyword outside a method"),$=this.startNode(),this.next(),this.type===C.parenL&&!this.allowDirectSuper&&this.raise($.start,"super() call outside constructor of a subclass"),this.type!==C.dot&&this.type!==C.bracketL&&this.type!==C.parenL&&this.unexpected(),this.finishNode($,"Super");case C._this:return $=this.startNode(),this.next(),this.finishNode($,"ThisExpression");case C.name:var M=this.start,H=this.startLoc,oe=this.containsEsc,de=this.parseIdent(!1);if(this.options.ecmaVersion>=8&&!oe&&de.name==="async"&&!this.canInsertSemicolon()&&this.eat(C._function))return this.parseFunction(this.startNodeAt(M,H),0,!1,!0);if(A&&!this.canInsertSemicolon()){if(this.eat(C.arrow))return this.parseArrowExpression(this.startNodeAt(M,H),[de],!1);if(this.options.ecmaVersion>=8&&de.name==="async"&&this.type===C.name&&!oe)return de=this.parseIdent(!1),(this.canInsertSemicolon()||!this.eat(C.arrow))&&this.unexpected(),this.parseArrowExpression(this.startNodeAt(M,H),[de],!0)}return de;case C.regexp:var Fe=this.value;return $=this.parseLiteral(Fe.value),$.regex={pattern:Fe.pattern,flags:Fe.flags},$;case C.num:case C.string:return this.parseLiteral(this.value);case C._null:case C._true:case C._false:return $=this.startNode(),$.value=this.type===C._null?null:this.type===C._true,$.raw=this.type.keyword,this.next(),this.finishNode($,"Literal");case C.parenL:var Xe=this.start,vt=this.parseParenAndDistinguishExpression(A);return y&&(y.parenthesizedAssign<0&&!this.isSimpleAssignTarget(vt)&&(y.parenthesizedAssign=Xe),y.parenthesizedBind<0&&(y.parenthesizedBind=Xe)),vt;case C.bracketL:return $=this.startNode(),this.next(),$.elements=this.parseExprList(C.bracketR,!0,!0,y),this.finishNode($,"ArrayExpression");case C.braceL:return this.parseObj(!1,y);case C._function:return $=this.startNode(),this.next(),this.parseFunction($,0);case C._class:return this.parseClass(this.startNode(),!1);case C._new:return this.parseNew();case C.backQuote:return this.parseTemplate();case C._import:return this.options.ecmaVersion>=11?this.parseExprImport():this.unexpected();default:this.unexpected()}},Ze.parseExprImport=function(){var y=this.startNode();switch(this.next(),this.type){case C.parenL:return this.parseDynamicImport(y);default:this.unexpected()}},Ze.parseDynamicImport=function(y){if(this.next(),y.source=this.parseMaybeAssign(),!this.eat(C.parenR)){var $=this.start;this.eat(C.comma)&&this.eat(C.parenR)?this.raiseRecoverable($,"Trailing comma is not allowed in import()"):this.unexpected($)}return this.finishNode(y,"ImportExpression")},Ze.parseLiteral=function(y){var $=this.startNode();return $.value=y,$.raw=this.input.slice(this.start,this.end),$.raw.charCodeAt($.raw.length-1)===110&&($.bigint=$.raw.slice(0,-1)),this.next(),this.finishNode($,"Literal")},Ze.parseParenExpression=function(){this.expect(C.parenL);var y=this.parseExpression();return this.expect(C.parenR),y},Ze.parseParenAndDistinguishExpression=function(y){var $=this.start,A=this.startLoc,M,H=this.options.ecmaVersion>=8;if(this.options.ecmaVersion>=6){this.next();var oe=this.start,de=this.startLoc,Fe=[],Xe=!0,vt=!1,ts=new ot,Fr=this.yieldPos,Go=this.awaitPos,Li;for(this.yieldPos=0,this.awaitPos=0;this.type!==C.parenR;)if(Xe?Xe=!1:this.expect(C.comma),H&&this.afterTrailingComma(C.parenR,!0)){vt=!0;break}else if(this.type===C.ellipsis){Li=this.start,Fe.push(this.parseParenItem(this.parseRestBinding())),this.type===C.comma&&this.raise(this.start,"Comma is not permitted after the rest element");break}else Fe.push(this.parseMaybeAssign(!1,ts,this.parseParenItem));var Xk=this.start,qk=this.startLoc;if(this.expect(C.parenR),y&&!this.canInsertSemicolon()&&this.eat(C.arrow))return this.checkPatternErrors(ts,!1),this.checkYieldAwaitInDefaultParams(),this.yieldPos=Fr,this.awaitPos=Go,this.parseParenArrowList($,A,Fe);(!Fe.length||vt)&&this.unexpected(this.lastTokStart),Li&&this.unexpected(Li),this.checkExpressionErrors(ts,!0),this.yieldPos=Fr||this.yieldPos,this.awaitPos=Go||this.awaitPos,Fe.length>1?(M=this.startNodeAt(oe,de),M.expressions=Fe,this.finishNodeAt(M,"SequenceExpression",Xk,qk)):M=Fe[0]}else M=this.parseParenExpression();if(this.options.preserveParens){var zb=this.startNodeAt($,A);return zb.expression=M,this.finishNode(zb,"ParenthesizedExpression")}else return M},Ze.parseParenItem=function(y){return y},Ze.parseParenArrowList=function(y,$,A){return this.parseArrowExpression(this.startNodeAt(y,$),A)};var rh=[];Ze.parseNew=function(){this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword new");var y=this.startNode(),$=this.parseIdent(!0);if(this.options.ecmaVersion>=6&&this.eat(C.dot)){y.meta=$;var A=this.containsEsc;return y.property=this.parseIdent(!0),(y.property.name!=="target"||A)&&this.raiseRecoverable(y.property.start,"The only valid meta property for new is new.target"),this.inNonArrowFunction()||this.raiseRecoverable(y.start,"new.target can only be used in functions"),this.finishNode(y,"MetaProperty")}var M=this.start,H=this.startLoc,oe=this.type===C._import;return y.callee=this.parseSubscripts(this.parseExprAtom(),M,H,!0),oe&&y.callee.type==="ImportExpression"&&this.raise(M,"Cannot use new with import()"),this.eat(C.parenL)?y.arguments=this.parseExprList(C.parenR,this.options.ecmaVersion>=8,!1):y.arguments=rh,this.finishNode(y,"NewExpression")},Ze.parseTemplateElement=function(y){var $=y.isTagged,A=this.startNode();return this.type===C.invalidTemplate?($||this.raiseRecoverable(this.start,"Bad escape sequence in untagged template literal"),A.value={raw:this.value,cooked:null}):A.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,`
`),cooked:this.value},this.next(),A.tail=this.type===C.backQuote,this.finishNode(A,"TemplateElement")},Ze.parseTemplate=function(y){y===void 0&&(y={});var $=y.isTagged;$===void 0&&($=!1);var A=this.startNode();this.next(),A.expressions=[];var M=this.parseTemplateElement({isTagged:$});for(A.quasis=[M];!M.tail;)this.type===C.eof&&this.raise(this.pos,"Unterminated template literal"),this.expect(C.dollarBraceL),A.expressions.push(this.parseExpression()),this.expect(C.braceR),A.quasis.push(M=this.parseTemplateElement({isTagged:$}));return this.next(),this.finishNode(A,"TemplateLiteral")},Ze.isAsyncProp=function(y){return!y.computed&&y.key.type==="Identifier"&&y.key.name==="async"&&(this.type===C.name||this.type===C.num||this.type===C.string||this.type===C.bracketL||this.type.keyword||this.options.ecmaVersion>=9&&this.type===C.star)&&!T.test(this.input.slice(this.lastTokEnd,this.start))},Ze.parseObj=function(y,$){var A=this.startNode(),M=!0,H={};for(A.properties=[],this.next();!this.eat(C.braceR);){if(M)M=!1;else if(this.expect(C.comma),this.options.ecmaVersion>=5&&this.afterTrailingComma(C.braceR))break;var oe=this.parseProperty(y,$);y||this.checkPropClash(oe,H,$),A.properties.push(oe)}return this.finishNode(A,y?"ObjectPattern":"ObjectExpression")},Ze.parseProperty=function(y,$){var A=this.startNode(),M,H,oe,de;if(this.options.ecmaVersion>=9&&this.eat(C.ellipsis))return y?(A.argument=this.parseIdent(!1),this.type===C.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.finishNode(A,"RestElement")):(this.type===C.parenL&&$&&($.parenthesizedAssign<0&&($.parenthesizedAssign=this.start),$.parenthesizedBind<0&&($.parenthesizedBind=this.start)),A.argument=this.parseMaybeAssign(!1,$),this.type===C.comma&&$&&$.trailingComma<0&&($.trailingComma=this.start),this.finishNode(A,"SpreadElement"));this.options.ecmaVersion>=6&&(A.method=!1,A.shorthand=!1,(y||$)&&(oe=this.start,de=this.startLoc),y||(M=this.eat(C.star)));var Fe=this.containsEsc;return this.parsePropertyName(A),!y&&!Fe&&this.options.ecmaVersion>=8&&!M&&this.isAsyncProp(A)?(H=!0,M=this.options.ecmaVersion>=9&&this.eat(C.star),this.parsePropertyName(A,$)):H=!1,this.parsePropertyValue(A,y,M,H,oe,de,$,Fe),this.finishNode(A,"Property")},Ze.parsePropertyValue=function(y,$,A,M,H,oe,de,Fe){if((A||M)&&this.type===C.colon&&this.unexpected(),this.eat(C.colon))y.value=$?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(!1,de),y.kind="init";else if(this.options.ecmaVersion>=6&&this.type===C.parenL)$&&this.unexpected(),y.kind="init",y.method=!0,y.value=this.parseMethod(A,M);else if(!$&&!Fe&&this.options.ecmaVersion>=5&&!y.computed&&y.key.type==="Identifier"&&(y.key.name==="get"||y.key.name==="set")&&this.type!==C.comma&&this.type!==C.braceR){(A||M)&&this.unexpected(),y.kind=y.key.name,this.parsePropertyName(y),y.value=this.parseMethod(!1);var Xe=y.kind==="get"?0:1;if(y.value.params.length!==Xe){var vt=y.value.start;y.kind==="get"?this.raiseRecoverable(vt,"getter should have no params"):this.raiseRecoverable(vt,"setter should have exactly one param")}else y.kind==="set"&&y.value.params[0].type==="RestElement"&&this.raiseRecoverable(y.value.params[0].start,"Setter cannot use rest params")}else this.options.ecmaVersion>=6&&!y.computed&&y.key.type==="Identifier"?((A||M)&&this.unexpected(),this.checkUnreserved(y.key),y.key.name==="await"&&!this.awaitIdentPos&&(this.awaitIdentPos=H),y.kind="init",$?y.value=this.parseMaybeDefault(H,oe,y.key):this.type===C.eq&&de?(de.shorthandAssign<0&&(de.shorthandAssign=this.start),y.value=this.parseMaybeDefault(H,oe,y.key)):y.value=y.key,y.shorthand=!0):this.unexpected()},Ze.parsePropertyName=function(y){if(this.options.ecmaVersion>=6){if(this.eat(C.bracketL))return y.computed=!0,y.key=this.parseMaybeAssign(),this.expect(C.bracketR),y.key;y.computed=!1}return y.key=this.type===C.num||this.type===C.string?this.parseExprAtom():this.parseIdent(this.options.allowReserved!=="never")},Ze.initFunction=function(y){y.id=null,this.options.ecmaVersion>=6&&(y.generator=y.expression=!1),this.options.ecmaVersion>=8&&(y.async=!1)},Ze.parseMethod=function(y,$,A){var M=this.startNode(),H=this.yieldPos,oe=this.awaitPos,de=this.awaitIdentPos;return this.initFunction(M),this.options.ecmaVersion>=6&&(M.generator=y),this.options.ecmaVersion>=8&&(M.async=!!$),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(ae($,M.generator)|ee|(A?ue:0)),this.expect(C.parenL),M.params=this.parseBindingList(C.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams(),this.parseFunctionBody(M,!1,!0),this.yieldPos=H,this.awaitPos=oe,this.awaitIdentPos=de,this.finishNode(M,"FunctionExpression")},Ze.parseArrowExpression=function(y,$,A){var M=this.yieldPos,H=this.awaitPos,oe=this.awaitIdentPos;return this.enterScope(ae(A,!1)|V),this.initFunction(y),this.options.ecmaVersion>=8&&(y.async=!!A),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,y.params=this.toAssignableList($,!0),this.parseFunctionBody(y,!0,!1),this.yieldPos=M,this.awaitPos=H,this.awaitIdentPos=oe,this.finishNode(y,"ArrowFunctionExpression")},Ze.parseFunctionBody=function(y,$,A){var M=$&&this.type!==C.braceL,H=this.strict,oe=!1;if(M)y.body=this.parseMaybeAssign(),y.expression=!0,this.checkParams(y,!1);else{var de=this.options.ecmaVersion>=7&&!this.isSimpleParamList(y.params);(!H||de)&&(oe=this.strictDirective(this.end),oe&&de&&this.raiseRecoverable(y.start,"Illegal 'use strict' directive in function with non-simple parameter list"));var Fe=this.labels;this.labels=[],oe&&(this.strict=!0),this.checkParams(y,!H&&!oe&&!$&&!A&&this.isSimpleParamList(y.params)),y.body=this.parseBlock(!1),y.expression=!1,this.adaptDirectivePrologue(y.body.body),this.labels=Fe}this.exitScope(),this.strict&&y.id&&this.checkLVal(y.id,Le),this.strict=H},Ze.isSimpleParamList=function(y){for(var $=0,A=y;$<A.length;$+=1){var M=A[$];if(M.type!=="Identifier")return!1}return!0},Ze.checkParams=function(y,$){for(var A={},M=0,H=y.params;M<H.length;M+=1){var oe=H[M];this.checkLVal(oe,me,$?null:A)}},Ze.parseExprList=function(y,$,A,M){for(var H=[],oe=!0;!this.eat(y);){if(oe)oe=!1;else if(this.expect(C.comma),$&&this.afterTrailingComma(y))break;var de=void 0;A&&this.type===C.comma?de=null:this.type===C.ellipsis?(de=this.parseSpread(M),M&&this.type===C.comma&&M.trailingComma<0&&(M.trailingComma=this.start)):de=this.parseMaybeAssign(!1,M),H.push(de)}return H},Ze.checkUnreserved=function(y){var $=y.start,A=y.end,M=y.name;if(this.inGenerator&&M==="yield"&&this.raiseRecoverable($,"Cannot use 'yield' as identifier inside a generator"),this.inAsync&&M==="await"&&this.raiseRecoverable($,"Cannot use 'await' as identifier inside an async function"),this.keywords.test(M)&&this.raise($,"Unexpected keyword '"+M+"'"),!(this.options.ecmaVersion<6&&this.input.slice($,A).indexOf("\\")!==-1)){var H=this.strict?this.reservedWordsStrict:this.reservedWords;H.test(M)&&(!this.inAsync&&M==="await"&&this.raiseRecoverable($,"Cannot use keyword 'await' outside an async function"),this.raiseRecoverable($,"The keyword '"+M+"' is reserved"))}},Ze.parseIdent=function(y,$){var A=this.startNode();return this.type===C.name?A.name=this.value:this.type.keyword?(A.name=this.type.keyword,(A.name==="class"||A.name==="function")&&(this.lastTokEnd!==this.lastTokStart+1||this.input.charCodeAt(this.lastTokStart)!==46)&&this.context.pop()):this.unexpected(),this.next(!!y),this.finishNode(A,"Identifier"),y||(this.checkUnreserved(A),A.name==="await"&&!this.awaitIdentPos&&(this.awaitIdentPos=A.start)),A},Ze.parseYield=function(y){this.yieldPos||(this.yieldPos=this.start);var $=this.startNode();return this.next(),this.type===C.semi||this.canInsertSemicolon()||this.type!==C.star&&!this.type.startsExpr?($.delegate=!1,$.argument=null):($.delegate=this.eat(C.star),$.argument=this.parseMaybeAssign(y)),this.finishNode($,"YieldExpression")},Ze.parseAwait=function(){this.awaitPos||(this.awaitPos=this.start);var y=this.startNode();return this.next(),y.argument=this.parseMaybeUnary(null,!1),this.finishNode(y,"AwaitExpression")};var Pi=be.prototype;Pi.raise=function(y,$){var A=te(this.input,y);$+=" ("+A.line+":"+A.column+")";var M=new SyntaxError($);throw M.pos=y,M.loc=A,M.raisedAt=this.pos,M},Pi.raiseRecoverable=Pi.raise,Pi.curPosition=function(){if(this.options.locations)return new U(this.curLine,this.pos-this.lineStart)};var ti=be.prototype,Pk=function($){this.flags=$,this.var=[],this.lexical=[],this.functions=[]};ti.enterScope=function(y){this.scopeStack.push(new Pk(y))},ti.exitScope=function(){this.scopeStack.pop()},ti.treatFunctionsAsVarInScope=function(y){return y.flags&xe||!this.inModule&&y.flags&Se},ti.declareName=function(y,$,A){var M=!1;if($===ye){var H=this.currentScope();M=H.lexical.indexOf(y)>-1||H.functions.indexOf(y)>-1||H.var.indexOf(y)>-1,H.lexical.push(y),this.inModule&&H.flags&Se&&delete this.undefinedExports[y]}else if($===pe){var oe=this.currentScope();oe.lexical.push(y)}else if($===ge){var de=this.currentScope();this.treatFunctionsAsVar?M=de.lexical.indexOf(y)>-1:M=de.lexical.indexOf(y)>-1||de.var.indexOf(y)>-1,de.functions.push(y)}else for(var Fe=this.scopeStack.length-1;Fe>=0;--Fe){var Xe=this.scopeStack[Fe];if(Xe.lexical.indexOf(y)>-1&&!(Xe.flags&G&&Xe.lexical[0]===y)||!this.treatFunctionsAsVarInScope(Xe)&&Xe.functions.indexOf(y)>-1){M=!0;break}if(Xe.var.push(y),this.inModule&&Xe.flags&Se&&delete this.undefinedExports[y],Xe.flags&Ce)break}M&&this.raiseRecoverable(A,"Identifier '"+y+"' has already been declared")},ti.checkLocalExport=function(y){this.scopeStack[0].lexical.indexOf(y.name)===-1&&this.scopeStack[0].var.indexOf(y.name)===-1&&(this.undefinedExports[y.name]=y)},ti.currentScope=function(){return this.scopeStack[this.scopeStack.length-1]},ti.currentVarScope=function(){for(var y=this.scopeStack.length-1;;y--){var $=this.scopeStack[y];if($.flags&Ce)return $}},ti.currentThisScope=function(){for(var y=this.scopeStack.length-1;;y--){var $=this.scopeStack[y];if($.flags&Ce&&!($.flags&V))return $}};var ih=function($,A,M){this.type="",this.start=A,this.end=0,$.options.locations&&(this.loc=new X($,M)),$.options.directSourceFile&&(this.sourceFile=$.options.directSourceFile),$.options.ranges&&(this.range=[A,0])},oh=be.prototype;oh.startNode=function(){return new ih(this,this.start,this.startLoc)},oh.startNodeAt=function(y,$){return new ih(this,y,$)};function Ib(y,$,A,M){return y.type=$,y.end=A,this.options.locations&&(y.loc.end=M),this.options.ranges&&(y.range[1]=A),y}oh.finishNode=function(y,$){return Ib.call(this,y,$,this.lastTokEnd,this.lastTokEndLoc)},oh.finishNodeAt=function(y,$,A,M){return Ib.call(this,y,$,A,M)};var Cs=function($,A,M,H,oe){this.token=$,this.isExpr=!!A,this.preserveSpace=!!M,this.override=H,this.generator=!!oe},Ht={b_stat:new Cs("{",!1),b_expr:new Cs("{",!0),b_tmpl:new Cs("${",!1),p_stat:new Cs("(",!1),p_expr:new Cs("(",!0),q_tmpl:new Cs("`",!0,!0,function(y){return y.tryReadTemplateToken()}),f_stat:new Cs("function",!1),f_expr:new Cs("function",!0),f_expr_gen:new Cs("function",!0,!1,null,!0),f_gen:new Cs("function",!1,!1,null,!0)},ah=be.prototype;ah.initialContext=function(){return[Ht.b_stat]},ah.braceIsBlock=function(y){var $=this.curContext();return $===Ht.f_expr||$===Ht.f_stat?!0:y===C.colon&&($===Ht.b_stat||$===Ht.b_expr)?!$.isExpr:y===C._return||y===C.name&&this.exprAllowed?T.test(this.input.slice(this.lastTokEnd,this.start)):y===C._else||y===C.semi||y===C.eof||y===C.parenR||y===C.arrow?!0:y===C.braceL?$===Ht.b_stat:y===C._var||y===C._const||y===C.name?!1:!this.exprAllowed},ah.inGeneratorContext=function(){for(var y=this.context.length-1;y>=1;y--){var $=this.context[y];if($.token==="function")return $.generator}return!1},ah.updateContext=function(y){var $,A=this.type;A.keyword&&y===C.dot?this.exprAllowed=!1:($=A.updateContext)?$.call(this,y):this.exprAllowed=A.beforeExpr},C.parenR.updateContext=C.braceR.updateContext=function(){if(this.context.length===1){this.exprAllowed=!0;return}var y=this.context.pop();y===Ht.b_stat&&this.curContext().token==="function"&&(y=this.context.pop()),this.exprAllowed=!y.isExpr},C.braceL.updateContext=function(y){this.context.push(this.braceIsBlock(y)?Ht.b_stat:Ht.b_expr),this.exprAllowed=!0},C.dollarBraceL.updateContext=function(){this.context.push(Ht.b_tmpl),this.exprAllowed=!0},C.parenL.updateContext=function(y){var $=y===C._if||y===C._for||y===C._with||y===C._while;this.context.push($?Ht.p_stat:Ht.p_expr),this.exprAllowed=!0},C.incDec.updateContext=function(){},C._function.updateContext=C._class.updateContext=function(y){y.beforeExpr&&y!==C.semi&&y!==C._else&&!(y===C._return&&T.test(this.input.slice(this.lastTokEnd,this.start)))&&!((y===C.colon||y===C.braceL)&&this.curContext()===Ht.b_stat)?this.context.push(Ht.f_expr):this.context.push(Ht.f_stat),this.exprAllowed=!1},C.backQuote.updateContext=function(){this.curContext()===Ht.q_tmpl?this.context.pop():this.context.push(Ht.q_tmpl),this.exprAllowed=!1},C.star.updateContext=function(y){if(y===C._function){var $=this.context.length-1;this.context[$]===Ht.f_expr?this.context[$]=Ht.f_expr_gen:this.context[$]=Ht.f_gen}this.exprAllowed=!0},C.name.updateContext=function(y){var $=!1;this.options.ecmaVersion>=6&&y!==C.dot&&(this.value==="of"&&!this.exprAllowed||this.value==="yield"&&this.inGeneratorContext())&&($=!0),this.exprAllowed=$};var $b="ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",kb=$b+" Extended_Pictographic",Lk=kb,Ok={9:$b,10:kb,11:Lk},Tb="Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",Eb="Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",Rb=Eb+" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",Mk=Rb+" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",zk={9:Eb,10:Rb,11:Mk},Nb={};function vf(y){var $=Nb[y]={binary:K(Ok[y]+" "+Tb),nonBinary:{General_Category:K(Tb),Script:K(zk[y])}};$.nonBinary.Script_Extensions=$.nonBinary.Script,$.nonBinary.gc=$.nonBinary.General_Category,$.nonBinary.sc=$.nonBinary.Script,$.nonBinary.scx=$.nonBinary.Script_Extensions}vf(9),vf(10),vf(11);var He=be.prototype,Ar=function($){this.parser=$,this.validFlags="gim"+($.options.ecmaVersion>=6?"uy":"")+($.options.ecmaVersion>=9?"s":""),this.unicodeProperties=Nb[$.options.ecmaVersion>=11?11:$.options.ecmaVersion],this.source="",this.flags="",this.start=0,this.switchU=!1,this.switchN=!1,this.pos=0,this.lastIntValue=0,this.lastStringValue="",this.lastAssertionIsQuantifiable=!1,this.numCapturingParens=0,this.maxBackReference=0,this.groupNames=[],this.backReferenceNames=[]};Ar.prototype.reset=function($,A,M){var H=M.indexOf("u")!==-1;this.start=$|0,this.source=A+"",this.flags=M,this.switchU=H&&this.parser.options.ecmaVersion>=6,this.switchN=H&&this.parser.options.ecmaVersion>=9},Ar.prototype.raise=function($){this.parser.raiseRecoverable(this.start,"Invalid regular expression: /"+this.source+"/: "+$)},Ar.prototype.at=function($){var A=this.source,M=A.length;if($>=M)return-1;var H=A.charCodeAt($);if(!this.switchU||H<=55295||H>=57344||$+1>=M)return H;var oe=A.charCodeAt($+1);return oe>=56320&&oe<=57343?(H<<10)+oe-56613888:H},Ar.prototype.nextIndex=function($){var A=this.source,M=A.length;if($>=M)return M;var H=A.charCodeAt($),oe;return!this.switchU||H<=55295||H>=57344||$+1>=M||(oe=A.charCodeAt($+1))<56320||oe>57343?$+1:$+2},Ar.prototype.current=function(){return this.at(this.pos)},Ar.prototype.lookahead=function(){return this.at(this.nextIndex(this.pos))},Ar.prototype.advance=function(){this.pos=this.nextIndex(this.pos)},Ar.prototype.eat=function($){return this.current()===$?(this.advance(),!0):!1};function uh(y){return y<=65535?String.fromCharCode(y):(y-=65536,String.fromCharCode((y>>10)+55296,(y&1023)+56320))}He.validateRegExpFlags=function(y){for(var $=y.validFlags,A=y.flags,M=0;M<A.length;M++){var H=A.charAt(M);$.indexOf(H)===-1&&this.raise(y.start,"Invalid regular expression flag"),A.indexOf(H,M+1)>-1&&this.raise(y.start,"Duplicate regular expression flag")}},He.validateRegExpPattern=function(y){this.regexp_pattern(y),!y.switchN&&this.options.ecmaVersion>=9&&y.groupNames.length>0&&(y.switchN=!0,this.regexp_pattern(y))},He.regexp_pattern=function(y){y.pos=0,y.lastIntValue=0,y.lastStringValue="",y.lastAssertionIsQuantifiable=!1,y.numCapturingParens=0,y.maxBackReference=0,y.groupNames.length=0,y.backReferenceNames.length=0,this.regexp_disjunction(y),y.pos!==y.source.length&&(y.eat(41)&&y.raise("Unmatched ')'"),(y.eat(93)||y.eat(125))&&y.raise("Lone quantifier brackets")),y.maxBackReference>y.numCapturingParens&&y.raise("Invalid escape");for(var $=0,A=y.backReferenceNames;$<A.length;$+=1){var M=A[$];y.groupNames.indexOf(M)===-1&&y.raise("Invalid named capture referenced")}},He.regexp_disjunction=function(y){for(this.regexp_alternative(y);y.eat(124);)this.regexp_alternative(y);this.regexp_eatQuantifier(y,!0)&&y.raise("Nothing to repeat"),y.eat(123)&&y.raise("Lone quantifier brackets")},He.regexp_alternative=function(y){for(;y.pos<y.source.length&&this.regexp_eatTerm(y););},He.regexp_eatTerm=function(y){return this.regexp_eatAssertion(y)?(y.lastAssertionIsQuantifiable&&this.regexp_eatQuantifier(y)&&y.switchU&&y.raise("Invalid quantifier"),!0):(y.switchU?this.regexp_eatAtom(y):this.regexp_eatExtendedAtom(y))?(this.regexp_eatQuantifier(y),!0):!1},He.regexp_eatAssertion=function(y){var $=y.pos;if(y.lastAssertionIsQuantifiable=!1,y.eat(94)||y.eat(36))return!0;if(y.eat(92)){if(y.eat(66)||y.eat(98))return!0;y.pos=$}if(y.eat(40)&&y.eat(63)){var A=!1;if(this.options.ecmaVersion>=9&&(A=y.eat(60)),y.eat(61)||y.eat(33))return this.regexp_disjunction(y),y.eat(41)||y.raise("Unterminated group"),y.lastAssertionIsQuantifiable=!A,!0}return y.pos=$,!1},He.regexp_eatQuantifier=function(y,$){return $===void 0&&($=!1),this.regexp_eatQuantifierPrefix(y,$)?(y.eat(63),!0):!1},He.regexp_eatQuantifierPrefix=function(y,$){return y.eat(42)||y.eat(43)||y.eat(63)||this.regexp_eatBracedQuantifier(y,$)},He.regexp_eatBracedQuantifier=function(y,$){var A=y.pos;if(y.eat(123)){var M=0,H=-1;if(this.regexp_eatDecimalDigits(y)&&(M=y.lastIntValue,y.eat(44)&&this.regexp_eatDecimalDigits(y)&&(H=y.lastIntValue),y.eat(125)))return H!==-1&&H<M&&!$&&y.raise("numbers out of order in {} quantifier"),!0;y.switchU&&!$&&y.raise("Incomplete quantifier"),y.pos=A}return!1},He.regexp_eatAtom=function(y){return this.regexp_eatPatternCharacters(y)||y.eat(46)||this.regexp_eatReverseSolidusAtomEscape(y)||this.regexp_eatCharacterClass(y)||this.regexp_eatUncapturingGroup(y)||this.regexp_eatCapturingGroup(y)},He.regexp_eatReverseSolidusAtomEscape=function(y){var $=y.pos;if(y.eat(92)){if(this.regexp_eatAtomEscape(y))return!0;y.pos=$}return!1},He.regexp_eatUncapturingGroup=function(y){var $=y.pos;if(y.eat(40)){if(y.eat(63)&&y.eat(58)){if(this.regexp_disjunction(y),y.eat(41))return!0;y.raise("Unterminated group")}y.pos=$}return!1},He.regexp_eatCapturingGroup=function(y){if(y.eat(40)){if(this.options.ecmaVersion>=9?this.regexp_groupSpecifier(y):y.current()===63&&y.raise("Invalid group"),this.regexp_disjunction(y),y.eat(41))return y.numCapturingParens+=1,!0;y.raise("Unterminated group")}return!1},He.regexp_eatExtendedAtom=function(y){return y.eat(46)||this.regexp_eatReverseSolidusAtomEscape(y)||this.regexp_eatCharacterClass(y)||this.regexp_eatUncapturingGroup(y)||this.regexp_eatCapturingGroup(y)||this.regexp_eatInvalidBracedQuantifier(y)||this.regexp_eatExtendedPatternCharacter(y)},He.regexp_eatInvalidBracedQuantifier=function(y){return this.regexp_eatBracedQuantifier(y,!0)&&y.raise("Nothing to repeat"),!1},He.regexp_eatSyntaxCharacter=function(y){var $=y.current();return _b($)?(y.lastIntValue=$,y.advance(),!0):!1};function _b(y){return y===36||y>=40&&y<=43||y===46||y===63||y>=91&&y<=94||y>=123&&y<=125}He.regexp_eatPatternCharacters=function(y){for(var $=y.pos,A=0;(A=y.current())!==-1&&!_b(A);)y.advance();return y.pos!==$},He.regexp_eatExtendedPatternCharacter=function(y){var $=y.current();return $!==-1&&$!==36&&!($>=40&&$<=43)&&$!==46&&$!==63&&$!==91&&$!==94&&$!==124?(y.advance(),!0):!1},He.regexp_groupSpecifier=function(y){if(y.eat(63)){if(this.regexp_eatGroupName(y)){y.groupNames.indexOf(y.lastStringValue)!==-1&&y.raise("Duplicate capture group name"),y.groupNames.push(y.lastStringValue);return}y.raise("Invalid group")}},He.regexp_eatGroupName=function(y){if(y.lastStringValue="",y.eat(60)){if(this.regexp_eatRegExpIdentifierName(y)&&y.eat(62))return!0;y.raise("Invalid capture group name")}return!1},He.regexp_eatRegExpIdentifierName=function(y){if(y.lastStringValue="",this.regexp_eatRegExpIdentifierStart(y)){for(y.lastStringValue+=uh(y.lastIntValue);this.regexp_eatRegExpIdentifierPart(y);)y.lastStringValue+=uh(y.lastIntValue);return!0}return!1},He.regexp_eatRegExpIdentifierStart=function(y){var $=y.pos,A=y.current();return y.advance(),A===92&&this.regexp_eatRegExpUnicodeEscapeSequence(y)&&(A=y.lastIntValue),Bk(A)?(y.lastIntValue=A,!0):(y.pos=$,!1)};function Bk(y){return b(y,!0)||y===36||y===95}He.regexp_eatRegExpIdentifierPart=function(y){var $=y.pos,A=y.current();return y.advance(),A===92&&this.regexp_eatRegExpUnicodeEscapeSequence(y)&&(A=y.lastIntValue),Vk(A)?(y.lastIntValue=A,!0):(y.pos=$,!1)};function Vk(y){return x(y,!0)||y===36||y===95||y===8204||y===8205}He.regexp_eatAtomEscape=function(y){return this.regexp_eatBackReference(y)||this.regexp_eatCharacterClassEscape(y)||this.regexp_eatCharacterEscape(y)||y.switchN&&this.regexp_eatKGroupName(y)?!0:(y.switchU&&(y.current()===99&&y.raise("Invalid unicode escape"),y.raise("Invalid escape")),!1)},He.regexp_eatBackReference=function(y){var $=y.pos;if(this.regexp_eatDecimalEscape(y)){var A=y.lastIntValue;if(y.switchU)return A>y.maxBackReference&&(y.maxBackReference=A),!0;if(A<=y.numCapturingParens)return!0;y.pos=$}return!1},He.regexp_eatKGroupName=function(y){if(y.eat(107)){if(this.regexp_eatGroupName(y))return y.backReferenceNames.push(y.lastStringValue),!0;y.raise("Invalid named reference")}return!1},He.regexp_eatCharacterEscape=function(y){return this.regexp_eatControlEscape(y)||this.regexp_eatCControlLetter(y)||this.regexp_eatZero(y)||this.regexp_eatHexEscapeSequence(y)||this.regexp_eatRegExpUnicodeEscapeSequence(y)||!y.switchU&&this.regexp_eatLegacyOctalEscapeSequence(y)||this.regexp_eatIdentityEscape(y)},He.regexp_eatCControlLetter=function(y){var $=y.pos;if(y.eat(99)){if(this.regexp_eatControlLetter(y))return!0;y.pos=$}return!1},He.regexp_eatZero=function(y){return y.current()===48&&!lh(y.lookahead())?(y.lastIntValue=0,y.advance(),!0):!1},He.regexp_eatControlEscape=function(y){var $=y.current();return $===116?(y.lastIntValue=9,y.advance(),!0):$===110?(y.lastIntValue=10,y.advance(),!0):$===118?(y.lastIntValue=11,y.advance(),!0):$===102?(y.lastIntValue=12,y.advance(),!0):$===114?(y.lastIntValue=13,y.advance(),!0):!1},He.regexp_eatControlLetter=function(y){var $=y.current();return Db($)?(y.lastIntValue=$%32,y.advance(),!0):!1};function Db(y){return y>=65&&y<=90||y>=97&&y<=122}He.regexp_eatRegExpUnicodeEscapeSequence=function(y){var $=y.pos;if(y.eat(117)){if(this.regexp_eatFixedHexDigits(y,4)){var A=y.lastIntValue;if(y.switchU&&A>=55296&&A<=56319){var M=y.pos;if(y.eat(92)&&y.eat(117)&&this.regexp_eatFixedHexDigits(y,4)){var H=y.lastIntValue;if(H>=56320&&H<=57343)return y.lastIntValue=(A-55296)*1024+(H-56320)+65536,!0}y.pos=M,y.lastIntValue=A}return!0}if(y.switchU&&y.eat(123)&&this.regexp_eatHexDigits(y)&&y.eat(125)&&Uk(y.lastIntValue))return!0;y.switchU&&y.raise("Invalid unicode escape"),y.pos=$}return!1};function Uk(y){return y>=0&&y<=1114111}He.regexp_eatIdentityEscape=function(y){if(y.switchU)return this.regexp_eatSyntaxCharacter(y)?!0:y.eat(47)?(y.lastIntValue=47,!0):!1;var $=y.current();return $!==99&&(!y.switchN||$!==107)?(y.lastIntValue=$,y.advance(),!0):!1},He.regexp_eatDecimalEscape=function(y){y.lastIntValue=0;var $=y.current();if($>=49&&$<=57){do y.lastIntValue=10*y.lastIntValue+($-48),y.advance();while(($=y.current())>=48&&$<=57);return!0}return!1},He.regexp_eatCharacterClassEscape=function(y){var $=y.current();if(Gk($))return y.lastIntValue=-1,y.advance(),!0;if(y.switchU&&this.options.ecmaVersion>=9&&($===80||$===112)){if(y.lastIntValue=-1,y.advance(),y.eat(123)&&this.regexp_eatUnicodePropertyValueExpression(y)&&y.eat(125))return!0;y.raise("Invalid property name")}return!1};function Gk(y){return y===100||y===68||y===115||y===83||y===119||y===87}He.regexp_eatUnicodePropertyValueExpression=function(y){var $=y.pos;if(this.regexp_eatUnicodePropertyName(y)&&y.eat(61)){var A=y.lastStringValue;if(this.regexp_eatUnicodePropertyValue(y)){var M=y.lastStringValue;return this.regexp_validateUnicodePropertyNameAndValue(y,A,M),!0}}if(y.pos=$,this.regexp_eatLoneUnicodePropertyNameOrValue(y)){var H=y.lastStringValue;return this.regexp_validateUnicodePropertyNameOrValue(y,H),!0}return!1},He.regexp_validateUnicodePropertyNameAndValue=function(y,$,A){N(y.unicodeProperties.nonBinary,$)||y.raise("Invalid property name"),y.unicodeProperties.nonBinary[$].test(A)||y.raise("Invalid property value")},He.regexp_validateUnicodePropertyNameOrValue=function(y,$){y.unicodeProperties.binary.test($)||y.raise("Invalid property name")},He.regexp_eatUnicodePropertyName=function(y){var $=0;for(y.lastStringValue="";Ab($=y.current());)y.lastStringValue+=uh($),y.advance();return y.lastStringValue!==""};function Ab(y){return Db(y)||y===95}He.regexp_eatUnicodePropertyValue=function(y){var $=0;for(y.lastStringValue="";Wk($=y.current());)y.lastStringValue+=uh($),y.advance();return y.lastStringValue!==""};function Wk(y){return Ab(y)||lh(y)}He.regexp_eatLoneUnicodePropertyNameOrValue=function(y){return this.regexp_eatUnicodePropertyValue(y)},He.regexp_eatCharacterClass=function(y){if(y.eat(91)){if(y.eat(94),this.regexp_classRanges(y),y.eat(93))return!0;y.raise("Unterminated character class")}return!1},He.regexp_classRanges=function(y){for(;this.regexp_eatClassAtom(y);){var $=y.lastIntValue;if(y.eat(45)&&this.regexp_eatClassAtom(y)){var A=y.lastIntValue;y.switchU&&($===-1||A===-1)&&y.raise("Invalid character class"),$!==-1&&A!==-1&&$>A&&y.raise("Range out of order in character class")}}},He.regexp_eatClassAtom=function(y){var $=y.pos;if(y.eat(92)){if(this.regexp_eatClassEscape(y))return!0;if(y.switchU){var A=y.current();(A===99||Lb(A))&&y.raise("Invalid class escape"),y.raise("Invalid escape")}y.pos=$}var M=y.current();return M!==93?(y.lastIntValue=M,y.advance(),!0):!1},He.regexp_eatClassEscape=function(y){var $=y.pos;if(y.eat(98))return y.lastIntValue=8,!0;if(y.switchU&&y.eat(45))return y.lastIntValue=45,!0;if(!y.switchU&&y.eat(99)){if(this.regexp_eatClassControlLetter(y))return!0;y.pos=$}return this.regexp_eatCharacterClassEscape(y)||this.regexp_eatCharacterEscape(y)},He.regexp_eatClassControlLetter=function(y){var $=y.current();return lh($)||$===95?(y.lastIntValue=$%32,y.advance(),!0):!1},He.regexp_eatHexEscapeSequence=function(y){var $=y.pos;if(y.eat(120)){if(this.regexp_eatFixedHexDigits(y,2))return!0;y.switchU&&y.raise("Invalid escape"),y.pos=$}return!1},He.regexp_eatDecimalDigits=function(y){var $=y.pos,A=0;for(y.lastIntValue=0;lh(A=y.current());)y.lastIntValue=10*y.lastIntValue+(A-48),y.advance();return y.pos!==$};function lh(y){return y>=48&&y<=57}He.regexp_eatHexDigits=function(y){var $=y.pos,A=0;for(y.lastIntValue=0;Fb(A=y.current());)y.lastIntValue=16*y.lastIntValue+Pb(A),y.advance();return y.pos!==$};function Fb(y){return y>=48&&y<=57||y>=65&&y<=70||y>=97&&y<=102}function Pb(y){return y>=65&&y<=70?10+(y-65):y>=97&&y<=102?10+(y-97):y-48}He.regexp_eatLegacyOctalEscapeSequence=function(y){if(this.regexp_eatOctalDigit(y)){var $=y.lastIntValue;if(this.regexp_eatOctalDigit(y)){var A=y.lastIntValue;$<=3&&this.regexp_eatOctalDigit(y)?y.lastIntValue=$*64+A*8+y.lastIntValue:y.lastIntValue=$*8+A}else y.lastIntValue=$;return!0}return!1},He.regexp_eatOctalDigit=function(y){var $=y.current();return Lb($)?(y.lastIntValue=$-48,y.advance(),!0):(y.lastIntValue=0,!1)};function Lb(y){return y>=48&&y<=55}He.regexp_eatFixedHexDigits=function(y,$){var A=y.pos;y.lastIntValue=0;for(var M=0;M<$;++M){var H=y.current();if(!Fb(H))return y.pos=A,!1;y.lastIntValue=16*y.lastIntValue+Pb(H),y.advance()}return!0};var ch=function($){this.type=$.type,this.value=$.value,this.start=$.start,this.end=$.end,$.options.locations&&(this.loc=new X($,$.startLoc,$.endLoc)),$.options.ranges&&(this.range=[$.start,$.end])},pt=be.prototype;pt.next=function(y){!y&&this.type.keyword&&this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword "+this.type.keyword),this.options.onToken&&this.options.onToken(new ch(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken()},pt.getToken=function(){return this.next(),new ch(this)},typeof Symbol<"u"&&(pt[Symbol.iterator]=function(){var y=this;return{next:function(){var $=y.getToken();return{done:$.type===C.eof,value:$}}}}),pt.curContext=function(){return this.context[this.context.length-1]},pt.nextToken=function(){var y=this.curContext();if((!y||!y.preserveSpace)&&this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length)return this.finishToken(C.eof);if(y.override)return y.override(this);this.readToken(this.fullCharCodeAtPos())},pt.readToken=function(y){return b(y,this.options.ecmaVersion>=6)||y===92?this.readWord():this.getTokenFromCode(y)},pt.fullCharCodeAtPos=function(){var y=this.input.charCodeAt(this.pos);if(y<=55295||y>=57344)return y;var $=this.input.charCodeAt(this.pos+1);return(y<<10)+$-56613888},pt.skipBlockComment=function(){var y=this.options.onComment&&this.curPosition(),$=this.pos,A=this.input.indexOf("*/",this.pos+=2);if(A===-1&&this.raise(this.pos-2,"Unterminated comment"),this.pos=A+2,this.options.locations){R.lastIndex=$;for(var M;(M=R.exec(this.input))&&M.index<this.pos;)++this.curLine,this.lineStart=M.index+M[0].length}this.options.onComment&&this.options.onComment(!0,this.input.slice($+2,A),$,this.pos,y,this.curPosition())},pt.skipLineComment=function(y){for(var $=this.pos,A=this.options.onComment&&this.curPosition(),M=this.input.charCodeAt(this.pos+=y);this.pos<this.input.length&&!P(M);)M=this.input.charCodeAt(++this.pos);this.options.onComment&&this.options.onComment(!1,this.input.slice($+y,this.pos),$,this.pos,A,this.curPosition())},pt.skipSpace=function(){e:for(;this.pos<this.input.length;){var y=this.input.charCodeAt(this.pos);switch(y){case 32:case 160:++this.pos;break;case 13:this.input.charCodeAt(this.pos+1)===10&&++this.pos;case 10:case 8232:case 8233:++this.pos,this.options.locations&&(++this.curLine,this.lineStart=this.pos);break;case 47:switch(this.input.charCodeAt(this.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break e}break;default:if(y>8&&y<14||y>=5760&&D.test(String.fromCharCode(y)))++this.pos;else break e}}},pt.finishToken=function(y,$){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var A=this.type;this.type=y,this.value=$,this.updateContext(A)},pt.readToken_dot=function(){var y=this.input.charCodeAt(this.pos+1);if(y>=48&&y<=57)return this.readNumber(!0);var $=this.input.charCodeAt(this.pos+2);return this.options.ecmaVersion>=6&&y===46&&$===46?(this.pos+=3,this.finishToken(C.ellipsis)):(++this.pos,this.finishToken(C.dot))},pt.readToken_slash=function(){var y=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):y===61?this.finishOp(C.assign,2):this.finishOp(C.slash,1)},pt.readToken_mult_modulo_exp=function(y){var $=this.input.charCodeAt(this.pos+1),A=1,M=y===42?C.star:C.modulo;return this.options.ecmaVersion>=7&&y===42&&$===42&&(++A,M=C.starstar,$=this.input.charCodeAt(this.pos+2)),$===61?this.finishOp(C.assign,A+1):this.finishOp(M,A)},pt.readToken_pipe_amp=function(y){var $=this.input.charCodeAt(this.pos+1);return $===y?this.finishOp(y===124?C.logicalOR:C.logicalAND,2):$===61?this.finishOp(C.assign,2):this.finishOp(y===124?C.bitwiseOR:C.bitwiseAND,1)},pt.readToken_caret=function(){var y=this.input.charCodeAt(this.pos+1);return y===61?this.finishOp(C.assign,2):this.finishOp(C.bitwiseXOR,1)},pt.readToken_plus_min=function(y){var $=this.input.charCodeAt(this.pos+1);return $===y?$===45&&!this.inModule&&this.input.charCodeAt(this.pos+2)===62&&(this.lastTokEnd===0||T.test(this.input.slice(this.lastTokEnd,this.pos)))?(this.skipLineComment(3),this.skipSpace(),this.nextToken()):this.finishOp(C.incDec,2):$===61?this.finishOp(C.assign,2):this.finishOp(C.plusMin,1)},pt.readToken_lt_gt=function(y){var $=this.input.charCodeAt(this.pos+1),A=1;return $===y?(A=y===62&&this.input.charCodeAt(this.pos+2)===62?3:2,this.input.charCodeAt(this.pos+A)===61?this.finishOp(C.assign,A+1):this.finishOp(C.bitShift,A)):$===33&&y===60&&!this.inModule&&this.input.charCodeAt(this.pos+2)===45&&this.input.charCodeAt(this.pos+3)===45?(this.skipLineComment(4),this.skipSpace(),this.nextToken()):($===61&&(A=2),this.finishOp(C.relational,A))},pt.readToken_eq_excl=function(y){var $=this.input.charCodeAt(this.pos+1);return $===61?this.finishOp(C.equality,this.input.charCodeAt(this.pos+2)===61?3:2):y===61&&$===62&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(C.arrow)):this.finishOp(y===61?C.eq:C.prefix,1)},pt.getTokenFromCode=function(y){switch(y){case 46:return this.readToken_dot();case 40:return++this.pos,this.finishToken(C.parenL);case 41:return++this.pos,this.finishToken(C.parenR);case 59:return++this.pos,this.finishToken(C.semi);case 44:return++this.pos,this.finishToken(C.comma);case 91:return++this.pos,this.finishToken(C.bracketL);case 93:return++this.pos,this.finishToken(C.bracketR);case 123:return++this.pos,this.finishToken(C.braceL);case 125:return++this.pos,this.finishToken(C.braceR);case 58:return++this.pos,this.finishToken(C.colon);case 63:return++this.pos,this.finishToken(C.question);case 96:if(this.options.ecmaVersion<6)break;return++this.pos,this.finishToken(C.backQuote);case 48:var $=this.input.charCodeAt(this.pos+1);if($===120||$===88)return this.readRadixNumber(16);if(this.options.ecmaVersion>=6){if($===111||$===79)return this.readRadixNumber(8);if($===98||$===66)return this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(!1);case 34:case 39:return this.readString(y);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo_exp(y);case 124:case 38:return this.readToken_pipe_amp(y);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(y);case 60:case 62:return this.readToken_lt_gt(y);case 61:case 33:return this.readToken_eq_excl(y);case 126:return this.finishOp(C.prefix,1)}this.raise(this.pos,"Unexpected character '"+Cf(y)+"'")},pt.finishOp=function(y,$){var A=this.input.slice(this.pos,this.pos+$);return this.pos+=$,this.finishToken(y,A)},pt.readRegexp=function(){for(var y,$,A=this.pos;;){this.pos>=this.input.length&&this.raise(A,"Unterminated regular expression");var M=this.input.charAt(this.pos);if(T.test(M)&&this.raise(A,"Unterminated regular expression"),y)y=!1;else{if(M==="[")$=!0;else if(M==="]"&&$)$=!1;else if(M==="/"&&!$)break;y=M==="\\"}++this.pos}var H=this.input.slice(A,this.pos);++this.pos;var oe=this.pos,de=this.readWord1();this.containsEsc&&this.unexpected(oe);var Fe=this.regexpState||(this.regexpState=new Ar(this));Fe.reset(A,H,de),this.validateRegExpFlags(Fe),this.validateRegExpPattern(Fe);var Xe=null;try{Xe=new RegExp(H,de)}catch{}return this.finishToken(C.regexp,{pattern:H,flags:de,value:Xe})},pt.readInt=function(y,$){for(var A=this.pos,M=0,H=0,oe=$??1/0;H<oe;++H){var de=this.input.charCodeAt(this.pos),Fe=void 0;if(de>=97?Fe=de-97+10:de>=65?Fe=de-65+10:de>=48&&de<=57?Fe=de-48:Fe=1/0,Fe>=y)break;++this.pos,M=M*y+Fe}return this.pos===A||$!=null&&this.pos-A!==$?null:M},pt.readRadixNumber=function(y){var $=this.pos;this.pos+=2;var A=this.readInt(y);return A==null&&this.raise(this.start+2,"Expected number in radix "+y),this.options.ecmaVersion>=11&&this.input.charCodeAt(this.pos)===110?(A=typeof BigInt<"u"?BigInt(this.input.slice($,this.pos)):null,++this.pos):b(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(C.num,A)},pt.readNumber=function(y){var $=this.pos;!y&&this.readInt(10)===null&&this.raise($,"Invalid number");var A=this.pos-$>=2&&this.input.charCodeAt($)===48;A&&this.strict&&this.raise($,"Invalid number");var M=this.input.charCodeAt(this.pos);if(!A&&!y&&this.options.ecmaVersion>=11&&M===110){var H=this.input.slice($,this.pos),oe=typeof BigInt<"u"?BigInt(H):null;return++this.pos,b(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(C.num,oe)}A&&/[89]/.test(this.input.slice($,this.pos))&&(A=!1),M===46&&!A&&(++this.pos,this.readInt(10),M=this.input.charCodeAt(this.pos)),(M===69||M===101)&&!A&&(M=this.input.charCodeAt(++this.pos),(M===43||M===45)&&++this.pos,this.readInt(10)===null&&this.raise($,"Invalid number")),b(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var de=this.input.slice($,this.pos),Fe=A?parseInt(de,8):parseFloat(de);return this.finishToken(C.num,Fe)},pt.readCodePoint=function(){var y=this.input.charCodeAt(this.pos),$;if(y===123){this.options.ecmaVersion<6&&this.unexpected();var A=++this.pos;$=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,$>1114111&&this.invalidStringToken(A,"Code point out of bounds")}else $=this.readHexChar(4);return $};function Cf(y){return y<=65535?String.fromCharCode(y):(y-=65536,String.fromCharCode((y>>10)+55296,(y&1023)+56320))}pt.readString=function(y){for(var $="",A=++this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated string constant");var M=this.input.charCodeAt(this.pos);if(M===y)break;M===92?($+=this.input.slice(A,this.pos),$+=this.readEscapedChar(!1),A=this.pos):(P(M,this.options.ecmaVersion>=10)&&this.raise(this.start,"Unterminated string constant"),++this.pos)}return $+=this.input.slice(A,this.pos++),this.finishToken(C.string,$)};var Ob={};pt.tryReadTemplateToken=function(){this.inTemplateElement=!0;try{this.readTmplToken()}catch(y){if(y===Ob)this.readInvalidTemplateToken();else throw y}this.inTemplateElement=!1},pt.invalidStringToken=function(y,$){if(this.inTemplateElement&&this.options.ecmaVersion>=9)throw Ob;this.raise(y,$)},pt.readTmplToken=function(){for(var y="",$=this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated template");var A=this.input.charCodeAt(this.pos);if(A===96||A===36&&this.input.charCodeAt(this.pos+1)===123)return this.pos===this.start&&(this.type===C.template||this.type===C.invalidTemplate)?A===36?(this.pos+=2,this.finishToken(C.dollarBraceL)):(++this.pos,this.finishToken(C.backQuote)):(y+=this.input.slice($,this.pos),this.finishToken(C.template,y));if(A===92)y+=this.input.slice($,this.pos),y+=this.readEscapedChar(!0),$=this.pos;else if(P(A)){switch(y+=this.input.slice($,this.pos),++this.pos,A){case 13:this.input.charCodeAt(this.pos)===10&&++this.pos;case 10:y+=`
`;break;default:y+=String.fromCharCode(A);break}this.options.locations&&(++this.curLine,this.lineStart=this.pos),$=this.pos}else++this.pos}},pt.readInvalidTemplateToken=function(){for(;this.pos<this.input.length;this.pos++)switch(this.input[this.pos]){case"\\":++this.pos;break;case"$":if(this.input[this.pos+1]!=="{")break;case"`":return this.finishToken(C.invalidTemplate,this.input.slice(this.start,this.pos))}this.raise(this.start,"Unterminated template")},pt.readEscapedChar=function(y){var $=this.input.charCodeAt(++this.pos);switch(++this.pos,$){case 110:return`
`;case 114:return"\r";case 120:return String.fromCharCode(this.readHexChar(2));case 117:return Cf(this.readCodePoint());case 116:return"	";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 13:this.input.charCodeAt(this.pos)===10&&++this.pos;case 10:return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";case 56:case 57:if(y){var A=this.pos-1;return this.invalidStringToken(A,"Invalid escape sequence in template string"),null}default:if($>=48&&$<=55){var M=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],H=parseInt(M,8);return H>255&&(M=M.slice(0,-1),H=parseInt(M,8)),this.pos+=M.length-1,$=this.input.charCodeAt(this.pos),(M!=="0"||$===56||$===57)&&(this.strict||y)&&this.invalidStringToken(this.pos-1-M.length,y?"Octal literal in template string":"Octal literal in strict mode"),String.fromCharCode(H)}return P($)?"":String.fromCharCode($)}},pt.readHexChar=function(y){var $=this.pos,A=this.readInt(16,y);return A===null&&this.invalidStringToken($,"Bad character escape sequence"),A},pt.readWord1=function(){this.containsEsc=!1;for(var y="",$=!0,A=this.pos,M=this.options.ecmaVersion>=6;this.pos<this.input.length;){var H=this.fullCharCodeAtPos();if(x(H,M))this.pos+=H<=65535?1:2;else if(H===92){this.containsEsc=!0,y+=this.input.slice(A,this.pos);var oe=this.pos;this.input.charCodeAt(++this.pos)!==117&&this.invalidStringToken(this.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.pos;var de=this.readCodePoint();($?b:x)(de,M)||this.invalidStringToken(oe,"Invalid Unicode escape"),y+=Cf(de),A=this.pos}else break;$=!1}return y+this.input.slice(A,this.pos)},pt.readWord=function(){var y=this.readWord1(),$=C.name;return this.keywords.test(y)&&($=E[y]),this.finishToken($,y)};var Mb="7.1.0";be.acorn={Parser:be,version:Mb,defaultOptions:ie,Position:U,SourceLocation:X,getLineInfo:te,Node:ih,TokenType:v,tokTypes:C,keywordTypes:E,TokContext:Cs,tokContexts:Ht,isIdentifierChar:x,isIdentifierStart:b,Token:ch,isNewLine:P,lineBreak:T,lineBreakG:R,nonASCIIwhitespace:D};function Hk(y,$){return be.parse(y,$)}function Kk(y,$,A){return be.parseExpressionAt(y,$,A)}function jk(y,$){return be.tokenizer(y,$)}i.Node=ih,i.Parser=be,i.Position=U,i.SourceLocation=X,i.TokContext=Cs,i.Token=ch,i.TokenType=v,i.defaultOptions=ie,i.getLineInfo=te,i.isIdentifierChar=x,i.isIdentifierStart=b,i.isNewLine=P,i.keywordTypes=E,i.lineBreak=T,i.lineBreakG=R,i.nonASCIIwhitespace=D,i.parse=Hk,i.parseExpressionAt=Kk,i.tokContexts=Ht,i.tokTypes=C,i.tokenizer=jk,i.version=Mb,Object.defineProperty(i,"__esModule",{value:!0})})},{}],2:[function(t,s,r){},{}],3:[function(t,s,r){function i(h,c={}){const{contextName:d="gl",throwGetError:p,useTrackablePrimitives:f,readPixelsFile:g,recording:m=[],variables:b={},onReadPixels:x,onUnrecognizedArgumentLookup:v}=c,w=new Proxy(h,{get:T}),S=[],k={};let E=0,I="",C;return w;function T(te,ie){switch(ie){case"addComment":return N;case"checkThrowError":return O;case"getReadPixelsVariableName":return C;case"insertVariable":return D;case"reset":return P;case"setIndent":return z;case"toString":return R;case"getContextVariableName":return X}return typeof h[ie]=="function"?function(){switch(ie){case"getError":return p?m.push(`${I}if (${d}.getError() !== ${d}.NONE) throw new Error('error');`):m.push(`${I}${d}.getError();`),h.getError();case"getExtension":{const Ce=`${d}Variables${S.length}`;m.push(`${I}const ${Ce} = ${d}.getExtension('${arguments[0]}');`);const De=h.getExtension(arguments[0]);if(De&&typeof De=="object"){const Ue=o(De,{getEntity:F,useTrackablePrimitives:f,recording:m,contextName:Ce,contextVariables:S,variables:b,indent:I,onUnrecognizedArgumentLookup:v});return S.push(Ue),Ue}else S.push(null);return De}case"readPixels":const he=S.indexOf(arguments[6]);let Se;if(he===-1){const Ce=U(arguments[6]);Ce?(Se=Ce,m.push(`${I}${Ce}`)):(Se=`${d}Variable${S.length}`,S.push(arguments[6]),m.push(`${I}const ${Se} = new ${arguments[6].constructor.name}(${arguments[6].length});`))}else Se=`${d}Variable${he}`;C=Se;const xe=[arguments[0],arguments[1],arguments[2],arguments[3],F(arguments[4]),F(arguments[5]),Se];return m.push(`${I}${d}.readPixels(${xe.join(", ")});`),g&&B(arguments[2],arguments[3]),x&&x(Se,xe),h.readPixels.apply(h,arguments);case"drawBuffers":return m.push(`${I}${d}.drawBuffers([${a(arguments[0],{contextName:d,contextVariables:S,getEntity:F,addVariable:_,variables:b,onUnrecognizedArgumentLookup:v})}]);`),h.drawBuffers(arguments[0])}let re=h[ie].apply(h,arguments);switch(typeof re){case"undefined":m.push(`${I}${K(ie,arguments)};`);return;case"number":case"boolean":if(f&&S.indexOf(l(re))===-1){m.push(`${I}const ${d}Variable${S.length} = ${K(ie,arguments)};`),S.push(re=l(re));break}default:re===null?m.push(`${K(ie,arguments)};`):m.push(`${I}const ${d}Variable${S.length} = ${K(ie,arguments)};`),S.push(re)}return re}:(k[h[ie]]=ie,h[ie])}function R(){return m.join(`
`)}function P(){for(;m.length>0;)m.pop()}function D(te,ie){b[te]=ie}function F(te){const ie=k[te];return ie?d+"."+ie:te}function z(te){I=" ".repeat(te)}function _(te,ie){const re=`${d}Variable${S.length}`;return m.push(`${I}const ${re} = ${ie};`),S.push(te),re}function B(te,ie){const re=`${d}Variable${S.length}`,he=`imageDatum${E}`;m.push(`${I}let ${he} = ["P3\\n# ${g}.ppm\\n", ${te}, ' ', ${ie}, "\\n255\\n"].join("");`),m.push(`${I}for (let i = 0; i < ${he}.length; i += 4) {`),m.push(`${I}  ${he} += ${re}[i] + ' ' + ${re}[i + 1] + ' ' + ${re}[i + 2] + ' ';`),m.push(`${I}}`),m.push(`${I}if (typeof require !== "undefined") {`),m.push(`${I}  require('fs').writeFileSync('./${g}.ppm', ${he});`),m.push(`${I}}`),E++}function N(te){m.push(`${I}// ${te}`)}function O(){m.push(`${I}(() => {
${I}const error = ${d}.getError();
${I}if (error !== ${d}.NONE) {
${I}  const names = Object.getOwnPropertyNames(gl);
${I}  for (let i = 0; i < names.length; i++) {
${I}    const name = names[i];
${I}    if (${d}[name] === error) {
${I}      throw new Error('${d} threw ' + name);
${I}    }
${I}  }
${I}}
${I}})();`)}function K(te,ie){return`${d}.${te}(${a(ie,{contextName:d,contextVariables:S,getEntity:F,addVariable:_,variables:b,onUnrecognizedArgumentLookup:v})})`}function U(te){if(b){for(const ie in b)if(b[ie]===te)return ie}return null}function X(te){const ie=S.indexOf(te);return ie!==-1?`${d}Variable${ie}`:null}}function o(h,c){const d=new Proxy(h,{get:k}),p={},{contextName:f,contextVariables:g,getEntity:m,useTrackablePrimitives:b,recording:x,variables:v,indent:w,onUnrecognizedArgumentLookup:S}=c;return d;function k(T,R){return typeof T[R]=="function"?function(){switch(R){case"drawBuffersWEBGL":return x.push(`${w}${f}.drawBuffersWEBGL([${a(arguments[0],{contextName:f,contextVariables:g,getEntity:E,addVariable:C,variables:v,onUnrecognizedArgumentLookup:S})}]);`),h.drawBuffersWEBGL(arguments[0])}let P=h[R].apply(h,arguments);switch(typeof P){case"undefined":x.push(`${w}${I(R,arguments)};`);return;case"number":case"boolean":b&&g.indexOf(l(P))===-1?(x.push(`${w}const ${f}Variable${g.length} = ${I(R,arguments)};`),g.push(P=l(P))):(x.push(`${w}const ${f}Variable${g.length} = ${I(R,arguments)};`),g.push(P));break;default:P===null?x.push(`${I(R,arguments)};`):x.push(`${w}const ${f}Variable${g.length} = ${I(R,arguments)};`),g.push(P)}return P}:(p[h[R]]=R,h[R])}function E(T){return p.hasOwnProperty(T)?`${f}.${p[T]}`:m(T)}function I(T,R){return`${f}.${T}(${a(R,{contextName:f,contextVariables:g,getEntity:E,addVariable:C,variables:v,onUnrecognizedArgumentLookup:S})})`}function C(T,R){const P=`${f}Variable${g.length}`;return g.push(T),x.push(`${w}const ${P} = ${R};`),P}}function a(h,c){const{variables:d,onUnrecognizedArgumentLookup:p}=c;return Array.from(h).map(g=>{const m=f(g);return m||u(g,c)}).join(", ");function f(g){if(d){for(const m in d)if(d.hasOwnProperty(m)&&d[m]===g)return m}return p?p(g):null}}function u(h,c){const{contextName:d,contextVariables:p,getEntity:f,addVariable:g,onUnrecognizedArgumentLookup:m}=c;if(typeof h>"u")return"undefined";if(h===null)return"null";const b=p.indexOf(h);if(b>-1)return`${d}Variable${b}`;switch(h.constructor.name){case"String":const x=/\n/.test(h),v=/'/.test(h),w=/"/.test(h);return x?"`"+h+"`":v&&!w?'"'+h+'"':"'"+h+"'";case"Number":return f(h);case"Boolean":return f(h);case"Array":return g(h,`new ${h.constructor.name}([${Array.from(h).join(",")}])`);case"Float32Array":case"Uint8Array":case"Uint16Array":case"Int32Array":return g(h,`new ${h.constructor.name}(${JSON.stringify(Array.from(h))})`);default:if(m){const S=m(h);if(S)return S}throw new Error(`unrecognized argument type ${h.constructor.name}`)}}function l(h){return new h.constructor(h)}typeof s<"u"&&(s.exports={glWiretap:i,glExtensionWiretap:o}),typeof window<"u"&&(i.glExtensionWiretap=o,window.glWiretap=i)},{}],4:[function(t,s,r){function i(g){const m=new Array(g.length);for(let b=0;b<g.length;b++){const x=g[b];x.toArray?m[b]=x.toArray():m[b]=x}return m}function o(){const g=i(arguments),m=new Float32Array(this.output.x);for(let b=0;b<this.output.x;b++)this.thread.x=b,this.thread.y=0,this.thread.z=0,m[b]=this._fn.apply(this,g);return m}function a(){const g=i(arguments),m=new Array(this.output.y);for(let b=0;b<this.output.y;b++){const x=new Float32Array(this.output.x);for(let v=0;v<this.output.x;v++)this.thread.x=v,this.thread.y=b,this.thread.z=0,x[v]=this._fn.apply(this,g);m[b]=x}return m}function u(){const g=i(arguments);for(let m=0;m<this.output.y;m++)for(let b=0;b<this.output.x;b++)this.thread.x=b,this.thread.y=m,this.thread.z=0,this._fn.apply(this,g)}function l(){const g=i(arguments),m=new Array(this.output.z);for(let b=0;b<this.output.z;b++){const x=new Array(this.output.y);for(let v=0;v<this.output.y;v++){const w=new Float32Array(this.output.x);for(let S=0;S<this.output.x;S++)this.thread.x=S,this.thread.y=v,this.thread.z=b,w[S]=this._fn.apply(this,g);x[v]=w}m[b]=x}return m}function h(g){g.setOutput=x=>{g.output=d(x),g.graphical&&c(g)},g.toJSON=()=>{throw new Error("Not usable with gpuMock")},g.setConstants=x=>(g.constants=x,g),g.setGraphical=x=>(g.graphical=x,g),g.setCanvas=x=>(g.canvas=x,g),g.setContext=x=>(g.context=x,g),g.destroy=()=>{},g.validateSettings=()=>{},g.graphical&&g.output&&c(g),g.exec=function(){return new Promise((x,v)=>{try{x(g.apply(g,arguments))}catch(w){v(w)}})},g.getPixels=x=>{const{x:v,y:w}=g.output;return x?f(g._imageData.data,v,w):g._imageData.data.slice(0)},g.color=function(x,v,w,S){typeof S>"u"&&(S=1),x=Math.floor(x*255),v=Math.floor(v*255),w=Math.floor(w*255),S=Math.floor(S*255);const k=g.output.x,E=g.output.y,I=g.thread.x,C=E-g.thread.y-1,T=I+C*k;g._colorData[T*4+0]=x,g._colorData[T*4+1]=v,g._colorData[T*4+2]=w,g._colorData[T*4+3]=S};const m=()=>g,b=["setWarnVarUsage","setArgumentTypes","setTactic","setOptimizeFloatMemory","setDebug","setLoopMaxIterations","setConstantTypes","setFunctions","setNativeFunctions","setInjectedNative","setPipeline","setPrecision","setOutputToTexture","setImmutable","setStrictIntegers","setDynamicOutput","setHardcodeConstants","setDynamicArguments","setUseLegacyEncoder","setWarnVarUsage","addSubKernel"];for(let x=0;x<b.length;x++)g[b[x]]=m;return g}function c(g){const{x:m,y:b}=g.output;if(g.context&&g.context.createImageData){const x=new Uint8ClampedArray(m*b*4);g._imageData=g.context.createImageData(m,b),g._colorData=x}else{const x=new Uint8ClampedArray(m*b*4);g._imageData={data:x},g._colorData=x}}function d(g){let m=null;if(g.length)if(g.length===3){const[b,x,v]=g;m={x:b,y:x,z:v}}else if(g.length===2){const[b,x]=g;m={x:b,y:x}}else{const[b]=g;m={x:b}}else m=g;return m}function p(g,m={}){const b=m.output?d(m.output):null;function x(){return x.output.z?l.apply(x,arguments):x.output.y?x.graphical?u.apply(x,arguments):a.apply(x,arguments):o.apply(x,arguments)}return x._fn=g,x.constants=m.constants||null,x.context=m.context||null,x.canvas=m.canvas||null,x.graphical=m.graphical||!1,x._imageData=null,x._colorData=null,x.output=b,x.thread={x:0,y:0,z:0},h(x)}function f(g,m,b){const x=b/2|0,v=m*4,w=new Uint8ClampedArray(m*4),S=g.slice(0);for(let k=0;k<x;++k){const E=k*v,I=(b-k-1)*v;w.set(S.subarray(E,E+v)),S.copyWithin(E,I,I+v),S.set(w,I)}return S}s.exports={gpuMock:p}},{}],5:[function(t,s,r){const{utils:i}=t("./utils");function o(a,u){const l=u.toString();return new Function(`return function ${a} (${i.getArgumentNamesFromString(l).join(", ")}) {
  ${i.getFunctionBodyFromString(l)}
}`)()}s.exports={alias:o}},{"./utils":114}],6:[function(t,s,r){const{FunctionNode:i}=t("../function-node");class o extends i{astFunction(u,l){if(!this.isRootKernel){l.push("function"),l.push(" "),l.push(this.name),l.push("(");for(let h=0;h<this.argumentNames.length;++h){const c=this.argumentNames[h];h>0&&l.push(", "),l.push("user_"),l.push(c)}l.push(`) {
`)}for(let h=0;h<u.body.body.length;++h)this.astGeneric(u.body.body[h],l),l.push(`
`);return this.isRootKernel||l.push(`}
`),l}astReturnStatement(u,l){const h=this.returnType||this.getType(u.argument);return this.returnType||(this.returnType=h),this.isRootKernel?(l.push(this.leadingReturnStatement),this.astGeneric(u.argument,l),l.push(`;
`),l.push(this.followingReturnStatement),l.push(`continue;
`)):this.isSubKernel?(l.push(`subKernelResult_${this.name} = `),this.astGeneric(u.argument,l),l.push(";"),l.push(`return subKernelResult_${this.name};`)):(l.push("return "),this.astGeneric(u.argument,l),l.push(";")),l}astLiteral(u,l){if(isNaN(u.value))throw this.astErrorOutput("Non-numeric literal not supported : "+u.value,u);return l.push(u.value),l}astBinaryExpression(u,l){return l.push("("),this.astGeneric(u.left,l),l.push(u.operator),this.astGeneric(u.right,l),l.push(")"),l}astIdentifierExpression(u,l){if(u.type!=="Identifier")throw this.astErrorOutput("IdentifierExpression - not an Identifier",u);switch(u.name){case"Infinity":l.push("Infinity");break;default:this.constants&&this.constants.hasOwnProperty(u.name)?l.push("constants_"+u.name):l.push("user_"+u.name)}return l}astForStatement(u,l){if(u.type!=="ForStatement")throw this.astErrorOutput("Invalid for statement",u);const h=[],c=[],d=[],p=[];let f=null;if(u.init){this.pushState("in-for-loop-init"),this.astGeneric(u.init,h);for(let g=0;g<h.length;g++)h[g].includes&&h[g].includes(",")&&(f=!1);this.popState("in-for-loop-init")}else f=!1;if(u.test?this.astGeneric(u.test,c):f=!1,u.update?this.astGeneric(u.update,d):f=!1,u.body&&(this.pushState("loop-body"),this.astGeneric(u.body,p),this.popState("loop-body")),f===null&&(f=this.isSafe(u.init)&&this.isSafe(u.test)),f)l.push(`for (${h.join("")};${c.join("")};${d.join("")}){
`),l.push(p.join("")),l.push(`}
`);else{const g=this.getInternalVariableName("safeI");h.length>0&&l.push(h.join(""),`;
`),l.push(`for (let ${g}=0;${g}<LOOP_MAX;${g}++){
`),c.length>0&&l.push(`if (!${c.join("")}) break;
`),l.push(p.join("")),l.push(`
${d.join("")};`),l.push(`}
`)}return l}astWhileStatement(u,l){if(u.type!=="WhileStatement")throw this.astErrorOutput("Invalid while statement",u);return l.push("for (let i = 0; i < LOOP_MAX; i++) {"),l.push("if ("),this.astGeneric(u.test,l),l.push(`) {
`),this.astGeneric(u.body,l),l.push(`} else {
`),l.push(`break;
`),l.push(`}
`),l.push(`}
`),l}astDoWhileStatement(u,l){if(u.type!=="DoWhileStatement")throw this.astErrorOutput("Invalid while statement",u);return l.push("for (let i = 0; i < LOOP_MAX; i++) {"),this.astGeneric(u.body,l),l.push("if (!"),this.astGeneric(u.test,l),l.push(`) {
`),l.push(`break;
`),l.push(`}
`),l.push(`}
`),l}astAssignmentExpression(u,l){const h=this.getDeclaration(u.left);if(h&&!h.assignable)throw this.astErrorOutput(`Variable ${u.left.name} is not assignable here`,u);return this.astGeneric(u.left,l),l.push(u.operator),this.astGeneric(u.right,l),l}astBlockStatement(u,l){if(this.isState("loop-body")){this.pushState("block-body");for(let h=0;h<u.body.length;h++)this.astGeneric(u.body[h],l);this.popState("block-body")}else{l.push(`{
`);for(let h=0;h<u.body.length;h++)this.astGeneric(u.body[h],l);l.push(`}
`)}return l}astVariableDeclaration(u,l){l.push(`${u.kind} `);const{declarations:h}=u;for(let c=0;c<h.length;c++){c>0&&l.push(",");const d=h[c],p=this.getDeclaration(d.id);p.valueType||(p.valueType=this.getType(d.init)),this.astGeneric(d,l)}return this.isState("in-for-loop-init")||l.push(";"),l}astIfStatement(u,l){return l.push("if ("),this.astGeneric(u.test,l),l.push(")"),u.consequent.type==="BlockStatement"?this.astGeneric(u.consequent,l):(l.push(` {
`),this.astGeneric(u.consequent,l),l.push(`
}
`)),u.alternate&&(l.push("else "),u.alternate.type==="BlockStatement"||u.alternate.type==="IfStatement"?this.astGeneric(u.alternate,l):(l.push(` {
`),this.astGeneric(u.alternate,l),l.push(`
}
`))),l}astSwitchStatement(u,l){const{discriminant:h,cases:c}=u;l.push("switch ("),this.astGeneric(h,l),l.push(`) {
`);for(let d=0;d<c.length;d++){if(c[d].test===null){l.push(`default:
`),this.astGeneric(c[d].consequent,l),c[d].consequent&&c[d].consequent.length>0&&l.push(`break;
`);continue}l.push("case "),this.astGeneric(c[d].test,l),l.push(`:
`),c[d].consequent&&c[d].consequent.length>0&&(this.astGeneric(c[d].consequent,l),l.push(`break;
`))}l.push(`
}`)}astThisExpression(u,l){return l.push("_this"),l}astMemberExpression(u,l){const{signature:h,type:c,property:d,xProperty:p,yProperty:f,zProperty:g,name:m,origin:b}=this.getMemberExpressionDetails(u);switch(h){case"this.thread.value":return l.push(`_this.thread.${m}`),l;case"this.output.value":switch(m){case"x":l.push("outputX");break;case"y":l.push("outputY");break;case"z":l.push("outputZ");break;default:throw this.astErrorOutput("Unexpected expression",u)}return l;case"value":throw this.astErrorOutput("Unexpected expression",u);case"value[]":case"value[][]":case"value[][][]":case"value.value":if(b==="Math")return l.push(Math[m]),l;switch(d){case"r":return l.push(`user_${m}[0]`),l;case"g":return l.push(`user_${m}[1]`),l;case"b":return l.push(`user_${m}[2]`),l;case"a":return l.push(`user_${m}[3]`),l}break;case"this.constants.value":case"this.constants.value[]":case"this.constants.value[][]":case"this.constants.value[][][]":break;case"fn()[]":return this.astGeneric(u.object,l),l.push("["),this.astGeneric(u.property,l),l.push("]"),l;case"fn()[][]":return this.astGeneric(u.object.object,l),l.push("["),this.astGeneric(u.object.property,l),l.push("]"),l.push("["),this.astGeneric(u.property,l),l.push("]"),l;default:throw this.astErrorOutput("Unexpected expression",u)}if(!u.computed)switch(c){case"Number":case"Integer":case"Float":case"Boolean":return l.push(`${b}_${m}`),l}const x=`${b}_${m}`;switch(c){case"Array(2)":case"Array(3)":case"Array(4)":case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":case"HTMLImageArray":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":case"HTMLImage":default:let v,w;if(b==="constants"){const S=this.constants[m];w=this.constantTypes[m]==="Input",v=w?S.size:null}else w=this.isInput(m),v=w?this.argumentSizes[this.argumentNames.indexOf(m)]:null;l.push(`${x}`),g&&f?w?(l.push("[("),this.astGeneric(g,l),l.push(`*${this.dynamicArguments?"(outputY * outputX)":v[1]*v[0]})+(`),this.astGeneric(f,l),l.push(`*${this.dynamicArguments?"outputX":v[0]})+`),this.astGeneric(p,l),l.push("]")):(l.push("["),this.astGeneric(g,l),l.push("]"),l.push("["),this.astGeneric(f,l),l.push("]"),l.push("["),this.astGeneric(p,l),l.push("]")):f?w?(l.push("[("),this.astGeneric(f,l),l.push(`*${this.dynamicArguments?"outputX":v[0]})+`),this.astGeneric(p,l),l.push("]")):(l.push("["),this.astGeneric(f,l),l.push("]"),l.push("["),this.astGeneric(p,l),l.push("]")):typeof p<"u"&&(l.push("["),this.astGeneric(p,l),l.push("]"))}return l}astCallExpression(u,l){if(u.type!=="CallExpression")throw this.astErrorOutput("Unknown CallExpression",u);let h=this.astMemberExpressionUnroll(u.callee);this.calledFunctions.indexOf(h)<0&&this.calledFunctions.push(h),this.isAstMathFunction(u),this.onFunctionCall&&this.onFunctionCall(this.name,h,u.arguments),l.push(h),l.push("(");const c=this.lookupFunctionArgumentTypes(h)||[];for(let d=0;d<u.arguments.length;++d){const p=u.arguments[d];let f=this.getType(p);c[d]||this.triggerImplyArgumentType(h,d,f,this),d>0&&l.push(", "),this.astGeneric(p,l)}return l.push(")"),l}astArrayExpression(u,l){const h=this.getType(u),c=u.elements.length,d=[];for(let p=0;p<c;++p){const f=[];this.astGeneric(u.elements[p],f),d.push(f.join(""))}switch(h){case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":l.push(`[${d.join(", ")}]`);break;default:l.push(`new Float32Array([${d.join(", ")}])`)}return l}astDebuggerStatement(u,l){return l.push("debugger;"),l}}s.exports={CPUFunctionNode:o}},{"../function-node":10}],7:[function(t,s,r){const{utils:i}=t("../../utils");function o(u,l){const h=[];for(const c in l){if(!l.hasOwnProperty(c))continue;const d=l[c],p=u[c];switch(d){case"Number":case"Integer":case"Float":case"Boolean":h.push(`${c}:${p}`);break;case"Array(2)":case"Array(3)":case"Array(4)":case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":h.push(`${c}:new ${p.constructor.name}(${JSON.stringify(Array.from(p))})`);break}}return`{ ${h.join()} }`}function a(u,l){const h=[],c=[],d=[],p=!/^function/.test(u.color.toString());if(h.push("  const { context, canvas, constants: incomingConstants } = settings;",`  const output = new Int32Array(${JSON.stringify(Array.from(u.output))});`,`  const _constantTypes = ${JSON.stringify(u.constantTypes)};`,`  const _constants = ${o(u.constants,u.constantTypes)};`),c.push("    constants: _constants,","    context,","    output,","    thread: {x: 0, y: 0, z: 0},"),u.graphical){h.push(`  const _imageData = context.createImageData(${u.output[0]}, ${u.output[1]});`),h.push(`  const _colorData = new Uint8ClampedArray(${u.output[0]} * ${u.output[1]} * 4);`);const m=i.flattenFunctionToString((p?"function ":"")+u.color.toString(),{thisLookup:x=>{switch(x){case"_colorData":return"_colorData";case"_imageData":return"_imageData";case"output":return"output";case"thread":return"this.thread"}return JSON.stringify(u[x])},findDependency:(x,v)=>null}),b=i.flattenFunctionToString((p?"function ":"")+u.getPixels.toString(),{thisLookup:x=>{switch(x){case"_colorData":return"_colorData";case"_imageData":return"_imageData";case"output":return"output";case"thread":return"this.thread"}return JSON.stringify(u[x])},findDependency:()=>null});c.push("    _imageData,","    _colorData,",`    color: ${m},`),d.push(`  kernel.getPixels = ${b};`)}const f=[],g=Object.keys(u.constantTypes);for(let m=0;m<g.length;m++)f.push(u.constantTypes[g]);if(u.argumentTypes.indexOf("HTMLImageArray")!==-1||f.indexOf("HTMLImageArray")!==-1){const m=i.flattenFunctionToString((p?"function ":"")+u._imageTo3DArray.toString(),{doNotDefine:["canvas"],findDependency:(b,x)=>b==="this"?(p?"function ":"")+u[x].toString():null,thisLookup:b=>{switch(b){case"canvas":return;case"context":return"context"}}});d.push(m),c.push("    _mediaTo2DArray,"),c.push("    _imageTo3DArray,")}else if(u.argumentTypes.indexOf("HTMLImage")!==-1||f.indexOf("HTMLImage")!==-1){const m=i.flattenFunctionToString((p?"function ":"")+u._mediaTo2DArray.toString(),{findDependency:(b,x)=>null,thisLookup:b=>{switch(b){case"canvas":return"settings.canvas";case"context":return"settings.context"}throw new Error("unhandled thisLookup")}});d.push(m),c.push("    _mediaTo2DArray,")}return`function(settings) {
${h.join(`
`)}
  for (const p in _constantTypes) {
    if (!_constantTypes.hasOwnProperty(p)) continue;
    const type = _constantTypes[p];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        if (incomingConstants.hasOwnProperty(p)) {
          console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');
        }
        continue;
    }
    if (!incomingConstants.hasOwnProperty(p)) {
      throw new Error('constant ' + p + ' not found');
    }
    _constants[p] = incomingConstants[p];
  }
  const kernel = (function() {
${u._kernelString}
  })
    .apply({ ${c.join(`
`)} });
  ${d.join(`
`)}
  return kernel;
}`}s.exports={cpuKernelString:a}},{"../../utils":114}],8:[function(t,s,r){const{Kernel:i}=t("../kernel"),{FunctionBuilder:o}=t("../function-builder"),{CPUFunctionNode:a}=t("./function-node"),{utils:u}=t("../../utils"),{cpuKernelString:l}=t("./kernel-string");class h extends i{static getFeatures(){return this.features}static get features(){return Object.freeze({kernelMap:!0,isIntegerDivisionAccurate:!0})}static get isSupported(){return!0}static isContextMatch(d){return!1}static get mode(){return"cpu"}static nativeFunctionArguments(){return null}static nativeFunctionReturnType(){throw new Error(`Looking up native function return type not supported on ${this.name}`)}static combineKernels(d){return d}static getSignature(d,p){return"cpu"+(p.length>0?":"+p.join(","):"")}constructor(d,p){super(d,p),this.mergeSettings(d.settings||p),this._imageData=null,this._colorData=null,this._kernelString=null,this._prependedString=[],this.thread={x:0,y:0,z:0},this.translatedSources=null}initCanvas(){if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(0,0)}initContext(){return this.canvas?this.canvas.getContext("2d"):null}initPlugins(d){return[]}validateSettings(d){if(!this.output||this.output.length===0){if(d.length!==1)throw new Error("Auto output only supported for kernels with only one input");const p=u.getVariableType(d[0],this.strictIntegers);if(p==="Array")this.output=u.getDimensions(p);else if(p==="NumberTexture"||p==="ArrayTexture(4)")this.output=d[0].output;else throw new Error("Auto output not supported for input type: "+p)}if(this.graphical&&this.output.length!==2)throw new Error("Output must have 2 dimensions on graphical mode");this.checkOutput()}translateSource(){if(this.leadingReturnStatement=this.output.length>1?"resultX[x] = ":"result[x] = ",this.subKernels){const p=[];for(let f=0;f<this.subKernels.length;f++){const{name:g}=this.subKernels[f];p.push(this.output.length>1?`resultX_${g}[x] = subKernelResult_${g};
`:`result_${g}[x] = subKernelResult_${g};
`)}this.followingReturnStatement=p.join("")}const d=o.fromKernel(this,a);this.translatedSources=d.getPrototypes("kernel"),!this.graphical&&!this.returnType&&(this.returnType=d.getKernelResultType())}build(){if(this.built)return;if(this.setupConstants(),this.setupArguments(arguments),this.validateSettings(arguments),this.translateSource(),this.graphical){const{canvas:p,output:f}=this;if(!p)throw new Error("no canvas available for using graphical output");const g=f[0],m=f[1]||1;p.width=g,p.height=m,this._imageData=this.context.createImageData(g,m),this._colorData=new Uint8ClampedArray(g*m*4)}const d=this.getKernelString();this.kernelString=d,this.debug&&(console.log("Function output:"),console.log(d));try{this.run=new Function([],d).bind(this)()}catch(p){console.error("An error occurred compiling the javascript: ",p)}this.buildSignature(arguments),this.built=!0}color(d,p,f,g){typeof g>"u"&&(g=1),d=Math.floor(d*255),p=Math.floor(p*255),f=Math.floor(f*255),g=Math.floor(g*255);const m=this.output[0],b=this.output[1],x=this.thread.x,v=b-this.thread.y-1,w=x+v*m;this._colorData[w*4+0]=d,this._colorData[w*4+1]=p,this._colorData[w*4+2]=f,this._colorData[w*4+3]=g}getKernelString(){if(this._kernelString!==null)return this._kernelString;let d=null,{translatedSources:p}=this;return p.length>1?p=p.filter(f=>/^function/.test(f)?f:(d=f,!1)):d=p.shift(),this._kernelString=`  const LOOP_MAX = ${this._getLoopMaxString()};
  ${this.injectedNative||""}
  const _this = this;
  ${this._resultKernelHeader()}
  ${this._processConstants()}
  return (${this.argumentNames.map(f=>"user_"+f).join(", ")}) => {
    ${this._prependedString.join("")}
    ${this._earlyThrows()}
    ${this._processArguments()}
    ${this.graphical?this._graphicalKernelBody(d):this._resultKernelBody(d)}
    ${p.length>0?p.join(`
`):""}
  };`}toString(){return l(this)}_getLoopMaxString(){return this.loopMaxIterations?` ${parseInt(this.loopMaxIterations)};`:" 1000;"}_processConstants(){if(!this.constants)return"";const d=[];for(let p in this.constants)switch(this.constantTypes[p]){case"HTMLCanvas":case"OffscreenCanvas":case"HTMLImage":case"ImageBitmap":case"ImageData":case"HTMLVideo":d.push(`    const constants_${p} = this._mediaTo2DArray(this.constants.${p});
`);break;case"HTMLImageArray":d.push(`    const constants_${p} = this._imageTo3DArray(this.constants.${p});
`);break;case"Input":d.push(`    const constants_${p} = this.constants.${p}.value;
`);break;default:d.push(`    const constants_${p} = this.constants.${p};
`)}return d.join("")}_earlyThrows(){if(this.graphical||this.immutable||!this.pipeline)return"";const d=[];for(let f=0;f<this.argumentTypes.length;f++)this.argumentTypes[f]==="Array"&&d.push(this.argumentNames[f]);if(d.length===0)return"";const p=[];for(let f=0;f<d.length;f++){const g=d[f],m=this._mapSubKernels(b=>`user_${g} === result_${b.name}`).join(" || ");p.push(`user_${g} === result${m?` || ${m}`:""}`)}return`if (${p.join(" || ")}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`}_processArguments(){const d=[];for(let p=0;p<this.argumentTypes.length;p++){const f=`user_${this.argumentNames[p]}`;switch(this.argumentTypes[p]){case"HTMLCanvas":case"OffscreenCanvas":case"HTMLImage":case"ImageBitmap":case"ImageData":case"HTMLVideo":d.push(`    ${f} = this._mediaTo2DArray(${f});
`);break;case"HTMLImageArray":d.push(`    ${f} = this._imageTo3DArray(${f});
`);break;case"Input":d.push(`    ${f} = ${f}.value;
`);break;case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":case"NumberTexture":case"MemoryOptimizedNumberTexture":d.push(`
    if (${f}.toArray) {
      if (!_this.textureCache) {
        _this.textureCache = [];
        _this.arrayCache = [];
      }
      const textureIndex = _this.textureCache.indexOf(${f});
      if (textureIndex !== -1) {
        ${f} = _this.arrayCache[textureIndex];
      } else {
        _this.textureCache.push(${f});
        ${f} = ${f}.toArray();
        _this.arrayCache.push(${f});
      }
    }`);break}}return d.join("")}_mediaTo2DArray(d){const p=this.canvas,f=d.width>0?d.width:d.videoWidth,g=d.height>0?d.height:d.videoHeight;p.width<f&&(p.width=f),p.height<g&&(p.height=g);const m=this.context;let b;d.constructor===ImageData?b=d.data:(m.drawImage(d,0,0,f,g),b=m.getImageData(0,0,f,g).data);const x=new Array(g);let v=0;for(let w=g-1;w>=0;w--){const S=x[w]=new Array(f);for(let k=0;k<f;k++){const E=new Float32Array(4);E[0]=b[v++]/255,E[1]=b[v++]/255,E[2]=b[v++]/255,E[3]=b[v++]/255,S[k]=E}}return x}getPixels(d){const[p,f]=this.output;return d?u.flipPixels(this._imageData.data,p,f):this._imageData.data.slice(0)}_imageTo3DArray(d){const p=new Array(d.length);for(let f=0;f<d.length;f++)p[f]=this._mediaTo2DArray(d[f]);return p}_resultKernelHeader(){if(this.graphical||this.immutable||!this.pipeline)return"";switch(this.output.length){case 1:return this._mutableKernel1DResults();case 2:return this._mutableKernel2DResults();case 3:return this._mutableKernel3DResults()}}_resultKernelBody(d){switch(this.output.length){case 1:return(!this.immutable&&this.pipeline?this._resultMutableKernel1DLoop(d):this._resultImmutableKernel1DLoop(d))+this._kernelOutput();case 2:return(!this.immutable&&this.pipeline?this._resultMutableKernel2DLoop(d):this._resultImmutableKernel2DLoop(d))+this._kernelOutput();case 3:return(!this.immutable&&this.pipeline?this._resultMutableKernel3DLoop(d):this._resultImmutableKernel3DLoop(d))+this._kernelOutput();default:throw new Error("unsupported size kernel")}}_graphicalKernelBody(d){switch(this.output.length){case 2:return this._graphicalKernel2DLoop(d)+this._graphicalOutput();default:throw new Error("unsupported size kernel")}}_graphicalOutput(){return`
    this._imageData.data.set(this._colorData);
    this.context.putImageData(this._imageData, 0, 0);
    return;`}_getKernelResultTypeConstructorString(){switch(this.returnType){case"LiteralInteger":case"Number":case"Integer":case"Float":return"Float32Array";case"Array(2)":case"Array(3)":case"Array(4)":return"Array";default:if(this.graphical)return"Float32Array";throw new Error(`unhandled returnType ${this.returnType}`)}}_resultImmutableKernel1DLoop(d){const p=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const result = new ${p}(outputX);
    ${this._mapSubKernels(f=>`const result_${f.name} = new ${p}(outputX);
`).join("    ")}
    ${this._mapSubKernels(f=>`let subKernelResult_${f.name};
`).join("    ")}
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${d}
    }`}_mutableKernel1DResults(){const d=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const result = new ${d}(outputX);
    ${this._mapSubKernels(p=>`const result_${p.name} = new ${d}(outputX);
`).join("    ")}
    ${this._mapSubKernels(p=>`let subKernelResult_${p.name};
`).join("    ")}`}_resultMutableKernel1DLoop(d){return`  const outputX = _this.output[0];
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${d}
    }`}_resultImmutableKernel2DLoop(d){const p=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${this._mapSubKernels(f=>`const result_${f.name} = new Array(outputY);
`).join("    ")}
    ${this._mapSubKernels(f=>`let subKernelResult_${f.name};
`).join("    ")}
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y] = new ${p}(outputX);
      ${this._mapSubKernels(f=>`const resultX_${f.name} = result_${f.name}[y] = new ${p}(outputX);
`).join("")}
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${d}
      }
    }`}_mutableKernel2DResults(){const d=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${this._mapSubKernels(p=>`const result_${p.name} = new Array(outputY);
`).join("    ")}
    ${this._mapSubKernels(p=>`let subKernelResult_${p.name};
`).join("    ")}
    for (let y = 0; y < outputY; y++) {
      const resultX = result[y] = new ${d}(outputX);
      ${this._mapSubKernels(p=>`const resultX_${p.name} = result_${p.name}[y] = new ${d}(outputX);
`).join("")}
    }`}_resultMutableKernel2DLoop(d){const p=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y];
      ${this._mapSubKernels(f=>`const resultX_${f.name} = result_${f.name}[y] = new ${p}(outputX);
`).join("")}
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${d}
      }
    }`}_graphicalKernel2DLoop(d){return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${d}
      }
    }`}_resultImmutableKernel3DLoop(d){const p=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${this._mapSubKernels(f=>`const result_${f.name} = new Array(outputZ);
`).join("    ")}
    ${this._mapSubKernels(f=>`let subKernelResult_${f.name};
`).join("    ")}
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z] = new Array(outputY);
      ${this._mapSubKernels(f=>`const resultY_${f.name} = result_${f.name}[z] = new Array(outputY);
`).join("      ")}
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y] = new ${p}(outputX);
        ${this._mapSubKernels(f=>`const resultX_${f.name} = resultY_${f.name}[y] = new ${p}(outputX);
`).join("        ")}
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${d}
        }
      }
    }`}_mutableKernel3DResults(){const d=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${this._mapSubKernels(p=>`const result_${p.name} = new Array(outputZ);
`).join("    ")}
    ${this._mapSubKernels(p=>`let subKernelResult_${p.name};
`).join("    ")}
    for (let z = 0; z < outputZ; z++) {
      const resultY = result[z] = new Array(outputY);
      ${this._mapSubKernels(p=>`const resultY_${p.name} = result_${p.name}[z] = new Array(outputY);
`).join("      ")}
      for (let y = 0; y < outputY; y++) {
        const resultX = resultY[y] = new ${d}(outputX);
        ${this._mapSubKernels(p=>`const resultX_${p.name} = resultY_${p.name}[y] = new ${d}(outputX);
`).join("        ")}
      }
    }`}_resultMutableKernel3DLoop(d){return`  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z];
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y];
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${d}
        }
      }
    }`}_kernelOutput(){return this.subKernels?`
    return {
      result: result,
      ${this.subKernels.map(d=>`${d.property}: result_${d.name}`).join(`,
      `)}
    };`:`
    return result;`}_mapSubKernels(d){return this.subKernels===null?[""]:this.subKernels.map(d)}destroy(d){d&&delete this.canvas}static destroyContext(d){}toJSON(){const d=super.toJSON();return d.functionNodes=o.fromKernel(this,a).toJSON(),d}setOutput(d){super.setOutput(d);const[p,f]=this.output;this.graphical&&(this._imageData=this.context.createImageData(p,f),this._colorData=new Uint8ClampedArray(p*f*4))}prependString(d){if(this._kernelString)throw new Error("Kernel already built");this._prependedString.push(d)}hasPrependString(d){return this._prependedString.indexOf(d)>-1}}s.exports={CPUKernel:h}},{"../../utils":114,"../function-builder":9,"../kernel":36,"./function-node":6,"./kernel-string":7}],9:[function(t,s,r){class i{static fromKernel(a,u,l){const{kernelArguments:h,kernelConstants:c,argumentNames:d,argumentSizes:p,argumentBitRatios:f,constants:g,constantBitRatios:m,debug:b,loopMaxIterations:x,nativeFunctions:v,output:w,optimizeFloatMemory:S,precision:k,plugins:E,source:I,subKernels:C,functions:T,leadingReturnStatement:R,followingReturnStatement:P,dynamicArguments:D,dynamicOutput:F}=a,z=new Array(h.length),_={};for(let G=0;G<h.length;G++)z[G]=h[G].type;for(let G=0;G<c.length;G++){const ee=c[G];_[ee.name]=ee.type}const B=(G,ee)=>V.needsArgumentType(G,ee),N=(G,ee,ue)=>{V.assignArgumentType(G,ee,ue)},O=(G,ee,ue)=>V.lookupReturnType(G,ee,ue),K=G=>V.lookupFunctionArgumentTypes(G),U=(G,ee)=>V.lookupFunctionArgumentName(G,ee),X=(G,ee)=>V.lookupFunctionArgumentBitRatio(G,ee),te=(G,ee,ue,ae)=>{V.assignArgumentType(G,ee,ue,ae)},ie=(G,ee,ue,ae)=>{V.assignArgumentBitRatio(G,ee,ue,ae)},re=(G,ee,ue)=>{V.trackFunctionCall(G,ee,ue)},he=(G,ee)=>{const ue=[];for(let ce=0;ce<G.params.length;ce++)ue.push(G.params[ce].name);const ae=new u(ee,Object.assign({},Se,{returnType:null,ast:G,name:G.id.name,argumentNames:ue,lookupReturnType:O,lookupFunctionArgumentTypes:K,lookupFunctionArgumentName:U,lookupFunctionArgumentBitRatio:X,needsArgumentType:B,assignArgumentType:N,triggerImplyArgumentType:te,triggerImplyArgumentBitRatio:ie,onFunctionCall:re}));ae.traceFunctionAST(G),V.addFunctionNode(ae)},Se=Object.assign({isRootKernel:!1,onNestedFunction:he,lookupReturnType:O,lookupFunctionArgumentTypes:K,lookupFunctionArgumentName:U,lookupFunctionArgumentBitRatio:X,needsArgumentType:B,assignArgumentType:N,triggerImplyArgumentType:te,triggerImplyArgumentBitRatio:ie,onFunctionCall:re,optimizeFloatMemory:S,precision:k,constants:g,constantTypes:_,constantBitRatios:m,debug:b,loopMaxIterations:x,output:w,plugins:E,dynamicArguments:D,dynamicOutput:F},l||{}),xe=Object.assign({},Se,{isRootKernel:!0,name:"kernel",argumentNames:d,argumentTypes:z,argumentSizes:p,argumentBitRatios:f,leadingReturnStatement:R,followingReturnStatement:P});if(typeof I=="object"&&I.functionNodes)return new i().fromJSON(I.functionNodes,u);const Ce=new u(I,xe);let De=null;T&&(De=T.map(G=>new u(G.source,{returnType:G.returnType,argumentTypes:G.argumentTypes,output:w,plugins:E,constants:g,constantTypes:_,constantBitRatios:m,optimizeFloatMemory:S,precision:k,lookupReturnType:O,lookupFunctionArgumentTypes:K,lookupFunctionArgumentName:U,lookupFunctionArgumentBitRatio:X,needsArgumentType:B,assignArgumentType:N,triggerImplyArgumentType:te,triggerImplyArgumentBitRatio:ie,onFunctionCall:re,onNestedFunction:he})));let Ue=null;C&&(Ue=C.map(G=>{const{name:ee,source:ue}=G;return new u(ue,Object.assign({},Se,{name:ee,isSubKernel:!0,isRootKernel:!1}))}));const V=new i({kernel:a,rootNode:Ce,functionNodes:De,nativeFunctions:v,subKernelNodes:Ue});return V}constructor(a){if(a=a||{},this.kernel=a.kernel,this.rootNode=a.rootNode,this.functionNodes=a.functionNodes||[],this.subKernelNodes=a.subKernelNodes||[],this.nativeFunctions=a.nativeFunctions||[],this.functionMap={},this.nativeFunctionNames=[],this.lookupChain=[],this.functionNodeDependencies={},this.functionCalls={},this.rootNode&&(this.functionMap.kernel=this.rootNode),this.functionNodes)for(let u=0;u<this.functionNodes.length;u++)this.functionMap[this.functionNodes[u].name]=this.functionNodes[u];if(this.subKernelNodes)for(let u=0;u<this.subKernelNodes.length;u++)this.functionMap[this.subKernelNodes[u].name]=this.subKernelNodes[u];if(this.nativeFunctions)for(let u=0;u<this.nativeFunctions.length;u++){const l=this.nativeFunctions[u];this.nativeFunctionNames.push(l.name)}}addFunctionNode(a){if(!a.name)throw new Error("functionNode.name needs set");this.functionMap[a.name]=a,a.isRootKernel&&(this.rootNode=a)}traceFunctionCalls(a,u){if(a=a||"kernel",u=u||[],this.nativeFunctionNames.indexOf(a)>-1){const h=u.indexOf(a);if(h===-1)u.push(a);else{const c=u.splice(h,1)[0];u.push(c)}return u}const l=this.functionMap[a];if(l){const h=u.indexOf(a);if(h===-1){u.push(a),l.toString();for(let c=0;c<l.calledFunctions.length;++c)this.traceFunctionCalls(l.calledFunctions[c],u)}else{const c=u.splice(h,1)[0];u.push(c)}}return u}getPrototypeString(a){return this.getPrototypes(a).join(`
`)}getPrototypes(a){return this.rootNode&&this.rootNode.toString(),a?this.getPrototypesFromFunctionNames(this.traceFunctionCalls(a,[]).reverse()):this.getPrototypesFromFunctionNames(Object.keys(this.functionMap))}getStringFromFunctionNames(a){const u=[];for(let l=0;l<a.length;++l)this.functionMap[a[l]]&&u.push(this.functionMap[a[l]].toString());return u.join(`
`)}getPrototypesFromFunctionNames(a){const u=[];for(let l=0;l<a.length;++l){const h=a[l],c=this.nativeFunctionNames.indexOf(h);if(c>-1){u.push(this.nativeFunctions[c].source);continue}const d=this.functionMap[h];d&&u.push(d.toString())}return u}toJSON(){return this.traceFunctionCalls(this.rootNode.name).reverse().map(a=>{const u=this.nativeFunctions.indexOf(a);if(u>-1)return{name:a,source:this.nativeFunctions[u].source};if(this.functionMap[a])return this.functionMap[a].toJSON();throw new Error(`function ${a} not found`)})}fromJSON(a,u){this.functionMap={};for(let l=0;l<a.length;l++){const h=a[l];this.functionMap[h.settings.name]=new u(h.ast,h.settings)}return this}getString(a){return a?this.getStringFromFunctionNames(this.traceFunctionCalls(a).reverse()):this.getStringFromFunctionNames(Object.keys(this.functionMap))}lookupReturnType(a,u,l){if(u.type!=="CallExpression")throw new Error(`expected ast type of "CallExpression", but is ${u.type}`);if(this._isNativeFunction(a))return this._lookupNativeFunctionReturnType(a);if(this._isFunction(a)){const h=this._getFunction(a);if(h.returnType)return h.returnType;{for(let d=0;d<this.lookupChain.length;d++)if(this.lookupChain[d].ast===u){if(h.argumentTypes.length===0&&u.arguments.length>0){const p=u.arguments;for(let f=0;f<p.length;f++)this.lookupChain.push({name:l.name,ast:p[d],requestingNode:l}),h.argumentTypes[f]=l.getType(p[f]),this.lookupChain.pop();return h.returnType=h.getType(h.getJsAST())}throw new Error("circlical logic detected!")}this.lookupChain.push({name:l.name,ast:u,requestingNode:l});const c=h.getType(h.getJsAST());return this.lookupChain.pop(),h.returnType=c}}return null}_getFunction(a){return this._isFunction(a),this.functionMap[a]}_isFunction(a){return!!this.functionMap[a]}_getNativeFunction(a){for(let u=0;u<this.nativeFunctions.length;u++)if(this.nativeFunctions[u].name===a)return this.nativeFunctions[u];return null}_isNativeFunction(a){return!!this._getNativeFunction(a)}_lookupNativeFunctionReturnType(a){let u=this._getNativeFunction(a);if(u)return u.returnType;throw new Error(`Native function ${a} not found`)}lookupFunctionArgumentTypes(a){return this._isNativeFunction(a)?this._getNativeFunction(a).argumentTypes:this._isFunction(a)?this._getFunction(a).argumentTypes:null}lookupFunctionArgumentName(a,u){return this._getFunction(a).argumentNames[u]}lookupFunctionArgumentBitRatio(a,u){if(!this._isFunction(a))throw new Error("function not found");if(this.rootNode.name===a){const d=this.rootNode.argumentNames.indexOf(u);if(d!==-1)return this.rootNode.argumentBitRatios[d]}const l=this._getFunction(a),h=l.argumentNames.indexOf(u);if(h===-1)throw new Error("argument not found");const c=l.argumentBitRatios[h];if(typeof c!="number")throw new Error("argument bit ratio not found");return c}needsArgumentType(a,u){return this._isFunction(a)?!this._getFunction(a).argumentTypes[u]:!1}assignArgumentType(a,u,l,h){if(!this._isFunction(a))return;const c=this._getFunction(a);c.argumentTypes[u]||(c.argumentTypes[u]=l)}assignArgumentBitRatio(a,u,l,h){const c=this._getFunction(a);if(this._isNativeFunction(l))return null;const d=this._getFunction(l),p=c.argumentNames.indexOf(u);if(p===-1)throw new Error(`Argument ${u} not found in arguments from function ${a}`);const f=c.argumentBitRatios[p];if(typeof f!="number")throw new Error(`Bit ratio for argument ${u} not found in function ${a}`);d.argumentBitRatios||(d.argumentBitRatios=new Array(d.argumentNames.length));const g=d.argumentBitRatios[p];if(typeof g=="number"){if(g!==f)throw new Error(`Incompatible bit ratio found at function ${a} at argument ${u}`);return g}return d.argumentBitRatios[p]=f,f}trackFunctionCall(a,u,l){this.functionNodeDependencies[a]||(this.functionNodeDependencies[a]=new Set,this.functionCalls[a]=[]),this.functionNodeDependencies[a].add(u),this.functionCalls[a].push(l)}getKernelResultType(){return this.rootNode.returnType||this.rootNode.getType(this.rootNode.ast)}getSubKernelResultType(a){const u=this.subKernelNodes[a];let l=!1;for(let h=0;h<this.rootNode.functionCalls.length;h++)this.rootNode.functionCalls[h].ast.callee.name===u.name&&(l=!0);if(!l)throw new Error(`SubKernel ${u.name} never called by kernel`);return u.returnType||u.getType(u.getJsAST())}getReturnTypes(){const a={[this.rootNode.name]:this.rootNode.getType(this.rootNode.ast)},u=this.traceFunctionCalls(this.rootNode.name);for(let l=0;l<u.length;l++){const h=u[l],c=this.functionMap[h];a[h]=c.getType(c.ast)}return a}}s.exports={FunctionBuilder:i}},{}],10:[function(t,s,r){const i=t("acorn"),{utils:o}=t("../utils"),{FunctionTracer:a}=t("./function-tracer");class u{constructor(c,d){if(!c&&!d.ast)throw new Error("source parameter is missing");if(d=d||{},this.source=c,this.ast=null,this.name=typeof c=="string"?d.isRootKernel?"kernel":d.name||o.getFunctionNameFromString(c):null,this.calledFunctions=[],this.constants={},this.constantTypes={},this.constantBitRatios={},this.isRootKernel=!1,this.isSubKernel=!1,this.debug=null,this.functions=null,this.identifiers=null,this.contexts=null,this.functionCalls=null,this.states=[],this.needsArgumentType=null,this.assignArgumentType=null,this.lookupReturnType=null,this.lookupFunctionArgumentTypes=null,this.lookupFunctionArgumentBitRatio=null,this.triggerImplyArgumentType=null,this.triggerImplyArgumentBitRatio=null,this.onNestedFunction=null,this.onFunctionCall=null,this.optimizeFloatMemory=null,this.precision=null,this.loopMaxIterations=null,this.argumentNames=typeof this.source=="string"?o.getArgumentNamesFromString(this.source):null,this.argumentTypes=[],this.argumentSizes=[],this.argumentBitRatios=null,this.returnType=null,this.output=[],this.plugins=null,this.leadingReturnStatement=null,this.followingReturnStatement=null,this.dynamicOutput=null,this.dynamicArguments=null,this.strictTypingChecking=!1,this.fixIntegerDivisionAccuracy=null,d)for(const p in d)d.hasOwnProperty(p)&&this.hasOwnProperty(p)&&(this[p]=d[p]);this.literalTypes={},this.validate(),this._string=null,this._internalVariableNames={}}validate(){if(typeof this.source!="string"&&!this.ast)throw new Error("this.source not a string");if(!this.ast&&!o.isFunctionString(this.source))throw new Error("this.source not a function string");if(!this.name)throw new Error("this.name could not be set");if(this.argumentTypes.length>0&&this.argumentTypes.length!==this.argumentNames.length)throw new Error(`argumentTypes count of ${this.argumentTypes.length} exceeds ${this.argumentNames.length}`);if(this.output.length<1)throw new Error("this.output is not big enough")}isIdentifierConstant(c){return this.constants?this.constants.hasOwnProperty(c):!1}isInput(c){return this.argumentTypes[this.argumentNames.indexOf(c)]==="Input"}pushState(c){this.states.push(c)}popState(c){if(this.state!==c)throw new Error(`Cannot popState ${c} when in ${this.state}`);this.states.pop()}isState(c){return this.state===c}get state(){return this.states[this.states.length-1]}astMemberExpressionUnroll(c){if(c.type==="Identifier")return c.name;if(c.type==="ThisExpression")return"this";if(c.type==="MemberExpression"&&c.object&&c.property)return c.object.hasOwnProperty("name")&&c.object.name!=="Math"?this.astMemberExpressionUnroll(c.property):this.astMemberExpressionUnroll(c.object)+"."+this.astMemberExpressionUnroll(c.property);if(c.hasOwnProperty("expressions")){const d=c.expressions[0];if(d.type==="Literal"&&d.value===0&&c.expressions.length===2)return this.astMemberExpressionUnroll(c.expressions[1])}throw this.astErrorOutput("Unknown astMemberExpressionUnroll",c)}getJsAST(c){if(this.ast)return this.ast;if(typeof this.source=="object")return this.traceFunctionAST(this.source),this.ast=this.source;if(c=c||i,c===null)throw new Error("Missing JS to AST parser");const d=Object.freeze(c.parse(`const parser_${this.name} = ${this.source};`,{locations:!0})),p=d.body[0].declarations[0].init;if(this.traceFunctionAST(p),!d)throw new Error("Failed to parse JS code");return this.ast=p}traceFunctionAST(c){const{contexts:d,declarations:p,functions:f,identifiers:g,functionCalls:m}=new a(c);this.contexts=d,this.identifiers=g,this.functionCalls=m,this.functions=f;for(let b=0;b<p.length;b++){const x=p[b],{ast:v,inForLoopInit:w,inForLoopTest:S}=x,{init:k}=v,E=this.getDependencies(k);let I=null;if(w&&S)I="Integer";else if(k){const C=this.getType(k);switch(C){case"Integer":case"Float":case"Number":k.type==="MemberExpression"?I=C:I="Number";break;case"LiteralInteger":I="Number";break;default:I=C}}x.valueType=I,x.dependencies=E,x.isSafe=this.isSafeDependencies(E)}for(let b=0;b<f.length;b++)this.onNestedFunction(f[b],this.source)}getDeclaration(c){for(let d=0;d<this.identifiers.length;d++){const p=this.identifiers[d];if(c===p.ast)return p.declaration}return null}getVariableType(c){if(c.type!=="Identifier")throw new Error(`ast of ${c.type} not "Identifier"`);let d=null;const p=this.argumentNames.indexOf(c.name);if(p===-1){const f=this.getDeclaration(c);if(f)return f.valueType}else{const f=this.argumentTypes[p];f&&(d=f)}if(!d&&this.strictTypingChecking)throw new Error(`Declaration of ${name} not found`);return d}getLookupType(c){if(!l.hasOwnProperty(c))throw new Error(`unknown typeLookupMap ${c}`);return l[c]}getConstantType(c){if(this.constantTypes[c]){const d=this.constantTypes[c];return d==="Float"?"Number":d}throw new Error(`Type for constant "${c}" not declared`)}toString(){return this._string?this._string:this._string=this.astGeneric(this.getJsAST(),[]).join("").trim()}toJSON(){const c={source:this.source,name:this.name,constants:this.constants,constantTypes:this.constantTypes,isRootKernel:this.isRootKernel,isSubKernel:this.isSubKernel,debug:this.debug,output:this.output,loopMaxIterations:this.loopMaxIterations,argumentNames:this.argumentNames,argumentTypes:this.argumentTypes,argumentSizes:this.argumentSizes,returnType:this.returnType,leadingReturnStatement:this.leadingReturnStatement,followingReturnStatement:this.followingReturnStatement};return{ast:this.ast,settings:c}}getType(c){if(Array.isArray(c))return this.getType(c[c.length-1]);switch(c.type){case"BlockStatement":return this.getType(c.body);case"ArrayExpression":switch(this.getType(c.elements[0])){case"Array(2)":case"Array(3)":case"Array(4)":return`Matrix(${c.elements.length})`}return`Array(${c.elements.length})`;case"Literal":const p=this.astKey(c);return this.literalTypes[p]?this.literalTypes[p]:Number.isInteger(c.value)?"LiteralInteger":c.value===!0||c.value===!1?"Boolean":"Number";case"AssignmentExpression":return this.getType(c.left);case"CallExpression":if(this.isAstMathFunction(c))return"Number";if(!c.callee||!c.callee.name){if(c.callee.type==="SequenceExpression"&&c.callee.expressions[c.callee.expressions.length-1].property.name){const x=c.callee.expressions[c.callee.expressions.length-1].property.name;return this.inferArgumentTypesIfNeeded(x,c.arguments),this.lookupReturnType(x,c,this)}if(this.getVariableSignature(c.callee,!0)==="this.color")return null;if(c.callee.type==="MemberExpression"&&c.callee.object&&c.callee.property&&c.callee.property.name&&c.arguments){const x=c.callee.property.name;return this.inferArgumentTypesIfNeeded(x,c.arguments),this.lookupReturnType(x,c,this)}throw this.astErrorOutput("Unknown call expression",c)}if(c.callee&&c.callee.name){const x=c.callee.name;return this.inferArgumentTypesIfNeeded(x,c.arguments),this.lookupReturnType(x,c,this)}throw this.astErrorOutput(`Unhandled getType Type "${c.type}"`,c);case"LogicalExpression":return"Boolean";case"BinaryExpression":switch(c.operator){case"%":case"/":if(this.fixIntegerDivisionAccuracy)return"Number";break;case">":case"<":return"Boolean";case"&":case"|":case"^":case"<<":case">>":case">>>":return"Integer"}const f=this.getType(c.left);if(this.isState("skip-literal-correction"))return f;if(f==="LiteralInteger"){const x=this.getType(c.right);return x==="LiteralInteger"?c.left.value%1===0?"Integer":"Float":x}return l[f]||f;case"UpdateExpression":return this.getType(c.argument);case"UnaryExpression":return c.operator==="~"?"Integer":this.getType(c.argument);case"VariableDeclaration":{const x=c.declarations;let v;for(let w=0;w<x.length;w++){const S=x[w];v=this.getType(S)}if(!v)throw this.astErrorOutput("Unable to find type for declaration",c);return v}case"VariableDeclarator":const g=this.getDeclaration(c.id);if(!g)throw this.astErrorOutput("Unable to find declarator",c);if(!g.valueType)throw this.astErrorOutput("Unable to find declarator valueType",c);return g.valueType;case"Identifier":if(c.name==="Infinity")return"Number";if(this.isAstVariable(c)&&this.getVariableSignature(c)==="value")return this.getCheckVariableType(c);const m=this.findIdentifierOrigin(c);return m&&m.init?this.getType(m.init):null;case"ReturnStatement":return this.getType(c.argument);case"MemberExpression":if(this.isAstMathFunction(c)){switch(c.property.name){case"ceil":return"Integer";case"floor":return"Integer";case"round":return"Integer"}return"Number"}if(this.isAstVariable(c)){switch(this.getVariableSignature(c)){case"value[]":return this.getLookupType(this.getCheckVariableType(c.object));case"value[][]":return this.getLookupType(this.getCheckVariableType(c.object.object));case"value[][][]":return this.getLookupType(this.getCheckVariableType(c.object.object.object));case"value[][][][]":return this.getLookupType(this.getCheckVariableType(c.object.object.object.object));case"value.thread.value":case"this.thread.value":return"Integer";case"this.output.value":return this.dynamicOutput?"Integer":"LiteralInteger";case"this.constants.value":return this.getConstantType(c.property.name);case"this.constants.value[]":return this.getLookupType(this.getConstantType(c.object.property.name));case"this.constants.value[][]":return this.getLookupType(this.getConstantType(c.object.object.property.name));case"this.constants.value[][][]":return this.getLookupType(this.getConstantType(c.object.object.object.property.name));case"this.constants.value[][][][]":return this.getLookupType(this.getConstantType(c.object.object.object.object.property.name));case"fn()[]":case"fn()[][]":case"fn()[][][]":return this.getLookupType(this.getType(c.object));case"value.value":if(this.isAstMathVariable(c))return"Number";switch(c.property.name){case"r":case"g":case"b":case"a":return this.getLookupType(this.getCheckVariableType(c.object))}case"[][]":return"Number"}throw this.astErrorOutput("Unhandled getType MemberExpression",c)}throw this.astErrorOutput("Unhandled getType MemberExpression",c);case"ConditionalExpression":return this.getType(c.consequent);case"FunctionDeclaration":case"FunctionExpression":const b=this.findLastReturn(c.body);return b?this.getType(b):null;case"IfStatement":return this.getType(c.consequent);case"SequenceExpression":return this.getType(c.expressions[c.expressions.length-1]);default:throw this.astErrorOutput(`Unhandled getType Type "${c.type}"`,c)}}getCheckVariableType(c){const d=this.getVariableType(c);if(!d)throw this.astErrorOutput(`${c.type} is not defined`,c);return d}inferArgumentTypesIfNeeded(c,d){for(let p=0;p<d.length;p++){if(!this.needsArgumentType(c,p))continue;const f=this.getType(d[p]);if(!f)throw this.astErrorOutput(`Unable to infer argument ${p}`,d[p]);this.assignArgumentType(c,p,f)}}isAstMathVariable(c){const d=["E","PI","SQRT2","SQRT1_2","LN2","LN10","LOG2E","LOG10E"];return c.type==="MemberExpression"&&c.object&&c.object.type==="Identifier"&&c.object.name==="Math"&&c.property&&c.property.type==="Identifier"&&d.indexOf(c.property.name)>-1}isAstMathFunction(c){const d=["abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","expm1","exp","floor","fround","imul","log","log2","log10","log1p","max","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc"];return c.type==="CallExpression"&&c.callee&&c.callee.type==="MemberExpression"&&c.callee.object&&c.callee.object.type==="Identifier"&&c.callee.object.name==="Math"&&c.callee.property&&c.callee.property.type==="Identifier"&&d.indexOf(c.callee.property.name)>-1}isAstVariable(c){return c.type==="Identifier"||c.type==="MemberExpression"}isSafe(c){return this.isSafeDependencies(this.getDependencies(c))}isSafeDependencies(c){return c&&c.every?c.every(d=>d.isSafe):!0}getDependencies(c,d,p){if(d||(d=[]),!c)return null;if(Array.isArray(c)){for(let f=0;f<c.length;f++)this.getDependencies(c[f],d,p);return d}switch(c.type){case"AssignmentExpression":return this.getDependencies(c.left,d,p),this.getDependencies(c.right,d,p),d;case"ConditionalExpression":return this.getDependencies(c.test,d,p),this.getDependencies(c.alternate,d,p),this.getDependencies(c.consequent,d,p),d;case"Literal":d.push({origin:"literal",value:c.value,isSafe:p===!0?!1:c.value>-1/0&&c.value<1/0&&!isNaN(c.value)});break;case"VariableDeclarator":return this.getDependencies(c.init,d,p);case"Identifier":const f=this.getDeclaration(c);if(f)d.push({name:c.name,origin:"declaration",isSafe:p?!1:this.isSafeDependencies(f.dependencies)});else if(this.argumentNames.indexOf(c.name)>-1)d.push({name:c.name,origin:"argument",isSafe:!1});else if(this.strictTypingChecking)throw new Error(`Cannot find identifier origin "${c.name}"`);break;case"FunctionDeclaration":return this.getDependencies(c.body.body[c.body.body.length-1],d,p);case"ReturnStatement":return this.getDependencies(c.argument,d);case"BinaryExpression":case"LogicalExpression":return p=c.operator==="/"||c.operator==="*",this.getDependencies(c.left,d,p),this.getDependencies(c.right,d,p),d;case"UnaryExpression":case"UpdateExpression":return this.getDependencies(c.argument,d,p);case"VariableDeclaration":return this.getDependencies(c.declarations,d,p);case"ArrayExpression":return d.push({origin:"declaration",isSafe:!0}),d;case"CallExpression":return d.push({origin:"function",isSafe:!0}),d;case"MemberExpression":const g=this.getMemberExpressionDetails(c);switch(g.signature){case"value[]":this.getDependencies(c.object,d,p);break;case"value[][]":this.getDependencies(c.object.object,d,p);break;case"value[][][]":this.getDependencies(c.object.object.object,d,p);break;case"this.output.value":this.dynamicOutput&&d.push({name:g.name,origin:"output",isSafe:!1});break}if(g)return g.property&&this.getDependencies(g.property,d,p),g.xProperty&&this.getDependencies(g.xProperty,d,p),g.yProperty&&this.getDependencies(g.yProperty,d,p),g.zProperty&&this.getDependencies(g.zProperty,d,p),d;case"SequenceExpression":return this.getDependencies(c.expressions,d,p);default:throw this.astErrorOutput(`Unhandled type ${c.type} in getDependencies`,c)}return d}getVariableSignature(c,d){if(!this.isAstVariable(c))throw new Error(`ast of type "${c.type}" is not a variable signature`);if(c.type==="Identifier")return"value";const p=[];for(;c;)c.computed?p.push("[]"):c.type==="ThisExpression"?p.unshift("this"):c.property&&c.property.name?c.property.name==="x"||c.property.name==="y"||c.property.name==="z"?p.unshift(d?"."+c.property.name:".value"):c.property.name==="constants"||c.property.name==="thread"||c.property.name==="output"?p.unshift("."+c.property.name):p.unshift(d?"."+c.property.name:".value"):c.name?p.unshift(d?c.name:"value"):c.callee&&c.callee.name?p.unshift(d?c.callee.name+"()":"fn()"):c.elements?p.unshift("[]"):p.unshift("unknown"),c=c.object;const f=p.join("");return d||["value","value[]","value[][]","value[][][]","value[][][][]","value.value","value.thread.value","this.thread.value","this.output.value","this.constants.value","this.constants.value[]","this.constants.value[][]","this.constants.value[][][]","this.constants.value[][][][]","fn()[]","fn()[][]","fn()[][][]","[][]"].indexOf(f)>-1?f:null}build(){return this.toString().length>0}astGeneric(c,d){if(c===null)throw this.astErrorOutput("NULL ast",c);if(Array.isArray(c)){for(let p=0;p<c.length;p++)this.astGeneric(c[p],d);return d}switch(c.type){case"FunctionDeclaration":return this.astFunctionDeclaration(c,d);case"FunctionExpression":return this.astFunctionExpression(c,d);case"ReturnStatement":return this.astReturnStatement(c,d);case"Literal":return this.astLiteral(c,d);case"BinaryExpression":return this.astBinaryExpression(c,d);case"Identifier":return this.astIdentifierExpression(c,d);case"AssignmentExpression":return this.astAssignmentExpression(c,d);case"ExpressionStatement":return this.astExpressionStatement(c,d);case"EmptyStatement":return this.astEmptyStatement(c,d);case"BlockStatement":return this.astBlockStatement(c,d);case"IfStatement":return this.astIfStatement(c,d);case"SwitchStatement":return this.astSwitchStatement(c,d);case"BreakStatement":return this.astBreakStatement(c,d);case"ContinueStatement":return this.astContinueStatement(c,d);case"ForStatement":return this.astForStatement(c,d);case"WhileStatement":return this.astWhileStatement(c,d);case"DoWhileStatement":return this.astDoWhileStatement(c,d);case"VariableDeclaration":return this.astVariableDeclaration(c,d);case"VariableDeclarator":return this.astVariableDeclarator(c,d);case"ThisExpression":return this.astThisExpression(c,d);case"SequenceExpression":return this.astSequenceExpression(c,d);case"UnaryExpression":return this.astUnaryExpression(c,d);case"UpdateExpression":return this.astUpdateExpression(c,d);case"LogicalExpression":return this.astLogicalExpression(c,d);case"MemberExpression":return this.astMemberExpression(c,d);case"CallExpression":return this.astCallExpression(c,d);case"ArrayExpression":return this.astArrayExpression(c,d);case"DebuggerStatement":return this.astDebuggerStatement(c,d);case"ConditionalExpression":return this.astConditionalExpression(c,d)}throw this.astErrorOutput("Unknown ast type : "+c.type,c)}astErrorOutput(c,d){if(typeof this.source!="string")return new Error(c);const p=o.getAstString(this.source,d),g=this.source.substr(d.start).split(/\n/),m=g.length>0?g[g.length-1]:0;return new Error(`${c} on line ${g.length}, position ${m.length}:
 ${p}`)}astDebuggerStatement(c,d){return d}astConditionalExpression(c,d){if(c.type!=="ConditionalExpression")throw this.astErrorOutput("Not a conditional expression",c);return d.push("("),this.astGeneric(c.test,d),d.push("?"),this.astGeneric(c.consequent,d),d.push(":"),this.astGeneric(c.alternate,d),d.push(")"),d}astFunction(c,d){throw new Error(`"astFunction" not defined on ${this.constructor.name}`)}astFunctionDeclaration(c,d){return this.isChildFunction(c)?d:this.astFunction(c,d)}astFunctionExpression(c,d){return this.isChildFunction(c)?d:this.astFunction(c,d)}isChildFunction(c){for(let d=0;d<this.functions.length;d++)if(this.functions[d]===c)return!0;return!1}astReturnStatement(c,d){return d}astLiteral(c,d){return this.literalTypes[this.astKey(c)]="Number",d}astBinaryExpression(c,d){return d}astIdentifierExpression(c,d){return d}astAssignmentExpression(c,d){return d}astExpressionStatement(c,d){return this.astGeneric(c.expression,d),d.push(";"),d}astEmptyStatement(c,d){return d}astBlockStatement(c,d){return d}astIfStatement(c,d){return d}astSwitchStatement(c,d){return d}astBreakStatement(c,d){return d.push("break;"),d}astContinueStatement(c,d){return d.push(`continue;
`),d}astForStatement(c,d){return d}astWhileStatement(c,d){return d}astDoWhileStatement(c,d){return d}astVariableDeclarator(c,d){return this.astGeneric(c.id,d),c.init!==null&&(d.push("="),this.astGeneric(c.init,d)),d}astThisExpression(c,d){return d}astSequenceExpression(c,d){const{expressions:p}=c,f=[];for(let g=0;g<p.length;g++){const m=p[g],b=[];this.astGeneric(m,b),f.push(b.join(""))}return f.length>1?d.push("(",f.join(","),")"):d.push(f[0]),d}astUnaryExpression(c,d){return this.checkAndUpconvertBitwiseUnary(c,d)||(c.prefix?(d.push(c.operator),this.astGeneric(c.argument,d)):(this.astGeneric(c.argument,d),d.push(c.operator))),d}checkAndUpconvertBitwiseUnary(c,d){}astUpdateExpression(c,d){return c.prefix?(d.push(c.operator),this.astGeneric(c.argument,d)):(this.astGeneric(c.argument,d),d.push(c.operator)),d}astLogicalExpression(c,d){return d.push("("),this.astGeneric(c.left,d),d.push(c.operator),this.astGeneric(c.right,d),d.push(")"),d}astMemberExpression(c,d){return d}astCallExpression(c,d){return d}astArrayExpression(c,d){return d}getMemberExpressionDetails(c){if(c.type!=="MemberExpression")throw this.astErrorOutput(`Expression ${c.type} not a MemberExpression`,c);let d=null,p=null;const f=this.getVariableSignature(c);switch(f){case"value":return null;case"value.thread.value":case"this.thread.value":case"this.output.value":return{signature:f,type:"Integer",name:c.property.name};case"value[]":if(typeof c.object.name!="string")throw this.astErrorOutput("Unexpected expression",c);return d=c.object.name,{name:d,origin:"user",signature:f,type:this.getVariableType(c.object),xProperty:c.property};case"value[][]":if(typeof c.object.object.name!="string")throw this.astErrorOutput("Unexpected expression",c);return d=c.object.object.name,{name:d,origin:"user",signature:f,type:this.getVariableType(c.object.object),yProperty:c.object.property,xProperty:c.property};case"value[][][]":if(typeof c.object.object.object.name!="string")throw this.astErrorOutput("Unexpected expression",c);return d=c.object.object.object.name,{name:d,origin:"user",signature:f,type:this.getVariableType(c.object.object.object),zProperty:c.object.object.property,yProperty:c.object.property,xProperty:c.property};case"value[][][][]":if(typeof c.object.object.object.object.name!="string")throw this.astErrorOutput("Unexpected expression",c);return d=c.object.object.object.object.name,{name:d,origin:"user",signature:f,type:this.getVariableType(c.object.object.object.object),zProperty:c.object.object.property,yProperty:c.object.property,xProperty:c.property};case"value.value":if(typeof c.property.name!="string")throw this.astErrorOutput("Unexpected expression",c);if(this.isAstMathVariable(c))return d=c.property.name,{name:d,origin:"Math",type:"Number",signature:f};switch(c.property.name){case"r":case"g":case"b":case"a":return d=c.object.name,{name:d,property:c.property.name,origin:"user",signature:f,type:"Number"};default:throw this.astErrorOutput("Unexpected expression",c)}case"this.constants.value":if(typeof c.property.name!="string")throw this.astErrorOutput("Unexpected expression",c);if(d=c.property.name,p=this.getConstantType(d),!p)throw this.astErrorOutput("Constant has no type",c);return{name:d,type:p,origin:"constants",signature:f};case"this.constants.value[]":if(typeof c.object.property.name!="string")throw this.astErrorOutput("Unexpected expression",c);if(d=c.object.property.name,p=this.getConstantType(d),!p)throw this.astErrorOutput("Constant has no type",c);return{name:d,type:p,origin:"constants",signature:f,xProperty:c.property};case"this.constants.value[][]":{if(typeof c.object.object.property.name!="string")throw this.astErrorOutput("Unexpected expression",c);if(d=c.object.object.property.name,p=this.getConstantType(d),!p)throw this.astErrorOutput("Constant has no type",c);return{name:d,type:p,origin:"constants",signature:f,yProperty:c.object.property,xProperty:c.property}}case"this.constants.value[][][]":{if(typeof c.object.object.object.property.name!="string")throw this.astErrorOutput("Unexpected expression",c);if(d=c.object.object.object.property.name,p=this.getConstantType(d),!p)throw this.astErrorOutput("Constant has no type",c);return{name:d,type:p,origin:"constants",signature:f,zProperty:c.object.object.property,yProperty:c.object.property,xProperty:c.property}}case"fn()[]":case"fn()[][]":case"[][]":return{signature:f,property:c.property};default:throw this.astErrorOutput("Unexpected expression",c)}}findIdentifierOrigin(c){const d=[this.ast];for(;d.length>0;){const p=d[0];if(p.type==="VariableDeclarator"&&p.id&&p.id.name&&p.id.name===c.name)return p;if(d.shift(),p.argument)d.push(p.argument);else if(p.body)d.push(p.body);else if(p.declarations)d.push(p.declarations);else if(Array.isArray(p))for(let f=0;f<p.length;f++)d.push(p[f])}return null}findLastReturn(c){const d=[c||this.ast];for(;d.length>0;){const p=d.pop();if(p.type==="ReturnStatement")return p;if(p.type!=="FunctionDeclaration")if(p.argument)d.push(p.argument);else if(p.body)d.push(p.body);else if(p.declarations)d.push(p.declarations);else if(Array.isArray(p))for(let f=0;f<p.length;f++)d.push(p[f]);else p.consequent?d.push(p.consequent):p.cases&&d.push(p.cases)}return null}getInternalVariableName(c){return this._internalVariableNames.hasOwnProperty(c)||(this._internalVariableNames[c]=0),this._internalVariableNames[c]++,this._internalVariableNames[c]===1?c:c+this._internalVariableNames[c]}astKey(c,d=","){if(!c.start||!c.end)throw new Error("AST start and end needed");return`${c.start}${d}${c.end}`}}const l={Number:"Number",Float:"Float",Integer:"Integer",Array:"Number","Array(2)":"Number","Array(3)":"Number","Array(4)":"Number","Matrix(2)":"Number","Matrix(3)":"Number","Matrix(4)":"Number",Array2D:"Number",Array3D:"Number",Input:"Number",HTMLCanvas:"Array(4)",OffscreenCanvas:"Array(4)",HTMLImage:"Array(4)",ImageBitmap:"Array(4)",ImageData:"Array(4)",HTMLVideo:"Array(4)",HTMLImageArray:"Array(4)",NumberTexture:"Number",MemoryOptimizedNumberTexture:"Number","Array1D(2)":"Array(2)","Array1D(3)":"Array(3)","Array1D(4)":"Array(4)","Array2D(2)":"Array(2)","Array2D(3)":"Array(3)","Array2D(4)":"Array(4)","Array3D(2)":"Array(2)","Array3D(3)":"Array(3)","Array3D(4)":"Array(4)","ArrayTexture(1)":"Number","ArrayTexture(2)":"Array(2)","ArrayTexture(3)":"Array(3)","ArrayTexture(4)":"Array(4)"};s.exports={FunctionNode:u}},{"../utils":114,"./function-tracer":11,acorn:1}],11:[function(t,s,r){const{utils:i}=t("../utils");function o(l){return l.length>0?l[l.length-1]:null}const a={trackIdentifiers:"trackIdentifiers",memberExpression:"memberExpression",inForLoopInit:"inForLoopInit"};class u{constructor(h){this.runningContexts=[],this.functionContexts=[],this.contexts=[],this.functionCalls=[],this.declarations=[],this.identifiers=[],this.functions=[],this.returnStatements=[],this.trackedIdentifiers=null,this.states=[],this.newFunctionContext(),this.scan(h)}isState(h){return this.states[this.states.length-1]===h}hasState(h){return this.states.indexOf(h)>-1}pushState(h){this.states.push(h)}popState(h){if(this.isState(h))this.states.pop();else throw new Error(`Cannot pop the non-active state "${h}"`)}get currentFunctionContext(){return o(this.functionContexts)}get currentContext(){return o(this.runningContexts)}newFunctionContext(){const h={"@contextType":"function"};this.contexts.push(h),this.functionContexts.push(h)}newContext(h){const c=Object.assign({"@contextType":"const/let"},this.currentContext);this.contexts.push(c),this.runningContexts.push(c),h();const{currentFunctionContext:d}=this;for(const p in d)!d.hasOwnProperty(p)||c.hasOwnProperty(p)||(c[p]=d[p]);return this.runningContexts.pop(),c}useFunctionContext(h){const c=o(this.functionContexts);this.runningContexts.push(c),h(),this.runningContexts.pop()}getIdentifiers(h){const c=this.trackedIdentifiers=[];return this.pushState(a.trackIdentifiers),h(),this.trackedIdentifiers=null,this.popState(a.trackIdentifiers),c}getDeclaration(h){const{currentContext:c,currentFunctionContext:d,runningContexts:p}=this,f=c[h]||d[h]||null;if(!f&&c===d&&p.length>0){const g=p[p.length-2];if(g[h])return g[h]}return f}scan(h){if(h){if(Array.isArray(h)){for(let c=0;c<h.length;c++)this.scan(h[c]);return}switch(h.type){case"Program":this.useFunctionContext(()=>{this.scan(h.body)});break;case"BlockStatement":this.newContext(()=>{this.scan(h.body)});break;case"AssignmentExpression":case"LogicalExpression":this.scan(h.left),this.scan(h.right);break;case"BinaryExpression":this.scan(h.left),this.scan(h.right);break;case"UpdateExpression":if(h.operator==="++"){const c=this.getDeclaration(h.argument.name);c&&(c.suggestedType="Integer")}this.scan(h.argument);break;case"UnaryExpression":this.scan(h.argument);break;case"VariableDeclaration":h.kind==="var"?this.useFunctionContext(()=>{h.declarations=i.normalizeDeclarations(h),this.scan(h.declarations)}):(h.declarations=i.normalizeDeclarations(h),this.scan(h.declarations));break;case"VariableDeclarator":{const{currentContext:c}=this,d=this.hasState(a.inForLoopInit),p={ast:h,context:c,name:h.id.name,origin:"declaration",inForLoopInit:d,inForLoopTest:null,assignable:c===this.currentFunctionContext||!d&&!c.hasOwnProperty(h.id.name),suggestedType:null,valueType:null,dependencies:null,isSafe:null};c[h.id.name]||(c[h.id.name]=p),this.declarations.push(p),this.scan(h.id),this.scan(h.init);break}case"FunctionExpression":case"FunctionDeclaration":this.runningContexts.length===0?this.scan(h.body):this.functions.push(h);break;case"IfStatement":this.scan(h.test),this.scan(h.consequent),h.alternate&&this.scan(h.alternate);break;case"ForStatement":{let c;const d=this.newContext(()=>{this.pushState(a.inForLoopInit),this.scan(h.init),this.popState(a.inForLoopInit),c=this.getIdentifiers(()=>{this.scan(h.test)}),this.scan(h.update),this.newContext(()=>{this.scan(h.body)})});if(c)for(const p in d)p!=="@contextType"&&c.indexOf(p)>-1&&(d[p].inForLoopTest=!0);break}case"DoWhileStatement":case"WhileStatement":this.newContext(()=>{this.scan(h.body),this.scan(h.test)});break;case"Identifier":{this.isState(a.trackIdentifiers)&&this.trackedIdentifiers.push(h.name),this.identifiers.push({context:this.currentContext,declaration:this.getDeclaration(h.name),ast:h});break}case"ReturnStatement":this.returnStatements.push(h),this.scan(h.argument);break;case"MemberExpression":this.pushState(a.memberExpression),this.scan(h.object),this.scan(h.property),this.popState(a.memberExpression);break;case"ExpressionStatement":this.scan(h.expression);break;case"SequenceExpression":this.scan(h.expressions);break;case"CallExpression":this.functionCalls.push({context:this.currentContext,ast:h}),this.scan(h.arguments);break;case"ArrayExpression":this.scan(h.elements);break;case"ConditionalExpression":this.scan(h.test),this.scan(h.alternate),this.scan(h.consequent);break;case"SwitchStatement":this.scan(h.discriminant),this.scan(h.cases);break;case"SwitchCase":this.scan(h.test),this.scan(h.consequent);break;case"ThisExpression":case"Literal":case"DebuggerStatement":case"EmptyStatement":case"BreakStatement":case"ContinueStatement":break;default:throw new Error(`unhandled type "${h.type}"`)}}}}s.exports={FunctionTracer:u}},{"../utils":114}],12:[function(t,s,r){const{glWiretap:i}=t("gl-wiretap"),{utils:o}=t("../../utils");function a(p){return p.toString().replace("=>","").replace(/^function /,"").replace(/utils[.]/g,"/*utils.*/")}function u(p,f,g,m,b){g.built||g.build.apply(g,f),f=f?Array.from(f).map(xe=>{switch(typeof xe){case"boolean":return new Boolean(xe);case"number":return new Number(xe);default:return xe}}):null;const x=[],v=i(g.context,{useTrackablePrimitives:!0,onReadPixels:xe=>{if(re.subKernels){if(!w)x.push(`    const result = { result: ${l(xe,re)} };`),w=!0;else{const Ce=re.subKernels[S++].property;x.push(`    result${isNaN(Ce)?"."+Ce:`[${Ce}]`} = ${l(xe,re)};`)}S===re.subKernels.length&&x.push("    return result;");return}xe?x.push(`    return ${l(xe,re)};`):x.push("    return null;")},onUnrecognizedArgumentLookup:xe=>{const Ce=d(xe,re.kernelArguments,[],v);if(Ce)return Ce;const De=d(xe,re.kernelConstants,P?Object.keys(P).map(Ue=>P[Ue]):[],v);return De||null}});let w=!1,S=0;const{source:k,canvas:E,output:I,pipeline:C,graphical:T,loopMaxIterations:R,constants:P,optimizeFloatMemory:D,precision:F,fixIntegerDivisionAccuracy:z,functions:_,nativeFunctions:B,subKernels:N,immutable:O,argumentTypes:K,constantTypes:U,kernelArguments:X,kernelConstants:te,tactic:ie}=g,re=new p(k,{canvas:E,context:v,checkContext:!1,output:I,pipeline:C,graphical:T,loopMaxIterations:R,constants:P,optimizeFloatMemory:D,precision:F,fixIntegerDivisionAccuracy:z,functions:_,nativeFunctions:B,subKernels:N,immutable:O,argumentTypes:K,constantTypes:U,tactic:ie});let he=[];if(v.setIndent(2),re.build.apply(re,f),he.push(v.toString()),v.reset(),re.kernelArguments.forEach((xe,Ce)=>{switch(xe.type){case"Integer":case"Boolean":case"Number":case"Float":case"Array":case"Array(2)":case"Array(3)":case"Array(4)":case"HTMLCanvas":case"HTMLImage":case"HTMLVideo":v.insertVariable(`uploadValue_${xe.name}`,xe.uploadValue);break;case"HTMLImageArray":for(let De=0;De<f[Ce].length;De++){const Ue=f[Ce];v.insertVariable(`uploadValue_${xe.name}[${De}]`,Ue[De])}break;case"Input":v.insertVariable(`uploadValue_${xe.name}`,xe.uploadValue);break;case"MemoryOptimizedNumberTexture":case"NumberTexture":case"Array1D(2)":case"Array1D(3)":case"Array1D(4)":case"Array2D(2)":case"Array2D(3)":case"Array2D(4)":case"Array3D(2)":case"Array3D(3)":case"Array3D(4)":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":v.insertVariable(`uploadValue_${xe.name}`,f[Ce].texture);break;default:throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${xe.type}`)}}),he.push("/** start of injected functions **/"),he.push(`function ${a(o.flattenTo)}`),he.push(`function ${a(o.flatten2dArrayTo)}`),he.push(`function ${a(o.flatten3dArrayTo)}`),he.push(`function ${a(o.flatten4dArrayTo)}`),he.push(`function ${a(o.isArray)}`),re.renderOutput!==re.renderTexture&&re.formatValues&&he.push(`  const renderOutput = function ${a(re.formatValues)};`),he.push("/** end of injected functions **/"),he.push(`  const innerKernel = function (${re.kernelArguments.map(xe=>xe.varName).join(", ")}) {`),v.setIndent(4),re.run.apply(re,f),re.renderKernels?re.renderKernels():re.renderOutput&&re.renderOutput(),he.push("    /** start setup uploads for kernel values **/"),re.kernelArguments.forEach(xe=>{he.push("    "+xe.getStringValueHandler().split(`
`).join(`
    `))}),he.push("    /** end setup uploads for kernel values **/"),he.push(v.toString()),re.renderOutput===re.renderTexture){v.reset();const xe=v.getContextVariableName(re.framebuffer);if(re.renderKernels){const Ce=re.renderKernels(),De=v.getContextVariableName(re.texture.texture);he.push(`    return {
      result: {
        texture: ${De},
        type: '${Ce.result.type}',
        toArray: ${c(Ce.result,De,xe)}
      },`);const{subKernels:Ue,mappedTextures:V}=re;for(let G=0;G<Ue.length;G++){const ee=V[G],ue=Ue[G],ae=Ce[ue.property],ce=v.getContextVariableName(ee.texture);he.push(`
      ${ue.property}: {
        texture: ${ce},
        type: '${ae.type}',
        toArray: ${c(ae,ce,xe)}
      },`)}he.push("    };")}else{const Ce=re.renderOutput(),De=v.getContextVariableName(re.texture.texture);he.push(`    return {
        texture: ${De},
        type: '${Ce.type}',
        toArray: ${c(Ce,De,xe)}
      };`)}}he.push(`    ${b?`
`+b+"    ":""}`),he.push(x.join(`
`)),he.push("  };"),re.graphical&&(he.push(h(re)),he.push("  innerKernel.getPixels = getPixels;")),he.push("  return innerKernel;");let Se=[];return te.forEach(xe=>{Se.push(`${xe.getStringValueHandler()}`)}),`function kernel(settings) {
  const { context, constants } = settings;
  ${Se.join("")}
  ${m||""}
${he.join(`
`)}
}`}function l(p,f){const g=f.precision==="single"?p:`new Float32Array(${p}.buffer)`;return f.output[2]?`renderOutput(${g}, ${f.output[0]}, ${f.output[1]}, ${f.output[2]})`:f.output[1]?`renderOutput(${g}, ${f.output[0]}, ${f.output[1]})`:`renderOutput(${g}, ${f.output[0]})`}function h(p){const f=p.getPixels.toString(),g=!/^function/.test(f);return o.flattenFunctionToString(`${g?"function ":""}${f}`,{findDependency:(m,b)=>m==="utils"?`const ${b} = ${o[b].toString()};`:null,thisLookup:m=>{if(m==="context")return null;if(p.hasOwnProperty(m))return JSON.stringify(p[m]);throw new Error(`unhandled thisLookup ${m}`)}})}function c(p,f,g){const m=p.toArray.toString(),b=!/^function/.test(m),x=o.flattenFunctionToString(`${b?"function ":""}${m}`,{findDependency:(v,w)=>{if(v==="utils")return`const ${w} = ${o[w].toString()};`;if(v==="this")return w==="framebuffer"?"":`${b?"function ":""}${p[w].toString()}`;throw new Error("unhandled fromObject")},thisLookup:(v,w)=>{if(v==="texture")return f;if(v==="context")return w?null:"gl";if(p.hasOwnProperty(v))return JSON.stringify(p[v]);throw new Error(`unhandled thisLookup ${v}`)}});return`() => {
  function framebuffer() { return ${g}; };
  ${x}
  return toArray();
  }`}function d(p,f,g,m,b){if(p===null||f===null)return null;switch(typeof p){case"boolean":case"number":return null}if(typeof HTMLImageElement<"u"&&p instanceof HTMLImageElement)for(let x=0;x<f.length;x++){const v=f[x];if(v.type!=="HTMLImageArray"&&v||v.uploadValue!==p)continue;const w=g[x].indexOf(p);if(w===-1)continue;const S=`uploadValue_${v.name}[${w}]`;return m.insertVariable(S,p),S}for(let x=0;x<f.length;x++){const v=f[x];if(p!==v.uploadValue)continue;const w=`uploadValue_${v.name}`;return m.insertVariable(w,v),w}return null}s.exports={glKernelString:u}},{"../../utils":114,"gl-wiretap":3}],13:[function(t,s,r){const{Kernel:i}=t("../kernel"),{utils:o}=t("../../utils"),{GLTextureArray2Float:a}=t("./texture/array-2-float"),{GLTextureArray2Float2D:u}=t("./texture/array-2-float-2d"),{GLTextureArray2Float3D:l}=t("./texture/array-2-float-3d"),{GLTextureArray3Float:h}=t("./texture/array-3-float"),{GLTextureArray3Float2D:c}=t("./texture/array-3-float-2d"),{GLTextureArray3Float3D:d}=t("./texture/array-3-float-3d"),{GLTextureArray4Float:p}=t("./texture/array-4-float"),{GLTextureArray4Float2D:f}=t("./texture/array-4-float-2d"),{GLTextureArray4Float3D:g}=t("./texture/array-4-float-3d"),{GLTextureFloat:m}=t("./texture/float"),{GLTextureFloat2D:b}=t("./texture/float-2d"),{GLTextureFloat3D:x}=t("./texture/float-3d"),{GLTextureMemoryOptimized:v}=t("./texture/memory-optimized"),{GLTextureMemoryOptimized2D:w}=t("./texture/memory-optimized-2d"),{GLTextureMemoryOptimized3D:S}=t("./texture/memory-optimized-3d"),{GLTextureUnsigned:k}=t("./texture/unsigned"),{GLTextureUnsigned2D:E}=t("./texture/unsigned-2d"),{GLTextureUnsigned3D:I}=t("./texture/unsigned-3d"),{GLTextureGraphical:C}=t("./texture/graphical");class T extends i{static get mode(){return"gpu"}static getIsFloatRead(){const D=`function kernelFunction() {
      return 1;
    }`,F=new this(D,{context:this.testContext,canvas:this.testCanvas,validate:!1,output:[1],precision:"single",returnType:"Number",tactic:"speed"});F.build(),F.run();const z=F.renderOutput();return F.destroy(!0),z[0]===1}static getIsIntegerDivisionAccurate(){function D(B,N){return B[this.thread.x]/N[this.thread.x]}const F=new this(D.toString(),{context:this.testContext,canvas:this.testCanvas,validate:!1,output:[2],returnType:"Number",precision:"unsigned",tactic:"speed"}),z=[[6,6030401],[3,3991]];F.build.apply(F,z),F.run.apply(F,z);const _=F.renderOutput();return F.destroy(!0),_[0]===2&&_[1]===1511}static getIsSpeedTacticSupported(){function D(B){return B[this.thread.x]}const F=new this(D.toString(),{context:this.testContext,canvas:this.testCanvas,validate:!1,output:[4],returnType:"Number",precision:"unsigned",tactic:"speed"}),z=[[0,1,2,3]];F.build.apply(F,z),F.run.apply(F,z);const _=F.renderOutput();return F.destroy(!0),Math.round(_[0])===0&&Math.round(_[1])===1&&Math.round(_[2])===2&&Math.round(_[3])===3}static get testCanvas(){throw new Error(`"testCanvas" not defined on ${this.name}`)}static get testContext(){throw new Error(`"testContext" not defined on ${this.name}`)}static getFeatures(){const D=this.testContext,F=this.getIsDrawBuffers();return Object.freeze({isFloatRead:this.getIsFloatRead(),isIntegerDivisionAccurate:this.getIsIntegerDivisionAccurate(),isSpeedTacticSupported:this.getIsSpeedTacticSupported(),isTextureFloat:this.getIsTextureFloat(),isDrawBuffers:F,kernelMap:F,channelCount:this.getChannelCount(),maxTextureSize:this.getMaxTextureSize(),lowIntPrecision:D.getShaderPrecisionFormat(D.FRAGMENT_SHADER,D.LOW_INT),lowFloatPrecision:D.getShaderPrecisionFormat(D.FRAGMENT_SHADER,D.LOW_FLOAT),mediumIntPrecision:D.getShaderPrecisionFormat(D.FRAGMENT_SHADER,D.MEDIUM_INT),mediumFloatPrecision:D.getShaderPrecisionFormat(D.FRAGMENT_SHADER,D.MEDIUM_FLOAT),highIntPrecision:D.getShaderPrecisionFormat(D.FRAGMENT_SHADER,D.HIGH_INT),highFloatPrecision:D.getShaderPrecisionFormat(D.FRAGMENT_SHADER,D.HIGH_FLOAT)})}static setupFeatureChecks(){throw new Error(`"setupFeatureChecks" not defined on ${this.name}`)}static getSignature(D,F){return D.getVariablePrecisionString()+(F.length>0?":"+F.join(","):"")}setFixIntegerDivisionAccuracy(D){return this.fixIntegerDivisionAccuracy=D,this}setPrecision(D){return this.precision=D,this}setFloatTextures(D){return o.warnDeprecated("method","setFloatTextures","setOptimizeFloatMemory"),this.floatTextures=D,this}static nativeFunctionArguments(D){const F=[],z=[],_=[],B=/^[a-zA-Z_]/,N=/[a-zA-Z_0-9]/;let O=0,K=null,U=null;for(;O<D.length;){const X=D[O],te=D[O+1],ie=_.length>0?_[_.length-1]:null;if(ie==="FUNCTION_ARGUMENTS"&&X==="/"&&te==="*"){_.push("MULTI_LINE_COMMENT"),O+=2;continue}else if(ie==="MULTI_LINE_COMMENT"&&X==="*"&&te==="/"){_.pop(),O+=2;continue}else if(ie==="FUNCTION_ARGUMENTS"&&X==="/"&&te==="/"){_.push("COMMENT"),O+=2;continue}else if(ie==="COMMENT"&&X===`
`){_.pop(),O++;continue}else if(ie===null&&X==="("){_.push("FUNCTION_ARGUMENTS"),O++;continue}else if(ie==="FUNCTION_ARGUMENTS"){if(X===")"){_.pop();break}if(X==="f"&&te==="l"&&D[O+2]==="o"&&D[O+3]==="a"&&D[O+4]==="t"&&D[O+5]===" "){_.push("DECLARE_VARIABLE"),U="float",K="",O+=6;continue}else if(X==="i"&&te==="n"&&D[O+2]==="t"&&D[O+3]===" "){_.push("DECLARE_VARIABLE"),U="int",K="",O+=4;continue}else if(X==="v"&&te==="e"&&D[O+2]==="c"&&D[O+3]==="2"&&D[O+4]===" "){_.push("DECLARE_VARIABLE"),U="vec2",K="",O+=5;continue}else if(X==="v"&&te==="e"&&D[O+2]==="c"&&D[O+3]==="3"&&D[O+4]===" "){_.push("DECLARE_VARIABLE"),U="vec3",K="",O+=5;continue}else if(X==="v"&&te==="e"&&D[O+2]==="c"&&D[O+3]==="4"&&D[O+4]===" "){_.push("DECLARE_VARIABLE"),U="vec4",K="",O+=5;continue}}else if(ie==="DECLARE_VARIABLE"){if(K===""){if(X===" "){O++;continue}if(!B.test(X))throw new Error("variable name is not expected string")}K+=X,N.test(te)||(_.pop(),z.push(K),F.push(R[U]))}O++}if(_.length>0)throw new Error("GLSL function was not parsable");return{argumentNames:z,argumentTypes:F}}static nativeFunctionReturnType(D){return R[D.match(/int|float|vec[2-4]/)[0]]}static combineKernels(D,F){D.apply(null,arguments);const{texSize:z,context:_,threadDim:B}=F.texSize;let N;if(F.precision==="single"){const O=z[0],K=Math.ceil(z[1]/4);N=new Float32Array(O*K*4*4),_.readPixels(0,0,O,K*4,_.RGBA,_.FLOAT,N)}else{const O=new Uint8Array(z[0]*z[1]*4);_.readPixels(0,0,z[0],z[1],_.RGBA,_.UNSIGNED_BYTE,O),N=new Float32Array(O.buffer)}if(N=N.subarray(0,B[0]*B[1]*B[2]),F.output.length===1)return N;if(F.output.length===2)return o.splitArray(N,F.output[0]);if(F.output.length===3)return o.splitArray(N,F.output[0]*F.output[1]).map(function(K){return o.splitArray(K,F.output[0])})}constructor(D,F){super(D,F),this.transferValues=null,this.formatValues=null,this.TextureConstructor=null,this.renderOutput=null,this.renderRawOutput=null,this.texSize=null,this.translatedSource=null,this.compiledFragmentShader=null,this.compiledVertexShader=null,this.switchingKernels=null,this._textureSwitched=null,this._mappedTextureSwitched=null}checkTextureSize(){const{features:D}=this.constructor;if(this.texSize[0]>D.maxTextureSize||this.texSize[1]>D.maxTextureSize)throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${D.maxTextureSize},${D.maxTextureSize}]`)}translateSource(){throw new Error(`"translateSource" not defined on ${this.constructor.name}`)}pickRenderStrategy(D){if(this.graphical)return this.renderRawOutput=this.readPackedPixelsToUint8Array,this.transferValues=F=>F,this.TextureConstructor=C,null;if(this.precision==="unsigned")if(this.renderRawOutput=this.readPackedPixelsToUint8Array,this.transferValues=this.readPackedPixelsToFloat32Array,this.pipeline)switch(this.renderOutput=this.renderTexture,this.subKernels!==null&&(this.renderKernels=this.renderKernelsToTextures),this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.output[2]>0?(this.TextureConstructor=I,null):this.output[1]>0?(this.TextureConstructor=E,null):(this.TextureConstructor=k,null);case"Array(2)":case"Array(3)":case"Array(4)":return this.requestFallback(D)}else switch(this.subKernels!==null&&(this.renderKernels=this.renderKernelsToArrays),this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.renderOutput=this.renderValues,this.output[2]>0?(this.TextureConstructor=I,this.formatValues=o.erect3DPackedFloat,null):this.output[1]>0?(this.TextureConstructor=E,this.formatValues=o.erect2DPackedFloat,null):(this.TextureConstructor=k,this.formatValues=o.erectPackedFloat,null);case"Array(2)":case"Array(3)":case"Array(4)":return this.requestFallback(D)}else if(this.precision==="single"){if(this.renderRawOutput=this.readFloatPixelsToFloat32Array,this.transferValues=this.readFloatPixelsToFloat32Array,this.pipeline)switch(this.renderOutput=this.renderTexture,this.subKernels!==null&&(this.renderKernels=this.renderKernelsToTextures),this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.optimizeFloatMemory?this.output[2]>0?(this.TextureConstructor=S,null):this.output[1]>0?(this.TextureConstructor=w,null):(this.TextureConstructor=v,null):this.output[2]>0?(this.TextureConstructor=x,null):this.output[1]>0?(this.TextureConstructor=b,null):(this.TextureConstructor=m,null);case"Array(2)":return this.output[2]>0?(this.TextureConstructor=l,null):this.output[1]>0?(this.TextureConstructor=u,null):(this.TextureConstructor=a,null);case"Array(3)":return this.output[2]>0?(this.TextureConstructor=d,null):this.output[1]>0?(this.TextureConstructor=c,null):(this.TextureConstructor=h,null);case"Array(4)":return this.output[2]>0?(this.TextureConstructor=g,null):this.output[1]>0?(this.TextureConstructor=f,null):(this.TextureConstructor=p,null)}if(this.renderOutput=this.renderValues,this.subKernels!==null&&(this.renderKernels=this.renderKernelsToArrays),this.optimizeFloatMemory)switch(this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.output[2]>0?(this.TextureConstructor=S,this.formatValues=o.erectMemoryOptimized3DFloat,null):this.output[1]>0?(this.TextureConstructor=w,this.formatValues=o.erectMemoryOptimized2DFloat,null):(this.TextureConstructor=v,this.formatValues=o.erectMemoryOptimizedFloat,null);case"Array(2)":return this.output[2]>0?(this.TextureConstructor=l,this.formatValues=o.erect3DArray2,null):this.output[1]>0?(this.TextureConstructor=u,this.formatValues=o.erect2DArray2,null):(this.TextureConstructor=a,this.formatValues=o.erectArray2,null);case"Array(3)":return this.output[2]>0?(this.TextureConstructor=d,this.formatValues=o.erect3DArray3,null):this.output[1]>0?(this.TextureConstructor=c,this.formatValues=o.erect2DArray3,null):(this.TextureConstructor=h,this.formatValues=o.erectArray3,null);case"Array(4)":return this.output[2]>0?(this.TextureConstructor=g,this.formatValues=o.erect3DArray4,null):this.output[1]>0?(this.TextureConstructor=f,this.formatValues=o.erect2DArray4,null):(this.TextureConstructor=p,this.formatValues=o.erectArray4,null)}else switch(this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.output[2]>0?(this.TextureConstructor=x,this.formatValues=o.erect3DFloat,null):this.output[1]>0?(this.TextureConstructor=b,this.formatValues=o.erect2DFloat,null):(this.TextureConstructor=m,this.formatValues=o.erectFloat,null);case"Array(2)":return this.output[2]>0?(this.TextureConstructor=l,this.formatValues=o.erect3DArray2,null):this.output[1]>0?(this.TextureConstructor=u,this.formatValues=o.erect2DArray2,null):(this.TextureConstructor=a,this.formatValues=o.erectArray2,null);case"Array(3)":return this.output[2]>0?(this.TextureConstructor=d,this.formatValues=o.erect3DArray3,null):this.output[1]>0?(this.TextureConstructor=c,this.formatValues=o.erect2DArray3,null):(this.TextureConstructor=h,this.formatValues=o.erectArray3,null);case"Array(4)":return this.output[2]>0?(this.TextureConstructor=g,this.formatValues=o.erect3DArray4,null):this.output[1]>0?(this.TextureConstructor=f,this.formatValues=o.erect2DArray4,null):(this.TextureConstructor=p,this.formatValues=o.erectArray4,null)}}else throw new Error(`unhandled precision of "${this.precision}"`);throw new Error(`unhandled return type "${this.returnType}"`)}getKernelString(){throw new Error("abstract method call")}getMainResultTexture(){switch(this.returnType){case"LiteralInteger":case"Float":case"Integer":case"Number":return this.getMainResultNumberTexture();case"Array(2)":return this.getMainResultArray2Texture();case"Array(3)":return this.getMainResultArray3Texture();case"Array(4)":return this.getMainResultArray4Texture();default:throw new Error(`unhandled returnType type ${this.returnType}`)}}getMainResultKernelNumberTexture(){throw new Error("abstract method call")}getMainResultSubKernelNumberTexture(){throw new Error("abstract method call")}getMainResultKernelArray2Texture(){throw new Error("abstract method call")}getMainResultSubKernelArray2Texture(){throw new Error("abstract method call")}getMainResultKernelArray3Texture(){throw new Error("abstract method call")}getMainResultSubKernelArray3Texture(){throw new Error("abstract method call")}getMainResultKernelArray4Texture(){throw new Error("abstract method call")}getMainResultSubKernelArray4Texture(){throw new Error("abstract method call")}getMainResultGraphical(){throw new Error("abstract method call")}getMainResultMemoryOptimizedFloats(){throw new Error("abstract method call")}getMainResultPackedPixels(){throw new Error("abstract method call")}getMainResultString(){return this.graphical?this.getMainResultGraphical():this.precision==="single"?this.optimizeFloatMemory?this.getMainResultMemoryOptimizedFloats():this.getMainResultTexture():this.getMainResultPackedPixels()}getMainResultNumberTexture(){return o.linesToString(this.getMainResultKernelNumberTexture())+o.linesToString(this.getMainResultSubKernelNumberTexture())}getMainResultArray2Texture(){return o.linesToString(this.getMainResultKernelArray2Texture())+o.linesToString(this.getMainResultSubKernelArray2Texture())}getMainResultArray3Texture(){return o.linesToString(this.getMainResultKernelArray3Texture())+o.linesToString(this.getMainResultSubKernelArray3Texture())}getMainResultArray4Texture(){return o.linesToString(this.getMainResultKernelArray4Texture())+o.linesToString(this.getMainResultSubKernelArray4Texture())}getFloatTacticDeclaration(){return`precision ${this.getVariablePrecisionString(this.texSize,this.tactic)} float;
`}getIntTacticDeclaration(){return`precision ${this.getVariablePrecisionString(this.texSize,this.tactic,!0)} int;
`}getSampler2DTacticDeclaration(){return`precision ${this.getVariablePrecisionString(this.texSize,this.tactic)} sampler2D;
`}getSampler2DArrayTacticDeclaration(){return`precision ${this.getVariablePrecisionString(this.texSize,this.tactic)} sampler2DArray;
`}renderTexture(){return this.immutable?this.texture.clone():this.texture}readPackedPixelsToUint8Array(){if(this.precision!=="unsigned")throw new Error('Requires this.precision to be "unsigned"');const{texSize:D,context:F}=this,z=new Uint8Array(D[0]*D[1]*4);return F.readPixels(0,0,D[0],D[1],F.RGBA,F.UNSIGNED_BYTE,z),z}readPackedPixelsToFloat32Array(){return new Float32Array(this.readPackedPixelsToUint8Array().buffer)}readFloatPixelsToFloat32Array(){if(this.precision!=="single")throw new Error('Requires this.precision to be "single"');const{texSize:D,context:F}=this,z=D[0],_=D[1],B=new Float32Array(z*_*4);return F.readPixels(0,0,z,_,F.RGBA,F.FLOAT,B),B}getPixels(D){const{context:F,output:z}=this,[_,B]=z,N=new Uint8Array(_*B*4);return F.readPixels(0,0,_,B,F.RGBA,F.UNSIGNED_BYTE,N),new Uint8ClampedArray((D?N:o.flipPixels(N,_,B)).buffer)}renderKernelsToArrays(){const D={result:this.renderOutput()};for(let F=0;F<this.subKernels.length;F++)D[this.subKernels[F].property]=this.mappedTextures[F].toArray();return D}renderKernelsToTextures(){const D={result:this.renderOutput()};if(this.immutable)for(let F=0;F<this.subKernels.length;F++)D[this.subKernels[F].property]=this.mappedTextures[F].clone();else for(let F=0;F<this.subKernels.length;F++)D[this.subKernels[F].property]=this.mappedTextures[F];return D}resetSwitchingKernels(){const D=this.switchingKernels;return this.switchingKernels=null,D}setOutput(D){const F=this.toKernelOutput(D);if(this.program){if(!this.dynamicOutput)throw new Error("Resizing a kernel with dynamicOutput: false is not possible");const z=[F[0],F[1]||1,F[2]||1],_=o.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},z),B=this.texSize;if(B){const O=this.getVariablePrecisionString(B,this.tactic),K=this.getVariablePrecisionString(_,this.tactic);if(O!==K){this.debug&&console.warn("Precision requirement changed, asking GPU instance to recompile"),this.switchKernels({type:"outputPrecisionMismatch",precision:K,needed:D});return}}this.output=F,this.threadDim=z,this.texSize=_;const{context:N}=this;if(N.bindFramebuffer(N.FRAMEBUFFER,this.framebuffer),this.updateMaxTexSize(),this.framebuffer.width=this.texSize[0],this.framebuffer.height=this.texSize[1],N.viewport(0,0,this.maxTexSize[0],this.maxTexSize[1]),this.canvas.width=this.maxTexSize[0],this.canvas.height=this.maxTexSize[1],this.texture&&this.texture.delete(),this.texture=null,this._setupOutputTexture(),this.mappedTextures&&this.mappedTextures.length>0){for(let O=0;O<this.mappedTextures.length;O++)this.mappedTextures[O].delete();this.mappedTextures=null,this._setupSubOutputTextures()}}else this.output=F;return this}renderValues(){return this.formatValues(this.transferValues(),this.output[0],this.output[1],this.output[2])}switchKernels(D){this.switchingKernels?this.switchingKernels.push(D):this.switchingKernels=[D]}getVariablePrecisionString(D=this.texSize,F=this.tactic,z=!1){if(!F){if(!this.constructor.features.isSpeedTacticSupported)return"highp";const _=this.constructor.features[z?"lowIntPrecision":"lowFloatPrecision"],B=this.constructor.features[z?"mediumIntPrecision":"mediumFloatPrecision"],N=this.constructor.features[z?"highIntPrecision":"highFloatPrecision"],O=Math.log2(D[0]*D[1]);if(O<=_.rangeMax)return"lowp";if(O<=B.rangeMax)return"mediump";if(O<=N.rangeMax)return"highp";throw new Error("The required size exceeds that of the ability of your system")}switch(F){case"speed":return"lowp";case"balanced":return"mediump";case"precision":return"highp";default:throw new Error(`Unknown tactic "${F}" use "speed", "balanced", "precision", or empty for auto`)}}updateTextureArgumentRefs(D,F){if(this.immutable){if(this.texture.texture===F.texture){const{prevArg:z}=D;z&&(z.texture._refs===1&&(this.texture.delete(),this.texture=z.clone(),this._textureSwitched=!0),z.delete()),D.prevArg=F.clone()}else if(this.mappedTextures&&this.mappedTextures.length>0){const{mappedTextures:z}=this;for(let _=0;_<z.length;_++){const B=z[_];if(B.texture===F.texture){const{prevArg:N}=D;N&&(N.texture._refs===1&&(B.delete(),z[_]=N.clone(),this._mappedTextureSwitched[_]=!0),N.delete()),D.prevArg=F.clone();return}}}}}onActivate(D){if(this._textureSwitched=!0,this.texture=D.texture,this.mappedTextures){for(let F=0;F<this.mappedTextures.length;F++)this._mappedTextureSwitched[F]=!0;this.mappedTextures=D.mappedTextures}}initCanvas(){}}const R={int:"Integer",float:"Number",vec2:"Array(2)",vec3:"Array(3)",vec4:"Array(4)"};s.exports={GLKernel:T}},{"../../utils":114,"../kernel":36,"./texture/array-2-float":16,"./texture/array-2-float-2d":14,"./texture/array-2-float-3d":15,"./texture/array-3-float":19,"./texture/array-3-float-2d":17,"./texture/array-3-float-3d":18,"./texture/array-4-float":22,"./texture/array-4-float-2d":20,"./texture/array-4-float-3d":21,"./texture/float":25,"./texture/float-2d":23,"./texture/float-3d":24,"./texture/graphical":26,"./texture/memory-optimized":30,"./texture/memory-optimized-2d":28,"./texture/memory-optimized-3d":29,"./texture/unsigned":33,"./texture/unsigned-2d":31,"./texture/unsigned-3d":32}],14:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="ArrayTexture(2)"}toArray(){return i.erect2DArray2(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureArray2Float2D:a}},{"../../../utils":114,"./float":25}],15:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="ArrayTexture(2)"}toArray(){return i.erect3DArray2(this.renderValues(),this.output[0],this.output[1],this.output[2])}}s.exports={GLTextureArray2Float3D:a}},{"../../../utils":114,"./float":25}],16:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="ArrayTexture(2)"}toArray(){return i.erectArray2(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureArray2Float:a}},{"../../../utils":114,"./float":25}],17:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="ArrayTexture(3)"}toArray(){return i.erect2DArray3(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureArray3Float2D:a}},{"../../../utils":114,"./float":25}],18:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="ArrayTexture(3)"}toArray(){return i.erect3DArray3(this.renderValues(),this.output[0],this.output[1],this.output[2])}}s.exports={GLTextureArray3Float3D:a}},{"../../../utils":114,"./float":25}],19:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="ArrayTexture(3)"}toArray(){return i.erectArray3(this.renderValues(),this.output[0])}}s.exports={GLTextureArray3Float:a}},{"../../../utils":114,"./float":25}],20:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="ArrayTexture(4)"}toArray(){return i.erect2DArray4(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureArray4Float2D:a}},{"../../../utils":114,"./float":25}],21:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="ArrayTexture(4)"}toArray(){return i.erect3DArray4(this.renderValues(),this.output[0],this.output[1],this.output[2])}}s.exports={GLTextureArray4Float3D:a}},{"../../../utils":114,"./float":25}],22:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="ArrayTexture(4)"}toArray(){return i.erectArray4(this.renderValues(),this.output[0])}}s.exports={GLTextureArray4Float:a}},{"../../../utils":114,"./float":25}],23:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="ArrayTexture(1)"}toArray(){return i.erect2DFloat(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureFloat2D:a}},{"../../../utils":114,"./float":25}],24:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="ArrayTexture(1)"}toArray(){return i.erect3DFloat(this.renderValues(),this.output[0],this.output[1],this.output[2])}}s.exports={GLTextureFloat3D:a}},{"../../../utils":114,"./float":25}],25:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTexture:o}=t("./index");class a extends o{get textureType(){return this.context.FLOAT}constructor(l){super(l),this.type="ArrayTexture(1)"}renderRawOutput(){const l=this.context,h=this.size;l.bindFramebuffer(l.FRAMEBUFFER,this.framebuffer()),l.framebufferTexture2D(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,this.texture,0);const c=new Float32Array(h[0]*h[1]*4);return l.readPixels(0,0,h[0],h[1],l.RGBA,l.FLOAT,c),c}renderValues(){return this._deleted?null:this.renderRawOutput()}toArray(){return i.erectFloat(this.renderValues(),this.output[0])}}s.exports={GLTextureFloat:a}},{"../../../utils":114,"./index":27}],26:[function(t,s,r){const{GLTextureUnsigned:i}=t("./unsigned");class o extends i{constructor(u){super(u),this.type="ArrayTexture(4)"}toArray(){return this.renderValues()}}s.exports={GLTextureGraphical:o}},{"./unsigned":33}],27:[function(t,s,r){const{Texture:i}=t("../../../texture");class o extends i{get textureType(){throw new Error(`"textureType" not implemented on ${this.name}`)}clone(){return new this.constructor(this)}beforeMutate(){return this.texture._refs>1?(this.newTexture(),!0):!1}cloneTexture(){this.texture._refs--;const{context:l,size:h,texture:c,kernel:d}=this;d.debug&&console.warn("cloning internal texture"),l.bindFramebuffer(l.FRAMEBUFFER,this.framebuffer()),a(l,c),l.framebufferTexture2D(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,c,0);const p=l.createTexture();a(l,p),l.texImage2D(l.TEXTURE_2D,0,this.internalFormat,h[0],h[1],0,this.textureFormat,this.textureType,null),l.copyTexSubImage2D(l.TEXTURE_2D,0,0,0,0,0,h[0],h[1]),p._refs=1,this.texture=p}newTexture(){this.texture._refs--;const l=this.context,h=this.size;this.kernel.debug&&console.warn("new internal texture");const d=l.createTexture();a(l,d),l.texImage2D(l.TEXTURE_2D,0,this.internalFormat,h[0],h[1],0,this.textureFormat,this.textureType,null),d._refs=1,this.texture=d}clear(){if(this.texture._refs){this.texture._refs--;const c=this.context,d=this.texture=c.createTexture();a(c,d);const p=this.size;d._refs=1,c.texImage2D(c.TEXTURE_2D,0,this.internalFormat,p[0],p[1],0,this.textureFormat,this.textureType,null)}const{context:l,texture:h}=this;l.bindFramebuffer(l.FRAMEBUFFER,this.framebuffer()),l.bindTexture(l.TEXTURE_2D,h),a(l,h),l.framebufferTexture2D(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,h,0),l.clearColor(0,0,0,0),l.clear(l.COLOR_BUFFER_BIT|l.DEPTH_BUFFER_BIT)}delete(){this._deleted||(this._deleted=!0,!(this.texture._refs&&(this.texture._refs--,this.texture._refs))&&this.context.deleteTexture(this.texture))}framebuffer(){return this._framebuffer||(this._framebuffer=this.kernel.getRawValueFramebuffer(this.size[0],this.size[1])),this._framebuffer}}function a(u,l){u.activeTexture(u.TEXTURE15),u.bindTexture(u.TEXTURE_2D,l),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_S,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_T,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MIN_FILTER,u.NEAREST),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MAG_FILTER,u.NEAREST)}s.exports={GLTexture:o}},{"../../../texture":113}],28:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="MemoryOptimizedNumberTexture"}toArray(){return i.erectMemoryOptimized2DFloat(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureMemoryOptimized2D:a}},{"../../../utils":114,"./float":25}],29:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="MemoryOptimizedNumberTexture"}toArray(){return i.erectMemoryOptimized3DFloat(this.renderValues(),this.output[0],this.output[1],this.output[2])}}s.exports={GLTextureMemoryOptimized3D:a}},{"../../../utils":114,"./float":25}],30:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureFloat:o}=t("./float");class a extends o{constructor(l){super(l),this.type="MemoryOptimizedNumberTexture"}toArray(){return i.erectMemoryOptimizedFloat(this.renderValues(),this.output[0])}}s.exports={GLTextureMemoryOptimized:a}},{"../../../utils":114,"./float":25}],31:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureUnsigned:o}=t("./unsigned");class a extends o{constructor(l){super(l),this.type="NumberTexture"}toArray(){return i.erect2DPackedFloat(this.renderValues(),this.output[0],this.output[1])}}s.exports={GLTextureUnsigned2D:a}},{"../../../utils":114,"./unsigned":33}],32:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTextureUnsigned:o}=t("./unsigned");class a extends o{constructor(l){super(l),this.type="NumberTexture"}toArray(){return i.erect3DPackedFloat(this.renderValues(),this.output[0],this.output[1],this.output[2])}}s.exports={GLTextureUnsigned3D:a}},{"../../../utils":114,"./unsigned":33}],33:[function(t,s,r){const{utils:i}=t("../../../utils"),{GLTexture:o}=t("./index");class a extends o{get textureType(){return this.context.UNSIGNED_BYTE}constructor(l){super(l),this.type="NumberTexture"}renderRawOutput(){const{context:l}=this;l.bindFramebuffer(l.FRAMEBUFFER,this.framebuffer()),l.framebufferTexture2D(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,this.texture,0);const h=new Uint8Array(this.size[0]*this.size[1]*4);return l.readPixels(0,0,this.size[0],this.size[1],l.RGBA,l.UNSIGNED_BYTE,h),h}renderValues(){return this._deleted?null:new Float32Array(this.renderRawOutput().buffer)}toArray(){return i.erectPackedFloat(this.renderValues(),this.output[0])}}s.exports={GLTextureUnsigned:a}},{"../../../utils":114,"./index":27}],34:[function(t,s,r){const i=t("gl"),{WebGLKernel:o}=t("../web-gl/kernel"),{glKernelString:a}=t("../gl/kernel-string");let u=null,l=null,h=null,c=null,d=null;class p extends o{static get isSupported(){return u!==null||(this.setupFeatureChecks(),u=h!==null),u}static setupFeatureChecks(){if(l=null,c=null,typeof i=="function")try{if(h=i(2,2,{preserveDrawingBuffer:!0}),!h||!h.getExtension)return;c={STACKGL_resize_drawingbuffer:h.getExtension("STACKGL_resize_drawingbuffer"),STACKGL_destroy_context:h.getExtension("STACKGL_destroy_context"),OES_texture_float:h.getExtension("OES_texture_float"),OES_texture_float_linear:h.getExtension("OES_texture_float_linear"),OES_element_index_uint:h.getExtension("OES_element_index_uint"),WEBGL_draw_buffers:h.getExtension("WEBGL_draw_buffers"),WEBGL_color_buffer_float:h.getExtension("WEBGL_color_buffer_float")},d=this.getFeatures()}catch(g){console.warn(g)}}static isContextMatch(g){try{return g.getParameter(g.RENDERER)==="ANGLE"}catch{return!1}}static getIsTextureFloat(){return!!c.OES_texture_float}static getIsDrawBuffers(){return!!c.WEBGL_draw_buffers}static getChannelCount(){return c.WEBGL_draw_buffers?h.getParameter(c.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL):1}static getMaxTextureSize(){return h.getParameter(h.MAX_TEXTURE_SIZE)}static get testCanvas(){return l}static get testContext(){return h}static get features(){return d}initCanvas(){return{}}initContext(){return i(2,2,{preserveDrawingBuffer:!0})}initExtensions(){this.extensions={STACKGL_resize_drawingbuffer:this.context.getExtension("STACKGL_resize_drawingbuffer"),STACKGL_destroy_context:this.context.getExtension("STACKGL_destroy_context"),OES_texture_float:this.context.getExtension("OES_texture_float"),OES_texture_float_linear:this.context.getExtension("OES_texture_float_linear"),OES_element_index_uint:this.context.getExtension("OES_element_index_uint"),WEBGL_draw_buffers:this.context.getExtension("WEBGL_draw_buffers")}}build(){super.build.apply(this,arguments),this.fallbackRequested||this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0],this.maxTexSize[1])}destroyExtensions(){this.extensions.STACKGL_resize_drawingbuffer=null,this.extensions.STACKGL_destroy_context=null,this.extensions.OES_texture_float=null,this.extensions.OES_texture_float_linear=null,this.extensions.OES_element_index_uint=null,this.extensions.WEBGL_draw_buffers=null}static destroyContext(g){const m=g.getExtension("STACKGL_destroy_context");m&&m.destroy&&m.destroy()}toString(){return a(this.constructor,arguments,this,`const gl = context || require('gl')(1, 1);
`,`    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }
`)}setOutput(g){return super.setOutput(g),this.graphical&&this.extensions.STACKGL_resize_drawingbuffer&&this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0],this.maxTexSize[1]),this}}s.exports={HeadlessGLKernel:p}},{"../gl/kernel-string":12,"../web-gl/kernel":70,gl:2}],35:[function(t,s,r){class i{constructor(a,u){const{name:l,kernel:h,context:c,checkContext:d,onRequestContextHandle:p,onUpdateValueMismatch:f,origin:g,strictIntegers:m,type:b,tactic:x}=u;if(!l)throw new Error("name not set");if(!b)throw new Error("type not set");if(!g)throw new Error("origin not set");if(g!=="user"&&g!=="constants")throw new Error(`origin must be "user" or "constants" value is "${g}"`);if(!p)throw new Error("onRequestContextHandle is not set");this.name=l,this.origin=g,this.tactic=x,this.varName=g==="constants"?`constants.${l}`:l,this.kernel=h,this.strictIntegers=m,this.type=a.type||b,this.size=a.size||null,this.index=null,this.context=c,this.checkContext=d??!0,this.contextHandle=null,this.onRequestContextHandle=p,this.onUpdateValueMismatch=f,this.forceUploadEachRun=null}get id(){return`${this.origin}_${name}`}getSource(){throw new Error(`"getSource" not defined on ${this.constructor.name}`)}updateValue(a){throw new Error(`"updateValue" not defined on ${this.constructor.name}`)}}s.exports={KernelValue:i}},{}],36:[function(t,s,r){const{utils:i}=t("../utils"),{Input:o}=t("../input");class a{static get isSupported(){throw new Error(`"isSupported" not implemented on ${this.name}`)}static isContextMatch(h){throw new Error(`"isContextMatch" not implemented on ${this.name}`)}static getFeatures(){throw new Error(`"getFeatures" not implemented on ${this.name}`)}static destroyContext(h){throw new Error(`"destroyContext" called on ${this.name}`)}static nativeFunctionArguments(){throw new Error(`"nativeFunctionArguments" called on ${this.name}`)}static nativeFunctionReturnType(){throw new Error(`"nativeFunctionReturnType" called on ${this.name}`)}static combineKernels(){throw new Error(`"combineKernels" called on ${this.name}`)}constructor(h,c){if(typeof h!="object"){if(typeof h!="string")throw new Error("source not a string");if(!i.isFunctionString(h))throw new Error("source not a function string")}this.useLegacyEncoder=!1,this.fallbackRequested=!1,this.onRequestFallback=null,this.argumentNames=typeof h=="string"?i.getArgumentNamesFromString(h):null,this.argumentTypes=null,this.argumentSizes=null,this.argumentBitRatios=null,this.kernelArguments=null,this.kernelConstants=null,this.forceUploadKernelConstants=null,this.source=h,this.output=null,this.debug=!1,this.graphical=!1,this.loopMaxIterations=0,this.constants=null,this.constantTypes=null,this.constantBitRatios=null,this.dynamicArguments=!1,this.dynamicOutput=!1,this.canvas=null,this.context=null,this.checkContext=null,this.gpu=null,this.functions=null,this.nativeFunctions=null,this.injectedNative=null,this.subKernels=null,this.validate=!0,this.immutable=!1,this.pipeline=!1,this.precision=null,this.tactic=null,this.plugins=null,this.returnType=null,this.leadingReturnStatement=null,this.followingReturnStatement=null,this.optimizeFloatMemory=null,this.strictIntegers=!1,this.fixIntegerDivisionAccuracy=null,this.built=!1,this.signature=null}mergeSettings(h){for(let c in h)if(!(!h.hasOwnProperty(c)||!this.hasOwnProperty(c))){switch(c){case"output":if(!Array.isArray(h.output)){this.setOutput(h.output);continue}break;case"functions":this.functions=[];for(let d=0;d<h.functions.length;d++)this.addFunction(h.functions[d]);continue;case"graphical":h[c]&&!h.hasOwnProperty("precision")&&(this.precision="unsigned"),this[c]=h[c];continue;case"nativeFunctions":if(!h.nativeFunctions)continue;this.nativeFunctions=[];for(let d=0;d<h.nativeFunctions.length;d++){const p=h.nativeFunctions[d],{name:f,source:g}=p;this.addNativeFunction(f,g,p)}continue}this[c]=h[c]}this.canvas||(this.canvas=this.initCanvas()),this.context||(this.context=this.initContext()),this.plugins||(this.plugins=this.initPlugins(h))}build(){throw new Error(`"build" not defined on ${this.constructor.name}`)}run(){throw new Error(`"run" not defined on ${this.constructor.name}`)}initCanvas(){throw new Error(`"initCanvas" not defined on ${this.constructor.name}`)}initContext(){throw new Error(`"initContext" not defined on ${this.constructor.name}`)}initPlugins(h){throw new Error(`"initPlugins" not defined on ${this.constructor.name}`)}addFunction(h,c={}){if(h.name&&h.source&&h.argumentTypes&&"returnType"in h)this.functions.push(h);else if("settings"in h&&"source"in h)this.functions.push(this.functionToIGPUFunction(h.source,h.settings));else if(typeof h=="string"||typeof h=="function")this.functions.push(this.functionToIGPUFunction(h,c));else throw new Error("function not properly defined");return this}addNativeFunction(h,c,d={}){const{argumentTypes:p,argumentNames:f}=d.argumentTypes?u(d.argumentTypes):this.constructor.nativeFunctionArguments(c)||{};return this.nativeFunctions.push({name:h,source:c,settings:d,argumentTypes:p,argumentNames:f,returnType:d.returnType||this.constructor.nativeFunctionReturnType(c)}),this}setupArguments(h){if(this.kernelArguments=[],this.argumentTypes)for(let c=0;c<this.argumentTypes.length;c++)this.kernelArguments.push({type:this.argumentTypes[c]});else if(!this.argumentTypes){this.argumentTypes=[];for(let c=0;c<h.length;c++){const d=i.getVariableType(h[c],this.strictIntegers),p=d==="Integer"?"Number":d;this.argumentTypes.push(p),this.kernelArguments.push({type:p})}}this.argumentSizes=new Array(h.length),this.argumentBitRatios=new Int32Array(h.length);for(let c=0;c<h.length;c++){const d=h[c];this.argumentSizes[c]=d.constructor===o?d.size:null,this.argumentBitRatios[c]=this.getBitRatio(d)}if(this.argumentNames.length!==h.length)throw new Error("arguments are miss-aligned")}setupConstants(){this.kernelConstants=[];let h=this.constantTypes===null;if(h&&(this.constantTypes={}),this.constantBitRatios={},this.constants)for(let c in this.constants){if(h){const d=i.getVariableType(this.constants[c],this.strictIntegers);this.constantTypes[c]=d,this.kernelConstants.push({name:c,type:d})}else this.kernelConstants.push({name:c,type:this.constantTypes[c]});this.constantBitRatios[c]=this.getBitRatio(this.constants[c])}}setOptimizeFloatMemory(h){return this.optimizeFloatMemory=h,this}toKernelOutput(h){return h.hasOwnProperty("x")?h.hasOwnProperty("y")?h.hasOwnProperty("z")?[h.x,h.y,h.z]:[h.x,h.y]:[h.x]:h}setOutput(h){return this.output=this.toKernelOutput(h),this}setDebug(h){return this.debug=h,this}setGraphical(h){return this.graphical=h,this.precision="unsigned",this}setLoopMaxIterations(h){return this.loopMaxIterations=h,this}setConstants(h){return this.constants=h,this}setConstantTypes(h){return this.constantTypes=h,this}setFunctions(h){for(let c=0;c<h.length;c++)this.addFunction(h[c]);return this}setNativeFunctions(h){for(let c=0;c<h.length;c++){const d=h[c],{name:p,source:f}=d;this.addNativeFunction(p,f,d)}return this}setInjectedNative(h){return this.injectedNative=h,this}setPipeline(h){return this.pipeline=h,this}setPrecision(h){return this.precision=h,this}setDimensions(h){return i.warnDeprecated("method","setDimensions","setOutput"),this.output=h,this}setOutputToTexture(h){return i.warnDeprecated("method","setOutputToTexture","setPipeline"),this.pipeline=h,this}setImmutable(h){return this.immutable=h,this}setCanvas(h){return this.canvas=h,this}setStrictIntegers(h){return this.strictIntegers=h,this}setDynamicOutput(h){return this.dynamicOutput=h,this}setHardcodeConstants(h){return i.warnDeprecated("method","setHardcodeConstants"),this.setDynamicOutput(h),this.setDynamicArguments(h),this}setDynamicArguments(h){return this.dynamicArguments=h,this}setUseLegacyEncoder(h){return this.useLegacyEncoder=h,this}setWarnVarUsage(h){return i.warnDeprecated("method","setWarnVarUsage"),this}getCanvas(){return i.warnDeprecated("method","getCanvas"),this.canvas}getWebGl(){return i.warnDeprecated("method","getWebGl"),this.context}setContext(h){return this.context=h,this}setArgumentTypes(h){if(Array.isArray(h))this.argumentTypes=h;else{this.argumentTypes=[];for(const c in h){if(!h.hasOwnProperty(c))continue;const d=this.argumentNames.indexOf(c);if(d===-1)throw new Error(`unable to find argument ${c}`);this.argumentTypes[d]=h[c]}}return this}setTactic(h){return this.tactic=h,this}requestFallback(h){if(!this.onRequestFallback)throw new Error(`"onRequestFallback" not defined on ${this.constructor.name}`);return this.fallbackRequested=!0,this.onRequestFallback(h)}validateSettings(){throw new Error(`"validateSettings" not defined on ${this.constructor.name}`)}addSubKernel(h){if(this.subKernels===null&&(this.subKernels=[]),!h.source)throw new Error('subKernel missing "source" property');if(!h.property&&isNaN(h.property))throw new Error('subKernel missing "property" property');if(!h.name)throw new Error('subKernel missing "name" property');return this.subKernels.push(h),this}destroy(h){throw new Error(`"destroy" called on ${this.constructor.name}`)}getBitRatio(h){if(this.precision==="single")return 4;if(Array.isArray(h[0]))return this.getBitRatio(h[0]);if(h.constructor===o)return this.getBitRatio(h.value);switch(h.constructor){case Uint8ClampedArray:case Uint8Array:case Int8Array:return 1;case Uint16Array:case Int16Array:return 2;case Float32Array:case Int32Array:default:return 4}}getPixels(h){throw new Error(`"getPixels" called on ${this.constructor.name}`)}checkOutput(){if(!this.output||!i.isArray(this.output))throw new Error("kernel.output not an array");if(this.output.length<1)throw new Error("kernel.output is empty, needs at least 1 value");for(let h=0;h<this.output.length;h++)if(isNaN(this.output[h])||this.output[h]<1)throw new Error(`${this.constructor.name}.output[${h}] incorrectly defined as \`${this.output[h]}\`, needs to be numeric, and greater than 0`)}prependString(h){throw new Error(`"prependString" called on ${this.constructor.name}`)}hasPrependString(h){throw new Error(`"hasPrependString" called on ${this.constructor.name}`)}toJSON(){return{settings:{output:this.output,pipeline:this.pipeline,argumentNames:this.argumentNames,argumentsTypes:this.argumentTypes,constants:this.constants,pluginNames:this.plugins?this.plugins.map(h=>h.name):null,returnType:this.returnType}}}buildSignature(h){const c=this.constructor;this.signature=c.getSignature(this,c.getArgumentTypes(this,h))}static getArgumentTypes(h,c){const d=new Array(c.length);for(let p=0;p<c.length;p++){const f=c[p],g=h.argumentTypes[p];if(f.type)d[p]=f.type;else switch(g){case"Number":case"Integer":case"Float":case"ArrayTexture(1)":d[p]=i.getVariableType(f);break;default:d[p]=g}}return d}static getSignature(h,c){throw new Error(`"getSignature" not implemented on ${this.name}`)}functionToIGPUFunction(h,c={}){if(typeof h!="string"&&typeof h!="function")throw new Error("source not a string or function");const d=typeof h=="string"?h:h.toString();let p=[];return Array.isArray(c.argumentTypes)?p=c.argumentTypes:typeof c.argumentTypes=="object"?p=i.getArgumentNamesFromString(d).map(f=>c.argumentTypes[f])||[]:p=c.argumentTypes||[],{name:i.getFunctionNameFromString(d)||null,source:d,argumentTypes:p,returnType:c.returnType||null}}onActivate(h){}}function u(l){const h=Object.keys(l),c=[];for(let d=0;d<h.length;d++){const p=h[d];c.push(l[p])}return{argumentTypes:c,argumentNames:h}}s.exports={Kernel:a}},{"../input":110,"../utils":114}],37:[function(t,s,r){const i=`__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

varying vec2 vTexCoord;

float acosh(float x) {
  return log(x + sqrt(x * x - 1.0));
}

float sinh(float x) {
  return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;
}

float asinh(float x) {
  return log(x + sqrt(x * x + 1.0));
}

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float atanh(float x) {
  x = (x + 1.0) / (x - 1.0);
  if (x < 0.0) {
    return 0.5 * log(-x);
  }
  return 0.5 * log(x);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float cosh(float x) {
  return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; 
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float tanh(float x) {
  float e = exp(2.0 * x);
  return (e - 1.0) / (e + 1.0);
}

float trunc(float x) {
  if (x >= 0.0) {
    return floor(x); 
  } else {
    return ceil(x);
  }
}

vec4 _round(vec4 x) {
  return floor(x + 0.5);
}

float _round(float x) {
  return floor(x + 0.5);
}

const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x / y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(_round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
  if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
  return 0.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  if (channel == 0) return texel.r * 255.0;
  if (channel == 1) return texel.g * 255.0;
  if (channel == 2) return texel.b * 255.0;
  if (channel == 3) return texel.a * 255.0;
  return 0.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return texel.r;
  if (channel == 1) return texel.g;
  if (channel == 2) return texel.b;
  if (channel == 3) return texel.a;
  return 0.0;
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture2D(tex, st / vec2(texSize));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
  
  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

void color(sampler2D image) {
  actualColor = texture2D(image, vTexCoord);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;s.exports={fragmentShader:i}},{}],38:[function(t,s,r){const{utils:i}=t("../../utils"),{FunctionNode:o}=t("../function-node");class a extends o{constructor(c,d){super(c,d),d&&d.hasOwnProperty("fixIntegerDivisionAccuracy")&&(this.fixIntegerDivisionAccuracy=d.fixIntegerDivisionAccuracy)}astConditionalExpression(c,d){if(c.type!=="ConditionalExpression")throw this.astErrorOutput("Not a conditional expression",c);const p=this.getType(c.consequent),f=this.getType(c.alternate);return p===null&&f===null?(d.push("if ("),this.astGeneric(c.test,d),d.push(") {"),this.astGeneric(c.consequent,d),d.push(";"),d.push("} else {"),this.astGeneric(c.alternate,d),d.push(";"),d.push("}"),d):(d.push("("),this.astGeneric(c.test,d),d.push("?"),this.astGeneric(c.consequent,d),d.push(":"),this.astGeneric(c.alternate,d),d.push(")"),d)}astFunction(c,d){if(this.isRootKernel)d.push("void");else{this.returnType||this.findLastReturn()&&(this.returnType=this.getType(c.body),this.returnType==="LiteralInteger"&&(this.returnType="Number"));const{returnType:p}=this;if(!p)d.push("void");else{const f=u[p];if(!f)throw new Error(`unknown type ${p}`);d.push(f)}}if(d.push(" "),d.push(this.name),d.push("("),!this.isRootKernel)for(let p=0;p<this.argumentNames.length;++p){const f=this.argumentNames[p];p>0&&d.push(", ");let g=this.argumentTypes[this.argumentNames.indexOf(f)];if(!g)throw this.astErrorOutput(`Unknown argument ${f} type`,c);g==="LiteralInteger"&&(this.argumentTypes[p]=g="Number");const m=u[g];if(!m)throw this.astErrorOutput("Unexpected expression",c);const b=i.sanitizeName(f);m==="sampler2D"||m==="sampler2DArray"?d.push(`${m} user_${b},ivec2 user_${b}Size,ivec3 user_${b}Dim`):d.push(`${m} user_${b}`)}d.push(`) {
`);for(let p=0;p<c.body.body.length;++p)this.astGeneric(c.body.body[p],d),d.push(`
`);return d.push(`}
`),d}astReturnStatement(c,d){if(!c.argument)throw this.astErrorOutput("Unexpected return statement",c);this.pushState("skip-literal-correction");const p=this.getType(c.argument);this.popState("skip-literal-correction");const f=[];switch(this.returnType||(p==="LiteralInteger"||p==="Integer"?this.returnType="Number":this.returnType=p),this.returnType){case"LiteralInteger":case"Number":case"Float":switch(p){case"Integer":f.push("float("),this.astGeneric(c.argument,f),f.push(")");break;case"LiteralInteger":this.castLiteralToFloat(c.argument,f),this.getType(c)==="Integer"&&(f.unshift("float("),f.push(")"));break;default:this.astGeneric(c.argument,f)}break;case"Integer":switch(p){case"Float":case"Number":this.castValueToInteger(c.argument,f);break;case"LiteralInteger":this.castLiteralToInteger(c.argument,f);break;default:this.astGeneric(c.argument,f)}break;case"Array(4)":case"Array(3)":case"Array(2)":case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":case"Input":this.astGeneric(c.argument,f);break;default:throw this.astErrorOutput(`unhandled return type ${this.returnType}`,c)}return this.isRootKernel?(d.push(`kernelResult = ${f.join("")};`),d.push("return;")):this.isSubKernel?(d.push(`subKernelResult_${this.name} = ${f.join("")};`),d.push(`return subKernelResult_${this.name};`)):d.push(`return ${f.join("")};`),d}astLiteral(c,d){if(isNaN(c.value))throw this.astErrorOutput("Non-numeric literal not supported : "+c.value,c);const p=this.astKey(c);return Number.isInteger(c.value)?this.isState("casting-to-integer")||this.isState("building-integer")?(this.literalTypes[p]="Integer",d.push(`${c.value}`)):this.isState("casting-to-float")||this.isState("building-float")?(this.literalTypes[p]="Number",d.push(`${c.value}.0`)):(this.literalTypes[p]="Number",d.push(`${c.value}.0`)):this.isState("casting-to-integer")||this.isState("building-integer")?(this.literalTypes[p]="Integer",d.push(Math.round(c.value))):(this.literalTypes[p]="Number",d.push(`${c.value}`)),d}astBinaryExpression(c,d){if(this.checkAndUpconvertOperator(c,d))return d;if(this.fixIntegerDivisionAccuracy&&c.operator==="/"){switch(d.push("divWithIntCheck("),this.pushState("building-float"),this.getType(c.left)){case"Integer":this.castValueToFloat(c.left,d);break;case"LiteralInteger":this.castLiteralToFloat(c.left,d);break;default:this.astGeneric(c.left,d)}switch(d.push(", "),this.getType(c.right)){case"Integer":this.castValueToFloat(c.right,d);break;case"LiteralInteger":this.castLiteralToFloat(c.right,d);break;default:this.astGeneric(c.right,d)}return this.popState("building-float"),d.push(")"),d}d.push("(");const p=this.getType(c.left)||"Number",f=this.getType(c.right)||"Number",g=p+" & "+f;switch(g){case"Integer & Integer":this.pushState("building-integer"),this.astGeneric(c.left,d),d.push(l[c.operator]||c.operator),this.astGeneric(c.right,d),this.popState("building-integer");break;case"Number & Float":case"Float & Number":case"Float & Float":case"Number & Number":this.pushState("building-float"),this.astGeneric(c.left,d),d.push(l[c.operator]||c.operator),this.astGeneric(c.right,d),this.popState("building-float");break;case"LiteralInteger & LiteralInteger":this.isState("casting-to-integer")||this.isState("building-integer")?(this.pushState("building-integer"),this.astGeneric(c.left,d),d.push(l[c.operator]||c.operator),this.astGeneric(c.right,d),this.popState("building-integer")):(this.pushState("building-float"),this.castLiteralToFloat(c.left,d),d.push(l[c.operator]||c.operator),this.castLiteralToFloat(c.right,d),this.popState("building-float"));break;case"Integer & Float":case"Integer & Number":if((c.operator===">"||c.operator==="<"&&c.right.type==="Literal")&&!Number.isInteger(c.right.value)){this.pushState("building-float"),this.castValueToFloat(c.left,d),d.push(l[c.operator]||c.operator),this.astGeneric(c.right,d),this.popState("building-float");break}if(this.pushState("building-integer"),this.astGeneric(c.left,d),d.push(l[c.operator]||c.operator),this.pushState("casting-to-integer"),c.right.type==="Literal"){const m=[];if(this.astGeneric(c.right,m),this.getType(c.right)==="Integer")d.push(m.join(""));else throw this.astErrorOutput("Unhandled binary expression with literal",c)}else d.push("int("),this.astGeneric(c.right,d),d.push(")");this.popState("casting-to-integer"),this.popState("building-integer");break;case"Integer & LiteralInteger":this.pushState("building-integer"),this.astGeneric(c.left,d),d.push(l[c.operator]||c.operator),this.castLiteralToInteger(c.right,d),this.popState("building-integer");break;case"Number & Integer":this.pushState("building-float"),this.astGeneric(c.left,d),d.push(l[c.operator]||c.operator),this.castValueToFloat(c.right,d),this.popState("building-float");break;case"Float & LiteralInteger":case"Number & LiteralInteger":this.pushState("building-float"),this.astGeneric(c.left,d),d.push(l[c.operator]||c.operator),this.castLiteralToFloat(c.right,d),this.popState("building-float");break;case"LiteralInteger & Float":case"LiteralInteger & Number":this.isState("casting-to-integer")?(this.pushState("building-integer"),this.castLiteralToInteger(c.left,d),d.push(l[c.operator]||c.operator),this.castValueToInteger(c.right,d),this.popState("building-integer")):(this.pushState("building-float"),this.astGeneric(c.left,d),d.push(l[c.operator]||c.operator),this.pushState("casting-to-float"),this.astGeneric(c.right,d),this.popState("casting-to-float"),this.popState("building-float"));break;case"LiteralInteger & Integer":this.pushState("building-integer"),this.castLiteralToInteger(c.left,d),d.push(l[c.operator]||c.operator),this.astGeneric(c.right,d),this.popState("building-integer");break;case"Boolean & Boolean":this.pushState("building-boolean"),this.astGeneric(c.left,d),d.push(l[c.operator]||c.operator),this.astGeneric(c.right,d),this.popState("building-boolean");break;case"Float & Integer":this.pushState("building-float"),this.astGeneric(c.left,d),d.push(l[c.operator]||c.operator),this.castValueToFloat(c.right,d),this.popState("building-float");break;default:throw this.astErrorOutput(`Unhandled binary expression between ${g}`,c)}return d.push(")"),d}checkAndUpconvertOperator(c,d){const p=this.checkAndUpconvertBitwiseOperators(c,d);if(p)return p;const g={"%":this.fixIntegerDivisionAccuracy?"integerCorrectionModulo":"modulo","**":"pow"}[c.operator];if(!g)return null;switch(d.push(g),d.push("("),this.getType(c.left)){case"Integer":this.castValueToFloat(c.left,d);break;case"LiteralInteger":this.castLiteralToFloat(c.left,d);break;default:this.astGeneric(c.left,d)}switch(d.push(","),this.getType(c.right)){case"Integer":this.castValueToFloat(c.right,d);break;case"LiteralInteger":this.castLiteralToFloat(c.right,d);break;default:this.astGeneric(c.right,d)}return d.push(")"),d}checkAndUpconvertBitwiseOperators(c,d){const f={"&":"bitwiseAnd","|":"bitwiseOr","^":"bitwiseXOR","<<":"bitwiseZeroFillLeftShift",">>":"bitwiseSignedRightShift",">>>":"bitwiseZeroFillRightShift"}[c.operator];if(!f)return null;switch(d.push(f),d.push("("),this.getType(c.left)){case"Number":case"Float":this.castValueToInteger(c.left,d);break;case"LiteralInteger":this.castLiteralToInteger(c.left,d);break;default:this.astGeneric(c.left,d)}switch(d.push(","),this.getType(c.right)){case"Number":case"Float":this.castValueToInteger(c.right,d);break;case"LiteralInteger":this.castLiteralToInteger(c.right,d);break;default:this.astGeneric(c.right,d)}return d.push(")"),d}checkAndUpconvertBitwiseUnary(c,d){const f={"~":"bitwiseNot"}[c.operator];if(!f)return null;switch(d.push(f),d.push("("),this.getType(c.argument)){case"Number":case"Float":this.castValueToInteger(c.argument,d);break;case"LiteralInteger":this.castLiteralToInteger(c.argument,d);break;default:this.astGeneric(c.argument,d)}return d.push(")"),d}castLiteralToInteger(c,d){return this.pushState("casting-to-integer"),this.astGeneric(c,d),this.popState("casting-to-integer"),d}castLiteralToFloat(c,d){return this.pushState("casting-to-float"),this.astGeneric(c,d),this.popState("casting-to-float"),d}castValueToInteger(c,d){return this.pushState("casting-to-integer"),d.push("int("),this.astGeneric(c,d),d.push(")"),this.popState("casting-to-integer"),d}castValueToFloat(c,d){return this.pushState("casting-to-float"),d.push("float("),this.astGeneric(c,d),d.push(")"),this.popState("casting-to-float"),d}astIdentifierExpression(c,d){if(c.type!=="Identifier")throw this.astErrorOutput("IdentifierExpression - not an Identifier",c);const p=this.getType(c),f=i.sanitizeName(c.name);return c.name==="Infinity"?d.push("3.402823466e+38"):p==="Boolean"?this.argumentNames.indexOf(f)>-1?d.push(`bool(user_${f})`):d.push(`user_${f}`):d.push(`user_${f}`),d}astForStatement(c,d){if(c.type!=="ForStatement")throw this.astErrorOutput("Invalid for statement",c);const p=[],f=[],g=[],m=[];let b=null;if(c.init){const{declarations:x}=c.init;x.length>1&&(b=!1),this.astGeneric(c.init,p);for(let v=0;v<x.length;v++)x[v].init&&x[v].init.type!=="Literal"&&(b=!1)}else b=!1;if(c.test?this.astGeneric(c.test,f):b=!1,c.update?this.astGeneric(c.update,g):b=!1,c.body&&(this.pushState("loop-body"),this.astGeneric(c.body,m),this.popState("loop-body")),b===null&&(b=this.isSafe(c.init)&&this.isSafe(c.test)),b){const x=p.join(""),v=x[x.length-1]!==";";d.push(`for (${x}${v?";":""}${f.join("")};${g.join("")}){
`),d.push(m.join("")),d.push(`}
`)}else{const x=this.getInternalVariableName("safeI");p.length>0&&d.push(p.join(""),`
`),d.push(`for (int ${x}=0;${x}<LOOP_MAX;${x}++){
`),f.length>0&&d.push(`if (!${f.join("")}) break;
`),d.push(m.join("")),d.push(`
${g.join("")};`),d.push(`}
`)}return d}astWhileStatement(c,d){if(c.type!=="WhileStatement")throw this.astErrorOutput("Invalid while statement",c);const p=this.getInternalVariableName("safeI");return d.push(`for (int ${p}=0;${p}<LOOP_MAX;${p}++){
`),d.push("if (!"),this.astGeneric(c.test,d),d.push(`) break;
`),this.astGeneric(c.body,d),d.push(`}
`),d}astDoWhileStatement(c,d){if(c.type!=="DoWhileStatement")throw this.astErrorOutput("Invalid while statement",c);const p=this.getInternalVariableName("safeI");return d.push(`for (int ${p}=0;${p}<LOOP_MAX;${p}++){
`),this.astGeneric(c.body,d),d.push("if (!"),this.astGeneric(c.test,d),d.push(`) break;
`),d.push(`}
`),d}astAssignmentExpression(c,d){if(c.operator==="%=")this.astGeneric(c.left,d),d.push("="),d.push("mod("),this.astGeneric(c.left,d),d.push(","),this.astGeneric(c.right,d),d.push(")");else if(c.operator==="**=")this.astGeneric(c.left,d),d.push("="),d.push("pow("),this.astGeneric(c.left,d),d.push(","),this.astGeneric(c.right,d),d.push(")");else{const p=this.getType(c.left),f=this.getType(c.right);return this.astGeneric(c.left,d),d.push(c.operator),p!=="Integer"&&f==="Integer"?(d.push("float("),this.astGeneric(c.right,d),d.push(")")):this.astGeneric(c.right,d),d}}astBlockStatement(c,d){if(this.isState("loop-body")){this.pushState("block-body");for(let p=0;p<c.body.length;p++)this.astGeneric(c.body[p],d);this.popState("block-body")}else{d.push(`{
`);for(let p=0;p<c.body.length;p++)this.astGeneric(c.body[p],d);d.push(`}
`)}return d}astVariableDeclaration(c,d){const p=c.declarations;if(!p||!p[0]||!p[0].init)throw this.astErrorOutput("Unexpected expression",c);const f=[];let g=null;const m=[];let b=[];for(let x=0;x<p.length;x++){const v=p[x],w=v.init,S=this.getDeclaration(v.id),k=this.getType(v.init);let E=k;E==="LiteralInteger"&&(S.suggestedType==="Integer"?E="Integer":E="Number");const I=u[E];if(!I)throw this.astErrorOutput(`Markup type ${E} not handled`,c);const C=[];if(k==="Integer"&&E==="Integer"){if(S.valueType="Number",x===0||g===null)C.push("float ");else if(E!==g)throw new Error("Unhandled declaration");g=E,C.push(`user_${i.sanitizeName(v.id.name)}=`),C.push("float("),this.astGeneric(w,C),C.push(")")}else S.valueType=E,x===0||g===null?C.push(`${I} `):E!==g&&(m.push(b.join(",")),b=[],C.push(`${I} `)),g=E,C.push(`user_${i.sanitizeName(v.id.name)}=`),k==="Number"&&E==="Integer"?w.left&&w.left.type==="Literal"?this.astGeneric(w,C):(C.push("int("),this.astGeneric(w,C),C.push(")")):k==="LiteralInteger"&&E==="Integer"?this.castLiteralToInteger(w,C):this.astGeneric(w,C);b.push(C.join(""))}return b.length>0&&m.push(b.join(",")),f.push(m.join(";")),d.push(f.join("")),d.push(";"),d}astIfStatement(c,d){return d.push("if ("),this.astGeneric(c.test,d),d.push(")"),c.consequent.type==="BlockStatement"?this.astGeneric(c.consequent,d):(d.push(` {
`),this.astGeneric(c.consequent,d),d.push(`
}
`)),c.alternate&&(d.push("else "),c.alternate.type==="BlockStatement"||c.alternate.type==="IfStatement"?this.astGeneric(c.alternate,d):(d.push(` {
`),this.astGeneric(c.alternate,d),d.push(`
}
`))),d}astSwitchStatement(c,d){if(c.type!=="SwitchStatement")throw this.astErrorOutput("Invalid switch statement",c);const{discriminant:p,cases:f}=c,g=this.getType(p),m=`switchDiscriminant${this.astKey(c,"_")}`;switch(g){case"Float":case"Number":d.push(`float ${m} = `),this.astGeneric(p,d),d.push(`;
`);break;case"Integer":d.push(`int ${m} = `),this.astGeneric(p,d),d.push(`;
`);break}if(f.length===1&&!f[0].test)return this.astGeneric(f[0].consequent,d),d;let b=!1,x=[],v=!1,w=!1;for(let S=0;S<f.length;S++){if(f[S].test){if(S===0||!w?(w=!0,d.push(`if (${m} == `)):b?(d.push(`${m} == `),b=!1):d.push(` else if (${m} == `),g==="Integer")switch(this.getType(f[S].test)){case"Number":case"Float":this.castValueToInteger(f[S].test,d);break;case"LiteralInteger":this.castLiteralToInteger(f[S].test,d);break}else if(g==="Float")switch(this.getType(f[S].test)){case"LiteralInteger":this.castLiteralToFloat(f[S].test,d);break;case"Integer":this.castValueToFloat(f[S].test,d);break}else throw new Error("unhanlded");if(!f[S].consequent||f[S].consequent.length===0){b=!0,d.push(" || ");continue}d.push(`) {
`)}else if(f.length>S+1){v=!0,this.astGeneric(f[S].consequent,x);continue}else d.push(` else {
`);this.astGeneric(f[S].consequent,d),d.push(`
}`)}return v&&(d.push(" else {"),d.push(x.join("")),d.push("}")),d}astThisExpression(c,d){return d.push("this"),d}astMemberExpression(c,d){const{property:p,name:f,signature:g,origin:m,type:b,xProperty:x,yProperty:v,zProperty:w}=this.getMemberExpressionDetails(c);switch(g){case"value.thread.value":case"this.thread.value":if(f!=="x"&&f!=="y"&&f!=="z")throw this.astErrorOutput("Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`",c);return d.push(`threadId.${f}`),d;case"this.output.value":if(this.dynamicOutput)switch(f){case"x":this.isState("casting-to-float")?d.push("float(uOutputDim.x)"):d.push("uOutputDim.x");break;case"y":this.isState("casting-to-float")?d.push("float(uOutputDim.y)"):d.push("uOutputDim.y");break;case"z":this.isState("casting-to-float")?d.push("float(uOutputDim.z)"):d.push("uOutputDim.z");break;default:throw this.astErrorOutput("Unexpected expression",c)}else switch(f){case"x":this.isState("casting-to-integer")?d.push(this.output[0]):d.push(this.output[0],".0");break;case"y":this.isState("casting-to-integer")?d.push(this.output[1]):d.push(this.output[1],".0");break;case"z":this.isState("casting-to-integer")?d.push(this.output[2]):d.push(this.output[2],".0");break;default:throw this.astErrorOutput("Unexpected expression",c)}return d;case"value":throw this.astErrorOutput("Unexpected expression",c);case"value[]":case"value[][]":case"value[][][]":case"value[][][][]":case"value.value":if(m==="Math")return d.push(Math[f]),d;const k=i.sanitizeName(f);switch(p){case"r":return d.push(`user_${k}.r`),d;case"g":return d.push(`user_${k}.g`),d;case"b":return d.push(`user_${k}.b`),d;case"a":return d.push(`user_${k}.a`),d}break;case"this.constants.value":if(typeof x>"u")switch(b){case"Array(2)":case"Array(3)":case"Array(4)":return d.push(`constants_${i.sanitizeName(f)}`),d}case"this.constants.value[]":case"this.constants.value[][]":case"this.constants.value[][][]":case"this.constants.value[][][][]":break;case"fn()[]":return this.astCallExpression(c.object,d),d.push("["),d.push(this.memberExpressionPropertyMarkup(p)),d.push("]"),d;case"fn()[][]":return this.astCallExpression(c.object.object,d),d.push("["),d.push(this.memberExpressionPropertyMarkup(c.object.property)),d.push("]"),d.push("["),d.push(this.memberExpressionPropertyMarkup(c.property)),d.push("]"),d;case"[][]":return this.astArrayExpression(c.object,d),d.push("["),d.push(this.memberExpressionPropertyMarkup(p)),d.push("]"),d;default:throw this.astErrorOutput("Unexpected expression",c)}if(c.computed===!1)switch(b){case"Number":case"Integer":case"Float":case"Boolean":return d.push(`${m}_${i.sanitizeName(f)}`),d}const S=`${m}_${i.sanitizeName(f)}`;switch(b){case"Array(2)":case"Array(3)":case"Array(4)":this.astGeneric(c.object,d),d.push("["),d.push(this.memberExpressionPropertyMarkup(x)),d.push("]");break;case"HTMLImageArray":d.push(`getImage3D(${S}, ${S}Size, ${S}Dim, `),this.memberExpressionXYZ(x,v,w,d),d.push(")");break;case"ArrayTexture(1)":d.push(`getFloatFromSampler2D(${S}, ${S}Size, ${S}Dim, `),this.memberExpressionXYZ(x,v,w,d),d.push(")");break;case"Array1D(2)":case"Array2D(2)":case"Array3D(2)":d.push(`getMemoryOptimizedVec2(${S}, ${S}Size, ${S}Dim, `),this.memberExpressionXYZ(x,v,w,d),d.push(")");break;case"ArrayTexture(2)":d.push(`getVec2FromSampler2D(${S}, ${S}Size, ${S}Dim, `),this.memberExpressionXYZ(x,v,w,d),d.push(")");break;case"Array1D(3)":case"Array2D(3)":case"Array3D(3)":d.push(`getMemoryOptimizedVec3(${S}, ${S}Size, ${S}Dim, `),this.memberExpressionXYZ(x,v,w,d),d.push(")");break;case"ArrayTexture(3)":d.push(`getVec3FromSampler2D(${S}, ${S}Size, ${S}Dim, `),this.memberExpressionXYZ(x,v,w,d),d.push(")");break;case"Array1D(4)":case"Array2D(4)":case"Array3D(4)":d.push(`getMemoryOptimizedVec4(${S}, ${S}Size, ${S}Dim, `),this.memberExpressionXYZ(x,v,w,d),d.push(")");break;case"ArrayTexture(4)":case"HTMLCanvas":case"OffscreenCanvas":case"HTMLImage":case"ImageBitmap":case"ImageData":case"HTMLVideo":d.push(`getVec4FromSampler2D(${S}, ${S}Size, ${S}Dim, `),this.memberExpressionXYZ(x,v,w,d),d.push(")");break;case"NumberTexture":case"Array":case"Array2D":case"Array3D":case"Array4D":case"Input":case"Number":case"Float":case"Integer":if(this.precision==="single")d.push(`getMemoryOptimized32(${S}, ${S}Size, ${S}Dim, `),this.memberExpressionXYZ(x,v,w,d),d.push(")");else{const k=m==="user"?this.lookupFunctionArgumentBitRatio(this.name,f):this.constantBitRatios[f];switch(k){case 1:d.push(`get8(${S}, ${S}Size, ${S}Dim, `);break;case 2:d.push(`get16(${S}, ${S}Size, ${S}Dim, `);break;case 4:case 0:d.push(`get32(${S}, ${S}Size, ${S}Dim, `);break;default:throw new Error(`unhandled bit ratio of ${k}`)}this.memberExpressionXYZ(x,v,w,d),d.push(")")}break;case"MemoryOptimizedNumberTexture":d.push(`getMemoryOptimized32(${S}, ${S}Size, ${S}Dim, `),this.memberExpressionXYZ(x,v,w,d),d.push(")");break;case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":d.push(`${S}[${this.memberExpressionPropertyMarkup(v)}]`),v&&d.push(`[${this.memberExpressionPropertyMarkup(x)}]`);break;default:throw new Error(`unhandled member expression "${b}"`)}return d}astCallExpression(c,d){if(!c.callee)throw this.astErrorOutput("Unknown CallExpression",c);let p=null;const f=this.isAstMathFunction(c);if(f||c.callee.object&&c.callee.object.type==="ThisExpression"?p=c.callee.property.name:c.callee.type==="SequenceExpression"&&c.callee.expressions[0].type==="Literal"&&!isNaN(c.callee.expressions[0].raw)?p=c.callee.expressions[1].property.name:p=c.callee.name,!p)throw this.astErrorOutput("Unhandled function, couldn't find name",c);switch(p){case"pow":p="_pow";break;case"round":p="_round";break}if(this.calledFunctions.indexOf(p)<0&&this.calledFunctions.push(p),p==="random"&&this.plugins&&this.plugins.length>0)for(let g=0;g<this.plugins.length;g++){const m=this.plugins[g];if(m.functionMatch==="Math.random()"&&m.functionReplace)return d.push(m.functionReplace),d}if(this.onFunctionCall&&this.onFunctionCall(this.name,p,c.arguments),d.push(p),d.push("("),f)for(let g=0;g<c.arguments.length;++g){const m=c.arguments[g],b=this.getType(m);switch(g>0&&d.push(", "),b){case"Integer":this.castValueToFloat(m,d);break;default:this.astGeneric(m,d);break}}else{const g=this.lookupFunctionArgumentTypes(p)||[];for(let m=0;m<c.arguments.length;++m){const b=c.arguments[m];let x=g[m];m>0&&d.push(", ");const v=this.getType(b);switch(x||(this.triggerImplyArgumentType(p,m,v,this),x=v),v){case"Boolean":this.astGeneric(b,d);continue;case"Number":case"Float":if(x==="Integer"){d.push("int("),this.astGeneric(b,d),d.push(")");continue}else if(x==="Number"||x==="Float"){this.astGeneric(b,d);continue}else if(x==="LiteralInteger"){this.castLiteralToFloat(b,d);continue}break;case"Integer":if(x==="Number"||x==="Float"){d.push("float("),this.astGeneric(b,d),d.push(")");continue}else if(x==="Integer"){this.astGeneric(b,d);continue}break;case"LiteralInteger":if(x==="Integer"){this.castLiteralToInteger(b,d);continue}else if(x==="Number"||x==="Float"){this.castLiteralToFloat(b,d);continue}else if(x==="LiteralInteger"){this.astGeneric(b,d);continue}break;case"Array(2)":case"Array(3)":case"Array(4)":if(x===v){if(b.type==="Identifier")d.push(`user_${i.sanitizeName(b.name)}`);else if(b.type==="ArrayExpression"||b.type==="MemberExpression"||b.type==="CallExpression")this.astGeneric(b,d);else throw this.astErrorOutput(`Unhandled argument type ${b.type}`,c);continue}break;case"HTMLCanvas":case"OffscreenCanvas":case"HTMLImage":case"ImageBitmap":case"ImageData":case"HTMLImageArray":case"HTMLVideo":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":case"Array":case"Input":if(x===v){if(b.type!=="Identifier")throw this.astErrorOutput(`Unhandled argument type ${b.type}`,c);this.triggerImplyArgumentBitRatio(this.name,b.name,p,m);const w=i.sanitizeName(b.name);d.push(`user_${w},user_${w}Size,user_${w}Dim`);continue}break}throw this.astErrorOutput(`Unhandled argument combination of ${v} and ${x} for argument named "${b.name}"`,c)}}return d.push(")"),d}astArrayExpression(c,d){const p=this.getType(c),f=c.elements.length;switch(p){case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":d.push(`mat${f}(`);break;default:d.push(`vec${f}(`)}for(let g=0;g<f;++g){g>0&&d.push(", ");const m=c.elements[g];this.astGeneric(m,d)}return d.push(")"),d}memberExpressionXYZ(c,d,p,f){return p?f.push(this.memberExpressionPropertyMarkup(p),", "):f.push("0, "),d?f.push(this.memberExpressionPropertyMarkup(d),", "):f.push("0, "),f.push(this.memberExpressionPropertyMarkup(c)),f}memberExpressionPropertyMarkup(c){if(!c)throw new Error("Property not set");const d=this.getType(c),p=[];switch(d){case"Number":case"Float":this.castValueToInteger(c,p);break;case"LiteralInteger":this.castLiteralToInteger(c,p);break;default:this.astGeneric(c,p)}return p.join("")}}const u={Array:"sampler2D","Array(2)":"vec2","Array(3)":"vec3","Array(4)":"vec4","Matrix(2)":"mat2","Matrix(3)":"mat3","Matrix(4)":"mat4",Array2D:"sampler2D",Array3D:"sampler2D",Boolean:"bool",Float:"float",Input:"sampler2D",Integer:"int",Number:"float",LiteralInteger:"float",NumberTexture:"sampler2D",MemoryOptimizedNumberTexture:"sampler2D","ArrayTexture(1)":"sampler2D","ArrayTexture(2)":"sampler2D","ArrayTexture(3)":"sampler2D","ArrayTexture(4)":"sampler2D",HTMLVideo:"sampler2D",HTMLCanvas:"sampler2D",OffscreenCanvas:"sampler2D",HTMLImage:"sampler2D",ImageBitmap:"sampler2D",ImageData:"sampler2D",HTMLImageArray:"sampler2DArray"},l={"===":"==","!==":"!="};s.exports={WebGLFunctionNode:a}},{"../../utils":114,"../function-node":10}],39:[function(t,s,r){const{WebGLKernelValueBoolean:i}=t("./kernel-value/boolean"),{WebGLKernelValueFloat:o}=t("./kernel-value/float"),{WebGLKernelValueInteger:a}=t("./kernel-value/integer"),{WebGLKernelValueHTMLImage:u}=t("./kernel-value/html-image"),{WebGLKernelValueDynamicHTMLImage:l}=t("./kernel-value/dynamic-html-image"),{WebGLKernelValueHTMLVideo:h}=t("./kernel-value/html-video"),{WebGLKernelValueDynamicHTMLVideo:c}=t("./kernel-value/dynamic-html-video"),{WebGLKernelValueSingleInput:d}=t("./kernel-value/single-input"),{WebGLKernelValueDynamicSingleInput:p}=t("./kernel-value/dynamic-single-input"),{WebGLKernelValueUnsignedInput:f}=t("./kernel-value/unsigned-input"),{WebGLKernelValueDynamicUnsignedInput:g}=t("./kernel-value/dynamic-unsigned-input"),{WebGLKernelValueMemoryOptimizedNumberTexture:m}=t("./kernel-value/memory-optimized-number-texture"),{WebGLKernelValueDynamicMemoryOptimizedNumberTexture:b}=t("./kernel-value/dynamic-memory-optimized-number-texture"),{WebGLKernelValueNumberTexture:x}=t("./kernel-value/number-texture"),{WebGLKernelValueDynamicNumberTexture:v}=t("./kernel-value/dynamic-number-texture"),{WebGLKernelValueSingleArray:w}=t("./kernel-value/single-array"),{WebGLKernelValueDynamicSingleArray:S}=t("./kernel-value/dynamic-single-array"),{WebGLKernelValueSingleArray1DI:k}=t("./kernel-value/single-array1d-i"),{WebGLKernelValueDynamicSingleArray1DI:E}=t("./kernel-value/dynamic-single-array1d-i"),{WebGLKernelValueSingleArray2DI:I}=t("./kernel-value/single-array2d-i"),{WebGLKernelValueDynamicSingleArray2DI:C}=t("./kernel-value/dynamic-single-array2d-i"),{WebGLKernelValueSingleArray3DI:T}=t("./kernel-value/single-array3d-i"),{WebGLKernelValueDynamicSingleArray3DI:R}=t("./kernel-value/dynamic-single-array3d-i"),{WebGLKernelValueArray2:P}=t("./kernel-value/array2"),{WebGLKernelValueArray3:D}=t("./kernel-value/array3"),{WebGLKernelValueArray4:F}=t("./kernel-value/array4"),{WebGLKernelValueUnsignedArray:z}=t("./kernel-value/unsigned-array"),{WebGLKernelValueDynamicUnsignedArray:_}=t("./kernel-value/dynamic-unsigned-array"),B={unsigned:{dynamic:{Boolean:i,Integer:a,Float:o,Array:_,"Array(2)":P,"Array(3)":D,"Array(4)":F,"Array1D(2)":!1,"Array1D(3)":!1,"Array1D(4)":!1,"Array2D(2)":!1,"Array2D(3)":!1,"Array2D(4)":!1,"Array3D(2)":!1,"Array3D(3)":!1,"Array3D(4)":!1,Input:g,NumberTexture:v,"ArrayTexture(1)":v,"ArrayTexture(2)":v,"ArrayTexture(3)":v,"ArrayTexture(4)":v,MemoryOptimizedNumberTexture:b,HTMLCanvas:l,OffscreenCanvas:l,HTMLImage:l,ImageBitmap:l,ImageData:l,HTMLImageArray:!1,HTMLVideo:c},static:{Boolean:i,Float:o,Integer:a,Array:z,"Array(2)":P,"Array(3)":D,"Array(4)":F,"Array1D(2)":!1,"Array1D(3)":!1,"Array1D(4)":!1,"Array2D(2)":!1,"Array2D(3)":!1,"Array2D(4)":!1,"Array3D(2)":!1,"Array3D(3)":!1,"Array3D(4)":!1,Input:f,NumberTexture:x,"ArrayTexture(1)":x,"ArrayTexture(2)":x,"ArrayTexture(3)":x,"ArrayTexture(4)":x,MemoryOptimizedNumberTexture:m,HTMLCanvas:u,OffscreenCanvas:u,HTMLImage:u,ImageBitmap:u,ImageData:u,HTMLImageArray:!1,HTMLVideo:h}},single:{dynamic:{Boolean:i,Integer:a,Float:o,Array:S,"Array(2)":P,"Array(3)":D,"Array(4)":F,"Array1D(2)":E,"Array1D(3)":E,"Array1D(4)":E,"Array2D(2)":C,"Array2D(3)":C,"Array2D(4)":C,"Array3D(2)":R,"Array3D(3)":R,"Array3D(4)":R,Input:p,NumberTexture:v,"ArrayTexture(1)":v,"ArrayTexture(2)":v,"ArrayTexture(3)":v,"ArrayTexture(4)":v,MemoryOptimizedNumberTexture:b,HTMLCanvas:l,OffscreenCanvas:l,HTMLImage:l,ImageBitmap:l,ImageData:l,HTMLImageArray:!1,HTMLVideo:c},static:{Boolean:i,Float:o,Integer:a,Array:w,"Array(2)":P,"Array(3)":D,"Array(4)":F,"Array1D(2)":k,"Array1D(3)":k,"Array1D(4)":k,"Array2D(2)":I,"Array2D(3)":I,"Array2D(4)":I,"Array3D(2)":T,"Array3D(3)":T,"Array3D(4)":T,Input:d,NumberTexture:x,"ArrayTexture(1)":x,"ArrayTexture(2)":x,"ArrayTexture(3)":x,"ArrayTexture(4)":x,MemoryOptimizedNumberTexture:m,HTMLCanvas:u,OffscreenCanvas:u,HTMLImage:u,ImageBitmap:u,ImageData:u,HTMLImageArray:!1,HTMLVideo:h}}};function N(O,K,U,X){if(!O)throw new Error("type missing");if(!K)throw new Error("dynamic missing");if(!U)throw new Error("precision missing");X.type&&(O=X.type);const te=B[U][K];if(te[O]===!1)return null;if(te[O]===void 0)throw new Error(`Could not find a KernelValue for ${O}`);return te[O]}s.exports={lookupKernelValueType:N,kernelValueMaps:B}},{"./kernel-value/array2":41,"./kernel-value/array3":42,"./kernel-value/array4":43,"./kernel-value/boolean":44,"./kernel-value/dynamic-html-image":45,"./kernel-value/dynamic-html-video":46,"./kernel-value/dynamic-memory-optimized-number-texture":47,"./kernel-value/dynamic-number-texture":48,"./kernel-value/dynamic-single-array":49,"./kernel-value/dynamic-single-array1d-i":50,"./kernel-value/dynamic-single-array2d-i":51,"./kernel-value/dynamic-single-array3d-i":52,"./kernel-value/dynamic-single-input":53,"./kernel-value/dynamic-unsigned-array":54,"./kernel-value/dynamic-unsigned-input":55,"./kernel-value/float":56,"./kernel-value/html-image":57,"./kernel-value/html-video":58,"./kernel-value/integer":60,"./kernel-value/memory-optimized-number-texture":61,"./kernel-value/number-texture":62,"./kernel-value/single-array":63,"./kernel-value/single-array1d-i":64,"./kernel-value/single-array2d-i":65,"./kernel-value/single-array3d-i":66,"./kernel-value/single-input":67,"./kernel-value/unsigned-array":68,"./kernel-value/unsigned-input":69}],40:[function(t,s,r){const{WebGLKernelValue:i}=t("./index"),{Input:o}=t("../../../input");class a extends i{checkSize(l,h){if(!this.kernel.validate)return;const{maxTextureSize:c}=this.kernel.constructor.features;if(l>c||h>c)throw l>h?new Error(`Argument texture width of ${l} larger than maximum size of ${c} for your GPU`):l<h?new Error(`Argument texture height of ${h} larger than maximum size of ${c} for your GPU`):new Error(`Argument texture height and width of ${h} larger than maximum size of ${c} for your GPU`)}setup(){this.requestTexture(),this.setupTexture(),this.defineTexture()}requestTexture(){this.texture=this.onRequestTexture()}defineTexture(){const{context:l}=this;l.activeTexture(this.contextHandle),l.bindTexture(l.TEXTURE_2D,this.texture),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_S,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_T,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MIN_FILTER,l.NEAREST),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MAG_FILTER,l.NEAREST)}setupTexture(){this.contextHandle=this.onRequestContextHandle(),this.index=this.onRequestIndex(),this.dimensionsId=this.id+"Dim",this.sizeId=this.id+"Size"}getBitRatio(l){if(Array.isArray(l[0]))return this.getBitRatio(l[0]);if(l.constructor===o)return this.getBitRatio(l.value);switch(l.constructor){case Uint8ClampedArray:case Uint8Array:case Int8Array:return 1;case Uint16Array:case Int16Array:return 2;case Float32Array:case Int32Array:default:return 4}}destroy(){this.prevArg&&this.prevArg.delete(),this.context.deleteTexture(this.texture)}}s.exports={WebGLKernelArray:a}},{"../../../input":110,"./index":59}],41:[function(t,s,r){const{WebGLKernelValue:i}=t("./index");class o extends i{constructor(u,l){super(u,l),this.uploadValue=u}getSource(u){return this.origin==="constants"?`const vec2 ${this.id} = vec2(${u[0]},${u[1]});
`:`uniform vec2 ${this.id};
`}getStringValueHandler(){return this.origin==="constants"?"":`const uploadValue_${this.name} = ${this.varName};
`}updateValue(u){this.origin!=="constants"&&this.kernel.setUniform2fv(this.id,this.uploadValue=u)}}s.exports={WebGLKernelValueArray2:o}},{"./index":59}],42:[function(t,s,r){const{WebGLKernelValue:i}=t("./index");class o extends i{constructor(u,l){super(u,l),this.uploadValue=u}getSource(u){return this.origin==="constants"?`const vec3 ${this.id} = vec3(${u[0]},${u[1]},${u[2]});
`:`uniform vec3 ${this.id};
`}getStringValueHandler(){return this.origin==="constants"?"":`const uploadValue_${this.name} = ${this.varName};
`}updateValue(u){this.origin!=="constants"&&this.kernel.setUniform3fv(this.id,this.uploadValue=u)}}s.exports={WebGLKernelValueArray3:o}},{"./index":59}],43:[function(t,s,r){const{WebGLKernelValue:i}=t("./index");class o extends i{constructor(u,l){super(u,l),this.uploadValue=u}getSource(u){return this.origin==="constants"?`const vec4 ${this.id} = vec4(${u[0]},${u[1]},${u[2]},${u[3]});
`:`uniform vec4 ${this.id};
`}getStringValueHandler(){return this.origin==="constants"?"":`const uploadValue_${this.name} = ${this.varName};
`}updateValue(u){this.origin!=="constants"&&this.kernel.setUniform4fv(this.id,this.uploadValue=u)}}s.exports={WebGLKernelValueArray4:o}},{"./index":59}],44:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValue:o}=t("./index");class a extends o{constructor(l,h){super(l,h),this.uploadValue=l}getSource(l){return this.origin==="constants"?`const bool ${this.id} = ${l};
`:`uniform bool ${this.id};
`}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform1i(this.id,this.uploadValue=l)}}s.exports={WebGLKernelValueBoolean:a}},{"../../../utils":114,"./index":59}],45:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueHTMLImage:o}=t("./html-image");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){const{width:h,height:c}=l;this.checkSize(h,c),this.dimensions=[h,c,1],this.textureSize=[h,c],this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGLKernelValueDynamicHTMLImage:a}},{"../../../utils":114,"./html-image":57}],46:[function(t,s,r){const{WebGLKernelValueDynamicHTMLImage:i}=t("./dynamic-html-image");class o extends i{}s.exports={WebGLKernelValueDynamicHTMLVideo:o}},{"./dynamic-html-image":45}],47:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueMemoryOptimizedNumberTexture:o}=t("./memory-optimized-number-texture");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.dimensions=l.dimensions,this.checkSize(l.size[0],l.size[1]),this.textureSize=l.size,this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGLKernelValueDynamicMemoryOptimizedNumberTexture:a}},{"../../../utils":114,"./memory-optimized-number-texture":61}],48:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueNumberTexture:o}=t("./number-texture");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.dimensions=l.dimensions,this.checkSize(l.size[0],l.size[1]),this.textureSize=l.size,this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGLKernelValueDynamicNumberTexture:a}},{"../../../utils":114,"./number-texture":62}],49:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueSingleArray:o}=t("./single-array");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.dimensions=i.getDimensions(l,!0),this.textureSize=i.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGLKernelValueDynamicSingleArray:a}},{"../../../utils":114,"./single-array":63}],50:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueSingleArray1DI:o}=t("./single-array1d-i");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.setShape(l),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGLKernelValueDynamicSingleArray1DI:a}},{"../../../utils":114,"./single-array1d-i":64}],51:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueSingleArray2DI:o}=t("./single-array2d-i");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.setShape(l),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGLKernelValueDynamicSingleArray2DI:a}},{"../../../utils":114,"./single-array2d-i":65}],52:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueSingleArray3DI:o}=t("./single-array3d-i");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.setShape(l),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGLKernelValueDynamicSingleArray3DI:a}},{"../../../utils":114,"./single-array3d-i":66}],53:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueSingleInput:o}=t("./single-input");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){let[h,c,d]=l.size;this.dimensions=new Int32Array([h||1,c||1,d||1]),this.textureSize=i.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGLKernelValueDynamicSingleInput:a}},{"../../../utils":114,"./single-input":67}],54:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueUnsignedArray:o}=t("./unsigned-array");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.dimensions=i.getDimensions(l,!0),this.textureSize=i.getMemoryOptimizedPackedTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*(4/this.bitRatio),this.checkSize(this.textureSize[0],this.textureSize[1]);const h=this.getTransferArrayType(l);this.preUploadValue=new h(this.uploadArrayLength),this.uploadValue=new Uint8Array(this.preUploadValue.buffer),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGLKernelValueDynamicUnsignedArray:a}},{"../../../utils":114,"./unsigned-array":68}],55:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueUnsignedInput:o}=t("./unsigned-input");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){let[h,c,d]=l.size;this.dimensions=new Int32Array([h||1,c||1,d||1]),this.textureSize=i.getMemoryOptimizedPackedTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*(4/this.bitRatio),this.checkSize(this.textureSize[0],this.textureSize[1]);const p=this.getTransferArrayType(l.value);this.preUploadValue=new p(this.uploadArrayLength),this.uploadValue=new Uint8Array(this.preUploadValue.buffer),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGLKernelValueDynamicUnsignedInput:a}},{"../../../utils":114,"./unsigned-input":69}],56:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValue:o}=t("./index");class a extends o{constructor(l,h){super(l,h),this.uploadValue=l}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}getSource(l){return this.origin==="constants"?Number.isInteger(l)?`const float ${this.id} = ${l}.0;
`:`const float ${this.id} = ${l};
`:`uniform float ${this.id};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform1f(this.id,this.uploadValue=l)}}s.exports={WebGLKernelValueFloat:a}},{"../../../utils":114,"./index":59}],57:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelArray:o}=t("./array");class a extends o{constructor(l,h){super(l,h);const{width:c,height:d}=l;this.checkSize(c,d),this.dimensions=[c,d,1],this.textureSize=[c,d],this.uploadValue=l}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}const{context:h}=this;h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!0),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,h.RGBA,h.UNSIGNED_BYTE,this.uploadValue=l),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueHTMLImage:a}},{"../../../utils":114,"./array":40}],58:[function(t,s,r){const{WebGLKernelValueHTMLImage:i}=t("./html-image");class o extends i{}s.exports={WebGLKernelValueHTMLVideo:o}},{"./html-image":57}],59:[function(t,s,r){const{utils:i}=t("../../../utils"),{KernelValue:o}=t("../../kernel-value");class a extends o{constructor(l,h){super(l,h),this.dimensionsId=null,this.sizeId=null,this.initialValueConstructor=l.constructor,this.onRequestTexture=h.onRequestTexture,this.onRequestIndex=h.onRequestIndex,this.uploadValue=null,this.textureSize=null,this.bitRatio=null,this.prevArg=null}get id(){return`${this.origin}_${i.sanitizeName(this.name)}`}setup(){}getTransferArrayType(l){if(Array.isArray(l[0]))return this.getTransferArrayType(l[0]);switch(l.constructor){case Array:case Int32Array:case Int16Array:case Int8Array:return Float32Array;case Uint8ClampedArray:case Uint8Array:case Uint16Array:case Uint32Array:case Float32Array:case Float64Array:return l.constructor}return console.warn("Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros"),l.constructor}getStringValueHandler(){throw new Error(`"getStringValueHandler" not implemented on ${this.constructor.name}`)}getVariablePrecisionString(){return this.kernel.getVariablePrecisionString(this.textureSize||void 0,this.tactic||void 0)}destroy(){}}s.exports={WebGLKernelValue:a}},{"../../../utils":114,"../../kernel-value":35}],60:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValue:o}=t("./index");class a extends o{constructor(l,h){super(l,h),this.uploadValue=l}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}getSource(l){return this.origin==="constants"?`const int ${this.id} = ${parseInt(l)};
`:`uniform int ${this.id};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform1i(this.id,this.uploadValue=l)}}s.exports={WebGLKernelValueInteger:a}},{"../../../utils":114,"./index":59}],61:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelArray:o}=t("./array"),a="Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()";class u extends o{constructor(h,c){super(h,c);const[d,p]=h.size;this.checkSize(d,p),this.dimensions=h.dimensions,this.textureSize=h.size,this.uploadValue=h.texture,this.forceUploadEachRun=!0}setup(){this.setupTexture()}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName}.texture;
`}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(h){if(h.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(h.constructor);return}if(this.checkContext&&h.context!==this.context)throw new Error(`Value ${this.name} (${this.type}) must be from same context`);const{kernel:c,context:d}=this;if(c.pipeline)if(c.immutable)c.updateTextureArgumentRefs(this,h);else{if(c.texture&&c.texture.texture===h.texture)throw new Error(a);if(c.mappedTextures){const{mappedTextures:p}=c;for(let f=0;f<p.length;f++)if(p[f].texture===h.texture)throw new Error(a)}}d.activeTexture(this.contextHandle),d.bindTexture(d.TEXTURE_2D,this.uploadValue=h.texture),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueMemoryOptimizedNumberTexture:u,sameError:a}},{"../../../utils":114,"./array":40}],62:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelArray:o}=t("./array"),{sameError:a}=t("./memory-optimized-number-texture");class u extends o{constructor(h,c){super(h,c);const[d,p]=h.size;this.checkSize(d,p);const{size:f,dimensions:g}=h;this.bitRatio=this.getBitRatio(h),this.dimensions=g,this.textureSize=f,this.uploadValue=h.texture,this.forceUploadEachRun=!0}setup(){this.setupTexture()}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName}.texture;
`}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(h){if(h.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(h.constructor);return}if(this.checkContext&&h.context!==this.context)throw new Error(`Value ${this.name} (${this.type}) must be from same context`);const{kernel:c,context:d}=this;if(c.pipeline)if(c.immutable)c.updateTextureArgumentRefs(this,h);else{if(c.texture&&c.texture.texture===h.texture)throw new Error(a);if(c.mappedTextures){const{mappedTextures:p}=c;for(let f=0;f<p.length;f++)if(p[f].texture===h.texture)throw new Error(a)}}d.activeTexture(this.contextHandle),d.bindTexture(d.TEXTURE_2D,this.uploadValue=h.texture),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueNumberTexture:u}},{"../../../utils":114,"./array":40,"./memory-optimized-number-texture":61}],63:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelArray:o}=t("./array");class a extends o{constructor(l,h){super(l,h),this.bitRatio=4,this.dimensions=i.getDimensions(l,!0),this.textureSize=i.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}, uploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}const{context:h}=this;i.flattenTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueSingleArray:a}},{"../../../utils":114,"./array":40}],64:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelArray:o}=t("./array");class a extends o{constructor(l,h){super(l,h),this.bitRatio=4,this.setShape(l)}setShape(l){const h=i.getDimensions(l,!0);this.textureSize=i.getMemoryOptimizedFloatTextureSize(h,this.bitRatio),this.dimensions=new Int32Array([h[1],1,1]),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}, uploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}const{context:h}=this;i.flatten2dArrayTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueSingleArray1DI:a}},{"../../../utils":114,"./array":40}],65:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelArray:o}=t("./array");class a extends o{constructor(l,h){super(l,h),this.bitRatio=4,this.setShape(l)}setShape(l){const h=i.getDimensions(l,!0);this.textureSize=i.getMemoryOptimizedFloatTextureSize(h,this.bitRatio),this.dimensions=new Int32Array([h[1],h[2],1]),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}, uploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}const{context:h}=this;i.flatten3dArrayTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueSingleArray2DI:a}},{"../../../utils":114,"./array":40}],66:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelArray:o}=t("./array");class a extends o{constructor(l,h){super(l,h),this.bitRatio=4,this.setShape(l)}setShape(l){const h=i.getDimensions(l,!0);this.textureSize=i.getMemoryOptimizedFloatTextureSize(h,this.bitRatio),this.dimensions=new Int32Array([h[1],h[2],h[3]]),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}, uploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}const{context:h}=this;i.flatten4dArrayTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueSingleArray3DI:a}},{"../../../utils":114,"./array":40}],67:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelArray:o}=t("./array");class a extends o{constructor(l,h){super(l,h),this.bitRatio=4;let[c,d,p]=l.size;this.dimensions=new Int32Array([c||1,d||1,p||1]),this.textureSize=i.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}.value, uploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}const{context:h}=this;i.flattenTo(l.value,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueSingleInput:a}},{"../../../utils":114,"./array":40}],68:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelArray:o}=t("./array");class a extends o{constructor(l,h){super(l,h),this.bitRatio=this.getBitRatio(l),this.dimensions=i.getDimensions(l,!0),this.textureSize=i.getMemoryOptimizedPackedTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*(4/this.bitRatio),this.checkSize(this.textureSize[0],this.textureSize[1]),this.TranserArrayType=this.getTransferArrayType(l),this.preUploadValue=new this.TranserArrayType(this.uploadArrayLength),this.uploadValue=new Uint8Array(this.preUploadValue.buffer)}getStringValueHandler(){return i.linesToString([`const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,`const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,`flattenTo(${this.varName}, preUploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}const{context:h}=this;i.flattenTo(l,this.preUploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.UNSIGNED_BYTE,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueUnsignedArray:a}},{"../../../utils":114,"./array":40}],69:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelArray:o}=t("./array");class a extends o{constructor(l,h){super(l,h),this.bitRatio=this.getBitRatio(l);const[c,d,p]=l.size;this.dimensions=new Int32Array([c||1,d||1,p||1]),this.textureSize=i.getMemoryOptimizedPackedTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*(4/this.bitRatio),this.checkSize(this.textureSize[0],this.textureSize[1]),this.TranserArrayType=this.getTransferArrayType(l.value),this.preUploadValue=new this.TranserArrayType(this.uploadArrayLength),this.uploadValue=new Uint8Array(this.preUploadValue.buffer)}getStringValueHandler(){return i.linesToString([`const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,`const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,`flattenTo(${this.varName}.value, preUploadValue_${this.name})`])}getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(value.constructor);return}const{context:h}=this;i.flattenTo(l.value,this.preUploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.UNSIGNED_BYTE,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGLKernelValueUnsignedInput:a}},{"../../../utils":114,"./array":40}],70:[function(t,s,r){const{GLKernel:i}=t("../gl/kernel"),{FunctionBuilder:o}=t("../function-builder"),{WebGLFunctionNode:a}=t("./function-node"),{utils:u}=t("../../utils"),l=t("../../plugins/math-random-uniformly-distributed"),{fragmentShader:h}=t("./fragment-shader"),{vertexShader:c}=t("./vertex-shader"),{glKernelString:d}=t("../gl/kernel-string"),{lookupKernelValueType:p}=t("./kernel-value-maps");let f=null,g=null,m=null,b=null,x=null;const v=[l],w=[],S={};class k extends i{static get isSupported(){return f!==null||(this.setupFeatureChecks(),f=this.isContextMatch(m)),f}static setupFeatureChecks(){typeof document<"u"?g=document.createElement("canvas"):typeof OffscreenCanvas<"u"&&(g=new OffscreenCanvas(0,0)),g&&(m=g.getContext("webgl")||g.getContext("experimental-webgl"),!(!m||!m.getExtension)&&(b={OES_texture_float:m.getExtension("OES_texture_float"),OES_texture_float_linear:m.getExtension("OES_texture_float_linear"),OES_element_index_uint:m.getExtension("OES_element_index_uint"),WEBGL_draw_buffers:m.getExtension("WEBGL_draw_buffers")},x=this.getFeatures()))}static isContextMatch(I){return typeof WebGLRenderingContext<"u"?I instanceof WebGLRenderingContext:!1}static getIsTextureFloat(){return!!b.OES_texture_float}static getIsDrawBuffers(){return!!b.WEBGL_draw_buffers}static getChannelCount(){return b.WEBGL_draw_buffers?m.getParameter(b.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL):1}static getMaxTextureSize(){return m.getParameter(m.MAX_TEXTURE_SIZE)}static lookupKernelValueType(I,C,T,R){return p(I,C,T,R)}static get testCanvas(){return g}static get testContext(){return m}static get features(){return x}static get fragmentShader(){return h}static get vertexShader(){return c}constructor(I,C){super(I,C),this.program=null,this.pipeline=C.pipeline,this.endianness=u.systemEndianness(),this.extensions={},this.argumentTextureCount=0,this.constantTextureCount=0,this.fragShader=null,this.vertShader=null,this.drawBuffersMap=null,this.maxTexSize=null,this.onRequestSwitchKernel=null,this.texture=null,this.mappedTextures=null,this.mergeSettings(I.settings||C),this.threadDim=null,this.framebuffer=null,this.buffer=null,this.textureCache=[],this.programUniformLocationCache={},this.uniform1fCache={},this.uniform1iCache={},this.uniform2fCache={},this.uniform2fvCache={},this.uniform2ivCache={},this.uniform3fvCache={},this.uniform3ivCache={},this.uniform4fvCache={},this.uniform4ivCache={}}initCanvas(){if(typeof document<"u"){const I=document.createElement("canvas");return I.width=2,I.height=2,I}else if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(0,0)}initContext(){const I={alpha:!1,depth:!1,antialias:!1};return this.canvas.getContext("webgl",I)||this.canvas.getContext("experimental-webgl",I)}initPlugins(I){const C=[],{source:T}=this;if(typeof T=="string")for(let R=0;R<v.length;R++){const P=v[R];T.match(P.functionMatch)&&C.push(P)}else if(typeof T=="object"&&I.pluginNames)for(let R=0;R<v.length;R++){const P=v[R];I.pluginNames.some(F=>F===P.name)&&C.push(P)}return C}initExtensions(){this.extensions={OES_texture_float:this.context.getExtension("OES_texture_float"),OES_texture_float_linear:this.context.getExtension("OES_texture_float_linear"),OES_element_index_uint:this.context.getExtension("OES_element_index_uint"),WEBGL_draw_buffers:this.context.getExtension("WEBGL_draw_buffers"),WEBGL_color_buffer_float:this.context.getExtension("WEBGL_color_buffer_float")}}validateSettings(I){if(!this.validate){this.texSize=u.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},this.output);return}const{features:C}=this.constructor;if(this.optimizeFloatMemory===!0&&!C.isTextureFloat)throw new Error("Float textures are not supported");if(this.precision==="single"&&!C.isFloatRead)throw new Error("Single precision not supported");if(!this.graphical&&this.precision===null&&C.isTextureFloat&&(this.precision=C.isFloatRead?"single":"unsigned"),this.subKernels&&this.subKernels.length>0&&!this.extensions.WEBGL_draw_buffers)throw new Error("could not instantiate draw buffers extension");if(this.fixIntegerDivisionAccuracy===null?this.fixIntegerDivisionAccuracy=!C.isIntegerDivisionAccurate:this.fixIntegerDivisionAccuracy&&C.isIntegerDivisionAccurate&&(this.fixIntegerDivisionAccuracy=!1),this.checkOutput(),!this.output||this.output.length===0){if(I.length!==1)throw new Error("Auto output only supported for kernels with only one input");const T=u.getVariableType(I[0],this.strictIntegers);switch(T){case"Array":this.output=u.getDimensions(T);break;case"NumberTexture":case"MemoryOptimizedNumberTexture":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":this.output=I[0].output;break;default:throw new Error("Auto output not supported for input type: "+T)}}if(this.graphical){if(this.output.length!==2)throw new Error("Output must have 2 dimensions on graphical mode");this.precision==="precision"&&(this.precision="unsigned",console.warn("Cannot use graphical mode and single precision at the same time")),this.texSize=u.clone(this.output);return}else this.precision===null&&C.isTextureFloat&&(this.precision="single");this.texSize=u.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},this.output),this.checkTextureSize()}updateMaxTexSize(){const{texSize:I,canvas:C}=this;if(this.maxTexSize===null){let T=w.indexOf(C);T===-1&&(T=w.length,w.push(C),S[T]=[I[0],I[1]]),this.maxTexSize=S[T]}this.maxTexSize[0]<I[0]&&(this.maxTexSize[0]=I[0]),this.maxTexSize[1]<I[1]&&(this.maxTexSize[1]=I[1])}setupArguments(I){this.kernelArguments=[],this.argumentTextureCount=0;const C=this.argumentTypes===null;if(C&&(this.argumentTypes=[]),this.argumentSizes=[],this.argumentBitRatios=[],I.length<this.argumentNames.length)throw new Error("not enough arguments for kernel");if(I.length>this.argumentNames.length)throw new Error("too many arguments for kernel");const{context:T}=this;let R=0;const P=()=>this.createTexture(),D=()=>this.constantTextureCount+R++,F=_=>{this.switchKernels({type:"argumentMismatch",needed:_})},z=()=>T.TEXTURE0+this.constantTextureCount+this.argumentTextureCount++;for(let _=0;_<I.length;_++){const B=I[_],N=this.argumentNames[_];let O;C?(O=u.getVariableType(B,this.strictIntegers),this.argumentTypes.push(O)):O=this.argumentTypes[_];const K=this.constructor.lookupKernelValueType(O,this.dynamicArguments?"dynamic":"static",this.precision,I[_]);if(K===null)return this.requestFallback(I);const U=new K(B,{name:N,type:O,tactic:this.tactic,origin:"user",context:T,checkContext:this.checkContext,kernel:this,strictIntegers:this.strictIntegers,onRequestTexture:P,onRequestIndex:D,onUpdateValueMismatch:F,onRequestContextHandle:z});this.kernelArguments.push(U),U.setup(),this.argumentSizes.push(U.textureSize),this.argumentBitRatios[_]=U.bitRatio}}createTexture(){const I=this.context.createTexture();return this.textureCache.push(I),I}setupConstants(I){const{context:C}=this;this.kernelConstants=[],this.forceUploadKernelConstants=[];let T=this.constantTypes===null;T&&(this.constantTypes={}),this.constantBitRatios={};let R=0;for(const P in this.constants){const D=this.constants[P];let F;T?(F=u.getVariableType(D,this.strictIntegers),this.constantTypes[P]=F):F=this.constantTypes[P];const z=this.constructor.lookupKernelValueType(F,"static",this.precision,D);if(z===null)return this.requestFallback(I);const _=new z(D,{name:P,type:F,tactic:this.tactic,origin:"constants",context:this.context,checkContext:this.checkContext,kernel:this,strictIntegers:this.strictIntegers,onRequestTexture:()=>this.createTexture(),onRequestIndex:()=>R++,onRequestContextHandle:()=>C.TEXTURE0+this.constantTextureCount++});this.constantBitRatios[P]=_.bitRatio,this.kernelConstants.push(_),_.setup(),_.forceUploadEachRun&&this.forceUploadKernelConstants.push(_)}}build(){if(this.built||(this.initExtensions(),this.validateSettings(arguments),this.setupConstants(arguments),this.fallbackRequested)||(this.setupArguments(arguments),this.fallbackRequested))return;this.updateMaxTexSize(),this.translateSource();const I=this.pickRenderStrategy(arguments);if(I)return I;const{texSize:C,context:T,canvas:R}=this;T.enable(T.SCISSOR_TEST),this.pipeline&&this.precision==="single"?(T.viewport(0,0,this.maxTexSize[0],this.maxTexSize[1]),R.width=this.maxTexSize[0],R.height=this.maxTexSize[1]):(T.viewport(0,0,this.maxTexSize[0],this.maxTexSize[1]),R.width=this.maxTexSize[0],R.height=this.maxTexSize[1]);const P=this.threadDim=Array.from(this.output);for(;P.length<3;)P.push(1);const D=this.getVertexShader(arguments),F=T.createShader(T.VERTEX_SHADER);T.shaderSource(F,D),T.compileShader(F),this.vertShader=F;const z=this.getFragmentShader(arguments),_=T.createShader(T.FRAGMENT_SHADER);if(T.shaderSource(_,z),T.compileShader(_),this.fragShader=_,this.debug&&(console.log("GLSL Shader Output:"),console.log(z)),!T.getShaderParameter(F,T.COMPILE_STATUS))throw new Error("Error compiling vertex shader: "+T.getShaderInfoLog(F));if(!T.getShaderParameter(_,T.COMPILE_STATUS))throw new Error("Error compiling fragment shader: "+T.getShaderInfoLog(_));const B=this.program=T.createProgram();T.attachShader(B,F),T.attachShader(B,_),T.linkProgram(B),this.framebuffer=T.createFramebuffer(),this.framebuffer.width=C[0],this.framebuffer.height=C[1],this.rawValueFramebuffers={};const N=new Float32Array([-1,-1,1,-1,-1,1,1,1]),O=new Float32Array([0,0,1,0,0,1,1,1]),K=N.byteLength;let U=this.buffer;U?T.bindBuffer(T.ARRAY_BUFFER,U):(U=this.buffer=T.createBuffer(),T.bindBuffer(T.ARRAY_BUFFER,U),T.bufferData(T.ARRAY_BUFFER,N.byteLength+O.byteLength,T.STATIC_DRAW)),T.bufferSubData(T.ARRAY_BUFFER,0,N),T.bufferSubData(T.ARRAY_BUFFER,K,O);const X=T.getAttribLocation(this.program,"aPos");T.enableVertexAttribArray(X),T.vertexAttribPointer(X,2,T.FLOAT,!1,0,0);const te=T.getAttribLocation(this.program,"aTexCoord");T.enableVertexAttribArray(te),T.vertexAttribPointer(te,2,T.FLOAT,!1,0,K),T.bindFramebuffer(T.FRAMEBUFFER,this.framebuffer);let ie=0;T.useProgram(this.program);for(let re in this.constants)this.kernelConstants[ie++].updateValue(this.constants[re]);this._setupOutputTexture(),this.subKernels!==null&&this.subKernels.length>0&&(this._mappedTextureSwitched={},this._setupSubOutputTextures()),this.buildSignature(arguments),this.built=!0}translateSource(){const I=o.fromKernel(this,a,{fixIntegerDivisionAccuracy:this.fixIntegerDivisionAccuracy});this.translatedSource=I.getPrototypeString("kernel"),this.setupReturnTypes(I)}setupReturnTypes(I){if(!this.graphical&&!this.returnType&&(this.returnType=I.getKernelResultType()),this.subKernels&&this.subKernels.length>0)for(let C=0;C<this.subKernels.length;C++){const T=this.subKernels[C];T.returnType||(T.returnType=I.getSubKernelResultType(C))}}run(){const{kernelArguments:I,texSize:C,forceUploadKernelConstants:T,context:R}=this;R.useProgram(this.program),R.scissor(0,0,C[0],C[1]),this.dynamicOutput&&(this.setUniform3iv("uOutputDim",new Int32Array(this.threadDim)),this.setUniform2iv("uTexSize",C)),this.setUniform2f("ratio",C[0]/this.maxTexSize[0],C[1]/this.maxTexSize[1]);for(let P=0;P<T.length;P++){const D=T[P];if(D.updateValue(this.constants[D.name]),this.switchingKernels)return}for(let P=0;P<I.length;P++)if(I[P].updateValue(arguments[P]),this.switchingKernels)return;if(this.plugins)for(let P=0;P<this.plugins.length;P++){const D=this.plugins[P];D.onBeforeRun&&D.onBeforeRun(this)}if(this.graphical){if(this.pipeline)return R.bindRenderbuffer(R.RENDERBUFFER,null),R.bindFramebuffer(R.FRAMEBUFFER,this.framebuffer),this.immutable&&this._replaceOutputTexture(),R.drawArrays(R.TRIANGLE_STRIP,0,4),this.immutable?this.texture.clone():this.texture;R.bindRenderbuffer(R.RENDERBUFFER,null),R.bindFramebuffer(R.FRAMEBUFFER,null),R.drawArrays(R.TRIANGLE_STRIP,0,4);return}R.bindFramebuffer(R.FRAMEBUFFER,this.framebuffer),this.immutable&&this._replaceOutputTexture(),this.subKernels!==null&&(this.immutable&&this._replaceSubOutputTextures(),this.drawBuffers()),R.drawArrays(R.TRIANGLE_STRIP,0,4)}drawBuffers(){this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap)}getInternalFormat(){return this.context.RGBA}getTextureFormat(){const{context:I}=this;switch(this.getInternalFormat()){case I.RGBA:return I.RGBA;default:throw new Error("Unknown internal format")}}_replaceOutputTexture(){if(this.texture.beforeMutate()||this._textureSwitched){const I=this.context;I.framebufferTexture2D(I.FRAMEBUFFER,I.COLOR_ATTACHMENT0,I.TEXTURE_2D,this.texture.texture,0),this._textureSwitched=!1}}_setupOutputTexture(){const I=this.context,C=this.texSize;if(this.texture){I.framebufferTexture2D(I.FRAMEBUFFER,I.COLOR_ATTACHMENT0,I.TEXTURE_2D,this.texture.texture,0);return}const T=this.createTexture();I.activeTexture(I.TEXTURE0+this.constantTextureCount+this.argumentTextureCount),I.bindTexture(I.TEXTURE_2D,T),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_WRAP_S,I.CLAMP_TO_EDGE),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_WRAP_T,I.CLAMP_TO_EDGE),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_MIN_FILTER,I.NEAREST),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_MAG_FILTER,I.NEAREST);const R=this.getInternalFormat();this.precision==="single"?I.texImage2D(I.TEXTURE_2D,0,R,C[0],C[1],0,I.RGBA,I.FLOAT,null):I.texImage2D(I.TEXTURE_2D,0,R,C[0],C[1],0,R,I.UNSIGNED_BYTE,null),I.framebufferTexture2D(I.FRAMEBUFFER,I.COLOR_ATTACHMENT0,I.TEXTURE_2D,T,0),this.texture=new this.TextureConstructor({texture:T,size:C,dimensions:this.threadDim,output:this.output,context:this.context,internalFormat:this.getInternalFormat(),textureFormat:this.getTextureFormat(),kernel:this})}_replaceSubOutputTextures(){const I=this.context;for(let C=0;C<this.mappedTextures.length;C++){const T=this.mappedTextures[C];(T.beforeMutate()||this._mappedTextureSwitched[C])&&(I.framebufferTexture2D(I.FRAMEBUFFER,I.COLOR_ATTACHMENT0+C+1,I.TEXTURE_2D,T.texture,0),this._mappedTextureSwitched[C]=!1)}}_setupSubOutputTextures(){const I=this.context;if(this.mappedTextures){for(let T=0;T<this.subKernels.length;T++)I.framebufferTexture2D(I.FRAMEBUFFER,I.COLOR_ATTACHMENT0+T+1,I.TEXTURE_2D,this.mappedTextures[T].texture,0);return}const C=this.texSize;this.drawBuffersMap=[I.COLOR_ATTACHMENT0],this.mappedTextures=[];for(let T=0;T<this.subKernels.length;T++){const R=this.createTexture();this.drawBuffersMap.push(I.COLOR_ATTACHMENT0+T+1),I.activeTexture(I.TEXTURE0+this.constantTextureCount+this.argumentTextureCount+T),I.bindTexture(I.TEXTURE_2D,R),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_WRAP_S,I.CLAMP_TO_EDGE),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_WRAP_T,I.CLAMP_TO_EDGE),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_MIN_FILTER,I.NEAREST),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_MAG_FILTER,I.NEAREST),this.precision==="single"?I.texImage2D(I.TEXTURE_2D,0,I.RGBA,C[0],C[1],0,I.RGBA,I.FLOAT,null):I.texImage2D(I.TEXTURE_2D,0,I.RGBA,C[0],C[1],0,I.RGBA,I.UNSIGNED_BYTE,null),I.framebufferTexture2D(I.FRAMEBUFFER,I.COLOR_ATTACHMENT0+T+1,I.TEXTURE_2D,R,0),this.mappedTextures.push(new this.TextureConstructor({texture:R,size:C,dimensions:this.threadDim,output:this.output,context:this.context,internalFormat:this.getInternalFormat(),textureFormat:this.getTextureFormat(),kernel:this}))}}setUniform1f(I,C){if(this.uniform1fCache.hasOwnProperty(I)){const R=this.uniform1fCache[I];if(C===R)return}this.uniform1fCache[I]=C;const T=this.getUniformLocation(I);this.context.uniform1f(T,C)}setUniform1i(I,C){if(this.uniform1iCache.hasOwnProperty(I)){const R=this.uniform1iCache[I];if(C===R)return}this.uniform1iCache[I]=C;const T=this.getUniformLocation(I);this.context.uniform1i(T,C)}setUniform2f(I,C,T){if(this.uniform2fCache.hasOwnProperty(I)){const P=this.uniform2fCache[I];if(C===P[0]&&T===P[1])return}this.uniform2fCache[I]=[C,T];const R=this.getUniformLocation(I);this.context.uniform2f(R,C,T)}setUniform2fv(I,C){if(this.uniform2fvCache.hasOwnProperty(I)){const R=this.uniform2fvCache[I];if(C[0]===R[0]&&C[1]===R[1])return}this.uniform2fvCache[I]=C;const T=this.getUniformLocation(I);this.context.uniform2fv(T,C)}setUniform2iv(I,C){if(this.uniform2ivCache.hasOwnProperty(I)){const R=this.uniform2ivCache[I];if(C[0]===R[0]&&C[1]===R[1])return}this.uniform2ivCache[I]=C;const T=this.getUniformLocation(I);this.context.uniform2iv(T,C)}setUniform3fv(I,C){if(this.uniform3fvCache.hasOwnProperty(I)){const R=this.uniform3fvCache[I];if(C[0]===R[0]&&C[1]===R[1]&&C[2]===R[2])return}this.uniform3fvCache[I]=C;const T=this.getUniformLocation(I);this.context.uniform3fv(T,C)}setUniform3iv(I,C){if(this.uniform3ivCache.hasOwnProperty(I)){const R=this.uniform3ivCache[I];if(C[0]===R[0]&&C[1]===R[1]&&C[2]===R[2])return}this.uniform3ivCache[I]=C;const T=this.getUniformLocation(I);this.context.uniform3iv(T,C)}setUniform4fv(I,C){if(this.uniform4fvCache.hasOwnProperty(I)){const R=this.uniform4fvCache[I];if(C[0]===R[0]&&C[1]===R[1]&&C[2]===R[2]&&C[3]===R[3])return}this.uniform4fvCache[I]=C;const T=this.getUniformLocation(I);this.context.uniform4fv(T,C)}setUniform4iv(I,C){if(this.uniform4ivCache.hasOwnProperty(I)){const R=this.uniform4ivCache[I];if(C[0]===R[0]&&C[1]===R[1]&&C[2]===R[2]&&C[3]===R[3])return}this.uniform4ivCache[I]=C;const T=this.getUniformLocation(I);this.context.uniform4iv(T,C)}getUniformLocation(I){return this.programUniformLocationCache.hasOwnProperty(I)?this.programUniformLocationCache[I]:this.programUniformLocationCache[I]=this.context.getUniformLocation(this.program,I)}_getFragShaderArtifactMap(I){return{HEADER:this._getHeaderString(),LOOP_MAX:this._getLoopMaxString(),PLUGINS:this._getPluginsString(),CONSTANTS:this._getConstantsString(),DECODE32_ENDIANNESS:this._getDecode32EndiannessString(),ENCODE32_ENDIANNESS:this._getEncode32EndiannessString(),DIVIDE_WITH_INTEGER_CHECK:this._getDivideWithIntegerCheckString(),INJECTED_NATIVE:this._getInjectedNative(),MAIN_CONSTANTS:this._getMainConstantsString(),MAIN_ARGUMENTS:this._getMainArgumentsString(I),KERNEL:this.getKernelString(),MAIN_RESULT:this.getMainResultString(),FLOAT_TACTIC_DECLARATION:this.getFloatTacticDeclaration(),INT_TACTIC_DECLARATION:this.getIntTacticDeclaration(),SAMPLER_2D_TACTIC_DECLARATION:this.getSampler2DTacticDeclaration(),SAMPLER_2D_ARRAY_TACTIC_DECLARATION:this.getSampler2DArrayTacticDeclaration()}}_getVertShaderArtifactMap(I){return{FLOAT_TACTIC_DECLARATION:this.getFloatTacticDeclaration(),INT_TACTIC_DECLARATION:this.getIntTacticDeclaration(),SAMPLER_2D_TACTIC_DECLARATION:this.getSampler2DTacticDeclaration(),SAMPLER_2D_ARRAY_TACTIC_DECLARATION:this.getSampler2DArrayTacticDeclaration()}}_getHeaderString(){return this.subKernels!==null?`#extension GL_EXT_draw_buffers : require
`:""}_getLoopMaxString(){return this.loopMaxIterations?` ${parseInt(this.loopMaxIterations)};
`:` 1000;
`}_getPluginsString(){return this.plugins?this.plugins.map(I=>I.source&&this.source.match(I.functionMatch)?I.source:"").join(`
`):`
`}_getConstantsString(){const I=[],{threadDim:C,texSize:T}=this;return this.dynamicOutput?I.push("uniform ivec3 uOutputDim","uniform ivec2 uTexSize"):I.push(`ivec3 uOutputDim = ivec3(${C[0]}, ${C[1]}, ${C[2]})`,`ivec2 uTexSize = ivec2(${T[0]}, ${T[1]})`),u.linesToString(I)}_getTextureCoordinate(){const I=this.subKernels;return I===null||I.length<1?`varying vec2 vTexCoord;
`:`out vec2 vTexCoord;
`}_getDecode32EndiannessString(){return this.endianness==="LE"?"":`  texel.rgba = texel.abgr;
`}_getEncode32EndiannessString(){return this.endianness==="LE"?"":`  texel.rgba = texel.abgr;
`}_getDivideWithIntegerCheckString(){return this.fixIntegerDivisionAccuracy?`float divWithIntCheck(float x, float y) {
  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
    return float(int(x) / int(y));
  }
  return x / y;
}

float integerCorrectionModulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -(number - (divisor * floor(divWithIntCheck(number, divisor))));
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return number - (divisor * floor(divWithIntCheck(number, divisor)));
}`:""}_getMainArgumentsString(I){const C=[],{argumentNames:T}=this;for(let R=0;R<T.length;R++)C.push(this.kernelArguments[R].getSource(I[R]));return C.join("")}_getInjectedNative(){return this.injectedNative||""}_getMainConstantsString(){const I=[],{constants:C}=this;if(C){let T=0;for(const R in C)this.constants.hasOwnProperty(R)&&I.push(this.kernelConstants[T++].getSource(this.constants[R]))}return I.join("")}getRawValueFramebuffer(I,C){if(this.rawValueFramebuffers[I]||(this.rawValueFramebuffers[I]={}),!this.rawValueFramebuffers[I][C]){const T=this.context.createFramebuffer();T.width=I,T.height=C,this.rawValueFramebuffers[I][C]=T}return this.rawValueFramebuffers[I][C]}getKernelResultDeclaration(){switch(this.returnType){case"Array(2)":return"vec2 kernelResult";case"Array(3)":return"vec3 kernelResult";case"Array(4)":return"vec4 kernelResult";case"LiteralInteger":case"Float":case"Number":case"Integer":return"float kernelResult";default:if(this.graphical)return"float kernelResult";throw new Error(`unrecognized output type "${this.returnType}"`)}}getKernelString(){const I=[this.getKernelResultDeclaration()],{subKernels:C}=this;if(C!==null)switch(this.returnType){case"Number":case"Float":case"Integer":for(let T=0;T<C.length;T++){const R=C[T];I.push(R.returnType==="Integer"?`int subKernelResult_${R.name} = 0`:`float subKernelResult_${R.name} = 0.0`)}break;case"Array(2)":for(let T=0;T<C.length;T++)I.push(`vec2 subKernelResult_${C[T].name}`);break;case"Array(3)":for(let T=0;T<C.length;T++)I.push(`vec3 subKernelResult_${C[T].name}`);break;case"Array(4)":for(let T=0;T<C.length;T++)I.push(`vec4 subKernelResult_${C[T].name}`);break}return u.linesToString(I)+this.translatedSource}getMainResultGraphical(){return u.linesToString(["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragColor = actualColor"])}getMainResultPackedPixels(){switch(this.returnType){case"LiteralInteger":case"Number":case"Integer":case"Float":return this.getMainResultKernelPackedPixels()+this.getMainResultSubKernelPackedPixels();default:throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`)}}getMainResultKernelPackedPixels(){return u.linesToString(["  threadId = indexTo3D(index, uOutputDim)","  kernel()",`  gl_FragData[0] = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(kernelResult)`])}getMainResultSubKernelPackedPixels(){const I=[];if(!this.subKernels)return"";for(let C=0;C<this.subKernels.length;C++)this.subKernels[C].returnType==="Integer"?I.push(`  gl_FragData[${C+1}] = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(float(subKernelResult_${this.subKernels[C].name}))`):I.push(`  gl_FragData[${C+1}] = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(subKernelResult_${this.subKernels[C].name})`);return u.linesToString(I)}getMainResultMemoryOptimizedFloats(){const I=["  index *= 4"];switch(this.returnType){case"Number":case"Integer":case"Float":const C=["r","g","b","a"];for(let T=0;T<C.length;T++){const R=C[T];this.getMainResultKernelMemoryOptimizedFloats(I,R),this.getMainResultSubKernelMemoryOptimizedFloats(I,R),T+1<C.length&&I.push("  index += 1")}break;default:throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`)}return u.linesToString(I)}getMainResultKernelMemoryOptimizedFloats(I,C){I.push("  threadId = indexTo3D(index, uOutputDim)","  kernel()",`  gl_FragData[0].${C} = kernelResult`)}getMainResultSubKernelMemoryOptimizedFloats(I,C){if(!this.subKernels)return I;for(let T=0;T<this.subKernels.length;T++)this.subKernels[T].returnType==="Integer"?I.push(`  gl_FragData[${T+1}].${C} = float(subKernelResult_${this.subKernels[T].name})`):I.push(`  gl_FragData[${T+1}].${C} = subKernelResult_${this.subKernels[T].name}`)}getMainResultKernelNumberTexture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragData[0][0] = kernelResult"]}getMainResultSubKernelNumberTexture(){const I=[];if(!this.subKernels)return I;for(let C=0;C<this.subKernels.length;++C){const T=this.subKernels[C];T.returnType==="Integer"?I.push(`  gl_FragData[${C+1}][0] = float(subKernelResult_${T.name})`):I.push(`  gl_FragData[${C+1}][0] = subKernelResult_${T.name}`)}return I}getMainResultKernelArray2Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragData[0][0] = kernelResult[0]","  gl_FragData[0][1] = kernelResult[1]"]}getMainResultSubKernelArray2Texture(){const I=[];if(!this.subKernels)return I;for(let C=0;C<this.subKernels.length;++C)I.push(`  gl_FragData[${C+1}][0] = subKernelResult_${this.subKernels[C].name}[0]`,`  gl_FragData[${C+1}][1] = subKernelResult_${this.subKernels[C].name}[1]`);return I}getMainResultKernelArray3Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragData[0][0] = kernelResult[0]","  gl_FragData[0][1] = kernelResult[1]","  gl_FragData[0][2] = kernelResult[2]"]}getMainResultSubKernelArray3Texture(){const I=[];if(!this.subKernels)return I;for(let C=0;C<this.subKernels.length;++C)I.push(`  gl_FragData[${C+1}][0] = subKernelResult_${this.subKernels[C].name}[0]`,`  gl_FragData[${C+1}][1] = subKernelResult_${this.subKernels[C].name}[1]`,`  gl_FragData[${C+1}][2] = subKernelResult_${this.subKernels[C].name}[2]`);return I}getMainResultKernelArray4Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragData[0] = kernelResult"]}getMainResultSubKernelArray4Texture(){const I=[];if(!this.subKernels)return I;switch(this.returnType){case"Number":case"Float":case"Integer":for(let C=0;C<this.subKernels.length;++C)this.subKernels[C].returnType==="Integer"?I.push(`  gl_FragData[${C+1}] = float(subKernelResult_${this.subKernels[C].name})`):I.push(`  gl_FragData[${C+1}] = subKernelResult_${this.subKernels[C].name}`);break;case"Array(2)":for(let C=0;C<this.subKernels.length;++C)I.push(`  gl_FragData[${C+1}][0] = subKernelResult_${this.subKernels[C].name}[0]`,`  gl_FragData[${C+1}][1] = subKernelResult_${this.subKernels[C].name}[1]`);break;case"Array(3)":for(let C=0;C<this.subKernels.length;++C)I.push(`  gl_FragData[${C+1}][0] = subKernelResult_${this.subKernels[C].name}[0]`,`  gl_FragData[${C+1}][1] = subKernelResult_${this.subKernels[C].name}[1]`,`  gl_FragData[${C+1}][2] = subKernelResult_${this.subKernels[C].name}[2]`);break;case"Array(4)":for(let C=0;C<this.subKernels.length;++C)I.push(`  gl_FragData[${C+1}][0] = subKernelResult_${this.subKernels[C].name}[0]`,`  gl_FragData[${C+1}][1] = subKernelResult_${this.subKernels[C].name}[1]`,`  gl_FragData[${C+1}][2] = subKernelResult_${this.subKernels[C].name}[2]`,`  gl_FragData[${C+1}][3] = subKernelResult_${this.subKernels[C].name}[3]`);break}return I}replaceArtifacts(I,C){return I.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\n/g,(T,R)=>{if(C.hasOwnProperty(R))return C[R];throw`unhandled artifact ${R}`})}getFragmentShader(I){return this.compiledFragmentShader!==null?this.compiledFragmentShader:this.compiledFragmentShader=this.replaceArtifacts(this.constructor.fragmentShader,this._getFragShaderArtifactMap(I))}getVertexShader(I){return this.compiledVertexShader!==null?this.compiledVertexShader:this.compiledVertexShader=this.replaceArtifacts(this.constructor.vertexShader,this._getVertShaderArtifactMap(I))}toString(){const I=u.linesToString(["const gl = context"]);return d(this.constructor,arguments,this,I)}destroy(I){if(!this.context)return;this.buffer&&this.context.deleteBuffer(this.buffer),this.framebuffer&&this.context.deleteFramebuffer(this.framebuffer);for(const T in this.rawValueFramebuffers){for(const R in this.rawValueFramebuffers[T])this.context.deleteFramebuffer(this.rawValueFramebuffers[T][R]),delete this.rawValueFramebuffers[T][R];delete this.rawValueFramebuffers[T]}if(this.vertShader&&this.context.deleteShader(this.vertShader),this.fragShader&&this.context.deleteShader(this.fragShader),this.program&&this.context.deleteProgram(this.program),this.texture){this.texture.delete();const T=this.textureCache.indexOf(this.texture.texture);T>-1&&this.textureCache.splice(T,1),this.texture=null}if(this.mappedTextures&&this.mappedTextures.length){for(let T=0;T<this.mappedTextures.length;T++){const R=this.mappedTextures[T];R.delete();const P=this.textureCache.indexOf(R.texture);P>-1&&this.textureCache.splice(P,1)}this.mappedTextures=null}if(this.kernelArguments)for(let T=0;T<this.kernelArguments.length;T++)this.kernelArguments[T].destroy();if(this.kernelConstants)for(let T=0;T<this.kernelConstants.length;T++)this.kernelConstants[T].destroy();for(;this.textureCache.length>0;){const T=this.textureCache.pop();this.context.deleteTexture(T)}if(I){const T=w.indexOf(this.canvas);T>=0&&(w[T]=null,S[T]=null)}if(this.destroyExtensions(),delete this.context,delete this.canvas,!this.gpu)return;const C=this.gpu.kernels.indexOf(this);C!==-1&&this.gpu.kernels.splice(C,1)}destroyExtensions(){this.extensions.OES_texture_float=null,this.extensions.OES_texture_float_linear=null,this.extensions.OES_element_index_uint=null,this.extensions.WEBGL_draw_buffers=null}static destroyContext(I){const C=I.getExtension("WEBGL_lose_context");C&&C.loseContext()}toJSON(){const I=super.toJSON();return I.functionNodes=o.fromKernel(this,a).toJSON(),I.settings.threadDim=this.threadDim,I}}s.exports={WebGLKernel:k}},{"../../plugins/math-random-uniformly-distributed":112,"../../utils":114,"../function-builder":9,"../gl/kernel":13,"../gl/kernel-string":12,"./fragment-shader":37,"./function-node":38,"./kernel-value-maps":39,"./vertex-shader":71}],71:[function(t,s,r){const i=`__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

attribute vec2 aPos;
attribute vec2 aTexCoord;

varying vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;s.exports={vertexShader:i}},{}],72:[function(t,s,r){const i=`#version 300 es
__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;
__SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

in vec2 vTexCoord;

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float _round(float x) {
  return floor(x + 0.5);
}


const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x/y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  return texel[channel] * 255.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  index = index / 4;
  vec4 texel = texture(tex, st / vec2(texSize));
  return texel[channel];
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, st / vec2(texSize));
}

vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, vec3(st / vec2(texSize), z));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));

  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;s.exports={fragmentShader:i}},{}],73:[function(t,s,r){const{utils:i}=t("../../utils"),{WebGLFunctionNode:o}=t("../web-gl/function-node");class a extends o{astIdentifierExpression(l,h){if(l.type!=="Identifier")throw this.astErrorOutput("IdentifierExpression - not an Identifier",l);const c=this.getType(l),d=i.sanitizeName(l.name);return l.name==="Infinity"?h.push("intBitsToFloat(2139095039)"):c==="Boolean"?this.argumentNames.indexOf(d)>-1?h.push(`bool(user_${d})`):h.push(`user_${d}`):h.push(`user_${d}`),h}}s.exports={WebGL2FunctionNode:a}},{"../../utils":114,"../web-gl/function-node":38}],74:[function(t,s,r){const{WebGL2KernelValueBoolean:i}=t("./kernel-value/boolean"),{WebGL2KernelValueFloat:o}=t("./kernel-value/float"),{WebGL2KernelValueInteger:a}=t("./kernel-value/integer"),{WebGL2KernelValueHTMLImage:u}=t("./kernel-value/html-image"),{WebGL2KernelValueDynamicHTMLImage:l}=t("./kernel-value/dynamic-html-image"),{WebGL2KernelValueHTMLImageArray:h}=t("./kernel-value/html-image-array"),{WebGL2KernelValueDynamicHTMLImageArray:c}=t("./kernel-value/dynamic-html-image-array"),{WebGL2KernelValueHTMLVideo:d}=t("./kernel-value/html-video"),{WebGL2KernelValueDynamicHTMLVideo:p}=t("./kernel-value/dynamic-html-video"),{WebGL2KernelValueSingleInput:f}=t("./kernel-value/single-input"),{WebGL2KernelValueDynamicSingleInput:g}=t("./kernel-value/dynamic-single-input"),{WebGL2KernelValueUnsignedInput:m}=t("./kernel-value/unsigned-input"),{WebGL2KernelValueDynamicUnsignedInput:b}=t("./kernel-value/dynamic-unsigned-input"),{WebGL2KernelValueMemoryOptimizedNumberTexture:x}=t("./kernel-value/memory-optimized-number-texture"),{WebGL2KernelValueDynamicMemoryOptimizedNumberTexture:v}=t("./kernel-value/dynamic-memory-optimized-number-texture"),{WebGL2KernelValueNumberTexture:w}=t("./kernel-value/number-texture"),{WebGL2KernelValueDynamicNumberTexture:S}=t("./kernel-value/dynamic-number-texture"),{WebGL2KernelValueSingleArray:k}=t("./kernel-value/single-array"),{WebGL2KernelValueDynamicSingleArray:E}=t("./kernel-value/dynamic-single-array"),{WebGL2KernelValueSingleArray1DI:I}=t("./kernel-value/single-array1d-i"),{WebGL2KernelValueDynamicSingleArray1DI:C}=t("./kernel-value/dynamic-single-array1d-i"),{WebGL2KernelValueSingleArray2DI:T}=t("./kernel-value/single-array2d-i"),{WebGL2KernelValueDynamicSingleArray2DI:R}=t("./kernel-value/dynamic-single-array2d-i"),{WebGL2KernelValueSingleArray3DI:P}=t("./kernel-value/single-array3d-i"),{WebGL2KernelValueDynamicSingleArray3DI:D}=t("./kernel-value/dynamic-single-array3d-i"),{WebGL2KernelValueArray2:F}=t("./kernel-value/array2"),{WebGL2KernelValueArray3:z}=t("./kernel-value/array3"),{WebGL2KernelValueArray4:_}=t("./kernel-value/array4"),{WebGL2KernelValueUnsignedArray:B}=t("./kernel-value/unsigned-array"),{WebGL2KernelValueDynamicUnsignedArray:N}=t("./kernel-value/dynamic-unsigned-array"),O={unsigned:{dynamic:{Boolean:i,Integer:a,Float:o,Array:N,"Array(2)":F,"Array(3)":z,"Array(4)":_,"Array1D(2)":!1,"Array1D(3)":!1,"Array1D(4)":!1,"Array2D(2)":!1,"Array2D(3)":!1,"Array2D(4)":!1,"Array3D(2)":!1,"Array3D(3)":!1,"Array3D(4)":!1,Input:b,NumberTexture:S,"ArrayTexture(1)":S,"ArrayTexture(2)":S,"ArrayTexture(3)":S,"ArrayTexture(4)":S,MemoryOptimizedNumberTexture:v,HTMLCanvas:l,OffscreenCanvas:l,HTMLImage:l,ImageBitmap:l,ImageData:l,HTMLImageArray:c,HTMLVideo:p},static:{Boolean:i,Float:o,Integer:a,Array:B,"Array(2)":F,"Array(3)":z,"Array(4)":_,"Array1D(2)":!1,"Array1D(3)":!1,"Array1D(4)":!1,"Array2D(2)":!1,"Array2D(3)":!1,"Array2D(4)":!1,"Array3D(2)":!1,"Array3D(3)":!1,"Array3D(4)":!1,Input:m,NumberTexture:w,"ArrayTexture(1)":w,"ArrayTexture(2)":w,"ArrayTexture(3)":w,"ArrayTexture(4)":w,MemoryOptimizedNumberTexture:v,HTMLCanvas:u,OffscreenCanvas:u,HTMLImage:u,ImageBitmap:u,ImageData:u,HTMLImageArray:h,HTMLVideo:d}},single:{dynamic:{Boolean:i,Integer:a,Float:o,Array:E,"Array(2)":F,"Array(3)":z,"Array(4)":_,"Array1D(2)":C,"Array1D(3)":C,"Array1D(4)":C,"Array2D(2)":R,"Array2D(3)":R,"Array2D(4)":R,"Array3D(2)":D,"Array3D(3)":D,"Array3D(4)":D,Input:g,NumberTexture:S,"ArrayTexture(1)":S,"ArrayTexture(2)":S,"ArrayTexture(3)":S,"ArrayTexture(4)":S,MemoryOptimizedNumberTexture:v,HTMLCanvas:l,OffscreenCanvas:l,HTMLImage:l,ImageBitmap:l,ImageData:l,HTMLImageArray:c,HTMLVideo:p},static:{Boolean:i,Float:o,Integer:a,Array:k,"Array(2)":F,"Array(3)":z,"Array(4)":_,"Array1D(2)":I,"Array1D(3)":I,"Array1D(4)":I,"Array2D(2)":T,"Array2D(3)":T,"Array2D(4)":T,"Array3D(2)":P,"Array3D(3)":P,"Array3D(4)":P,Input:f,NumberTexture:w,"ArrayTexture(1)":w,"ArrayTexture(2)":w,"ArrayTexture(3)":w,"ArrayTexture(4)":w,MemoryOptimizedNumberTexture:x,HTMLCanvas:u,OffscreenCanvas:u,HTMLImage:u,ImageBitmap:u,ImageData:u,HTMLImageArray:h,HTMLVideo:d}}};function K(U,X,te,ie){if(!U)throw new Error("type missing");if(!X)throw new Error("dynamic missing");if(!te)throw new Error("precision missing");ie.type&&(U=ie.type);const re=O[te][X];if(re[U]===!1)return null;if(re[U]===void 0)throw new Error(`Could not find a KernelValue for ${U}`);return re[U]}s.exports={kernelValueMaps:O,lookupKernelValueType:K}},{"./kernel-value/array2":75,"./kernel-value/array3":76,"./kernel-value/array4":77,"./kernel-value/boolean":78,"./kernel-value/dynamic-html-image":80,"./kernel-value/dynamic-html-image-array":79,"./kernel-value/dynamic-html-video":81,"./kernel-value/dynamic-memory-optimized-number-texture":82,"./kernel-value/dynamic-number-texture":83,"./kernel-value/dynamic-single-array":84,"./kernel-value/dynamic-single-array1d-i":85,"./kernel-value/dynamic-single-array2d-i":86,"./kernel-value/dynamic-single-array3d-i":87,"./kernel-value/dynamic-single-input":88,"./kernel-value/dynamic-unsigned-array":89,"./kernel-value/dynamic-unsigned-input":90,"./kernel-value/float":91,"./kernel-value/html-image":93,"./kernel-value/html-image-array":92,"./kernel-value/html-video":94,"./kernel-value/integer":95,"./kernel-value/memory-optimized-number-texture":96,"./kernel-value/number-texture":97,"./kernel-value/single-array":98,"./kernel-value/single-array1d-i":99,"./kernel-value/single-array2d-i":100,"./kernel-value/single-array3d-i":101,"./kernel-value/single-input":102,"./kernel-value/unsigned-array":103,"./kernel-value/unsigned-input":104}],75:[function(t,s,r){const{WebGLKernelValueArray2:i}=t("../../web-gl/kernel-value/array2");class o extends i{}s.exports={WebGL2KernelValueArray2:o}},{"../../web-gl/kernel-value/array2":41}],76:[function(t,s,r){const{WebGLKernelValueArray3:i}=t("../../web-gl/kernel-value/array3");class o extends i{}s.exports={WebGL2KernelValueArray3:o}},{"../../web-gl/kernel-value/array3":42}],77:[function(t,s,r){const{WebGLKernelValueArray4:i}=t("../../web-gl/kernel-value/array4");class o extends i{}s.exports={WebGL2KernelValueArray4:o}},{"../../web-gl/kernel-value/array4":43}],78:[function(t,s,r){const{WebGLKernelValueBoolean:i}=t("../../web-gl/kernel-value/boolean");class o extends i{}s.exports={WebGL2KernelValueBoolean:o}},{"../../web-gl/kernel-value/boolean":44}],79:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGL2KernelValueHTMLImageArray:o}=t("./html-image-array");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2DArray ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}updateValue(l){const{width:h,height:c}=l[0];this.checkSize(h,c),this.dimensions=[h,c,l.length],this.textureSize=[h,c],this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGL2KernelValueDynamicHTMLImageArray:a}},{"../../../utils":114,"./html-image-array":92}],80:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueDynamicHTMLImage:o}=t("../../web-gl/kernel-value/dynamic-html-image");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}}s.exports={WebGL2KernelValueDynamicHTMLImage:a}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-html-image":45}],81:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGL2KernelValueDynamicHTMLImage:o}=t("./dynamic-html-image");class a extends o{}s.exports={WebGL2KernelValueDynamicHTMLVideo:a}},{"../../../utils":114,"./dynamic-html-image":80}],82:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueDynamicMemoryOptimizedNumberTexture:o}=t("../../web-gl/kernel-value/dynamic-memory-optimized-number-texture");class a extends o{getSource(){return i.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}}s.exports={WebGL2KernelValueDynamicMemoryOptimizedNumberTexture:a}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture":47}],83:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueDynamicNumberTexture:o}=t("../../web-gl/kernel-value/dynamic-number-texture");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}}s.exports={WebGL2KernelValueDynamicNumberTexture:a}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-number-texture":48}],84:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGL2KernelValueSingleArray:o}=t("../../web-gl2/kernel-value/single-array");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}updateValue(l){this.dimensions=i.getDimensions(l,!0),this.textureSize=i.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGL2KernelValueDynamicSingleArray:a}},{"../../../utils":114,"../../web-gl2/kernel-value/single-array":98}],85:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGL2KernelValueSingleArray1DI:o}=t("../../web-gl2/kernel-value/single-array1d-i");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}updateValue(l){this.setShape(l),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGL2KernelValueDynamicSingleArray1DI:a}},{"../../../utils":114,"../../web-gl2/kernel-value/single-array1d-i":99}],86:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGL2KernelValueSingleArray2DI:o}=t("../../web-gl2/kernel-value/single-array2d-i");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}updateValue(l){this.setShape(l),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGL2KernelValueDynamicSingleArray2DI:a}},{"../../../utils":114,"../../web-gl2/kernel-value/single-array2d-i":100}],87:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGL2KernelValueSingleArray3DI:o}=t("../../web-gl2/kernel-value/single-array3d-i");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}updateValue(l){this.setShape(l),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGL2KernelValueDynamicSingleArray3DI:a}},{"../../../utils":114,"../../web-gl2/kernel-value/single-array3d-i":101}],88:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGL2KernelValueSingleInput:o}=t("../../web-gl2/kernel-value/single-input");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}updateValue(l){let[h,c,d]=l.size;this.dimensions=new Int32Array([h||1,c||1,d||1]),this.textureSize=i.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}s.exports={WebGL2KernelValueDynamicSingleInput:a}},{"../../../utils":114,"../../web-gl2/kernel-value/single-input":102}],89:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueDynamicUnsignedArray:o}=t("../../web-gl/kernel-value/dynamic-unsigned-array");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}}s.exports={WebGL2KernelValueDynamicUnsignedArray:a}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-array":54}],90:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueDynamicUnsignedInput:o}=t("../../web-gl/kernel-value/dynamic-unsigned-input");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}}s.exports={WebGL2KernelValueDynamicUnsignedInput:a}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-input":55}],91:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueFloat:o}=t("../../web-gl/kernel-value/float");class a extends o{}s.exports={WebGL2KernelValueFloat:a}},{"../../../utils":114,"../../web-gl/kernel-value/float":56}],92:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelArray:o}=t("../../web-gl/kernel-value/array");class a extends o{constructor(l,h){super(l,h),this.checkSize(l[0].width,l[0].height),this.dimensions=[l[0].width,l[0].height,l.length],this.textureSize=[l[0].width,l[0].height]}defineTexture(){const{context:l}=this;l.activeTexture(this.contextHandle),l.bindTexture(l.TEXTURE_2D_ARRAY,this.texture),l.texParameteri(l.TEXTURE_2D_ARRAY,l.TEXTURE_MAG_FILTER,l.NEAREST),l.texParameteri(l.TEXTURE_2D_ARRAY,l.TEXTURE_MIN_FILTER,l.NEAREST)}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2DArray ${this.id}`,`${l} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${l} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){const{context:h}=this;h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D_ARRAY,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!0),h.texImage3D(h.TEXTURE_2D_ARRAY,0,h.RGBA,l[0].width,l[0].height,l.length,0,h.RGBA,h.UNSIGNED_BYTE,null);for(let c=0;c<l.length;c++)h.texSubImage3D(h.TEXTURE_2D_ARRAY,0,0,0,c,l[c].width,l[c].height,1,h.RGBA,h.UNSIGNED_BYTE,this.uploadValue=l[c]);this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGL2KernelValueHTMLImageArray:a}},{"../../../utils":114,"../../web-gl/kernel-value/array":40}],93:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueHTMLImage:o}=t("../../web-gl/kernel-value/html-image");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`${l} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${l} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}}s.exports={WebGL2KernelValueHTMLImage:a}},{"../../../utils":114,"../../web-gl/kernel-value/html-image":57}],94:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGL2KernelValueHTMLImage:o}=t("./html-image");class a extends o{}s.exports={WebGL2KernelValueHTMLVideo:a}},{"../../../utils":114,"./html-image":93}],95:[function(t,s,r){const{WebGLKernelValueInteger:i}=t("../../web-gl/kernel-value/integer");class o extends i{getSource(u){const l=this.getVariablePrecisionString();return this.origin==="constants"?`const ${l} int ${this.id} = ${parseInt(u)};
`:`uniform ${l} int ${this.id};
`}updateValue(u){this.origin!=="constants"&&this.kernel.setUniform1i(this.id,this.uploadValue=u)}}s.exports={WebGL2KernelValueInteger:o}},{"../../web-gl/kernel-value/integer":60}],96:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueMemoryOptimizedNumberTexture:o}=t("../../web-gl/kernel-value/memory-optimized-number-texture");class a extends o{getSource(){const{id:l,sizeId:h,textureSize:c,dimensionsId:d,dimensions:p}=this,f=this.getVariablePrecisionString();return i.linesToString([`uniform sampler2D ${l}`,`${f} ivec2 ${h} = ivec2(${c[0]}, ${c[1]})`,`${f} ivec3 ${d} = ivec3(${p[0]}, ${p[1]}, ${p[2]})`])}}s.exports={WebGL2KernelValueMemoryOptimizedNumberTexture:a}},{"../../../utils":114,"../../web-gl/kernel-value/memory-optimized-number-texture":61}],97:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueNumberTexture:o}=t("../../web-gl/kernel-value/number-texture");class a extends o{getSource(){const{id:l,sizeId:h,textureSize:c,dimensionsId:d,dimensions:p}=this,f=this.getVariablePrecisionString();return i.linesToString([`uniform ${f} sampler2D ${l}`,`${f} ivec2 ${h} = ivec2(${c[0]}, ${c[1]})`,`${f} ivec3 ${d} = ivec3(${p[0]}, ${p[1]}, ${p[2]})`])}}s.exports={WebGL2KernelValueNumberTexture:a}},{"../../../utils":114,"../../web-gl/kernel-value/number-texture":62}],98:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueSingleArray:o}=t("../../web-gl/kernel-value/single-array");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`${l} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${l} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}const{context:h}=this;i.flattenTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA32F,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGL2KernelValueSingleArray:a}},{"../../../utils":114,"../../web-gl/kernel-value/single-array":63}],99:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueSingleArray1DI:o}=t("../../web-gl/kernel-value/single-array1d-i");class a extends o{updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}const{context:h}=this;i.flattenTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA32F,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGL2KernelValueSingleArray1DI:a}},{"../../../utils":114,"../../web-gl/kernel-value/single-array1d-i":64}],100:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueSingleArray2DI:o}=t("../../web-gl/kernel-value/single-array2d-i");class a extends o{updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}const{context:h}=this;i.flattenTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA32F,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGL2KernelValueSingleArray2DI:a}},{"../../../utils":114,"../../web-gl/kernel-value/single-array2d-i":65}],101:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueSingleArray3DI:o}=t("../../web-gl/kernel-value/single-array3d-i");class a extends o{updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}const{context:h}=this;i.flattenTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA32F,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGL2KernelValueSingleArray3DI:a}},{"../../../utils":114,"../../web-gl/kernel-value/single-array3d-i":66}],102:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueSingleInput:o}=t("../../web-gl/kernel-value/single-input");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`${l} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${l} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){const{context:h}=this;i.flattenTo(l.value,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA32F,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}s.exports={WebGL2KernelValueSingleInput:a}},{"../../../utils":114,"../../web-gl/kernel-value/single-input":67}],103:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueUnsignedArray:o}=t("../../web-gl/kernel-value/unsigned-array");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`${l} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${l} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}}s.exports={WebGL2KernelValueUnsignedArray:a}},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-array":68}],104:[function(t,s,r){const{utils:i}=t("../../../utils"),{WebGLKernelValueUnsignedInput:o}=t("../../web-gl/kernel-value/unsigned-input");class a extends o{getSource(){const l=this.getVariablePrecisionString();return i.linesToString([`uniform ${l} sampler2D ${this.id}`,`${l} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${l} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}}s.exports={WebGL2KernelValueUnsignedInput:a}},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-input":69}],105:[function(t,s,r){const{WebGLKernel:i}=t("../web-gl/kernel"),{WebGL2FunctionNode:o}=t("./function-node"),{FunctionBuilder:a}=t("../function-builder"),{utils:u}=t("../../utils"),{fragmentShader:l}=t("./fragment-shader"),{vertexShader:h}=t("./vertex-shader"),{lookupKernelValueType:c}=t("./kernel-value-maps");let d=null,p=null,f=null,g=null;class m extends i{static get isSupported(){return d!==null||(this.setupFeatureChecks(),d=this.isContextMatch(f)),d}static setupFeatureChecks(){typeof document<"u"?p=document.createElement("canvas"):typeof OffscreenCanvas<"u"&&(p=new OffscreenCanvas(0,0)),p&&(f=p.getContext("webgl2"),!(!f||!f.getExtension)&&(f.getExtension("EXT_color_buffer_float"),f.getExtension("OES_texture_float_linear"),g=this.getFeatures()))}static isContextMatch(x){return typeof WebGL2RenderingContext<"u"?x instanceof WebGL2RenderingContext:!1}static getFeatures(){const x=this.testContext;return Object.freeze({isFloatRead:this.getIsFloatRead(),isIntegerDivisionAccurate:this.getIsIntegerDivisionAccurate(),isSpeedTacticSupported:this.getIsSpeedTacticSupported(),kernelMap:!0,isTextureFloat:!0,isDrawBuffers:!0,channelCount:this.getChannelCount(),maxTextureSize:this.getMaxTextureSize(),lowIntPrecision:x.getShaderPrecisionFormat(x.FRAGMENT_SHADER,x.LOW_INT),lowFloatPrecision:x.getShaderPrecisionFormat(x.FRAGMENT_SHADER,x.LOW_FLOAT),mediumIntPrecision:x.getShaderPrecisionFormat(x.FRAGMENT_SHADER,x.MEDIUM_INT),mediumFloatPrecision:x.getShaderPrecisionFormat(x.FRAGMENT_SHADER,x.MEDIUM_FLOAT),highIntPrecision:x.getShaderPrecisionFormat(x.FRAGMENT_SHADER,x.HIGH_INT),highFloatPrecision:x.getShaderPrecisionFormat(x.FRAGMENT_SHADER,x.HIGH_FLOAT)})}static getIsTextureFloat(){return!0}static getChannelCount(){return f.getParameter(f.MAX_DRAW_BUFFERS)}static getMaxTextureSize(){return f.getParameter(f.MAX_TEXTURE_SIZE)}static lookupKernelValueType(x,v,w,S){return c(x,v,w,S)}static get testCanvas(){return p}static get testContext(){return f}static get features(){return g}static get fragmentShader(){return l}static get vertexShader(){return h}initContext(){const x={alpha:!1,depth:!1,antialias:!1};return this.canvas.getContext("webgl2",x)}initExtensions(){this.extensions={EXT_color_buffer_float:this.context.getExtension("EXT_color_buffer_float"),OES_texture_float_linear:this.context.getExtension("OES_texture_float_linear")}}validateSettings(x){if(!this.validate){this.texSize=u.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},this.output);return}const{features:v}=this.constructor;if(this.precision==="single"&&!v.isFloatRead)throw new Error("Float texture outputs are not supported");if(!this.graphical&&this.precision===null&&(this.precision=v.isFloatRead?"single":"unsigned"),this.fixIntegerDivisionAccuracy===null?this.fixIntegerDivisionAccuracy=!v.isIntegerDivisionAccurate:this.fixIntegerDivisionAccuracy&&v.isIntegerDivisionAccurate&&(this.fixIntegerDivisionAccuracy=!1),this.checkOutput(),!this.output||this.output.length===0){if(x.length!==1)throw new Error("Auto output only supported for kernels with only one input");const w=u.getVariableType(x[0],this.strictIntegers);switch(w){case"Array":this.output=u.getDimensions(w);break;case"NumberTexture":case"MemoryOptimizedNumberTexture":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":this.output=x[0].output;break;default:throw new Error("Auto output not supported for input type: "+w)}}if(this.graphical){if(this.output.length!==2)throw new Error("Output must have 2 dimensions on graphical mode");this.precision==="single"&&(console.warn("Cannot use graphical mode and single precision at the same time"),this.precision="unsigned"),this.texSize=u.clone(this.output);return}else!this.graphical&&this.precision===null&&v.isTextureFloat&&(this.precision="single");this.texSize=u.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},this.output),this.checkTextureSize()}translateSource(){const x=a.fromKernel(this,o,{fixIntegerDivisionAccuracy:this.fixIntegerDivisionAccuracy});this.translatedSource=x.getPrototypeString("kernel"),this.setupReturnTypes(x)}drawBuffers(){this.context.drawBuffers(this.drawBuffersMap)}getTextureFormat(){const{context:x}=this;switch(this.getInternalFormat()){case x.R32F:return x.RED;case x.RG32F:return x.RG;case x.RGBA32F:return x.RGBA;case x.RGBA:return x.RGBA;default:throw new Error("Unknown internal format")}}getInternalFormat(){const{context:x}=this;if(this.precision==="single"){if(this.pipeline)switch(this.returnType){case"Number":case"Float":case"Integer":return this.optimizeFloatMemory?x.RGBA32F:x.R32F;case"Array(2)":return x.RG32F;case"Array(3)":case"Array(4)":return x.RGBA32F;default:throw new Error("Unhandled return type")}return x.RGBA32F}return x.RGBA}_setupOutputTexture(){const x=this.context;if(this.texture){x.framebufferTexture2D(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0,x.TEXTURE_2D,this.texture.texture,0);return}x.bindFramebuffer(x.FRAMEBUFFER,this.framebuffer);const v=x.createTexture(),w=this.texSize;x.activeTexture(x.TEXTURE0+this.constantTextureCount+this.argumentTextureCount),x.bindTexture(x.TEXTURE_2D,v),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_WRAP_S,x.REPEAT),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_WRAP_T,x.REPEAT),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_MIN_FILTER,x.NEAREST),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_MAG_FILTER,x.NEAREST);const S=this.getInternalFormat();this.precision==="single"?x.texStorage2D(x.TEXTURE_2D,1,S,w[0],w[1]):x.texImage2D(x.TEXTURE_2D,0,S,w[0],w[1],0,S,x.UNSIGNED_BYTE,null),x.framebufferTexture2D(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0,x.TEXTURE_2D,v,0),this.texture=new this.TextureConstructor({texture:v,size:w,dimensions:this.threadDim,output:this.output,context:this.context,internalFormat:this.getInternalFormat(),textureFormat:this.getTextureFormat(),kernel:this})}_setupSubOutputTextures(){const x=this.context;if(this.mappedTextures){for(let w=0;w<this.subKernels.length;w++)x.framebufferTexture2D(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0+w+1,x.TEXTURE_2D,this.mappedTextures[w].texture,0);return}const v=this.texSize;this.drawBuffersMap=[x.COLOR_ATTACHMENT0],this.mappedTextures=[];for(let w=0;w<this.subKernels.length;w++){const S=this.createTexture();this.drawBuffersMap.push(x.COLOR_ATTACHMENT0+w+1),x.activeTexture(x.TEXTURE0+this.constantTextureCount+this.argumentTextureCount+w),x.bindTexture(x.TEXTURE_2D,S),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_WRAP_S,x.CLAMP_TO_EDGE),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_WRAP_T,x.CLAMP_TO_EDGE),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_MIN_FILTER,x.NEAREST),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_MAG_FILTER,x.NEAREST);const k=this.getInternalFormat();this.precision==="single"?x.texStorage2D(x.TEXTURE_2D,1,k,v[0],v[1]):x.texImage2D(x.TEXTURE_2D,0,x.RGBA,v[0],v[1],0,x.RGBA,x.UNSIGNED_BYTE,null),x.framebufferTexture2D(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0+w+1,x.TEXTURE_2D,S,0),this.mappedTextures.push(new this.TextureConstructor({texture:S,size:v,dimensions:this.threadDim,output:this.output,context:this.context,internalFormat:this.getInternalFormat(),textureFormat:this.getTextureFormat(),kernel:this}))}}_getHeaderString(){return""}_getTextureCoordinate(){const x=this.subKernels,v=this.getVariablePrecisionString(this.texSize,this.tactic);return x===null||x.length<1?`in ${v} vec2 vTexCoord;
`:`out ${v} vec2 vTexCoord;
`}_getMainArgumentsString(x){const v=[],w=this.argumentNames;for(let S=0;S<w.length;S++)v.push(this.kernelArguments[S].getSource(x[S]));return v.join("")}getKernelString(){const x=[this.getKernelResultDeclaration()],v=this.subKernels;if(v!==null)switch(x.push("layout(location = 0) out vec4 data0"),this.returnType){case"Number":case"Float":case"Integer":for(let w=0;w<v.length;w++){const S=v[w];x.push(S.returnType==="Integer"?`int subKernelResult_${S.name} = 0`:`float subKernelResult_${S.name} = 0.0`,`layout(location = ${w+1}) out vec4 data${w+1}`)}break;case"Array(2)":for(let w=0;w<v.length;w++)x.push(`vec2 subKernelResult_${v[w].name}`,`layout(location = ${w+1}) out vec4 data${w+1}`);break;case"Array(3)":for(let w=0;w<v.length;w++)x.push(`vec3 subKernelResult_${v[w].name}`,`layout(location = ${w+1}) out vec4 data${w+1}`);break;case"Array(4)":for(let w=0;w<v.length;w++)x.push(`vec4 subKernelResult_${v[w].name}`,`layout(location = ${w+1}) out vec4 data${w+1}`);break}else x.push("out vec4 data0");return u.linesToString(x)+this.translatedSource}getMainResultGraphical(){return u.linesToString(["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0 = actualColor"])}getMainResultPackedPixels(){switch(this.returnType){case"LiteralInteger":case"Number":case"Integer":case"Float":return this.getMainResultKernelPackedPixels()+this.getMainResultSubKernelPackedPixels();default:throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`)}}getMainResultKernelPackedPixels(){return u.linesToString(["  threadId = indexTo3D(index, uOutputDim)","  kernel()",`  data0 = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(kernelResult)`])}getMainResultSubKernelPackedPixels(){const x=[];if(!this.subKernels)return"";for(let v=0;v<this.subKernels.length;v++)this.subKernels[v].returnType==="Integer"?x.push(`  data${v+1} = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(float(subKernelResult_${this.subKernels[v].name}))`):x.push(`  data${v+1} = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(subKernelResult_${this.subKernels[v].name})`);return u.linesToString(x)}getMainResultKernelMemoryOptimizedFloats(x,v){x.push("  threadId = indexTo3D(index, uOutputDim)","  kernel()",`  data0.${v} = kernelResult`)}getMainResultSubKernelMemoryOptimizedFloats(x,v){if(!this.subKernels)return x;for(let w=0;w<this.subKernels.length;w++){const S=this.subKernels[w];S.returnType==="Integer"?x.push(`  data${w+1}.${v} = float(subKernelResult_${S.name})`):x.push(`  data${w+1}.${v} = subKernelResult_${S.name}`)}}getMainResultKernelNumberTexture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0[0] = kernelResult"]}getMainResultSubKernelNumberTexture(){const x=[];if(!this.subKernels)return x;for(let v=0;v<this.subKernels.length;++v){const w=this.subKernels[v];w.returnType==="Integer"?x.push(`  data${v+1}[0] = float(subKernelResult_${w.name})`):x.push(`  data${v+1}[0] = subKernelResult_${w.name}`)}return x}getMainResultKernelArray2Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0[0] = kernelResult[0]","  data0[1] = kernelResult[1]"]}getMainResultSubKernelArray2Texture(){const x=[];if(!this.subKernels)return x;for(let v=0;v<this.subKernels.length;++v){const w=this.subKernels[v];x.push(`  data${v+1}[0] = subKernelResult_${w.name}[0]`,`  data${v+1}[1] = subKernelResult_${w.name}[1]`)}return x}getMainResultKernelArray3Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0[0] = kernelResult[0]","  data0[1] = kernelResult[1]","  data0[2] = kernelResult[2]"]}getMainResultSubKernelArray3Texture(){const x=[];if(!this.subKernels)return x;for(let v=0;v<this.subKernels.length;++v){const w=this.subKernels[v];x.push(`  data${v+1}[0] = subKernelResult_${w.name}[0]`,`  data${v+1}[1] = subKernelResult_${w.name}[1]`,`  data${v+1}[2] = subKernelResult_${w.name}[2]`)}return x}getMainResultKernelArray4Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0 = kernelResult"]}getMainResultSubKernelArray4Texture(){const x=[];if(!this.subKernels)return x;for(let v=0;v<this.subKernels.length;++v)x.push(`  data${v+1} = subKernelResult_${this.subKernels[v].name}`);return x}destroyExtensions(){this.extensions.EXT_color_buffer_float=null,this.extensions.OES_texture_float_linear=null}toJSON(){const x=super.toJSON();return x.functionNodes=a.fromKernel(this,o).toJSON(),x.settings.threadDim=this.threadDim,x}}s.exports={WebGL2Kernel:m}},{"../../utils":114,"../function-builder":9,"../web-gl/kernel":70,"./fragment-shader":72,"./function-node":73,"./kernel-value-maps":74,"./vertex-shader":106}],106:[function(t,s,r){const i=`#version 300 es
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

in vec2 aPos;
in vec2 aTexCoord;

out vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;s.exports={vertexShader:i}},{}],107:[function(t,s,r){const i=t("./index"),o=i.GPU;for(const u in i)i.hasOwnProperty(u)&&u!=="GPU"&&(o[u]=i[u]);typeof window<"u"&&a(window),typeof self<"u"&&a(self);function a(u){u.GPU||Object.defineProperty(u,"GPU",{get(){return o}})}s.exports=i},{"./index":109}],108:[function(t,s,r){const{gpuMock:i}=t("gpu-mock.js"),{utils:o}=t("./utils"),{Kernel:a}=t("./backend/kernel"),{CPUKernel:u}=t("./backend/cpu/kernel"),{HeadlessGLKernel:l}=t("./backend/headless-gl/kernel"),{WebGL2Kernel:h}=t("./backend/web-gl2/kernel"),{WebGLKernel:c}=t("./backend/web-gl/kernel"),{kernelRunShortcut:d}=t("./kernel-run-shortcut"),p=[l,h,c],f=["gpu","cpu"],g={headlessgl:l,webgl2:h,webgl:c};let m=!0;class b{static disableValidation(){m=!1}static enableValidation(){m=!0}static get isGPUSupported(){return p.some(w=>w.isSupported)}static get isKernelMapSupported(){return p.some(w=>w.isSupported&&w.features.kernelMap)}static get isOffscreenCanvasSupported(){return typeof Worker<"u"&&typeof OffscreenCanvas<"u"||typeof importScripts<"u"}static get isWebGLSupported(){return c.isSupported}static get isWebGL2Supported(){return h.isSupported}static get isHeadlessGLSupported(){return l.isSupported}static get isCanvasSupported(){return typeof HTMLCanvasElement<"u"}static get isGPUHTMLImageArraySupported(){return h.isSupported}static get isSinglePrecisionSupported(){return p.some(w=>w.isSupported&&w.features.isFloatRead&&w.features.isTextureFloat)}constructor(w){if(w=w||{},this.canvas=w.canvas||null,this.context=w.context||null,this.mode=w.mode,this.Kernel=null,this.kernels=[],this.functions=[],this.nativeFunctions=[],this.injectedNative=null,this.mode!=="dev"){if(this.chooseKernel(),w.functions)for(let S=0;S<w.functions.length;S++)this.addFunction(w.functions[S]);if(w.nativeFunctions)for(const S in w.nativeFunctions){if(!w.nativeFunctions.hasOwnProperty(S))continue;const k=w.nativeFunctions[S],{name:E,source:I}=k;this.addNativeFunction(E,I,k)}}}chooseKernel(){if(this.Kernel)return;let w=null;if(this.context){for(let S=0;S<p.length;S++){const k=p[S];if(k.isContextMatch(this.context)){if(!k.isSupported)throw new Error(`Kernel type ${k.name} not supported`);w=k;break}}if(w===null)throw new Error("unknown Context")}else if(this.mode){if(this.mode in g)(!m||g[this.mode].isSupported)&&(w=g[this.mode]);else if(this.mode==="gpu"){for(let S=0;S<p.length;S++)if(p[S].isSupported){w=p[S];break}}else this.mode==="cpu"&&(w=u);if(!w)throw new Error(`A requested mode of "${this.mode}" and is not supported`)}else{for(let S=0;S<p.length;S++)if(p[S].isSupported){w=p[S];break}w||(w=u)}this.mode||(this.mode=w.mode),this.Kernel=w}createKernel(w,S){if(typeof w>"u")throw new Error("Missing source parameter");if(typeof w!="object"&&!o.isFunction(w)&&typeof w!="string")throw new Error("source parameter not a function");const k=this.kernels;if(this.mode==="dev"){const F=i(w,x(S));return k.push(F),F}w=typeof w=="function"?w.toString():w;const E={},I=x(S)||{};S&&typeof S.argumentTypes=="object"&&(I.argumentTypes=Object.keys(S.argumentTypes).map(F=>S.argumentTypes[F]));function C(F){console.warn("Falling back to CPU");const z=new u(w,{argumentTypes:D.argumentTypes,constantTypes:D.constantTypes,graphical:D.graphical,loopMaxIterations:D.loopMaxIterations,constants:D.constants,dynamicOutput:D.dynamicOutput,dynamicArgument:D.dynamicArguments,output:D.output,precision:D.precision,pipeline:D.pipeline,immutable:D.immutable,optimizeFloatMemory:D.optimizeFloatMemory,fixIntegerDivisionAccuracy:D.fixIntegerDivisionAccuracy,functions:D.functions,nativeFunctions:D.nativeFunctions,injectedNative:D.injectedNative,subKernels:D.subKernels,strictIntegers:D.strictIntegers,debug:D.debug});z.build.apply(z,F);const _=z.run.apply(z,F);return D.replaceKernel(z),_}function T(F,z,_){_.debug&&console.warn("Switching kernels");let B=null;if(_.signature&&!E[_.signature]&&(E[_.signature]=_),_.dynamicOutput)for(let te=F.length-1;te>=0;te--){const ie=F[te];ie.type==="outputPrecisionMismatch"&&(B=ie.needed)}const N=_.constructor,O=N.getArgumentTypes(_,z),K=N.getSignature(_,O),U=E[K];if(U)return U.onActivate(_),U;const X=E[K]=new N(w,{argumentTypes:O,constantTypes:_.constantTypes,graphical:_.graphical,loopMaxIterations:_.loopMaxIterations,constants:_.constants,dynamicOutput:_.dynamicOutput,dynamicArgument:_.dynamicArguments,context:_.context,canvas:_.canvas,output:B||_.output,precision:_.precision,pipeline:_.pipeline,immutable:_.immutable,optimizeFloatMemory:_.optimizeFloatMemory,fixIntegerDivisionAccuracy:_.fixIntegerDivisionAccuracy,functions:_.functions,nativeFunctions:_.nativeFunctions,injectedNative:_.injectedNative,subKernels:_.subKernels,strictIntegers:_.strictIntegers,debug:_.debug,gpu:_.gpu,validate:m,returnType:_.returnType,tactic:_.tactic,onRequestFallback:C,onRequestSwitchKernel:T,texture:_.texture,mappedTextures:_.mappedTextures,drawBuffersMap:_.drawBuffersMap});return X.build.apply(X,z),D.replaceKernel(X),k.push(X),X}const R=Object.assign({context:this.context,canvas:this.canvas,functions:this.functions,nativeFunctions:this.nativeFunctions,injectedNative:this.injectedNative,gpu:this,validate:m,onRequestFallback:C,onRequestSwitchKernel:T},I),P=new this.Kernel(w,R),D=d(P);return this.canvas||(this.canvas=P.canvas),this.context||(this.context=P.context),k.push(P),D}createKernelMap(){let w,S;const k=typeof arguments[arguments.length-2];if(k==="function"||k==="string"?(w=arguments[arguments.length-2],S=arguments[arguments.length-1]):w=arguments[arguments.length-1],this.mode!=="dev"&&(!this.Kernel.isSupported||!this.Kernel.features.kernelMap)&&this.mode&&f.indexOf(this.mode)<0)throw new Error(`kernelMap not supported on ${this.Kernel.name}`);const E=x(S);if(S&&typeof S.argumentTypes=="object"&&(E.argumentTypes=Object.keys(S.argumentTypes).map(I=>S.argumentTypes[I])),Array.isArray(arguments[0])){E.subKernels=[];const I=arguments[0];for(let C=0;C<I.length;C++){const T=I[C].toString(),R=o.getFunctionNameFromString(T);E.subKernels.push({name:R,source:T,property:C})}}else{E.subKernels=[];const I=arguments[0];for(let C in I){if(!I.hasOwnProperty(C))continue;const T=I[C].toString(),R=o.getFunctionNameFromString(T);E.subKernels.push({name:R||C,source:T,property:C})}}return this.createKernel(w,E)}combineKernels(){const w=arguments[0],S=arguments[arguments.length-1];if(w.kernel.constructor.mode==="cpu")return S;const k=arguments[0].canvas,E=arguments[0].context,I=arguments.length-1;for(let C=0;C<I;C++)arguments[C].setCanvas(k).setContext(E).setPipeline(!0);return function(){const C=S.apply(this,arguments);return C.toArray?C.toArray():C}}setFunctions(w){return this.functions=w,this}setNativeFunctions(w){return this.nativeFunctions=w,this}addFunction(w,S){return this.functions.push({source:w,settings:S}),this}addNativeFunction(w,S,k){if(this.kernels.length>0)throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');return this.nativeFunctions.push(Object.assign({name:w,source:S},k)),this}injectNative(w){return this.injectedNative=w,this}destroy(){return new Promise((w,S)=>{this.kernels||w(),setTimeout(()=>{try{for(let E=0;E<this.kernels.length;E++)this.kernels[E].destroy(!0);let k=this.kernels[0];k&&(k.kernel&&(k=k.kernel),k.constructor.destroyContext&&k.constructor.destroyContext(this.context))}catch(k){S(k)}w()},0)})}}function x(v){if(!v)return{};const w=Object.assign({},v);return v.hasOwnProperty("floatOutput")&&(o.warnDeprecated("setting","floatOutput","precision"),w.precision=v.floatOutput?"single":"unsigned"),v.hasOwnProperty("outputToTexture")&&(o.warnDeprecated("setting","outputToTexture","pipeline"),w.pipeline=!!v.outputToTexture),v.hasOwnProperty("outputImmutable")&&(o.warnDeprecated("setting","outputImmutable","immutable"),w.immutable=!!v.outputImmutable),v.hasOwnProperty("floatTextures")&&(o.warnDeprecated("setting","floatTextures","optimizeFloatMemory"),w.optimizeFloatMemory=!!v.floatTextures),w}s.exports={GPU:b,kernelOrder:p,kernelTypes:f}},{"./backend/cpu/kernel":8,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/kernel":70,"./backend/web-gl2/kernel":105,"./kernel-run-shortcut":111,"./utils":114,"gpu-mock.js":4}],109:[function(t,s,r){const{GPU:i}=t("./gpu"),{alias:o}=t("./alias"),{utils:a}=t("./utils"),{Input:u,input:l}=t("./input"),{Texture:h}=t("./texture"),{FunctionBuilder:c}=t("./backend/function-builder"),{FunctionNode:d}=t("./backend/function-node"),{CPUFunctionNode:p}=t("./backend/cpu/function-node"),{CPUKernel:f}=t("./backend/cpu/kernel"),{HeadlessGLKernel:g}=t("./backend/headless-gl/kernel"),{WebGLFunctionNode:m}=t("./backend/web-gl/function-node"),{WebGLKernel:b}=t("./backend/web-gl/kernel"),{kernelValueMaps:x}=t("./backend/web-gl/kernel-value-maps"),{WebGL2FunctionNode:v}=t("./backend/web-gl2/function-node"),{WebGL2Kernel:w}=t("./backend/web-gl2/kernel"),{kernelValueMaps:S}=t("./backend/web-gl2/kernel-value-maps"),{GLKernel:k}=t("./backend/gl/kernel"),{Kernel:E}=t("./backend/kernel"),{FunctionTracer:I}=t("./backend/function-tracer"),C=t("./plugins/math-random-uniformly-distributed");s.exports={alias:o,CPUFunctionNode:p,CPUKernel:f,GPU:i,FunctionBuilder:c,FunctionNode:d,HeadlessGLKernel:g,Input:u,input:l,Texture:h,utils:a,WebGL2FunctionNode:v,WebGL2Kernel:w,webGL2KernelValueMaps:S,WebGLFunctionNode:m,WebGLKernel:b,webGLKernelValueMaps:x,GLKernel:k,Kernel:E,FunctionTracer:I,plugins:{mathRandom:C}}},{"./alias":5,"./backend/cpu/function-node":6,"./backend/cpu/kernel":8,"./backend/function-builder":9,"./backend/function-node":10,"./backend/function-tracer":11,"./backend/gl/kernel":13,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/function-node":38,"./backend/web-gl/kernel":70,"./backend/web-gl/kernel-value-maps":39,"./backend/web-gl2/function-node":73,"./backend/web-gl2/kernel":105,"./backend/web-gl2/kernel-value-maps":74,"./gpu":108,"./input":110,"./plugins/math-random-uniformly-distributed":112,"./texture":113,"./utils":114}],110:[function(t,s,r){class i{constructor(u,l){this.value=u,Array.isArray(l)?this.size=l:(this.size=new Int32Array(3),l.z?this.size=new Int32Array([l.x,l.y,l.z]):l.y?this.size=new Int32Array([l.x,l.y]):this.size=new Int32Array([l.x]));const[h,c,d]=this.size;if(d){if(this.value.length!==h*c*d)throw new Error(`Input size ${this.value.length} does not match ${h} * ${c} * ${d} = ${c*h*d}`)}else if(c){if(this.value.length!==h*c)throw new Error(`Input size ${this.value.length} does not match ${h} * ${c} = ${c*h}`)}else if(this.value.length!==h)throw new Error(`Input size ${this.value.length} does not match ${h}`)}toArray(){const{utils:u}=t("./utils"),[l,h,c]=this.size;return c?u.erectMemoryOptimized3DFloat(this.value.subarray?this.value:new Float32Array(this.value),l,h,c):h?u.erectMemoryOptimized2DFloat(this.value.subarray?this.value:new Float32Array(this.value),l,h):this.value}}function o(a,u){return new i(a,u)}s.exports={Input:i,input:o}},{"./utils":114}],111:[function(t,s,r){const{utils:i}=t("./utils");function o(u){let l=function(){return u.build.apply(u,arguments),l=function(){let c=u.run.apply(u,arguments);if(u.switchingKernels){const d=u.resetSwitchingKernels(),p=u.onRequestSwitchKernel(d,arguments,u);h.kernel=u=p,c=p.run.apply(p,arguments)}return u.renderKernels?u.renderKernels():u.renderOutput?u.renderOutput():c},l.apply(u,arguments)};const h=function(){return l.apply(u,arguments)};return h.exec=function(){return new Promise((c,d)=>{try{c(l.apply(this,arguments))}catch(p){d(p)}})},h.replaceKernel=function(c){u=c,a(u,h)},a(u,h),h}function a(u,l){if(l.kernel){l.kernel=u;return}const h=i.allPropertiesOf(u);for(let c=0;c<h.length;c++){const d=h[c];d[0]==="_"&&d[1]==="_"||(typeof u[d]=="function"?d.substring(0,3)==="add"||d.substring(0,3)==="set"?l[d]=function(){return l.kernel[d].apply(l.kernel,arguments),l}:l[d]=function(){return l.kernel[d].apply(l.kernel,arguments)}:(l.__defineGetter__(d,()=>l.kernel[d]),l.__defineSetter__(d,p=>{l.kernel[d]=p})))}l.kernel=u}s.exports={kernelRunShortcut:o}},{"./utils":114}],112:[function(t,s,r){const c={name:"math-random-uniformly-distributed",onBeforeRun:d=>{d.setUniform1f("randomSeed1",Math.random()),d.setUniform1f("randomSeed2",Math.random())},functionMatch:"Math.random()",functionReplace:"nrand(vTexCoord)",functionReturnType:"Number",source:`// https://www.shadertoy.com/view/4t2SDh
//note: uniformly distributed, normalized rand, [0,1]
highp float randomSeedShift = 1.0;
highp float slide = 1.0;
uniform highp float randomSeed1;
uniform highp float randomSeed2;

highp float nrand(highp vec2 n) {
  highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);
  randomSeedShift = result;
  if (randomSeedShift > 0.5) {
    slide += 0.00009; 
  } else {
    slide += 0.0009;
  }
  return result;
}`};s.exports=c},{}],113:[function(t,s,r){class i{constructor(a){const{texture:u,size:l,dimensions:h,output:c,context:d,type:p="NumberTexture",kernel:f,internalFormat:g,textureFormat:m}=a;if(!c)throw new Error('settings property "output" required.');if(!d)throw new Error('settings property "context" required.');if(!u)throw new Error('settings property "texture" required.');if(!f)throw new Error('settings property "kernel" required.');this.texture=u,u._refs?u._refs++:u._refs=1,this.size=l,this.dimensions=h,this.output=c,this.context=d,this.kernel=f,this.type=p,this._deleted=!1,this.internalFormat=g,this.textureFormat=m}toArray(){throw new Error(`Not implemented on ${this.constructor.name}`)}clone(){throw new Error(`Not implemented on ${this.constructor.name}`)}delete(){throw new Error(`Not implemented on ${this.constructor.name}`)}clear(){throw new Error(`Not implemented on ${this.constructor.name}`)}}s.exports={Texture:i}},{}],114:[function(t,s,r){const i=t("acorn"),{Input:o}=t("./input"),{Texture:a}=t("./texture"),u=/function ([^(]*)/,l=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,h=/([^\s,]+)/g,c={systemEndianness(){return g},getSystemEndianness(){const m=new ArrayBuffer(4),b=new Uint32Array(m),x=new Uint8Array(m);if(b[0]=3735928559,x[0]===239)return"LE";if(x[0]===222)return"BE";throw new Error("unknown endianness")},isFunction(m){return typeof m=="function"},isFunctionString(m){return typeof m=="string"?m.slice(0,8).toLowerCase()==="function":!1},getFunctionNameFromString(m){const b=u.exec(m);return!b||b.length===0?null:b[1].trim()},getFunctionBodyFromString(m){return m.substring(m.indexOf("{")+1,m.lastIndexOf("}"))},getArgumentNamesFromString(m){const b=m.replace(l,"");let x=b.slice(b.indexOf("(")+1,b.indexOf(")")).match(h);return x===null&&(x=[]),x},clone(m){if(m===null||typeof m!="object"||m.hasOwnProperty("isActiveClone"))return m;const b=m.constructor();for(let x in m)Object.prototype.hasOwnProperty.call(m,x)&&(m.isActiveClone=null,b[x]=c.clone(m[x]),delete m.isActiveClone);return b},isArray(m){return!isNaN(m.length)},getVariableType(m,b){if(c.isArray(m))return m.length>0&&m[0].nodeName==="IMG"?"HTMLImageArray":"Array";switch(m.constructor){case Boolean:return"Boolean";case Number:return b&&Number.isInteger(m)?"Integer":"Float";case a:return m.type;case o:return"Input"}if("nodeName"in m)switch(m.nodeName){case"IMG":return"HTMLImage";case"CANVAS":return"HTMLImage";case"VIDEO":return"HTMLVideo"}else{if(m.hasOwnProperty("type"))return m.type;if(typeof OffscreenCanvas<"u"&&m instanceof OffscreenCanvas)return"OffscreenCanvas";if(typeof ImageBitmap<"u"&&m instanceof ImageBitmap)return"ImageBitmap";if(typeof ImageData<"u"&&m instanceof ImageData)return"ImageData"}return"Unknown"},getKernelTextureSize(m,b){let[x,v,w]=b,S=(x||1)*(v||1)*(w||1);return m.optimizeFloatMemory&&m.precision==="single"&&(x=S=Math.ceil(S/4)),v>1&&x*v===S?new Int32Array([x,v]):c.closestSquareDimensions(S)},closestSquareDimensions(m){const b=Math.sqrt(m);let x=Math.ceil(b),v=Math.floor(b);for(;x*v<m;)x--,v=Math.ceil(m/x);return new Int32Array([v,Math.ceil(m/v)])},getMemoryOptimizedFloatTextureSize(m,b){const v=c.roundTo((m[0]||1)*(m[1]||1)*(m[2]||1)*(m[3]||1),4)/b;return c.closestSquareDimensions(v)},getMemoryOptimizedPackedTextureSize(m,b){const[x,v,w]=m,k=c.roundTo((x||1)*(v||1)*(w||1),4)/(4/b);return c.closestSquareDimensions(k)},roundTo(m,b){return Math.floor((m+b-1)/b)*b},getDimensions(m,b){let x;if(c.isArray(m)){const v=[];let w=m;for(;c.isArray(w);)v.push(w.length),w=w[0];x=v.reverse()}else if(m instanceof a)x=m.output;else if(m instanceof o)x=m.size;else throw new Error(`Unknown dimensions of ${m}`);if(b)for(x=Array.from(x);x.length<3;)x.push(1);return new Int32Array(x)},flatten2dArrayTo(m,b){let x=0;for(let v=0;v<m.length;v++)b.set(m[v],x),x+=m[v].length},flatten3dArrayTo(m,b){let x=0;for(let v=0;v<m.length;v++)for(let w=0;w<m[v].length;w++)b.set(m[v][w],x),x+=m[v][w].length},flatten4dArrayTo(m,b){let x=0;for(let v=0;v<m.length;v++)for(let w=0;w<m[v].length;w++)for(let S=0;S<m[v][w].length;S++)b.set(m[v][w][S],x),x+=m[v][w][S].length},flattenTo(m,b){c.isArray(m[0])?c.isArray(m[0][0])?c.isArray(m[0][0][0])?c.flatten4dArrayTo(m,b):c.flatten3dArrayTo(m,b):c.flatten2dArrayTo(m,b):b.set(m)},splitArray(m,b){const x=[];for(let v=0;v<m.length;v+=b)x.push(new m.constructor(m.buffer,v*4+m.byteOffset,b));return x},getAstString(m,b){const x=Array.isArray(m)?m:m.split(/\r?\n/g),v=b.loc.start,w=b.loc.end,S=[];if(v.line===w.line)S.push(x[v.line-1].substring(v.column,w.column));else{S.push(x[v.line-1].slice(v.column));for(let k=v.line;k<w.line;k++)S.push(x[k]);S.push(x[w.line-1].slice(0,w.column))}return S.join(`
`)},allPropertiesOf(m){const b=[];do b.push.apply(b,Object.getOwnPropertyNames(m));while(m=Object.getPrototypeOf(m));return b},linesToString(m){return m.length>0?m.join(`;
`)+`;
`:`
`},warnDeprecated(m,b,x){console.warn(x?`You are using a deprecated ${m} "${b}". It has been replaced with "${x}". Fixing, but please upgrade as it will soon be removed.`:`You are using a deprecated ${m} "${b}". It has been removed. Fixing, but please upgrade as it will soon be removed.`)},flipPixels:(m,b,x)=>{const v=x/2|0,w=b*4,S=new Uint8ClampedArray(b*4),k=m.slice(0);for(let E=0;E<v;++E){const I=E*w,C=(x-E-1)*w;S.set(k.subarray(I,I+w)),k.copyWithin(I,C,C+w),k.set(S,C)}return k},erectPackedFloat:(m,b)=>m.subarray(0,b),erect2DPackedFloat:(m,b,x)=>{const v=new Array(x);for(let w=0;w<x;w++){const S=w*b,k=S+b;v[w]=m.subarray(S,k)}return v},erect3DPackedFloat:(m,b,x,v)=>{const w=new Array(v);for(let S=0;S<v;S++){const k=new Array(x);for(let E=0;E<x;E++){const I=S*x*b+E*b,C=I+b;k[E]=m.subarray(I,C)}w[S]=k}return w},erectMemoryOptimizedFloat:(m,b)=>m.subarray(0,b),erectMemoryOptimized2DFloat:(m,b,x)=>{const v=new Array(x);for(let w=0;w<x;w++){const S=w*b;v[w]=m.subarray(S,S+b)}return v},erectMemoryOptimized3DFloat:(m,b,x,v)=>{const w=new Array(v);for(let S=0;S<v;S++){const k=new Array(x);for(let E=0;E<x;E++){const I=S*x*b+E*b;k[E]=m.subarray(I,I+b)}w[S]=k}return w},erectFloat:(m,b)=>{const x=new Float32Array(b);let v=0;for(let w=0;w<b;w++)x[w]=m[v],v+=4;return x},erect2DFloat:(m,b,x)=>{const v=new Array(x);let w=0;for(let S=0;S<x;S++){const k=new Float32Array(b);for(let E=0;E<b;E++)k[E]=m[w],w+=4;v[S]=k}return v},erect3DFloat:(m,b,x,v)=>{const w=new Array(v);let S=0;for(let k=0;k<v;k++){const E=new Array(x);for(let I=0;I<x;I++){const C=new Float32Array(b);for(let T=0;T<b;T++)C[T]=m[S],S+=4;E[I]=C}w[k]=E}return w},erectArray2:(m,b)=>{const x=new Array(b),v=b*4;let w=0;for(let S=0;S<v;S+=4)x[w++]=m.subarray(S,S+2);return x},erect2DArray2:(m,b,x)=>{const v=new Array(x),w=b*4;for(let S=0;S<x;S++){const k=new Array(b),E=S*w;let I=0;for(let C=0;C<w;C+=4)k[I++]=m.subarray(C+E,C+E+2);v[S]=k}return v},erect3DArray2:(m,b,x,v)=>{const w=b*4,S=new Array(v);for(let k=0;k<v;k++){const E=new Array(x);for(let I=0;I<x;I++){const C=new Array(b),T=k*w*x+I*w;let R=0;for(let P=0;P<w;P+=4)C[R++]=m.subarray(P+T,P+T+2);E[I]=C}S[k]=E}return S},erectArray3:(m,b)=>{const x=new Array(b),v=b*4;let w=0;for(let S=0;S<v;S+=4)x[w++]=m.subarray(S,S+3);return x},erect2DArray3:(m,b,x)=>{const v=b*4,w=new Array(x);for(let S=0;S<x;S++){const k=new Array(b),E=S*v;let I=0;for(let C=0;C<v;C+=4)k[I++]=m.subarray(C+E,C+E+3);w[S]=k}return w},erect3DArray3:(m,b,x,v)=>{const w=b*4,S=new Array(v);for(let k=0;k<v;k++){const E=new Array(x);for(let I=0;I<x;I++){const C=new Array(b),T=k*w*x+I*w;let R=0;for(let P=0;P<w;P+=4)C[R++]=m.subarray(P+T,P+T+3);E[I]=C}S[k]=E}return S},erectArray4:(m,b)=>{const x=new Array(m),v=b*4;let w=0;for(let S=0;S<v;S+=4)x[w++]=m.subarray(S,S+4);return x},erect2DArray4:(m,b,x)=>{const v=b*4,w=new Array(x);for(let S=0;S<x;S++){const k=new Array(b),E=S*v;let I=0;for(let C=0;C<v;C+=4)k[I++]=m.subarray(C+E,C+E+4);w[S]=k}return w},erect3DArray4:(m,b,x,v)=>{const w=b*4,S=new Array(v);for(let k=0;k<v;k++){const E=new Array(x);for(let I=0;I<x;I++){const C=new Array(b),T=k*w*x+I*w;let R=0;for(let P=0;P<w;P+=4)C[R++]=m.subarray(P+T,P+T+4);E[I]=C}S[k]=E}return S},flattenFunctionToString:(m,b)=>{const{findDependency:x,thisLookup:v,doNotDefine:w}=b;let S=b.flattened;S||(S=b.flattened={});const k=i.parse(m),E=[];let I=0;function C(R){if(Array.isArray(R)){const P=[];for(let D=0;D<R.length;D++)P.push(C(R[D]));return P.join("")}switch(R.type){case"Program":return C(R.body)+(R.body[0].type==="VariableDeclaration"?";":"");case"FunctionDeclaration":return`function ${R.id.name}(${R.params.map(C).join(", ")}) ${C(R.body)}`;case"BlockStatement":{const D=[];I+=2;for(let F=0;F<R.body.length;F++){const z=C(R.body[F]);z&&D.push(" ".repeat(I)+z,`;
`)}return I-=2,`{
${D.join("")}}`}case"VariableDeclaration":const P=c.normalizeDeclarations(R).map(C).filter(D=>D!==null);return P.length<1?"":`${R.kind} ${P.join(",")}`;case"VariableDeclarator":return R.init.object&&R.init.object.type==="ThisExpression"?v(R.init.property.name,!0)?`${R.id.name} = ${C(R.init)}`:null:`${R.id.name} = ${C(R.init)}`;case"CallExpression":{if(R.callee.property.name==="subarray")return`${C(R.callee.object)}.${C(R.callee.property)}(${R.arguments.map(D=>C(D)).join(", ")})`;if(R.callee.object.name==="gl"||R.callee.object.name==="context")return`${C(R.callee.object)}.${C(R.callee.property)}(${R.arguments.map(D=>C(D)).join(", ")})`;if(R.callee.object.type==="ThisExpression")return E.push(x("this",R.callee.property.name)),`${R.callee.property.name}(${R.arguments.map(D=>C(D)).join(", ")})`;if(R.callee.object.name){const D=x(R.callee.object.name,R.callee.property.name);return D===null?`${R.callee.object.name}.${R.callee.property.name}(${R.arguments.map(F=>C(F)).join(", ")})`:(E.push(D),`${R.callee.property.name}(${R.arguments.map(F=>C(F)).join(", ")})`)}else{if(R.callee.object.type==="MemberExpression")return`${C(R.callee.object)}.${R.callee.property.name}(${R.arguments.map(D=>C(D)).join(", ")})`;throw new Error("unknown ast.callee")}}case"ReturnStatement":return`return ${C(R.argument)}`;case"BinaryExpression":return`(${C(R.left)}${R.operator}${C(R.right)})`;case"UnaryExpression":return R.prefix?`${R.operator} ${C(R.argument)}`:`${C(R.argument)} ${R.operator}`;case"ExpressionStatement":return`${C(R.expression)}`;case"SequenceExpression":return`(${C(R.expressions)})`;case"ArrowFunctionExpression":return`(${R.params.map(C).join(", ")}) => ${C(R.body)}`;case"Literal":return R.raw;case"Identifier":return R.name;case"MemberExpression":return R.object.type==="ThisExpression"?v(R.property.name):R.computed?`${C(R.object)}[${C(R.property)}]`:C(R.object)+"."+C(R.property);case"ThisExpression":return"this";case"NewExpression":return`new ${C(R.callee)}(${R.arguments.map(D=>C(D)).join(", ")})`;case"ForStatement":return`for (${C(R.init)};${C(R.test)};${C(R.update)}) ${C(R.body)}`;case"AssignmentExpression":return`${C(R.left)}${R.operator}${C(R.right)}`;case"UpdateExpression":return`${C(R.argument)}${R.operator}`;case"IfStatement":return`if (${C(R.test)}) ${C(R.consequent)}`;case"ThrowStatement":return`throw ${C(R.argument)}`;case"ObjectPattern":return R.properties.map(C).join(", ");case"ArrayPattern":return R.elements.map(C).join(", ");case"DebuggerStatement":return"debugger;";case"ConditionalExpression":return`${C(R.test)}?${C(R.consequent)}:${C(R.alternate)}`;case"Property":if(R.kind==="init")return C(R.key)}throw new Error(`unhandled ast.type of ${R.type}`)}const T=C(k);if(E.length>0){const R=[];for(let P=0;P<E.length;P++){const D=E[P];S[D]||(S[D]=!0),D&&R.push(c.flattenFunctionToString(D,b)+`
`)}return R.join("")+T}return T},normalizeDeclarations:m=>{if(m.type!=="VariableDeclaration")throw new Error('Ast is not of type "VariableDeclaration"');const b=[];for(let x=0;x<m.declarations.length;x++){const v=m.declarations[x];if(v.id&&v.id.type==="ObjectPattern"&&v.id.properties){const{properties:w}=v.id;for(let S=0;S<w.length;S++){const k=w[S];if(k.value.type==="ObjectPattern"&&k.value.properties)for(let E=0;E<k.value.properties.length;E++){const I=k.value.properties[E];if(I.type==="Property")b.push({type:"VariableDeclarator",id:{type:"Identifier",name:I.key.name},init:{type:"MemberExpression",object:{type:"MemberExpression",object:v.init,property:{type:"Identifier",name:k.key.name},computed:!1},property:{type:"Identifier",name:I.key.name},computed:!1}});else throw new Error("unexpected state")}else if(k.value.type==="Identifier")b.push({type:"VariableDeclarator",id:{type:"Identifier",name:k.value&&k.value.name?k.value.name:k.key.name},init:{type:"MemberExpression",object:v.init,property:{type:"Identifier",name:k.key.name},computed:!1}});else throw new Error("unexpected state")}}else if(v.id&&v.id.type==="ArrayPattern"&&v.id.elements){const{elements:w}=v.id;for(let S=0;S<w.length;S++){const k=w[S];if(k.type==="Identifier")b.push({type:"VariableDeclarator",id:{type:"Identifier",name:k.name},init:{type:"MemberExpression",object:v.init,property:{type:"Literal",value:S,raw:S.toString(),start:k.start,end:k.end},computed:!0}});else throw new Error("unexpected state")}}else b.push(v)}return b},splitHTMLImageToRGB:(m,b)=>{const x=m.createKernel(function(E){return E[this.thread.y][this.thread.x].r*255},{output:[b.width,b.height],precision:"unsigned",argumentTypes:{a:"HTMLImage"}}),v=m.createKernel(function(E){return E[this.thread.y][this.thread.x].g*255},{output:[b.width,b.height],precision:"unsigned",argumentTypes:{a:"HTMLImage"}}),w=m.createKernel(function(E){return E[this.thread.y][this.thread.x].b*255},{output:[b.width,b.height],precision:"unsigned",argumentTypes:{a:"HTMLImage"}}),S=m.createKernel(function(E){return E[this.thread.y][this.thread.x].a*255},{output:[b.width,b.height],precision:"unsigned",argumentTypes:{a:"HTMLImage"}}),k=[x(b),v(b),w(b),S(b)];return k.rKernel=x,k.gKernel=v,k.bKernel=w,k.aKernel=S,k.gpu=m,k},splitRGBAToCanvases:(m,b,x,v)=>{const w=m.createKernel(function(I){const C=I[this.thread.y][this.thread.x];this.color(C.r/255,0,0,255)},{output:[x,v],graphical:!0,argumentTypes:{v:"Array2D(4)"}});w(b);const S=m.createKernel(function(I){const C=I[this.thread.y][this.thread.x];this.color(0,C.g/255,0,255)},{output:[x,v],graphical:!0,argumentTypes:{v:"Array2D(4)"}});S(b);const k=m.createKernel(function(I){const C=I[this.thread.y][this.thread.x];this.color(0,0,C.b/255,255)},{output:[x,v],graphical:!0,argumentTypes:{v:"Array2D(4)"}});k(b);const E=m.createKernel(function(I){const C=I[this.thread.y][this.thread.x];this.color(255,255,255,C.a/255)},{output:[x,v],graphical:!0,argumentTypes:{v:"Array2D(4)"}});return E(b),[w.canvas,S.canvas,k.canvas,E.canvas]},getMinifySafeName:m=>{try{const b=i.parse(`const value = ${m.toString()}`),{init:x}=b.body[0].declarations[0];return x.body.name||x.body.body[0].argument.name}catch{throw new Error("Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }")}},sanitizeName:function(m){return d.test(m)&&(m=m.replace(d,"S_S")),p.test(m)?m=m.replace(p,"U_U"):f.test(m)&&(m=m.replace(f,"u_u")),m}},d=/\$/,p=/__/,f=/_/,g=c.getSystemEndianness();s.exports={utils:c}},{"./input":110,"./texture":113,acorn:1}]},{},[107])(107)})})(Nw);var _R=Nw.exports;let Wh=null;try{Wh=new _R.GPU}catch(n){console.error("GPU.js :",n),Wh=null}const DR=n=>{let e=0,t=0;return e=-Math.log((1-n)*(1+n)),e<5?(e=e-2.5,t=281022636e-16,t=343273939e-15+t*e,t=-35233877e-13+t*e,t=-439150654e-14+t*e,t=.00021858087+t*e,t=-.00125372503+t*e,t=-.00417768164+t*e,t=.246640727+t*e,t=1.50140941+t*e):(e=Math.sqrt(e)-3,t=-.000200214257,t=.000100950558+t*e,t=.00134934322+t*e,t=-.00367342844+t*e,t=.00573950773+t*e,t=-.0076224613+t*e,t=.00943887047+t*e,t=1.00167406+t*e,t=2.83297682+t*e),t*n},AR=n=>{const e=new Float32Array(n);for(let t=0;t<n;t++){const s=(t+.5)/n;e[t]=Math.sqrt(2)*DR(2*s-1)}return e},FR=n=>Wh?Wh.createKernel(function(t){function s(i){let o=0,a=0;return o=-Math.log((1-i)*(1+i)),o<5?(o=o-2.5,a=281022636e-16,a=343273939e-15+a*o,a=-35233877e-13+a*o,a=-439150654e-14+a*o,a=.00021858087+a*o,a=-.00125372503+a*o,a=-.00417768164+a*o,a=.246640727+a*o,a=1.50140941+a*o):(o=Math.sqrt(o)-3,a=-.000200214257,a=.000100950558+a*o,a=.00134934322+a*o,a=-.00367342844+a*o,a=.00573950773+a*o,a=-.0076224613+a*o,a=.00943887047+a*o,a=1.00167406+a*o,a=2.83297682+a*o),a*i}const r=(this.thread.x+.5)/t;return Math.sqrt(2)*s(2*r-1)},{output:[n],precision:"single"})(n):(console.warn("GPU.js  CPU "),AR(n));function PR(n,e,t){const s=n.width,r=n.height,i=s*r,o=FR(i),a=new Uint8Array(i);for(let u=0;u<i;u++){const l=e[u*3],h=e[u*3+1],c=e[u*3+2],d=o[u];if(l<i&&!(a[l]&1)){const p=l*4;t.data[p]=d,a[l]===0&&(t.data[p+3]=n.data[p+3]),a[l]|=1}if(h<i&&!(a[h]&2)){const p=h*4;t.data[p+1]=d,a[h]===0&&(t.data[p+3]=n.data[p+3]),a[h]|=2}if(c<i&&!(a[c]&4)){const p=c*4;t.data[p+2]=d,a[c]===0&&(t.data[p+3]=n.data[p+3]),a[c]|=4}}}async function LR(n,e){let t=await ai(ER)(n,e);const s=n.width*n.height;let i={data:new Array(s*4).fill(0),width:n.width,height:n.height};return ai(PR)(n,t,i),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OR=1e-7,MR=1e-4;class yg{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Ad{refCount(e){return ns("refCount")}incRef(e){return ns("incRef")}timerAvailable(){return!0}time(e){return ns("time")}read(e){return ns("read")}readSync(e){return ns("readSync")}readToGPU(e,t){return ns("readToGPU")}numDataIds(){return ns("numDataIds")}disposeData(e,t){return ns("disposeData")}write(e,t,s){return ns("write")}move(e,t,s,r,i){return ns("move")}createTensorFromGPUData(e,t,s){return ns("createTensorFromGPUData")}memory(){return ns("memory")}floatPrecision(){return ns("floatPrecision")}epsilon(){return this.floatPrecision()===32?OR:MR}dispose(){return ns("dispose")}}function ns(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zR(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Qo(n,e,t)}function oo(n,e,t){return Math.max(n,Math.min(e,t))}function wg(n){return n%2===0?n:n+1}function Qo(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function _w(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function L(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Fd(n,e,t=""){L(ct(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function Dw(n){L(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Q(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function Sy(n){return n.length===0}function ct(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function da(n){return n%1===0}function dm(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function oa(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Iy(n,e=r=>0,t,s){return new Promise((r,i)=>{let o=0;const a=()=>{if(n()){r();return}o++;const u=e(o);if(t!=null&&o>=t){i();return}s!=null?s(a,u):setTimeout(a,u)};a()})}function vg(n,e){let t=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function Qe(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),L(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),L(n.every(s=>da(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function Ii(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||r?null:Qe(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(t.push(n[a]),s.push(a)),i[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),s.push(a))}return{newShape:t,keptDims:s}}function fn(n,e){return Wt(n,e)}function Wt(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function BR(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function VR(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function Cg(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Hh(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function UR(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Ia(n){return typeof n=="string"||n instanceof String}function GR(n){return typeof n=="boolean"}function pm(n){return typeof n=="number"}function So(n){return Array.isArray(n)?So(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":pm(n)?"float32":Ia(n)?"string":GR(n)?"bool":"float32"}function fm(n){return!!(n&&n.constructor&&n.call&&n.apply)}function mm(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Be(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function Aw(n,e,t,s=!1){const r=new Array;if(e.length===1){const i=e[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=t[n+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((u,l)=>u*l)*(s?2:1);for(let u=0;u<i;u++)r[u]=Aw(n+u*a,o,t,s)}return r}function Ws(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,i)=>r*i)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Aw(0,n,e,t)}function Fh(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function Sg(n,e){const t=Cn(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function Cn(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function Fw(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return Ws(n,new Float32Array(t));if(e==="int32")return Ws(n,new Int32Array(t));if(e==="bool")return Ws(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Qr(n){n.forEach(e=>{L(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function yr(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function $a(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Ig(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $y="tfjsflags";class WR{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=HR,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ne().getBool("IS_TEST")||ne().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];ne().getBool("IS_TEST")||ne().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Ig(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);$y in e&&e[$y].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=jR(r,i)})}}function HR(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(KR(e,s[0],s[1]),s.join("="))),e}function KR(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function jR(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function ne(){return Pw}let Pw=null;function XR(n){Pw=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pf;function Lw(){if(Pf==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Pf=n}return Pf}function qR(){const n=Lw();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function $g(n,e){const t=qR();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const Ll="Abs",ka="Acos",Ta="Acosh",Io="Add",Pd="AddN",Ld="All",Od="Any",Ol="ArgMax",Ml="ArgMin",Ea="Asin",Ra="Asinh",Na="Atan",_a="Atanh",Da="Atan2",zl="AvgPool",Md="AvgPoolGrad",Bl="AvgPool3D",zd="AvgPool3DGrad",Vl="BatchMatMul",Ul="BatchToSpaceND",Bd="Bincount",kg="BitwiseAnd",YR="BroadcastTo",Tg="BroadcastArgs",Aa="Cast",Fa="Ceil",Pa="ClipByValue",Vd="Complex",Gl="ComplexAbs",Wl="Concat",Hl="Conv2D",Ud="Conv2DBackpropFilter",Kl="Conv2DBackpropInput",jl="Conv3D",Gd="Conv3DBackpropFilterV2",Wd="Conv3DBackpropInputV2",La="Cos",Oa="Cosh",Hd="Cumprod",Xl="Cumsum",Kd="CropAndResize",jd="DenseBincount",Xd="DepthToSpace",ql="DepthwiseConv2dNative",qd="DepthwiseConv2dNativeBackpropFilter",Yd="DepthwiseConv2dNativeBackpropInput",Eg="Diag",Yl="Dilation2D",Kh="Dilation2DBackpropInput",jh="Dilation2DBackpropFilter",Ow="Draw",Ma="RealDiv",Zd="Einsum",za="Elu",Qd="EluGrad",Ba="Erf",Zl="Equal",Va="Exp",Ql="ExpandDims",Ua="Expm1",Jd="FFT",ep="Fill",tp="FlipLeftRight",Ga="Floor",Wa="FloorDiv",Jl="FusedBatchNorm",ec="GatherV2",Rg="GatherNd",tc="Greater",Ha="GreaterEqual",Ka="Identity",np="IFFT",sp="Imag",ja="IsFinite",Xa="IsInf",qa="IsNan",nc="LeakyRelu",sc="Less",rc="LessEqual",Ng="LinSpace",Ya="Log",Za="Log1p",ic="LogicalAnd",oc="LogicalNot",ac="LogicalOr",ZR="LogSoftmax",uc="LRN",rp="LRNGrad",lc="Max",Qa="Maximum",cc="MaxPool",ip="MaxPoolGrad",hc="MaxPool3D",op="MaxPool3DGrad",_g="MaxPoolWithArgmax",dc="Mean",pc="Min",Ja="Minimum",fc="MirrorPad",eu="Mod",Dg="Multinomial",tu="Multiply",mc="Neg",gc="NotEqual",ap="NonMaxSuppressionV3",Ag="NonMaxSuppressionV4",up="NonMaxSuppressionV5",xc="OnesLike",bc="OneHot",yc="Pack",wc="PadV2",nu="Pow",vc="Prelu",Cc="Prod",Mw="RaggedGather",zw="RaggedRange",Bw="RaggedTensorToTensor",lp="Range",cp="Real",su="Reciprocal",ru="Relu",Sc="Reshape",Ic="ResizeNearestNeighbor",hp="ResizeNearestNeighborGrad",$c="ResizeBilinear",dp="ResizeBilinearGrad",iu="Relu6",kc="Reverse",ou="Round",au="Rsqrt",Fg="ScatterNd",Pg="TensorScatterUpdate",Lg="SearchSorted",Tc="Select",uu="Selu",Ec="Slice",lu="Sin",cu="Sinh",hu="Sign",du="Sigmoid",pu="Softplus",fu="Sqrt",Rc="Sum",Nc="SpaceToBatchND",_c="SplitV",Dc="Softmax",Vw="SparseFillEmptyRows",Uw="SparseReshape",Og="SparseSegmentMean",Mg="SparseSegmentSum",zg="SparseToDense",mu="SquaredDifference",pp="Square",Bg="StaticRegexReplace",fp="StridedSlice",Vg="StringNGrams",Gw="StringSplit",Ww="StringToHashBucketFast",gu="Sub",xu="Tan",bu="Tanh",yu="Tile",mp="TopK",gp="Transform",to="Transpose",Ug="Unique",Ac="Unpack",Fc="UnsortedSegmentSum",Pc="ZerosLike",wu="Step",Hw="FromPixels",xp="RotateWithOffset",ml="_FusedMatMul",gl="FusedConv2D",Gg="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ps(...n){ne().getBool("IS_TEST")||ne().getBool("PROD")||console.warn(...n)}function QR(...n){ne().getBool("IS_TEST")||ne().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xh=$g("kernelRegistry",()=>new Map),gm=$g("gradRegistry",()=>new Map);function ky(n,e){const t=Kw(n,e);return Xh.get(t)}function Ty(n){return gm.get(n)}function Ey(n){const e=Xh.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,o]=r,[a]=i.split("_");a===n&&t.push(o)}return t}function Wg(n){const{kernelName:e,backendName:t}=n,s=Kw(e,t);Xh.has(s)&&ps(`The kernel '${e}' for backend '${t}' is already registered`),Xh.set(s,n)}function JR(n){const{kernelName:e}=n;gm.has(e)&&ne().getBool("DEBUG")&&ps(`Overriding the gradient for '${e}'`),gm.set(e,n)}function Kw(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jw(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Xw=Pt,Es=null;try{Es=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Pt(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}Pt.prototype.__isLong__;Object.defineProperty(Pt.prototype,"__isLong__",{value:!0});function cs(n){return(n&&n.__isLong__)===!0}Pt.isLong=cs;var Ry={},Ny={};function $o(n,e){var t,s,r;return e?(n>>>=0,(r=0<=n&&n<256)&&(s=Ny[n],s)?s:(t=Lt(n,(n|0)<0?-1:0,!0),r&&(Ny[n]=t),t)):(n|=0,(r=-128<=n&&n<128)&&(s=Ry[n],s)?s:(t=Lt(n,n<0?-1:0,!1),r&&(Ry[n]=t),t))}Pt.fromInt=$o;function Rs(n,e){if(isNaN(n))return e?qi:Ns;if(e){if(n<0)return qi;if(n>=qw)return Qw}else{if(n<=-Dy)return is;if(n+1>=Dy)return Zw}return n<0?Rs(-n,e).neg():Lt(n%pa|0,n/pa|0,e)}Pt.fromNumber=Rs;function Lt(n,e,t){return new Pt(n,e,t)}Pt.fromBits=Lt;var qh=Math.pow;function Hg(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return Ns;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var s;if((s=n.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return Hg(n.substring(1),e,t).neg();for(var r=Rs(qh(t,8)),i=Ns,o=0;o<n.length;o+=8){var a=Math.min(8,n.length-o),u=parseInt(n.substring(o,o+a),t);if(a<8){var l=Rs(qh(t,a));i=i.mul(l).add(Rs(u))}else i=i.mul(r),i=i.add(Rs(u))}return i.unsigned=e,i}Pt.fromString=Hg;function er(n,e){return typeof n=="number"?Rs(n,e):typeof n=="string"?Hg(n,e):Lt(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}Pt.fromValue=er;var _y=65536,eN=1<<24,pa=_y*_y,qw=pa*pa,Dy=qw/2,Ay=$o(eN),Ns=$o(0);Pt.ZERO=Ns;var qi=$o(0,!0);Pt.UZERO=qi;var ta=$o(1);Pt.ONE=ta;var Yw=$o(1,!0);Pt.UONE=Yw;var xm=$o(-1);Pt.NEG_ONE=xm;var Zw=Lt(-1,2147483647,!1);Pt.MAX_VALUE=Zw;var Qw=Lt(-1,-1,!0);Pt.MAX_UNSIGNED_VALUE=Qw;var is=Lt(0,-2147483648,!1);Pt.MIN_VALUE=is;var Ee=Pt.prototype;Ee.toInt=function(){return this.unsigned?this.low>>>0:this.low};Ee.toNumber=function(){return this.unsigned?(this.high>>>0)*pa+(this.low>>>0):this.high*pa+(this.low>>>0)};Ee.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(is)){var t=Rs(e),s=this.div(t),r=s.mul(t).sub(this);return s.toString(e)+r.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var i=Rs(qh(e,6),this.unsigned),o=this,a="";;){var u=o.div(i),l=o.sub(u.mul(i)).toInt()>>>0,h=l.toString(e);if(o=u,o.isZero())return h+a;for(;h.length<6;)h="0"+h;a=""+h+a}};Ee.getHighBits=function(){return this.high};Ee.getHighBitsUnsigned=function(){return this.high>>>0};Ee.getLowBits=function(){return this.low};Ee.getLowBitsUnsigned=function(){return this.low>>>0};Ee.getNumBitsAbs=function(){if(this.isNegative())return this.eq(is)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return this.high!=0?t+33:t+1};Ee.isZero=function(){return this.high===0&&this.low===0};Ee.eqz=Ee.isZero;Ee.isNegative=function(){return!this.unsigned&&this.high<0};Ee.isPositive=function(){return this.unsigned||this.high>=0};Ee.isOdd=function(){return(this.low&1)===1};Ee.isEven=function(){return(this.low&1)===0};Ee.equals=function(e){return cs(e)||(e=er(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Ee.eq=Ee.equals;Ee.notEquals=function(e){return!this.eq(e)};Ee.neq=Ee.notEquals;Ee.ne=Ee.notEquals;Ee.lessThan=function(e){return this.comp(e)<0};Ee.lt=Ee.lessThan;Ee.lessThanOrEqual=function(e){return this.comp(e)<=0};Ee.lte=Ee.lessThanOrEqual;Ee.le=Ee.lessThanOrEqual;Ee.greaterThan=function(e){return this.comp(e)>0};Ee.gt=Ee.greaterThan;Ee.greaterThanOrEqual=function(e){return this.comp(e)>=0};Ee.gte=Ee.greaterThanOrEqual;Ee.ge=Ee.greaterThanOrEqual;Ee.compare=function(e){if(cs(e)||(e=er(e)),this.eq(e))return 0;var t=this.isNegative(),s=e.isNegative();return t&&!s?-1:!t&&s?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Ee.comp=Ee.compare;Ee.negate=function(){return!this.unsigned&&this.eq(is)?is:this.not().add(ta)};Ee.neg=Ee.negate;Ee.add=function(e){cs(e)||(e=er(e));var t=this.high>>>16,s=this.high&65535,r=this.low>>>16,i=this.low&65535,o=e.high>>>16,a=e.high&65535,u=e.low>>>16,l=e.low&65535,h=0,c=0,d=0,p=0;return p+=i+l,d+=p>>>16,p&=65535,d+=r+u,c+=d>>>16,d&=65535,c+=s+a,h+=c>>>16,c&=65535,h+=t+o,h&=65535,Lt(d<<16|p,h<<16|c,this.unsigned)};Ee.subtract=function(e){return cs(e)||(e=er(e)),this.add(e.neg())};Ee.sub=Ee.subtract;Ee.multiply=function(e){if(this.isZero())return Ns;if(cs(e)||(e=er(e)),Es){var t=Es.mul(this.low,this.high,e.low,e.high);return Lt(t,Es.get_high(),this.unsigned)}if(e.isZero())return Ns;if(this.eq(is))return e.isOdd()?is:Ns;if(e.eq(is))return this.isOdd()?is:Ns;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Ay)&&e.lt(Ay))return Rs(this.toNumber()*e.toNumber(),this.unsigned);var s=this.high>>>16,r=this.high&65535,i=this.low>>>16,o=this.low&65535,a=e.high>>>16,u=e.high&65535,l=e.low>>>16,h=e.low&65535,c=0,d=0,p=0,f=0;return f+=o*h,p+=f>>>16,f&=65535,p+=i*h,d+=p>>>16,p&=65535,p+=o*l,d+=p>>>16,p&=65535,d+=r*h,c+=d>>>16,d&=65535,d+=i*l,c+=d>>>16,d&=65535,d+=o*u,c+=d>>>16,d&=65535,c+=s*h+r*l+i*u+o*a,c&=65535,Lt(p<<16|f,c<<16|d,this.unsigned)};Ee.mul=Ee.multiply;Ee.divide=function(e){if(cs(e)||(e=er(e)),e.isZero())throw Error("division by zero");if(Es){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?Es.div_u:Es.div_s)(this.low,this.high,e.low,e.high);return Lt(t,Es.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?qi:Ns;var s,r,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return qi;if(e.gt(this.shru(1)))return Yw;i=qi}else{if(this.eq(is)){if(e.eq(ta)||e.eq(xm))return is;if(e.eq(is))return ta;var o=this.shr(1);return s=o.div(e).shl(1),s.eq(Ns)?e.isNegative()?ta:xm:(r=this.sub(e.mul(s)),i=s.add(r.div(e)),i)}else if(e.eq(is))return this.unsigned?qi:Ns;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=Ns}for(r=this;r.gte(e);){s=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(s)/Math.LN2),u=a<=48?1:qh(2,a-48),l=Rs(s),h=l.mul(e);h.isNegative()||h.gt(r);)s-=u,l=Rs(s,this.unsigned),h=l.mul(e);l.isZero()&&(l=ta),i=i.add(l),r=r.sub(h)}return i};Ee.div=Ee.divide;Ee.modulo=function(e){if(cs(e)||(e=er(e)),Es){var t=(this.unsigned?Es.rem_u:Es.rem_s)(this.low,this.high,e.low,e.high);return Lt(t,Es.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Ee.mod=Ee.modulo;Ee.rem=Ee.modulo;Ee.not=function(){return Lt(~this.low,~this.high,this.unsigned)};Ee.and=function(e){return cs(e)||(e=er(e)),Lt(this.low&e.low,this.high&e.high,this.unsigned)};Ee.or=function(e){return cs(e)||(e=er(e)),Lt(this.low|e.low,this.high|e.high,this.unsigned)};Ee.xor=function(e){return cs(e)||(e=er(e)),Lt(this.low^e.low,this.high^e.high,this.unsigned)};Ee.shiftLeft=function(e){return cs(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Lt(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Lt(0,this.low<<e-32,this.unsigned)};Ee.shl=Ee.shiftLeft;Ee.shiftRight=function(e){return cs(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Lt(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Lt(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Ee.shr=Ee.shiftRight;Ee.shiftRightUnsigned=function(e){if(cs(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var s=this.low;return Lt(s>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?Lt(t,0,this.unsigned):Lt(t>>>e-32,0,this.unsigned)};Ee.shru=Ee.shiftRightUnsigned;Ee.shr_u=Ee.shiftRightUnsigned;Ee.toSigned=function(){return this.unsigned?Lt(this.low,this.high,!1):this};Ee.toUnsigned=function(){return this.unsigned?this:Lt(this.low,this.high,!0)};Ee.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Ee.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Ee.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};Pt.fromBytes=function(e,t,s){return s?Pt.fromBytesLE(e,t):Pt.fromBytesBE(e,t)};Pt.fromBytesLE=function(e,t){return new Pt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};Pt.fromBytesBE=function(e,t){return new Pt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const Jw=RR(Xw),tN=Zk({__proto__:null,default:Jw},[Xw]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hi=Jw||tN;function bp(n){return Hi.fromString(n,!0,16)}const ev=bp("c3a5c85c97cb3127"),Gi=bp("b492b66fbe98f273"),An=bp("9ae16a3b2f90404f");function bm(n){return n.xor(n.shru(47))}function tv(n,e,t){const s=n.slice(e,e+t);return Hi.fromBytes(Array.from(s),!0,!0)}function Et(n,e){return tv(n,e,8)}function Fy(n,e){return tv(n,e,4)}function dn(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function di(n,e,t=bp("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function nN(n,e,t,s,r,i){r=r.add(n),i=dn(i.add(r).add(s),21);const o=r;return r=r.add(e),r=r.add(t),i=i.add(dn(r,44)),[r.add(s),i.add(o)]}function gh(n,e,t,s){return nN(Et(n,e),Et(n,e+8),Et(n,e+16),Et(n,e+24),t,s)}function sN(n,e=n.length){if(e>=8){const t=An.add(e*2),s=Et(n,0).add(An),r=Et(n,e-8),i=dn(r,37).mul(t).add(s),o=dn(s,25).add(r).mul(t);return di(i,o,t)}if(e>=4){const t=An.add(e*2),s=Fy(n,0);return di(s.shl(3).add(e),Fy(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],i=t+(s<<8),o=e+(r<<2);return bm(An.mul(i).xor(ev.mul(o))).mul(An)}return An}function rN(n,e=n.length){const t=An.add(e*2),s=Et(n,0).mul(Gi),r=Et(n,8),i=Et(n,e-8).mul(t),o=Et(n,e-16).mul(An);return di(dn(s.add(r),43).add(dn(i,30)).add(o),s.add(dn(r.add(An),18)).add(i),t)}function iN(n,e=n.length){const t=An.add(e*2),s=Et(n,0).mul(An),r=Et(n,8),i=Et(n,e-8).mul(t),o=Et(n,e-16).mul(An),a=dn(s.add(r),43).add(dn(i,30)).add(o),u=di(a,s.add(dn(r.add(An),18)).add(i),t),l=Et(n,16).mul(t),h=Et(n,24),c=a.add(Et(n,e-32)).mul(t),d=u.add(Et(n,e-24)).mul(t);return di(dn(l.add(h),43).add(dn(c,30)).add(d),l.add(dn(h.add(s),18)).add(c),t)}function oN(n,e=n.length){const t=Hi.fromNumber(81,!0);if(e<=32)return e<=16?sN(n,e):rN(n,e);if(e<=64)return iN(n,e);let s=t,r=t.mul(Gi).add(113),i=bm(r.mul(An).add(113)).mul(An),o=[Hi.UZERO,Hi.UZERO],a=[Hi.UZERO,Hi.UZERO];s=s.mul(An).add(Et(n,0));let u=0;const l=(e-1>>6)*64,h=l+(e-1&63)-63;do s=dn(s.add(r).add(o[0]).add(Et(n,u+8)),37).mul(Gi),r=dn(r.add(o[1]).add(Et(n,u+48)),42).mul(Gi),s=s.xor(a[1]),r=r.add(o[0]).add(Et(n,u+40)),i=dn(i.add(a[0]),33).mul(Gi),o=gh(n,u,o[1].mul(Gi),s.add(a[0])),a=gh(n,u+32,i.add(a[1]),r.add(Et(n,u+16))),[i,s]=[s,i],u+=64;while(u!==l);const c=Gi.add(i.and(255).shl(1));return u=h,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),s=dn(s.add(r).add(o[0]).add(Et(n,u+8)),37).mul(c),r=dn(r.add(o[1]).add(Et(n,u+48)),42).mul(c),s=s.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(Et(n,u+40))),i=dn(i.add(a[0]),33).mul(c),o=gh(n,u,o[1].mul(c),s.add(a[0])),a=gh(n,u+32,i.add(a[1]),r.add(Et(n,u+16))),[i,s]=[s,i],di(di(o[0],a[0],c).add(bm(r).mul(ev)).add(i),di(o[1],a[1],c).add(s),c)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $i(n,e){return e==="string"?Ur(n):ko([n],e)}function aN(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function ko(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Xr(n)),ne().getBool("DEBUG")&&BR(n,e),aN(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Gn(){return ne().platform.now()}function Ur(n,e="utf-8"){return e=e||"utf-8",ne().platform.encode(n,e)}function Xs(n,e="utf-8"){return e=e||"utf-8",ne().platform.decode(n,e)}function Fs(n){return ne().platform.isTypedArray!=null?ne().platform.isTypedArray(n):jw(n)}function Xr(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Ig(n)||n==null||Fs(n)&&t)e.push(n);else if(Array.isArray(n)||Fs(n))for(let s=0;s<n.length;++s)Xr(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Xr(n[r],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uN{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new cN)}profileKernel(e,t,s){let r;const i=()=>{r=s()};let o;const a=Gn();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const l of r)l.dataSync();o=Promise.resolve({kernelMs:Gn()-a})}if(ne().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<r.length;l++){const h=r[l];h.data().then(c=>{lN(c,h.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(l=>l.kernelMs),extraInfo:o.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:i,extraInfo:o}=e;s.forEach(a=>{Promise.all([a.data(),r,o]).then(u=>{this.logger.logKernelProfile(t,a,u[0],u[1],i,u[2])})})}}function lN(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class cN{logKernelProfile(e,t,s,r,i,o){const a=typeof r=="number"?oa(`${r}ms`,9):r.error,u=oa(e,25),l=t.rank,h=t.size,c=oa(t.shape.toString(),14);let d="";for(const p in i){const f=i[p];if(f!=null){const g=f.shape||t.shape,m=g.length;d+=`${p}: ${m}D ${m>0?g:""} `}}console.log(`%c${u}	%c${a}	%c${l}D ${c}	%c${h}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(n,e,t){const s={},r={};for(let u=0;u<e.length;u++)s[e[u].id]=!0;for(let u=0;u<n.length;u++){const l=n[u],h=l.inputs;for(const c in h){const d=h[c];let p=!1;for(let f=0;f<e.length;f++)if(s[d.id]){l.outputs.forEach(g=>s[g.id]=!0),p=!0,r[l.id]=!0;break}if(p)break}}const i={};i[t.id]=!0;const o={};for(let u=n.length-1;u>=0;u--){const l=n[u],h=l.inputs;for(let c=0;c<l.outputs.length;c++)if(i[l.outputs[c].id]){for(const d in h)i[h[d].id]=!0,o[l.id]=!0;break}}const a=[];for(let u=0;u<n.length;u++){const l=n[u];if(r[l.id]&&o[l.id]){const h={};for(const d in l.inputs){const p=l.inputs[d];s[p.id]&&(h[d]=p)}const c=Object.assign({},l);c.inputs=h,c.outputs=l.outputs,a.push(c)}}return a}function dN(n,e,t,s){for(let r=e.length-1;r>=0;r--){const i=e[r],o=[];if(i.outputs.forEach(u=>{const l=n[u.id];l!=null?o.push(l):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const u in i.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);const l=t(()=>a[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);const h=i.inputs[u];if(!ct(l.shape,h.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${h.shape}'`);if(n[h.id]==null)n[h.id]=l;else{const c=n[h.id];n[h.id]=s(c,l),c.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Py=20,zu=3,Lf=7;function pN(n,e,t,s){const r=Be(e),i=fN(n,e,t,r),o=e.length,a=Ph(n,e,t,r,i),u=["Tensor"];return s&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${o}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(a.map(l=>"    "+l).join(`
`)),u.join(`
`)}function fN(n,e,t,s){const r=Q(e),i=s[s.length-1],o=new Array(i).fill(0),a=e.length,u=t==="complex64"?Hu(n):n;if(a>1)for(let l=0;l<r/i;l++){const h=l*i;for(let c=0;c<i;c++)o[c]=Math.max(o[c],Wu(u[h+c],0,t).length)}return o}function Wu(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Lf))} + ${parseFloat(n[1].toFixed(Lf))}j`:Ia(n)?s=`'${n}'`:t==="bool"?s=nv(n):s=parseFloat(n.toFixed(Lf)).toString(),oa(s,e)}function nv(n){return n===0?"false":"true"}function Ph(n,e,t,s,r,i=!0){const o=t==="complex64"?2:1,a=e[0],u=e.length;if(u===0){if(t==="complex64"){const g=Hu(n);return[Wu(g[0],0,t)]}return t==="bool"?[nv(n[0])]:[n[0].toString()]}if(u===1){if(a>Py){const m=zu*o;let b=Array.from(n.slice(0,m)),x=Array.from(n.slice((a-zu)*o,a*o));return t==="complex64"&&(b=Hu(b),x=Hu(x)),["["+b.map((v,w)=>Wu(v,r[w],t)).join(", ")+", ..., "+x.map((v,w)=>Wu(v,r[a-zu+w],t)).join(", ")+"]"]}return["["+(t==="complex64"?Hu(n):Array.from(n)).map((m,b)=>Wu(m,r[b],t)).join(", ")+"]"]}const l=e.slice(1),h=s.slice(1),c=s[0]*o,d=[];if(a>Py){for(let g=0;g<zu;g++){const m=g*c,b=m+c;d.push(...Ph(n.slice(m,b),l,t,h,r,!1))}d.push("...");for(let g=a-zu;g<a;g++){const m=g*c,b=m+c;d.push(...Ph(n.slice(m,b),l,t,h,r,g===a-1))}}else for(let g=0;g<a;g++){const m=g*c,b=m+c;d.push(...Ph(n.slice(m,b),l,t,h,r,g===a-1))}const p=u===2?",":"";d[0]="["+(a>0?d[0]+p:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=`,
`;for(let g=2;g<u;g++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function Hu(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vn{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=Q(e),s!=null){const r=s.length;L(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Wt(t,this.size),this.strides=Be(e)}set(e,...t){t.length===0&&(t=[0]),L(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Bs().makeTensor(this.values,this.shape,this.dtype)}}let Bs=null,Jo=null;function mN(n){Bs=n}function gN(n){Jo=n}class sn{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Q(e),this.strides=Be(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Jo.buffer(this.shape,this.dtype,e)}bufferSync(){return Jo.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Ws(this.shape,e,this.dtype==="complex64")}arraySync(){return Ws(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Bs().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Xs(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Bs().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Bs().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Xs(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Bs().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Bs().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Jo.print(this,e)}clone(){return this.throwIfDisposed(),Jo.clone(this)}toString(e=!1){const t=this.dataSync();return pN(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Jo.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),Bs().makeVariable(this,e,t,s)}}Object.defineProperty(sn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function le(){return $g("Tensor",()=>sn)}le();class Yh extends sn{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ct(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Bs().disposeTensor(this),this.dataId=e.dataId,Bs().incRef(this,null)}dispose(){Bs().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Yh,Symbol.hasInstance,{value:n=>n instanceof sn&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ly;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(Ly||(Ly={}));var ym;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(ym||(ym={}));var wm;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(wm||(wm={}));var vm;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(vm||(vm={}));var Cm;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(Cm||(Cm={}));const xN={float32:vm,int32:ym,bool:wm,complex64:Cm};function mn(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return xN[n][e]}function yp(n){return mn(n,"int32")}function sv(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function rv(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xt(n,e){if(n.dtype===e.dtype)return[n,e];const t=mn(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function iv(n){const e=[];return ov(n,e,new Set),e}function ov(n,e,t){if(n==null)return;if(n instanceof sn){e.push(n);return}if(!bN(n))return;const s=n;for(const r in s){const i=s[r];t.has(i)||(t.add(i),ov(i,e,t))}}function bN(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Of(n){return n.kernelName!=null}class Oy{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class fa{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Oy}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(ps(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new uN(this.backendInstance),!0}setupRegisteredKernels(){Ey(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Ey(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof Ad)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,ps(`Initialization of backend ${e} failed`),ps(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return ps(`Initialization of backend ${e} failed`),ps(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,i=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return fa.nextTensorId++}nextVariableId(){return fa.nextVariableId++}clone(e){const t=Y.runKernel(Ka,{x:e}),s={x:e},r=o=>({x:()=>{const a="float32",u={x:o},l={dtype:a};return Y.runKernel(Aa,u,l)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,i,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(ky(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let i=0;s.forEach(u=>{i+=u.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let u;const l=Of(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Of(e)){const{kernelName:f,inputs:g,attrs:m}=e;this.backendName==null&&this.backend;const b=ky(f,this.backendName);L(b!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{const x=this.backend.numDataIds();u=b.kernelFunc({inputs:g,attrs:m,backend:this.backend});const v=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,x,v);const w=v.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(r){const S=this.getTensorsForGradient(f,g,w);s=this.saveTensorsForBackwardMode(S)}return w}}else{const{forwardFunc:f}=e,g=m=>{r&&(s=m.map(b=>this.keep(this.clone(b))))};a=()=>{const m=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,g));const b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,m,b),b}}const{inputs:h,attrs:c}=e,d=Of(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(p=this.profiler.profileKernel(l,h,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),r&&this.addTapeNode(l,h,t,d,s,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(f=>h[f]!=null?h[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=Ty(e);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?(L(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(l=>t[l])):a=i.map(l=>t[l]);const u=s.filter((l,h)=>o[h]);return a.concat(u)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=e;s==="string"&&Ia(e[0])&&(i=e.map(u=>Ur(u)));const o=r.write(i,t,s),a=new sn(t,s,o,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const u=this.state.tensorInfo.get(o),l=UR(i);this.state.numBytes+=l-u.bytes,u.bytes=l}return a}makeTensorFromDataId(e,t,s,r){s=s||"float32";const i={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:i}=e,o=new sn(r,i,s,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const i=new Yh(e,t,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Hh(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Yh||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Hh(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:i},u=Ty(e);u!=null&&(r=u.gradFunc),r!=null&&(a.gradient=l=>(l=l.map((h,c)=>{if(h==null){const d=s[c],p=Cn(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return h}),r(l.length>1?l:l[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=iv(e),s=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(e,t,s,r=!1){if(L(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));L(i instanceof sn,()=>"The result y returned by f() must be a tensor.");const o=hN(this.state.activeTape,t,i);if(!r&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=s??yN(i.shape),dN(a,o,l=>this.tidy(l),wN);const u=t.map(l=>a[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const h of l.saved)h.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return L(fm(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{L(t.every(a=>a instanceof sn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((a,u)=>{r[u]=a});const i=(a,u)=>(s=e(...t,u),L(s.value instanceof sn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),L(fm(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(a,u)=>{const l=s.gradFunc(a,u),h=Array.isArray(l)?l:[l];L(h.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),L(h.every(d=>d instanceof sn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const c={};return h.forEach((d,p)=>{c[p]=()=>d}),c};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Gn(),s=await this.backend.time(e);return s.wallMs=Gn()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Oy;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}fa.nextTensorId=0;fa.nextVariableId=0;function yN(n){const e=Sg(Q(n),"float32");return Y.makeTensor(e,n,"float32")}function av(){const n=Lw();if(n._tfengine==null){const e=new WR(n);n._tfengine=new fa(e)}return XR(n._tfengine.ENV),mN(()=>n._tfengine),n._tfengine}const Y=av();function wN(n,e){const t={a:n,b:e};return Y.runKernel(Io,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vN(){return typeof navigator<"u"&&navigator!=null}function uv(n){if(n||vN()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function lv(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zn=ne();Zn.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Zn.registerFlag("IS_BROWSER",()=>lv());Zn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Zn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Zn.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Zn.registerFlag("PROD",()=>!1);Zn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Zn.getBool("DEBUG"));Zn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Zn.registerFlag("IS_TEST",()=>!1);Zn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Zn.getBool("DEBUG"));Zn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Zn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Zn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wp(n,e){let t=n;if(Fs(n))return e==="string"?[]:[n.length];if(sv(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(rv(n))return[n.buffer.size/(e==null?4:Hh(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||Fs(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&ne().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&cv(n,s,[]),s}function cv(n,e,t){if(t=t||[],!Array.isArray(n)&&!Fs(n)){L(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}L(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),L(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)cv(n[r],s,t.concat(r))}function My(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function W(n,e,t,s="numeric"){if(n instanceof le())return My(s,n.dtype,e,t),n;let r=So(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),My(s,r,e,t),n==null||!Fs(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const i=wp(n,r);!Fs(n)&&!Array.isArray(n)&&(n=[n]);const a=r!=="string"?ko(n,r):Xr(n,[],!0);return Y.makeTensor(a,i,r)}function hv(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>W(i,`${e}[${o}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CN="__op";function J(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+CN;const r=(...i)=>{Y.startScope(t);try{const o=s(...i);return Ig(o)&&console.error("Cannot return a Promise inside of tidy."),Y.endScope(o),o}catch(o){throw Y.endScope(null),o}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SN(n,e){const t=W(n,"real","complex"),s=W(e,"imag","complex");Fd(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return Y.runKernel(Vd,r)}const ma=J({complex_:SN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vp(n,e,t,s){if(s==null)s=So(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(rv(n)||sv(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return Y.backend.createTensorFromGPUData(n,e||t,s)}if(!Fs(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Qr(e);const r=Q(e),i=Q(t);L(r===i,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<t.length;++o){const a=t[o],u=o===t.length-1?a!==Q(e.slice(o)):!0;L(t[o]===e[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Fs(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?ko(n,s):Xr(n,[],!0),Y.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dv(n,e,t){const s=wp(n,t);return vp(n,e,s,t)}class vu{static join(e){return new vu(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>Fs(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+r.byteLength;this.shards.push({buffer:r,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,i=new ArrayBuffer(r),o=new Uint8Array(i);let a=0;for(let u=s;u<this.shards.length;u++){const l=this.shards[u],c=e+a-l.start,d=a,f=Math.min(t,l.end)-l.start,g=new Uint8Array(l.buffer,c,f-c);if(o.set(g,d),a+=g.length,t<l.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=IN(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function IN(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,i=e(n[r]);if(i===0)return r;i<0?s=r:t=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ds(){return Y}function zy(){return Y.memory()}function se(n,e){return Y.tidy(n,e)}function ut(n){iv(n).forEach(t=>t.dispose())}function wr(n){return Y.keep(n)}function pv(n){return Y.setBackend(n)}function fv(){return Y.ready()}function $N(){return Y.backendName}function Kg(n,e,t=1){return Y.registerBackend(n,e,t)}function kN(){return Y.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const By=4;async function Vy(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const a=r[o],u=Array.isArray(n)?n[o].tensor:n[a];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);const l={name:a,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const h=new Promise(async c=>{const d=await u.bytes(),p=d.reduce((m,b)=>m+b.length,0)+By*d.length,f=new Uint8Array(p);let g=0;for(let m=0;m<d.length;m++){const b=d[m],x=new Uint8Array(new Uint32Array([b.length]).buffer);f.set(x,g),g+=By,f.set(b,g),g+=b.length}c(f)});s.push(h)}else s.push(u.data());e!=null&&(l.group=e),t.push(l)}const i=await Promise.all(s);return{data:TN(i),specs:t}}function TN(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const jg=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Uy(n){return jg?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function EN(n){if(jg)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function RN(n){if(jg){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function NN(n){return vu.join(n)}function mv(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:Uy(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:Uy(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new vu(n.weightData).byteLength}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Nn.instance==null&&(Nn.instance=new Nn),Nn.instance}static registerSaveRouter(e){Nn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Nn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Nn.getHandlers(e,"save")}static getLoadHandlers(e,t){return Nn.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?Nn.getInstance().loadRouters:Nn.getInstance().saveRouters).forEach(o=>{const a=o(e,s);a!==null&&r.push(a)}),r}}const _N=n=>Nn.getSaveHandlers(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sm="tensorflowjs",Im=1,Yi="models_store",ui="model_info_store";function gv(){if(!ne().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function $m(n){const e=n.result;e.createObjectStore(Yi,{keyPath:"modelPath"}),e.createObjectStore(ui,{keyPath:"modelPath"})}class ao{constructor(e){if(this.indexedDB=gv(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const i=this.indexedDB.open(Sm,Im);i.onupgradeneeded=()=>$m(i),i.onsuccess=()=>{const o=i.result;if(t==null){const a=o.transaction(Yi,"readonly"),l=a.objectStore(Yi).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(l.result.modelArtifacts)},l.onerror=h=>(o.close(),r(l.error)),a.oncomplete=()=>o.close()}else{t.weightData=vu.join(t.weightData);const a=mv(t),u=o.transaction(ui,"readwrite");let l=u.objectStore(ui),h;try{h=l.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(d){return r(d)}let c;h.onsuccess=()=>{c=o.transaction(Yi,"readwrite");const d=c.objectStore(Yi);let p;try{p=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(f){return r(f)}p.onsuccess=()=>s({modelArtifactsInfo:a}),p.onerror=f=>{l=u.objectStore(ui);const g=l.delete(this.modelPath);g.onsuccess=()=>(o.close(),r(p.error)),g.onerror=m=>(o.close(),r(p.error))}},h.onerror=d=>(o.close(),r(h.error)),u.oncomplete=()=>{c==null?o.close():c.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}ao.URL_SCHEME="indexeddb://";const xv=n=>ne().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ao.URL_SCHEME)?DN(n.slice(ao.URL_SCHEME.length)):null;Nn.registerSaveRouter(xv);Nn.registerLoadRouter(xv);function DN(n){return new ao(n)}function AN(n){return n.startsWith(ao.URL_SCHEME)?n.slice(ao.URL_SCHEME.length):n}class FN{constructor(){this.indexedDB=gv()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(Sm,Im);s.onupgradeneeded=()=>$m(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(ui,"readonly"),a=i.objectStore(ui).getAll();a.onsuccess=()=>{const u={};for(const l of a.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},a.onerror=u=>(r.close(),t(a.error)),i.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=AN(e),new Promise((t,s)=>{const r=this.indexedDB.open(Sm,Im);r.onupgradeneeded=()=>$m(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(ui,"readwrite"),a=o.objectStore(ui),u=a.get(e);let l;u.onsuccess=()=>{if(u.result==null)return i.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const h=a.delete(e),c=()=>{l=i.transaction(Yi,"readwrite");const p=l.objectStore(Yi).delete(e);p.onsuccess=()=>t(u.result.modelArtifactsInfo),p.onerror=f=>s(u.error)};h.onsuccess=c,h.onerror=d=>(c(),i.close(),s(u.error))}},u.onerror=h=>(i.close(),s(u.error)),o.oncomplete=()=>{l==null?i.close():l.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zr="/",ea="tensorflowjs_models",bv="info",PN="model_topology",LN="weight_specs",ON="weight_data",MN="model_metadata";function yv(n){return{info:[ea,n,bv].join(zr),topology:[ea,n,PN].join(zr),weightSpecs:[ea,n,LN].join(zr),weightData:[ea,n,ON].join(zr),modelMetadata:[ea,n,MN].join(zr)}}function wv(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function zN(n){const e=n.split(zr);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(zr)}function BN(n){return n.startsWith(uo.URL_SCHEME)?n.slice(uo.URL_SCHEME.length):n}class uo{constructor(e){if(!ne().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=yv(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=mv(e),i=vu.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,EN(i));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw wv(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=RN(o),t}}uo.URL_SCHEME="localstorage://";const vv=n=>ne().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(uo.URL_SCHEME)?VN(n.slice(uo.URL_SCHEME.length)):null;Nn.registerSaveRouter(vv);Nn.registerLoadRouter(vv);function VN(n){return new uo(n)}class UN{constructor(){L(ne().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),L(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=ea+zr,s=zr+bv;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(t)&&i.endsWith(s)){const o=zN(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=BN(e);const t=yv(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return wv(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gy="://";class ur{constructor(){this.managers={}}static getInstance(){return ur.instance==null&&(ur.instance=new ur),ur.instance}static registerManager(e,t){L(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Gy)&&(e=e.slice(0,e.indexOf(Gy))),L(e.length>0,()=>"scheme must not be an empty string.");const s=ur.getInstance();L(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=ur.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(ur.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GN{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ne().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return jw(e)}}if(ne().get("IS_BROWSER")){ne().setPlatform("browser",new GN);try{ur.registerManager(uo.URL_SCHEME,new UN)}catch{}try{ur.registerManager(ao.URL_SCHEME,new FN)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WN={importFetch:()=>require("node-fetch")};let Mf;class HN{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ne().global.fetch!=null?ne().global.fetch(e,t):(Mf==null&&(Mf=WN.importFetch()),Mf(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ne().get("IS_NODE")&&!ne().get("IS_BROWSER")&&ne().setPlatform("node",new HN);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Je(n,e="float32",t){return e=e||"float32",Qr(n),new vn(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KN(n,e){const t=W(n,"x","cast");if(!VR(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return Y.runKernel(Aa,s,r)}const Ne=J({cast_:KN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jN(n){const t={x:W(n,"x","clone","string_or_numeric")};return Y.runKernel(Ka,t)}const no=J({clone_:jN});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XN(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */av();const qN={buffer:Je,cast:Ne,clone:no,print:XN};gN(qN);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YN(n,e){let t=W(n,"a","add"),s=W(e,"b","add");[t,s]=Xt(t,s);const r={a:t,b:s};return Y.runKernel(Io,r)}const we=J({add_:YN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZN(n,e){let t=W(n,"a","floorDiv"),s=W(e,"b","floorDiv");[t,s]=Xt(t,s);const r={a:t,b:s};return Y.runKernel(Wa,r)}const Cv=J({floorDiv_:ZN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QN(n,e){let t=W(n,"a","div"),s=W(e,"b","div");if([t,s]=Xt(t,s),t.dtype==="int32"&&s.dtype==="int32")return Cv(t,s);const r={a:t,b:s},i={};return Y.runKernel(Ma,r,i)}const We=J({div_:QN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JN(n,e){let t=W(n,"a","mul"),s=W(e,"b","mul");[t,s]=Xt(t,s);const r={a:t,b:s};return Y.runKernel(tu,r)}const q=J({mul_:JN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e_(n){const e=W(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return Y.runKernel(Gl,t)}else{const t={x:e};return Y.runKernel(Ll,t)}}const _n=J({abs_:e_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t_(n){const t={x:W(n,"x","acos")};return Y.runKernel(ka,t)}const n_=J({acos_:t_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s_(n){const t={x:W(n,"x","acosh")};return Y.runKernel(Ta,t)}const r_=J({acosh_:s_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i_(n,e=null,t=!1){const r={x:W(n,"x","all","bool")},i={axis:e,keepDims:t};return Y.runKernel(Ld,r,i)}const Sv=J({all_:i_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o_(n,e=null,t=!1){const r={x:W(n,"x","any","bool")},i={axis:e,keepDims:t};return Y.runKernel(Od,r,i)}const km=J({any_:o_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a_(n,e=0){const s={x:W(n,"x","argMax")},r={axis:e};return Y.runKernel(Ol,s,r)}const xl=J({argMax_:a_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u_(n,e=0){const s={x:W(n,"x","argMin")},r={axis:e};return Y.runKernel(Ml,s,r)}const l_=J({argMin_:u_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c_(n){const t={x:W(n,"x","asin")};return Y.runKernel(Ea,t)}const h_=J({asin_:c_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d_(n){const t={x:W(n,"x","asinh")};return Y.runKernel(Ra,t)}const p_=J({asinh_:d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f_(n){const t={x:W(n,"x","atan")};return Y.runKernel(Na,t)}const m_=J({atan_:f_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g_(n,e){let t=W(n,"a","atan2"),s=W(e,"b","atan2");[t,s]=Xt(t,s);const r={a:t,b:s};return Y.runKernel(Da,r)}const x_=J({atan2_:g_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b_(n){const t={x:W(n,"x","atanh")};return Y.runKernel(_a,t)}const y_=J({atanh_:b_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ki(n,e,t,s,r="NHWC",i){const o=n[3],a=[...e,o],u=hs(r);return Ot(n,a,t,i,s,null,null,u)}function kn(n,e,t,s,r,i,o="channelsLast"){const[a,u]=bl(e);let l;if(o==="channelsLast")l=[a,u,n[3],n[3]];else if(o==="channelsFirst")l=[a,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Ot(n,l,t,s,r,i,!1,o)}function bs(n,e,t,s,r,i,o="NDHWC"){const[a,u,l]=Tm(e);let h,c;if(o==="NDHWC")c="channelsLast",h=[a,u,l,n[4],n[4]];else if(o==="NCDHW")c="channelsFirst",h=[a,u,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return tr(n,h,t,s,r,!1,c,i)}function Ot(n,e,t,s,r,i,o=!1,a="channelsLast"){let[u,l,h,c]=[-1,-1,-1,-1];if(a==="channelsLast")[u,l,h,c]=n;else if(a==="channelsFirst")[u,c,l,h]=n;else throw new Error(`Unknown dataFormat ${a}`);const[d,p,,f]=e,[g,m]=bl(t),[b,x]=bl(s),v=aa(d,b),w=aa(p,x),{padInfo:S,outHeight:k,outWidth:E}=C_(r,l,h,g,m,v,w,i,a),I=o?f*c:f;let C;return a==="channelsFirst"?C=[u,I,k,E]:a==="channelsLast"&&(C=[u,k,E,I]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:h,inChannels:c,outHeight:k,outWidth:E,outChannels:I,padInfo:S,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:x,inShape:n,outShape:C,filterShape:e}}function tr(n,e,t,s,r,i=!1,o="channelsLast",a){let[u,l,h,c,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[u,l,h,c,d]=n;else if(o==="channelsFirst")[u,d,l,h,c]=n;else throw new Error(`Unknown dataFormat ${o}`);const[p,f,g,,m]=e,[b,x,v]=Tm(t),[w,S,k]=Tm(s),E=aa(p,w),I=aa(f,S),C=aa(g,k),{padInfo:T,outDepth:R,outHeight:P,outWidth:D}=S_(r,l,h,c,b,x,v,E,I,C,a),F=i?m*d:m;let z;return o==="channelsFirst"?z=[u,F,R,P,D]:o==="channelsLast"&&(z=[u,R,P,D,F]),{batchSize:u,dataFormat:o,inDepth:l,inHeight:h,inWidth:c,inChannels:d,outDepth:R,outHeight:P,outWidth:D,outChannels:F,padInfo:T,strideDepth:b,strideHeight:x,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:E,effectiveFilterHeight:I,effectiveFilterWidth:C,dilationDepth:w,dilationHeight:S,dilationWidth:k,inShape:n,outShape:z,filterShape:e}}function w_(n,e,t,s,r){s==null&&(s=Xg(n,e,t));const i=n[0],o=n[1],a=yl((i-e+2*s)/t+1,r),u=yl((o-e+2*s)/t+1,r);return[a,u]}function v_(n,e,t,s,r,i){r==null&&(r=Xg(n,e[0],s[0]));const o=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*r>=e[a]&&(o[a]=yl((n[a]-e[a]+2*r)/s[a]+1,i));return o}function Xg(n,e,t,s=1){const r=aa(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function bl(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Tm(n){return typeof n=="number"?[n,n,n]:n}function aa(n,e){return e<=1?n:n+(n-1)*(e-1)}function C_(n,e,t,s,r,i,o,a,u){let l,h,c;if(typeof n=="number"){l={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const p=w_([e,t],i,s,n,a);h=p[0],c=p[1]}else if(n==="same"){h=Math.ceil(e/s),c=Math.ceil(t/r);const d=Math.max(0,(h-1)*s+i-e),p=Math.max(0,(c-1)*r+o-t),f=Math.floor(d/2),g=d-f,m=Math.floor(p/2),b=p-m;l={top:f,bottom:g,left:m,right:b,type:"SAME"}}else if(n==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((e-i+1)/s),c=Math.ceil((t-o+1)/r);else if(typeof n=="object"){const d=u==="channelsLast"?n[1][0]:n[2][0],p=u==="channelsLast"?n[1][1]:n[2][1],f=u==="channelsLast"?n[2][0]:n[3][0],g=u==="channelsLast"?n[2][1]:n[3][1];l={top:d,bottom:p,left:f,right:g,type:d===0&&p===0&&f===0&&g===0?"VALID":"EXPLICIT"},h=yl((e-i+d+p)/s+1,a),c=yl((t-o+f+g)/r+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:l,outHeight:h,outWidth:c}}function S_(n,e,t,s,r,i,o,a,u,l,h){let c,d,p,f;if(n==="valid"&&(n=0),typeof n=="number"){c={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const m=v_([e,t,s,1],[a,u,l],1,[r,i,o],n,h);d=m[0],p=m[1],f=m[2]}else if(n==="same"){d=Math.ceil(e/r),p=Math.ceil(t/i),f=Math.ceil(s/o);const g=(d-1)*r+a-e,m=(p-1)*i+u-t,b=(f-1)*o+l-s,x=Math.floor(g/2),v=g-x,w=Math.floor(m/2),S=m-w,k=Math.floor(b/2),E=b-k;c={top:w,bottom:S,left:k,right:E,front:x,back:v,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outDepth:d,outHeight:p,outWidth:f}}function yl(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function lo(n){const[e,t,s]=bl(n);return e===1&&t===1&&s===1}function gn(n,e){return lo(n)||lo(e)}function co(n){return bl(n).every(e=>e>0)}function hs(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Jn(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")L(da(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{L(da(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I_(n,e){const s={x:W(n,"x","reshape","string_or_numeric")},r={shape:e};return Y.runKernel(Sc,s,r)}const Z=J({reshape_:I_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $_(n,e,t,s,r){const i=W(n,"x","avgPool","float32"),o=1;L(gn(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=i,u=!1;i.rank===3&&(u=!0,a=Z(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Jn("avgPool",s,r);const l={x:a},h={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let c=Y.runKernel(zl,l,h);return c=Ne(c,i.dtype),u?Z(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const qg=J({avgPool_:$_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k_(n,e,t,s,r,i="NDHWC"){const o=W(n,"x","avgPool3d","float32");let a=o,u=!1;o.rank===4&&(u=!0,a=Z(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),L(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),L(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),L(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Jn("avgPool3d",s,r);const l={x:a},h={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i};let c=Y.runKernel(Bl,l,h);return c=Ne(c,a.dtype),u?Z(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}const T_=J({avgPool3d_:k_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E_(n,e=0){L(n.length>=1,()=>"Pass at least one tensor to concat");const t=hv(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return no(t[0]);const s=t,r={axis:e};return Y.runKernel(Wl,s,r)}const Xn=J({concat_:E_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R_(n,e,t=!1,s=!1){let r=W(n,"a","matMul"),i=W(e,"b","matMul");[r,i]=Xt(r,i);const o={a:r,b:i},a={transposeA:t,transposeB:s};return Y.runKernel(Vl,o,a)}const ft=J({matMul_:R_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N_(n){const t={x:W(n,"x","sigmoid","float32")};return Y.runKernel(du,t)}const Cu=J({sigmoid_:N_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function __(n,e,t){const s=W(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:e,size:t};return Y.runKernel(Ec,r,i)}const Rt=J({slice_:__});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D_(n){const t={x:W(n,"x","tanh","float32")};return Y.runKernel(bu,t)}const Cp=J({tanh_:D_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A_(n,e,t){const s=W(n,"x","batchToSpaceND"),r=e.reduce((a,u)=>a*u);L(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),L(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),L(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const i={x:s},o={blockShape:e,crops:t};return Y.runKernel(Ul,i,o)}const Yg=J({batchToSpaceND_:A_});function F_(n){let e;return n.rank===0||n.rank===1?e=Z(n,[1,1,1,n.size]):n.rank===2?e=Z(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=Z(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_(n,e,t,s,r,i){i==null&&(i=.001);const o=W(n,"x","batchNorm"),a=W(e,"mean","batchNorm"),u=W(t,"variance","batchNorm");let l;r!=null&&(l=W(r,"scale","batchNorm"));let h;s!=null&&(h=W(s,"offset","batchNorm")),L(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),L(h==null||a.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),L(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:F_(o),scale:l,offset:h,mean:a,variance:u},p={varianceEpsilon:i},f=Y.runKernel(Jl,d,p);return Z(f,o.shape)}const Sp=J({batchNorm_:P_});function L_(n,e,t,s,r,i){const o=W(n,"x","batchNorm"),a=W(e,"mean","batchNorm"),u=W(t,"variance","batchNorm");let l;r!=null&&(l=W(r,"scale","batchNorm"));let h;return s!=null&&(h=W(s,"offset","batchNorm")),L(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),L(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),L(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&L(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),h!=null&&L(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),Sp(o,a,u,h,l,i)}const O_=J({batchNorm2d_:L_});function M_(n,e,t,s,r,i){const o=W(n,"x","batchNorm"),a=W(e,"mean","batchNorm"),u=W(t,"variance","batchNorm");let l;r!=null&&(l=W(r,"scale","batchNorm"));let h;return s!=null&&(h=W(s,"offset","batchNorm")),L(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),L(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),L(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&L(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),h!=null&&L(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),Sp(o,a,u,h,l,i)}const z_=J({batchNorm3d_:M_});function B_(n,e,t,s,r,i){const o=W(n,"x","batchNorm"),a=W(e,"mean","batchNorm"),u=W(t,"variance","batchNorm");let l;r!=null&&(l=W(r,"scale","batchNorm"));let h;return s!=null&&(h=W(s,"offset","batchNorm")),L(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),L(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),L(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&L(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),h!=null&&L(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),Sp(o,a,u,h,l,i)}const V_=J({batchNorm4d_:B_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U_(n,e,t){const s=W(n,"x","bincount"),r=W(e,"weights","bincount");L(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),L(t>=0,()=>`size must be non-negative, but got ${t}.`),L(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:t};return Y.runKernel(Bd,i,o)}const G_=J({bincount_:U_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W_(n,e){let t=W(n,"broadcastTo","x");const s=t.shape;if(Qr(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=Z(t,l)}const r=t.shape,i=Array.from(e);for(let l=e.length-1;l>=0;l--)if(r[l]===e[l])i[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(i.map((l,h)=>l>1?h:-1).filter(l=>l>=0).length===0)return no(t);const a={x:t},u={reps:i};return Y.runKernel(yu,a,u)}const il=J({broadcastTo_:W_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H_(n){const t={x:W(n,"x","ceil","float32")};return Y.runKernel(Fa,t)}const K_=J({ceil_:H_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ip(n,e,t){Qr(n),t=t||So(e);const s={shape:n,value:e,dtype:t};return Y.runKernel(ep,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j_(n,e,t){const s=W(n,"x","clipByValue");if(L(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Ip(s.shape,e,s.dtype);const r={x:s},i={clipValueMin:e,clipValueMax:t};return Y.runKernel(Pa,r,i)}const xs=J({clipByValue_:j_});function X_(n){return Xn(n,0)}const q_=J({concat1d_:X_});function Y_(n,e){return Xn(n,e)}const Z_=J({concat2d_:Y_});function Q_(n,e){return Xn(n,e)}const J_=J({concat3d_:Q_});function eD(n,e){return Xn(n,e)}const tD=J({concat4d_:eD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nD(n,e,t,s,r="NHWC",i=[1,1],o){const a=W(n,"x","conv2d","float32"),u=W(e,"filter","conv2d","float32");let l=a,h=!1;a.rank===3&&(h=!0,l=Z(a,[1,a.shape[0],a.shape[1],a.shape[2]])),L(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),L(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Jn("conv2d",s,o);const c=r==="NHWC"?l.shape[3]:l.shape[1];L(c===u.shape[2],()=>`Error in conv2d: depth of input (${c}) must match input depth for filter ${u.shape[2]}.`),L(gn(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),L(co(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),L(co(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:l,filter:u},p={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},f=Y.runKernel(Hl,d,p);return h?Z(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const ho=J({conv2d_:nD});function sD(n,e,t,s,r="NWC",i=1,o){const a=W(n,"x","conv1d"),u=W(e,"filter","conv1d");let l=a,h=!1;a.rank===2&&(h=!0,l=Z(a,[1,a.shape[0],a.shape[1]])),L(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),L(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Jn("conv1d",s,o),L(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),L(gn(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),L(co(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),L(co(t),()=>"Error in conv1D: Stride should be larger than 0."),L(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const c=Z(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=Z(l,[l.shape[0],1,l.shape[1],l.shape[2]]),m=ho(d,c,[1,t],s,"NHWC",[1,i],o);return h?Z(m,[m.shape[2],m.shape[3]]):Z(m,[m.shape[0],m.shape[2],m.shape[3]])}const Iv=J({conv1d_:sD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rD(n,e,t,s,r,i="NHWC",o){L(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,u=e,l=!1;e.rank===3&&(l=!0,u=Z(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),L(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),L(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),L(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const h=i==="NHWC"?a[3]:a[1],c=i==="NHWC"?u.shape[3]:u.shape[1];L(h===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${t.shape[2]}.`),L(c===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[3]}.`),Jn("conv2dDerInput",r,o);const d={dy:u,filter:t},p={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:a},f=Y.runKernel(Kl,d,p);return l?Z(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Zg=J({conv2DBackpropInput_:rD});function iD(n,e,t,s,r,i){const o=W(n,"x","conv2dTranspose"),a=W(e,"filter","conv2dTranspose");return Zg(t,o,a,s,r,"NHWC",i)}const $v=J({conv2dTranspose_:iD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oD(n,e,t,s,r="NDHWC",i=[1,1,1]){const o=W(n,"x","conv3d"),a=W(e,"filter","conv3d");let u=o,l=!1;o.rank===4&&(l=!0,u=Z(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),L(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),L(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),L(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),L(gn(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),L(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),L(co(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),L(co(t),()=>"Error in conv3D: Strides should be larger than 0.");const h={x:u,filter:a},c={strides:t,pad:s,dataFormat:r,dilations:i},d=Y.runKernel(jl,h,c);return l?Z(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const aD=J({conv3d_:oD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uD(n,e,t,s,r){L(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,o=e,a=!1;e.rank===4&&(a=!0,o=Z(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const u=i[4],l=o.shape[4];L(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),L(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),L(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),L(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),L(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);const h={dy:o,filter:t},c={pad:r,strides:s,inputShape:i},d=Y.runKernel(Wd,h,c);return a?Z(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const kv=J({conv3DBackpropInput_:uD});function lD(n,e,t,s,r){const i=W(n,"x","conv3dTranspose"),o=W(e,"filter","conv3dTranspose");return kv(t,i,o,s,r)}const cD=J({conv3dTranspose_:lD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hD(n){const t={x:W(n,"x","cos","float32")};return Y.runKernel(La,t)}const Qg=J({cos_:hD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dD(n){const t={x:W(n,"x","cosh","float32")};return Y.runKernel(Oa,t)}const Tv=J({cosh_:dD});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pD(n,e=0,t=!1,s=!1){const i={x:W(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:s};return Y.runKernel(Hd,i,o)}const Em=J({cumprod_:pD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fD(n,e=0,t=!1,s=!1){const i={x:W(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:s};return Y.runKernel(Xl,i,o)}const Ev=J({cumsum_:fD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mD(n,e,t,s=!1){const r=W(n,"x","denseBincount"),i=W(e,"weights","denseBincount");L(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),L(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),L(t>=0,()=>`size must be non-negative, but got ${t}.`),L(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},a={size:t,binaryOutput:s};return Y.runKernel(jd,o,a)}const Wy=J({denseBincount_:mD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gD(n,e,t="NHWC"){const s=W(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],i=t==="NHWC"?s.shape[2]:s.shape[3],o=t==="NHWC"?s.shape[3]:s.shape[1];L(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),L(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),L(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${s.shape}`),L(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${s.shape}`);const a={x:s},u={blockSize:e,dataFormat:t};return Y.runKernel(Xd,a,u)}const xD=J({depthToSpace_:gD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bD(n,e,t,s,r="NHWC",i=[1,1],o){const a=W(n,"x","depthwiseConv2d","float32"),u=W(e,"filter","depthwiseConv2d","float32");let l=a,h=!1;a.rank===3&&(h=!0,l=Z(a,[1,a.shape[0],a.shape[1],a.shape[2]])),L(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),L(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const c=r==="NHWC"?l.shape[3]:l.shape[1];L(c===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${c}) must match the inChannels dimension in filter ${u.shape[2]}.`),Jn("depthwiseConv2d",s,o);const d={x:l,filter:u},p={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},f=Y.runKernel(ql,d,p);return h?Z(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Jg=J({depthwiseConv2d_:bD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yD(n,e,t,s,r=[1,1],i="NHWC"){const o=W(n,"x","dilation2d"),a=W(e,"filter","dilation2d");L(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),L(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),L(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let u=o,l=!1;o.rank===3&&(u=Z(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0),L(u.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${a.shape[2]}`);const h={x:u,filter:a},c={strides:t,pad:s,dilations:r},d=Y.runKernel(Yl,h,c);return l?Z(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const wD=J({dilation2d_:yD});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xi(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const i=t-1-r,o=n[i]||1;(e[e.length-1-r]||1)>1&&o===1&&s.unshift(i)}return s}function cn(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],i=e.length-s-1,o=e[i];(r==null||r===1&&o>1)&&t.unshift(i)}return t}function Ke(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let i=n[n.length-r-1];i==null&&(i=1);let o=e[e.length-r-1];if(o==null&&(o=1),i===1)s[t-r-1]=o;else if(o===1)s[t-r-1]=i;else if(i!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else s[t-r-1]=i}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vD(n,e){let t=W(n,"a","equal","string_or_numeric"),s=W(e,"b","equal","string_or_numeric");[t,s]=Xt(t,s),Ke(t.shape,s.shape);const r={a:t,b:s};return Y.runKernel(Zl,r)}const Ir=J({equal_:vD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CD(n,e,t){const s=W(e,"a","where"),r=W(t,"b","where"),i=W(n,"condition","where","bool"),o=Ke(Ke(i.shape,s.shape),r.shape),a=il(i,o),u=il(s,o),l=il(r,o),h={condition:a,t:u,e:l};return Y.runKernel(Tc,h)}const On=J({where_:CD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SD(n){const t={x:W(n,"x","zerosLike")};return Y.runKernel(Pc,t)}const gt=J({zerosLike_:SD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ID(n,e){let t=W(n,"a","div"),s=W(e,"b","div");[t,s]=Xt(t,s);const r=We(t,s),i=gt(r),o=Ir(s,i);return On(o,i,r)}const $D=J({divNoNan_:ID});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kD(n,e){const t=W(n,"t1","dot"),s=W(e,"t2","dot");L((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],i=s.rank===1?s.size:s.shape[0];if(L(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),t.rank===1&&s.rank===1){const o=Z(t,[1,-1]),a=Z(s,[-1,1]),u=ft(o,a);return Z(u,[])}else if(t.rank===1&&s.rank===2){const o=Z(t,[1,-1]),a=Z(s,[s.shape[0],s.shape[1]]),u=ft(o,a);return Z(u,[u.size])}else if(t.rank===2&&s.rank===1){const o=Z(s,[-1,1]),a=ft(t,o);return Z(a,[a.size])}else{const o=Z(s,[s.shape[0],s.shape[1]]);return ft(t,o)}}const TD=J({dot_:kD});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ED(n,...e){const t=e.map((r,i)=>W(r,`tensors${i}`,"einsum")),s={equation:n};return Y.runKernel(Zd,t,s)}const Bu=J({einsum_:ED});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RD(n){const t={x:W(n,"x","elu","float32")};return Y.runKernel(za,t)}const $p=J({elu_:RD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ND(n){let e=W(n,"x","erf");L(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ne(e,"float32"));const t={x:e};return Y.runKernel(Ba,t)}const Rv=J({erf_:ND});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ex(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function Nv(n,e,t){const s=n.length+e.length,r=[];let i=0,o=0;for(let a=0;a<s;a++)t.indexOf(a)===-1?r.push(n[i++]):r.push(e[o++]);return r}function Yt(n,e){const t=[],s=n.length;for(let i=0;i<s;i++)e.indexOf(i)===-1&&t.push(n[i]);const r=e.map(i=>n[i]);return[t,r]}function qt(n,e){const t=e.map(s=>1);return Nv(n,t,e)}function tn(n,e,t){L(ex(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function kt(n,e){if(ex(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function Nr(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function _t(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _D(n,e=null,t=!1){const r={x:W(n,"x","max")},i={reductionIndices:e,keepDims:t};return Y.runKernel(lc,r,i)}const Hs=J({max_:_D});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DD(n,e=null,t=!1){const r={x:W(n,"x","min")},i={axis:e,keepDims:t};return Y.runKernel(pc,r,i)}const Zh=J({min_:DD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AD(n,e){let t=W(n,"base","pow"),s=W(e,"exp","pow");[t,s]=Xt(t,s);const r={a:t,b:s};return Y.runKernel(nu,r)}const po=J({pow_:AD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wt(n,e){if((Fs(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Fs(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return vp(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FD(n){const t={x:W(n,"x","sqrt","float32")};return Y.runKernel(fu,t)}const $n=J({sqrt_:FD});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PD(n){const e=W(n,"x","square"),t={};return Y.runKernel("Square",{x:e},t)}const Ft=J({square_:PD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LD(n,e=null,t=!1){let s=W(n,"x","sum");s.dtype==="bool"&&(s=Ne(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return Y.runKernel(Rc,r,i)}const Ge=J({sum_:LD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OD(n,e="euclidean",t=null,s=!1){n=W(n,"x","norm");const r=_v(n,e,t);let i=r.shape;if(s){const o=Qe(t,n.shape);i=qt(r.shape,o)}return Z(r,i)}function _v(n,e,t=null){if(n.rank===0)return _n(n);if(n.rank!==1&&t===null)return _v(Z(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Ge(_n(n),t);if(e===1/0)return Hs(_n(n),t);if(e===-1/0)return Zh(_n(n),t);if(e==="euclidean"||e===2)return $n(Ge(po(_n(n),wt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Hs(Ge(_n(n),t[0]),t[1]-1);if(e===1/0)return Hs(Ge(_n(n),t[1]),t[0]);if(e===-1/0)return Zh(Ge(_n(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return $n(Ge(Ft(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const kp=J({norm_:OD});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MD(n,e=null,t=!1){return kp(n,"euclidean",e,t)}const zD=J({euclideanNorm_:MD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BD(n){const t={x:W(n,"x","exp")};return Y.runKernel(Va,t)}const $r=J({exp_:BD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VD(n,e=0){const t=W(n,"x","expandDims","string_or_numeric");L(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return Y.runKernel(Ql,s,r)}const Hn=J({expandDims_:VD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UD(n){const t={x:W(n,"x","expm1")};return Y.runKernel(Ua,t)}const GD=J({expm1_:UD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WD(n,e){const t=W(n,"x","tile","string_or_numeric");L(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return Y.runKernel(yu,s,r)}const Us=J({tile_:WD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HD(n,e,t,s="float32"){e==null&&(e=n);const r=Je([n,e],s),i=n<=e?n:e;for(let a=0;a<i;++a)r.set(1,a,a);const o=Z(r.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return Us(Hn(o,0),[t[0],1,1]);if(t.length===2)return Us(Hn(Hn(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Us(Hn(Hn(Hn(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const tx=J({eye_:HD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KD(n){const t={x:W(n,"x","floor","float32")};return Y.runKernel(Ga,t)}const Tp=J({floor_:KD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jD(n,e,t=0,s=0){const r=W(n,"x","gather"),i=W(e,"indices","gather","int32"),o={x:r,indices:i},a={axis:t,batchDims:s};return Y.runKernel(ec,o,a)}const nx=J({gather_:jD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XD(n,e){let t=W(n,"a","greater","string_or_numeric"),s=W(e,"b","greater","string_or_numeric");[t,s]=Xt(t,s),Ke(t.shape,s.shape);const r={a:t,b:s};return Y.runKernel(tc,r)}const ys=J({greater_:XD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qD(n,e){let t=W(n,"a","greaterEqual","string_or_numeric"),s=W(e,"b","greaterEqual","string_or_numeric");[t,s]=Xt(t,s),Ke(t.shape,s.shape);const r={a:t,b:s};return Y.runKernel(Ha,r)}const To=J({greaterEqual_:qD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YD(n){const t={input:W(n,"input","imag")};return Y.runKernel(sp,t)}const sx=J({imag_:YD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZD(n){const t={x:W(n,"x","isFinite")};return Y.runKernel(ja,t)}const QD=J({isFinite_:ZD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JD(n){const t={x:W(n,"x","isInf")};return Y.runKernel(Xa,t)}const eA=J({isInf_:JD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tA(n){const t={x:W(n,"x","isNaN")};return Y.runKernel(qa,t)}const nA=J({isNaN_:tA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sA(n,e=.2){const s={x:W(n,"x","leakyRelu")},r={alpha:e};return Y.runKernel(nc,s,r)}const rx=J({leakyRelu_:sA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rA(n,e){let t=W(n,"a","less","string_or_numeric"),s=W(e,"b","less","string_or_numeric");[t,s]=Xt(t,s),Ke(t.shape,s.shape);const r={a:t,b:s};return Y.runKernel(sc,r)}const Qh=J({less_:rA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iA(n,e){let t=W(n,"a","lessEqual","string_or_numeric"),s=W(e,"b","lessEqual","string_or_numeric");[t,s]=Xt(t,s),Ke(t.shape,s.shape);const r={a:t,b:s};return Y.runKernel(rc,r)}const Su=J({lessEqual_:iA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oA(n,e=5,t=1,s=1,r=.5){const i=W(n,"x","localResponseNormalization");L(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),L(da(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=Z(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u={x:o},l={depthRadius:e,bias:t,alpha:s,beta:r},h=Y.runKernel(uc,u,l);return a?Z(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const aA=J({localResponseNormalization_:oA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uA(n){const t={x:W(n,"x","log","float32")};return Y.runKernel(Ya,t)}const kr=J({log_:uA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lA(n){const t={x:W(n,"x","log1p")};return Y.runKernel(Za,t)}const Dv=J({log1p_:lA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cA(n,e){L(fm(n),()=>"The f passed in variableGrads(f) must be a function"),L(e==null||Array.isArray(e)&&e.every(l=>l instanceof Yh),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const l in Y.registeredVariables)e.push(Y.registeredVariables[l])}const s=t?e.filter(l=>!l.trainable):null,r=e.length;e=e.filter(l=>l.trainable),L(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:o,grads:a}=Y.gradients(n,e,null,i);L(a.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),L(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const u={};return e.forEach((l,h)=>{a[h]!=null&&(u[l.name]=a[h])}),s!=null&&s.forEach(l=>u[l.name]=null),{value:o,grads:u}}function ga(n){return Y.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hA(n){const t={x:W(n,"x","neg")};return Y.runKernel(mc,t)}const jt=J({neg_:hA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dA(n){const t={x:W(n,"x","softplus")};return Y.runKernel(pu,t)}const Lc=J({softplus_:dA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pA(n){const e=W(n,"x","logSigmoid");return ga(s=>({value:jt(Lc(jt(s))),gradFunc:o=>q(o,Cu(jt(s)))}))(e)}const fA=J({logSigmoid_:pA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mA(n,e){let t=W(n,"a","sub"),s=W(e,"b","sub");[t,s]=Xt(t,s);const r={a:t,b:s};return Y.runKernel(gu,r)}const je=J({sub_:mA});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gA(n,e=-1){const t=W(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return ga((r,i)=>{const a=Hs(r,e,!0),u=je(r,a),l=je(Ne(u,"float32"),kr(Ge($r(u),e,!0)));return i([l]),{value:l,gradFunc:(c,d)=>{const[p]=d,f=!0,g=$r(p);return je(c,q(Ge(c,e,f),g))}}})(t)}const Av=J({logSoftmax_:gA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xA(n,e=null,t=!1){const s=W(n,"x","logSumExp"),r=Qe(e,s.shape),i=Hs(s,r,!0),o=je(s,i),a=$r(o),u=Ge(a,r),l=kr(u),h=we(Z(i,l.shape),l);if(t){const c=qt(h.shape,r);return Z(h,c)}return h}const Fv=J({logSumExp_:xA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bA(n,e){const t=W(n,"a","logicalAnd","bool"),s=W(e,"b","logicalAnd","bool");Ke(t.shape,s.shape);const r={a:t,b:s};return Y.runKernel(ic,r)}const qr=J({logicalAnd_:bA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yA(n){const t={x:W(n,"x","logicalNot","bool")};return Y.runKernel(oc,t)}const ix=J({logicalNot_:yA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wA(n,e){const t=W(n,"a","logicalOr","bool"),s=W(e,"b","logicalOr","bool");Ke(t.shape,s.shape);const r={a:t,b:s};return Y.runKernel(ac,r)}const Pv=J({logicalOr_:wA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vA(n,e){const t=W(n,"a","logicalXor","bool"),s=W(e,"b","logicalXor","bool");return Ke(t.shape,s.shape),qr(Pv(n,e),ix(qr(n,e)))}const CA=J({logicalXor_:vA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SA(n,e,t,s,r){const i=W(n,"x","maxPool"),o=1;let a=i,u=!1;i.rank===3&&(u=!0,a=Z(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),L(gn(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Jn("maxPool",s,r);const l={x:a},h={filterSize:e,strides:t,pad:s,dimRoundingMode:r},c=Y.runKernel(cc,l,h);return u?Z(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const ox=J({maxPool_:SA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IA(n,e=[1,1,1],t,s,r,i="NDHWC"){const o=W(n,"x","maxPool3d");let a=o,u=!1;o.rank===4&&(u=!0,a=Z(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),L(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),L(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Jn("maxPool3d",s,r);const l={x:a},h={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i},c=Y.runKernel(hc,l,h);return u?Z(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}const $A=J({maxPool3d_:IA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kA(n,e){let t=W(n,"a","maximum"),s=W(e,"b","maximum");[t,s]=Xt(t,s),t.dtype==="bool"&&(t=Ne(t,"int32"),s=Ne(s,"int32")),Ke(t.shape,s.shape);const r={a:t,b:s};return Y.runKernel(Qa,r)}const Ti=J({maximum_:kA});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TA(n,e=null,t=!1){const r={x:W(n,"x","mean")},i={axis:e,keepDims:t};return Y.runKernel(dc,r,i)}const Jt=J({mean_:TA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rn(n,e="float32"){if(Qr(n),e==="complex64"){const s=rn(n,"float32"),r=rn(n,"float32");return ma(s,r)}const t=Cn(Q(n),e);return Y.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ei(n,e="float32"){if(Qr(n),e==="complex64"){const s=Ei(n,"float32"),r=rn(n,"float32");return ma(s,r)}const t=Sg(Q(n),e);return Y.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EA(n,e){let t=W(n,"a","minimum"),s=W(e,"b","minimum");[t,s]=Xt(t,s),t.dtype==="bool"&&(t=Ne(t,"int32"),s=Ne(s,"int32")),Ke(t.shape,s.shape);const r={a:t,b:s};return Y.runKernel(Ja,r)}const wl=J({minimum_:EA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RA(n,e,t){L(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=W(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");L(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let a=0;a<s.rank;a++)L(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),L(e[a][0]>=0&&e[a][0]<=s.shape[a]-r&&e[a][1]>=0&&e[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:e,mode:t},o={x:s};return Y.runKernel(fc,o,i)}const NA=J({mirrorPad_:RA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _A(n,e){let t=W(n,"a","mod"),s=W(e,"b","mod");[t,s]=Xt(t,s);const r={a:t,b:s};return Y.runKernel(eu,r)}const DA=J({mod_:_A});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AA(n,e=null,t=!1){n=W(n,"x","moments");const s=Qe(e,n.shape),r=Jt(n,s,t);let i=r.shape;t||(i=qt(r.shape,s));const o=Ft(je(Ne(n,"float32"),Z(r,i))),a=Jt(o,s,t);return{mean:r,variance:a}}const ax=J({moments_:AA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FA(n,e){let t=W(n,"a","notEqual","string_or_numeric"),s=W(e,"b","notEqual","string_or_numeric");[t,s]=Xt(t,s),Ke(t.shape,s.shape);const r={a:t,b:s};return Y.runKernel(gc,r)}const Jh=J({notEqual_:FA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PA(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:W(n,"indices","oneHot","int32")},a={dtype:r,depth:e,onValue:t,offValue:s};return Y.runKernel(bc,o,a)}const Lv=J({oneHot_:PA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LA(n){const t={x:W(n,"x","onesLike")};return Y.runKernel(xc,t)}const Ps=J({onesLike_:LA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OA(n,e,t=0){const s=W(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},i={x:s};return Y.runKernel(wc,i,r)}const ux=J({pad_:OA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MA(n,e,t){const s=W(n,"x","spaceToBatchND");L(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),L(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),L(s.shape.reduce((o,a,u)=>u>0&&u<=e.length?o&&(a+t[u-1][0]+t[u-1][1])%e[u-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},i={blockShape:e,paddings:t};return Y.runKernel(Nc,r,i)}const lx=J({spaceToBatchND_:MA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zA(n,e,t,s,r,i,o){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const a=W(n,"x","maxPool");let u=a,l=!1;a.rank===3&&(l=!0,u=Z(a,[1,a.shape[0],a.shape[1],a.shape[2]])),L(gn(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const h=kn(u.shape,e,i,r,s),c=[h.dilationHeight,h.dilationWidth];let d;s==="same"?d=VA([h.filterHeight,h.filterWidth],c):d=[[0,0],[0,0]];const p=c[0]===1&&c[1]===1,[f,g]=BA([h.inHeight,h.inWidth],c,d),m=p?s:"valid",b=p?u:lx(u,c,f),v=(t==="avg"?()=>qg(b,e,i,m,o):()=>ox(b,e,i,m,o))(),w=p?v:Yg(v,c,g);return l?Z(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function BA(n,e,t){const s=t.map(h=>h[0]),r=t.map(h=>h[1]),i=n.concat(s,r),o=e.map((h,c)=>(h-i[c]%h)%h),a=r.map((h,c)=>h+o[c]),u=e.map((h,c)=>[s[c],a[c]]),l=e.map((h,c)=>[0,o[c]]);return[u,l]}function VA(n,e){const s=n.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),i=s.map((o,a)=>o-r[a]);return s.map((o,a)=>[r[a],i[a]])}const UA=J({pool_:zA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GA(n,e){const t=W(n,"x","prelu"),s=W(e,"alpha","prelu"),r={x:t,alpha:s};return Y.runKernel(vc,r)}const cx=J({prelu_:GA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WA(n,e=null,t=!1){let s=W(n,"x","prod");s.dtype==="bool"&&(s=Ne(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return Y.runKernel(Cc,r,i)}const HA=J({prod_:WA});var hx={exports:{}};hx.exports;(function(n){(function(e,t,s){function r(u){var l=this,h=a();l.next=function(){var c=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=c-(l.c=c|0)},l.c=1,l.s0=h(" "),l.s1=h(" "),l.s2=h(" "),l.s0-=h(u),l.s0<0&&(l.s0+=1),l.s1-=h(u),l.s1<0&&(l.s1+=1),l.s2-=h(u),l.s2<0&&(l.s2+=1),h=null}function i(u,l){return l.c=u.c,l.s0=u.s0,l.s1=u.s1,l.s2=u.s2,l}function o(u,l){var h=new r(u),c=l&&l.state,d=h.next;return d.int32=function(){return h.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,c&&(typeof c=="object"&&i(c,h),d.state=function(){return i(h,{})}),d}function a(){var u=4022871197,l=function(h){h=String(h);for(var c=0;c<h.length;c++){u+=h.charCodeAt(c);var d=.02519603282416938*u;u=d>>>0,d-=u,d*=u,u=d>>>0,d-=u,u+=d*4294967296}return(u>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=o:this.alea=o})(Co,n)})(hx);var KA=hx.exports,dx={exports:{}};dx.exports;(function(n){(function(e,t,s){function r(a){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var c=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^c^c>>>8},a===(a|0)?u.x=a:l+=a;for(var h=0;h<l.length+64;h++)u.x^=l.charCodeAt(h)|0,u.next()}function i(a,u){return u.x=a.x,u.y=a.y,u.z=a.z,u.w=a.w,u}function o(a,u){var l=new r(a),h=u&&u.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var d=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,h&&(typeof h=="object"&&i(h,l),c.state=function(){return i(l,{})}),c}t&&t.exports?t.exports=o:this.xor128=o})(Co,n)})(dx);var jA=dx.exports,px={exports:{}};px.exports;(function(n){(function(e,t,s){function r(a){var u=this,l="";u.next=function(){var c=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(c^c<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,a===(a|0)?u.x=a:l+=a;for(var h=0;h<l.length+64;h++)u.x^=l.charCodeAt(h)|0,h==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function i(a,u){return u.x=a.x,u.y=a.y,u.z=a.z,u.w=a.w,u.v=a.v,u.d=a.d,u}function o(a,u){var l=new r(a),h=u&&u.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var d=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,h&&(typeof h=="object"&&i(h,l),c.state=function(){return i(l,{})}),c}t&&t.exports?t.exports=o:this.xorwow=o})(Co,n)})(px);var XA=px.exports,fx={exports:{}};fx.exports;(function(n){(function(e,t,s){function r(a){var u=this;u.next=function(){var h=u.x,c=u.i,d,p;return d=h[c],d^=d>>>7,p=d^d<<24,d=h[c+1&7],p^=d^d>>>10,d=h[c+3&7],p^=d^d>>>3,d=h[c+4&7],p^=d^d<<7,d=h[c+7&7],d=d^d<<13,p^=d^d<<9,h[c]=p,u.i=c+1&7,p};function l(h,c){var d,p=[];if(c===(c|0))p[0]=c;else for(c=""+c,d=0;d<c.length;++d)p[d&7]=p[d&7]<<15^c.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8?p[7]=-1:p[d],h.x=p,h.i=0,d=256;d>0;--d)h.next()}l(u,a)}function i(a,u){return u.x=a.x.slice(),u.i=a.i,u}function o(a,u){a==null&&(a=+new Date);var l=new r(a),h=u&&u.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var d=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,h&&(h.x&&i(h,l),c.state=function(){return i(l,{})}),c}t&&t.exports?t.exports=o:this.xorshift7=o})(Co,n)})(fx);var qA=fx.exports,mx={exports:{}};mx.exports;(function(n){(function(e,t,s){function r(a){var u=this;u.next=function(){var h=u.w,c=u.X,d=u.i,p,f;return u.w=h=h+1640531527|0,f=c[d+34&127],p=c[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=c[d]=f^p,u.i=d,f+(h^h>>>16)|0};function l(h,c){var d,p,f,g,m,b=[],x=128;for(c===(c|0)?(p=c,c=null):(c=c+"\0",p=0,x=Math.max(x,c.length)),f=0,g=-32;g<x;++g)c&&(p^=c.charCodeAt((g+32)%c.length)),g===0&&(m=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,g>=0&&(m=m+1640531527|0,d=b[g&127]^=p+m,f=d==0?f+1:0);for(f>=128&&(b[(c&&c.length||0)&127]=-1),f=127,g=4*128;g>0;--g)p=b[f+34&127],d=b[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,b[f]=p^d;h.w=m,h.X=b,h.i=f}l(u,a)}function i(a,u){return u.i=a.i,u.w=a.w,u.X=a.X.slice(),u}function o(a,u){a==null&&(a=+new Date);var l=new r(a),h=u&&u.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var d=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,h&&(h.X&&i(h,l),c.state=function(){return i(l,{})}),c}t&&t.exports?t.exports=o:this.xor4096=o})(Co,n)})(mx);var YA=mx.exports,gx={exports:{}};gx.exports;(function(n){(function(e,t,s){function r(a){var u=this,l="";u.next=function(){var c=u.b,d=u.c,p=u.d,f=u.a;return c=c<<25^c>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-c|0,u.b=c=c<<20^c>>>12^d,u.c=d=d-p|0,u.d=p<<16^d>>>16^f,u.a=f-c|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,a===Math.floor(a)?(u.a=a/4294967296|0,u.b=a|0):l+=a;for(var h=0;h<l.length+20;h++)u.b^=l.charCodeAt(h)|0,u.next()}function i(a,u){return u.a=a.a,u.b=a.b,u.c=a.c,u.d=a.d,u}function o(a,u){var l=new r(a),h=u&&u.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var d=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,h&&(typeof h=="object"&&i(h,l),c.state=function(){return i(l,{})}),c}t&&t.exports?t.exports=o:this.tychei=o})(Co,n)})(gx);var ZA=gx.exports,Ov={exports:{}};const QA={},JA=Object.freeze(Object.defineProperty({__proto__:null,default:QA},Symbol.toStringTag,{value:"Module"})),e3=NR(JA);(function(n){(function(e,t,s){var r=256,i=6,o=52,a="random",u=s.pow(r,i),l=s.pow(2,o),h=l*2,c=r-1,d;function p(w,S,k){var E=[];S=S==!0?{entropy:!0}:S||{};var I=b(m(S.entropy?[w,v(t)]:w??x(),3),E),C=new f(E),T=function(){for(var R=C.g(i),P=u,D=0;R<l;)R=(R+D)*r,P*=r,D=C.g(1);for(;R>=h;)R/=2,P/=2,D>>>=1;return(R+D)/P};return T.int32=function(){return C.g(4)|0},T.quick=function(){return C.g(4)/4294967296},T.double=T,b(v(C.S),t),(S.pass||k||function(R,P,D,F){return F&&(F.S&&g(F,C),R.state=function(){return g(C,{})}),D?(s[a]=R,P):R})(T,I,"global"in S?S.global:this==s,S.state)}function f(w){var S,k=w.length,E=this,I=0,C=E.i=E.j=0,T=E.S=[];for(k||(w=[k++]);I<r;)T[I]=I++;for(I=0;I<r;I++)T[I]=T[C=c&C+w[I%k]+(S=T[I])],T[C]=S;(E.g=function(R){for(var P,D=0,F=E.i,z=E.j,_=E.S;R--;)P=_[F=c&F+1],D=D*r+_[c&(_[F]=_[z=c&z+P])+(_[z]=P)];return E.i=F,E.j=z,D})(r)}function g(w,S){return S.i=w.i,S.j=w.j,S.S=w.S.slice(),S}function m(w,S){var k=[],E=typeof w,I;if(S&&E=="object")for(I in w)try{k.push(m(w[I],S-1))}catch{}return k.length?k:E=="string"?w:w+"\0"}function b(w,S){for(var k=w+"",E,I=0;I<k.length;)S[c&I]=c&(E^=S[c&I]*19)+k.charCodeAt(I++);return v(S)}function x(){try{var w;return d&&(w=d.randomBytes)?w=w(r):(w=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(w)),v(w)}catch{var S=e.navigator,k=S&&S.plugins;return[+new Date,e,k,e.screen,v(t)]}}function v(w){return String.fromCharCode.apply(0,w)}if(b(s.random(),t),n.exports){n.exports=p;try{d=e3}catch{}}else s["seed"+a]=p})(typeof self<"u"?self:Co,[],Math)})(Ov);var t3=Ov.exports,n3=KA,s3=jA,r3=XA,i3=qA,o3=YA,a3=ZA,Eo=t3;Eo.alea=n3;Eo.xor128=s3;Eo.xorwow=r3;Eo.xorshift7=i3;Eo.xor4096=o3;Eo.tychei=a3;var xx=Eo;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mv{constructor(e,t,s,r,i){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=xx.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class u3{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=xx.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l3(n,e=0,t=1,s,r){if(Qr(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new Mv(e,t,s,!1,r),o=Je(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const c3=J({randomNormal_:l3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h3(n,e=0,t=1,s="float32",r){Qr(n);const i=Je(n,s),o=new u3(e,t,null,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Oc=J({randomUniform_:h3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vl(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return Y.runKernel(lp,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d3(n){const t={input:W(n,"input","real")};return Y.runKernel(cp,t)}const ed=J({real_:d3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p3(n){const t={x:W(n,"x","reciprocal")};return Y.runKernel(su,t)}const f3=J({reciprocal_:p3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m3(n){const t={x:W(n,"x","relu")};return Y.runKernel(ru,t)}const Ro=J({relu_:m3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g3(n){const t={x:W(n,"x","relu6")};return Y.runKernel(iu,t)}const zv=J({relu6_:g3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x3(n,e){const s={x:W(n,"x","reverse")},r={dims:e};return Y.runKernel(kc,s,r)}const fo=J({reverse_:x3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b3(n){const t={x:W(n,"x","round")};return Y.runKernel(ou,t)}const Bv=J({round_:b3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y3(n){const t={x:W(n,"x","rsqrt","float32")};return Y.runKernel(au,t)}const Vv=J({rsqrt_:y3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w3(n){const t={x:W(n,"x","selu")};return Y.runKernel(uu,t)}const Uv=J({selu_:w3});function v3(n,e,t,s,r,i=[1,1],o="NHWC"){const a=W(n,"x","separableConv2d"),u=W(e,"depthwiseFilter","separableConv2d"),l=W(t,"pointwiseFilter","separableConv2d");let h=a,c=!1;if(a.rank===3&&(c=!0,h=Z(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");L(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),L(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),L(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),L(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),L(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const d=u.shape[2],p=u.shape[3];L(l.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${l.shape[2]}.`);const f=Jg(h,u,s,r,o,i),m=ho(f,l,1,"valid",o);return c?Z(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const Gv=J({separableConv2d_:v3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C3(n){const t={x:W(n,"x","sign")};return Y.runKernel(hu,t)}const S3=J({sign_:C3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3(n){const t={x:W(n,"x","sin","float32")};return Y.runKernel(lu,t)}const Wv=J({sin_:I3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $3(n){const t={x:W(n,"x","sinh")};return Y.runKernel(cu,t)}const Hv=J({sinh_:$3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k3(n,e,t){const s=W(n,"x","slice1d");return L(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Rt(s,[e],[t])}const bx=J({slice1d_:k3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T3(n,e,t){const s=W(n,"x","slice2d");return L(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Rt(s,e,t)}const Kv=J({slice2d_:T3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E3(n,e,t){const s=W(n,"x","slice3d");return L(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Rt(s,e,t)}const yx=J({slice3d_:E3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R3(n,e,t){const s=W(n,"x","slice4d");return L(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Rt(s,e,t)}const td=J({slice4d_:R3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N3(n,e=-1){const t=W(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return Y.runKernel(Dc,s,r)}const wx=J({softmax_:N3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _3(n){L(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Y.runKernel(Jd,e)}const jv=J({fft_:_3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D3(n){L(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Y.runKernel(np,e)}const Rm=J({ifft_:D3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A3(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=Z(n,[t,e]);s=Rm(r)}else{const r=[t,2*(e-1)],i=Z(ed(n),[t,e]),o=Z(sx(n),[t,e]),a=fo(Rt(i,[0,1],[t,e-2]),1),u=q(fo(Rt(o,[0,1],[t,e-2]),1),wt(-1)),l=Xn([i,a],1),h=Xn([o,u],1),c=Z(ma(l,h),[r[0],r[1]]);s=Rm(c)}if(s=ed(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=Z(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const F3=J({irfft_:A3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P3(n,e,t=0){const r={x:W(n,"x","split")},i={numOrSizeSplits:e,axis:t};return Y.runKernel(_c,r,i)}const gs=J({split_:P3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L3(n,e){L(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const f=n.shape.map(m=>0),g=n.shape.map(m=>m);g[n.shape.length-1]=e,r=Rt(n,f,g),t=e}else if(e!=null&&e>t){const f=n.shape.map(g=>g);f[n.shape.length-1]=e-t,r=Xn([n,rn(f)],n.shape.length-1),t=e}else r=n;const i=gt(r),o=Z(ma(r,i),[s,t]),a=jv(o),u=Math.floor(t/2)+1,l=ed(a),h=sx(a),c=gs(l,[u,t-u],l.shape.length-1),d=gs(h,[u,t-u],h.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=u,Z(ma(c[0],d[0]),p)}const O3=J({rfft_:L3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M3(n,e){let t=W(n,"a","squaredDifference"),s=W(e,"b","squaredDifference");[t,s]=Xt(t,s),Ke(t.shape,s.shape);const r={a:t,b:s},i={};return Y.runKernel(mu,r,i)}const z3=J({squaredDifference_:M3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B3(n,e){const t=W(n,"x","squeeze","string_or_numeric");return Z(t,Ii(t.shape,e).newShape)}const Mc=J({squeeze_:B3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V3(n,e=0){const t=hv(n,"tensors","stack","string_or_numeric");L(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&L(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return Y.runKernel(yc,s,r)}const Yr=J({stack_:V3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U3(n,e=0){const s={x:W(n,"x","step")},r={alpha:e};return Y.runKernel(wu,s,r)}const zc=J({step_:U3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G3(n,e,t,s,r=0,i=0,o=0,a=0,u=0){const h={x:W(n,"x","stridedSlice","string_or_numeric")},c={begin:e,end:t,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:u};return Y.runKernel(fp,h,c)}const W3=J({stridedSlice_:G3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H3(n){const t={x:W(n,"x","tan","float32")};return Y.runKernel(xu,t)}const K3=J({tan_:H3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function os(n,e){Dw(n);const t=wp(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return vp(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ol(n,e,t){if(Dw(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=wp(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return vp(n,e,s,t)}function Xv(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(i+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let o=0;o<r;++o)if(t.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-r;++o)if(t.shape[o+r]!==n[o+s])throw new Error(i+` updates.shape[${o+r}] (${t.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function j3(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Xv(t,e,n)}function _r(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=t.length;let o=1;for(let c=r;c<i;++c)o*=t[c];const a=r<1?1:r,u=Q(e.shape)/a,l=[...Be(t.slice(0,r)),1],h=Q(t);return{sliceRank:r,numUpdates:u,sliceSize:o,strides:l,outputSize:h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X3(n,e=1,t=!0){const s=W(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},o={k:e,sorted:t},[a,u]=Y.runKernel(mp,i,o);return{values:a,indices:u}}const q3=J({topk_:X3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y3(n,e=0,t=1,s,r){if(Qr(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new Mv(e,t,s,!0,r),o=Je(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const qv=J({truncatedNormal_:Y3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3(n,e=0){const t=W(n,"x","unique","string_or_numeric");L(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[i,o]=Y.runKernel(Ug,s,r);return{values:i,indices:o}}const Q3=J({unique_:Z3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J3(n,e,t){const s=W(n,"x","unsortedSegmentSum"),r=W(e,"segmentIds","unsortedSegmentSum","int32");L(da(t),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},o={numSegments:t};return Y.runKernel(Fc,i,o)}const Yv=J({unsortedSegmentSum_:J3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eF(n,e=0){const t=W(n,"x","unstack","string_or_numeric");L(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return Y.runKernel(Ac,s,r)}const mo=J({unstack_:eF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tF(n,e=!0,t,s){return Y.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zv(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const s=Je(n,"int32"),r=Je([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const o=s.indexToLoc(t[i]),a=i*n.length;r.values.set(o,a)}return r.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nF(n,e,t){const s=W(n,"x","transpose");if(e==null&&(e=s.shape.map((o,a)=>a).reverse()),L(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(o=>{L(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:e};return s.dtype==="complex64"?se(()=>{let o=ed(s),a=sx(s);return o=Y.runKernel(to,{x:o},i),a=Y.runKernel(to,{x:a},i),t&&(a=jt(a)),ma(o,a)}):Y.runKernel(to,r,i)}const mt=J({transpose_:nF});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sF(n,e){if(e==null)return n.shape.slice();if(ct(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rF(n,e,t,s){const r=W(n,"x","dropout");if(L(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),L(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof sn?r.clone():r;const i=sF(r,t),o=1-e,a=We(Tp(we(Oc(i,0,1,"float32",s),o)),o);return q(r,a)}const iF=J({dropout_:rF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oF(n,e,t,s,r,i="NHWC",o){let a=n;n.rank===3&&(a=Z(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=Z(e,[1,e.shape[0],e.shape[1],e.shape[2]])),L(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),L(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),L(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const l=i==="NHWC"?a.shape[3]:a.shape[1],h=i==="NHWC"?u.shape[3]:u.shape[1];L(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),L(h===t[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${t[3]}).`),Jn("conv2dDerFilter",r,o);const c={x:a,dy:u},d={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:t};return Y.runKernel(Ud,c,d)}const vx=J({conv2DBackpropFilter_:oF});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cx(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return q(n,zc(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Sx(n,e){let t=e;const s=cn(n.shape,e.shape);return s.length>0&&(t=Ge(t,s)),Z(t,n.shape)}function Ix(n,e,t,s){if(e==="linear")return n;if(e==="relu")return Ro(n);if(e==="elu")return $p(n);if(e==="relu6")return zv(n);if(e==="prelu")return cx(n,t);if(e==="leakyrelu")return rx(n,s);if(e==="sigmoid")return Cu(n);throw new Error(`Unknown fused activation ${e}.`)}const $x=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aF({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:h}){if(u=u||"linear",$x(Y.state.gradientDepth,u)===!1){L(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=ho(n,e,t,s,r,i,o);return a!=null&&(k=we(k,a)),Ix(k,u,l,h)}const c=W(n,"x","conv2d","float32"),d=W(e,"filter","conv2d","float32");let p=c,f=!1;c.rank===3&&(f=!0,p=Z(c,[1,c.shape[0],c.shape[1],c.shape[2]])),L(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),L(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Jn("fused conv2d",s,o);const g=r==="NHWC"?p.shape[3]:p.shape[1];L(d.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`),L(gn(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const m=Ot(p.shape,d.shape,t,i,s,o);let b;a!=null&&(b=W(a,"bias","fused conv2d"),[b]=Xt(b,c),r==="NHWC"?Ke(m.outShape,b.shape):(L(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),L(b.shape.length===0||b.shape[0]===m.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let x;if(l!=null){const k=l.shape;if(L(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)L(k[0]===1||k[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${m.outChannels}).`);else if(k.length===3)try{Ke(k,m.outShape)}catch{const I=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(I)}x=W(l,"prelu weights","fused conv2d")}const v=(k,E)=>{L(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[I,C,T,R]=E,P=Cx(k,T,u);L(lo(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const D=Zg(C.shape,P,I,t,s),F=vx(C,P,I.shape,t,s),z=[D,F];if(R!=null){const _=Sx(R,P);z.push(_)}return z},w={x:p,filter:d,bias:b,preluActivationWeights:x},S={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:h};return a==null?ga((E,I,C)=>{let T=Y.runKernel(gl,w,S);return C([I,E,T]),f&&(T=Z(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:v}})(p,d):ga((E,I,C,T)=>{let R=Y.runKernel(gl,w,S);return T([I,E,R,C]),f&&(R=Z(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:v}})(p,d,b)}const uF=J({fusedConv2d_:aF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lF(n,e,t,s,r,i=[1,1],o){let a=n;n.rank===3&&(a=Z(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=Z(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:a,dy:u},h={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:t};return Y.runKernel(qd,l,h)}const cF=J({depthwiseConv2dNativeBackpropFilter_:lF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hF(n,e,t,s,r,i=[1,1],o){let a=e,u=!1;e.rank===3&&(u=!0,a=Z(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:a,filter:t},h={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:n},c=Y.runKernel(Yd,l,h);return u?Z(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const dF=J({depthwiseConv2dNativeBackpropInput_:hF});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pF({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if($x(Y.state.gradientDepth,i)===!1){let R=ft(n,e,t,s);return r!=null&&(R=we(R,r)),Ix(R,i,o,a)}let u=W(n,"a","fused matMul"),l=W(e,"b","fused matMul");[u,l]=Xt(u,l);const h=t?u.shape[u.rank-2]:u.shape[u.rank-1],c=s?l.shape[l.rank-1]:l.shape[l.rank-2],d=t?u.shape[u.rank-1]:u.shape[u.rank-2],p=s?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),g=l.shape.slice(0,-2),m=Q(f),b=Q(g);L(h===c,()=>`Error in fused matMul: inner shapes (${h}) and (${c}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${t} and transposeB=${s} must match.`);const v=Ke(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([d,p]),w=t?Z(u,[m,h,d]):Z(u,[m,d,h]),S=s?Z(l,[b,p,c]):Z(l,[b,c,p]);let k;r!=null&&(k=W(r,"bias","fused matMul"),[k]=Xt(k,u),Ke(v,k.shape));let E;o!=null&&(E=W(o,"prelu weights","fused matMul"));const I=(R,P)=>{const[D,F,z,_]=P,B=Cx(Z(R,z.shape),z,i);let N,O;if(!t&&!s?(N=ft(B,F,!1,!0),O=ft(D,B,!0,!1)):!t&&s?(N=ft(B,F,!1,!1),O=ft(B,D,!0,!1)):t&&!s?(N=ft(F,B,!1,!0),O=ft(D,B,!1,!1)):(N=ft(F,B,!0,!0),O=ft(B,D,!0,!0)),r!=null){const K=Sx(_,B);return[N,O,K]}else return[N,O]},C={a:w,b:S,bias:k,preluActivationWeights:E},T={transposeA:t,transposeB:s,activation:i,leakyreluAlpha:a};return r==null?ga((P,D,F)=>{const z=Y.runKernel(ml,C,T);return F([P,D,z]),{value:Z(z,v),gradFunc:I}})(w,S):ga((P,D,F,z)=>{const _=Y.runKernel(ml,C,T);return z([P,D,_,F]),{value:Z(_,v),gradFunc:I}})(w,S,k)}const Hy=J({fusedMatMul_:pF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fF(n,e,t,s,r="bilinear",i=0){const o=W(n,"image","cropAndResize"),a=W(e,"boxes","cropAndResize","float32"),u=W(t,"boxInd","cropAndResize","int32"),l=a.shape[0];L(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),L(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),L(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),L(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),L(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),L(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const h={image:o,boxes:a,boxInd:u},c={method:r,extrapolationValue:i,cropSize:s};return Y.runKernel(Kd,h,c)}const mF=J({cropAndResize_:fF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gF(n){const e=W(n,"image","flipLeftRight","float32");L(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return Y.runKernel(tp,t,{})}const xF=J({flipLeftRight_:gF});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bF(n){const e=W(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];L(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),L(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,Us(e,r)}const yF=J({grayscaleToRGB_:bF});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wF(n){const e=W(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];L(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),L(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,i=Ne(e,"float32"),o=os([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Bu("ij,j->i",i,o);break;case 3:a=Bu("ijk,k->ij",i,o);break;case 4:a=Bu("ijkl,l->ijk",i,o);break;case 5:a=Bu("ijklm,m->ijkl",i,o);break;case 6:a=Bu("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=Hn(a,-1),Ne(a,r)}const vF=J({rgbToGrayscale_:wF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CF(n,e,t=0,s=.5){const r=W(n,"image","rotateWithOffset","float32");L(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:e,fillValue:t,center:s};return Y.runKernel(xp,i,o)}const SF=J({rotateWithOffset_:CF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iu(n,e,t,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return t=Math.min(t,o),L(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),L(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),L(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),L(e.rank===1,()=>"scores must be a 1D tensor"),L(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),L(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IF(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=W(n,"boxes","nonMaxSuppression","float32"),o=W(e,"scores","nonMaxSuppression","float32"),a=Iu(i,o,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const u={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return Y.runKernel(ap,{boxes:i,scores:o},u)}const $F=J({nonMaxSuppression_:IF});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kF(n,e,t){const s=TF(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function TF(n,e,t){return RF(n,e,t||EF)}function EF(n,e){return n>e?1:n<e?-1:0}function RF(n,e,t){let s=0,r=n.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const a=t(e,n[i]);a>0?s=i+1:(r=i,o=!a)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ep(n,e,t,s,r){return Tx(n,e,t,s,r,0)}function kx(n,e,t,s,r,i){return Tx(n,e,t,s,r,0,!1,i,!0)}function Rp(n,e,t,s,r,i){return Tx(n,e,t,s,r,i,!0)}function Tx(n,e,t,s,r,i,o=!1,a=!1,u=!1){const l=[];for(let m=0;m<e.length;m++)e[m]>r&&l.push({score:e[m],boxIndex:m,suppressBeginIndex:0});l.sort(Ky);const h=i>0?-.5/i:0,c=[],d=[];for(;c.length<t&&l.length>0;){const m=l.pop(),{score:b,boxIndex:x,suppressBeginIndex:v}=m;if(b<r)break;let w=!1;for(let S=c.length-1;S>=v;--S){const k=NF(n,x,c[S]);if(k>=s){w=!0;break}if(m.score=m.score*_F(s,h,k),m.score<=r)break}m.suppressBeginIndex=c.length,w||(m.score===b?(c.push(x),d.push(m.score)):m.score>r&&kF(l,m,Ky))}const p=c.length,f=t-p;a&&f>0&&(c.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:c};return o&&(g.selectedScores=d),u&&(g.validOutputs=p),g}function NF(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),l=Math.min(r[0],r[2]),h=Math.min(r[1],r[3]),c=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(a-i)*(u-o),f=(c-l)*(d-h);if(p<=0||f<=0)return 0;const g=Math.max(i,l),m=Math.max(o,h),b=Math.min(a,c),x=Math.min(u,d),v=Math.max(b-g,0)*Math.max(x-m,0);return v/(p+f-v)}function _F(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function Ky(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function DF(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=W(n,"boxes","nonMaxSuppressionAsync"),o=W(e,"scores","nonMaxSuppressionAsync"),a=Iu(i,o,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const u=await Promise.all([i.data(),o.data()]),l=u[0],h=u[1],{selectedIndices:c}=Ep(l,h,t,s,r);return i!==n&&i.dispose(),o!==e&&o.dispose(),os(c,"int32")}const AF=DF;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FF(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=W(n,"boxes","nonMaxSuppression"),a=W(e,"scores","nonMaxSuppression"),u=Iu(o,a,t,s,r,i);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,i=u.softNmsSigma;const l={boxes:o,scores:a},h={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},c=Y.runKernel(up,l,h);return{selectedIndices:c[0],selectedScores:c[1]}}const PF=J({nonMaxSuppressionWithScore_:FF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function LF(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=W(n,"boxes","nonMaxSuppressionAsync"),a=W(e,"scores","nonMaxSuppressionAsync"),u=Iu(o,a,t,s,r,i);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,i=u.softNmsSigma;const l=await Promise.all([o.data(),a.data()]),h=l[0],c=l[1],{selectedIndices:d,selectedScores:p}=Rp(h,c,t,s,r,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:os(d,"int32"),selectedScores:os(p)}}const OF=LF;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MF(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=W(n,"boxes","nonMaxSuppression"),a=W(e,"scores","nonMaxSuppression"),u=Iu(o,a,t,s,r,null),l=u.maxOutputSize,h=u.iouThreshold,c=u.scoreThreshold,d={boxes:o,scores:a},p={maxOutputSize:l,iouThreshold:h,scoreThreshold:c,padToMaxOutputSize:i},f=Y.runKernel(Ag,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const zF=J({nonMaxSuppressionPadded_:MF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function BF(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=W(n,"boxes","nonMaxSuppressionAsync"),a=W(e,"scores","nonMaxSuppressionAsync"),u=Iu(o,a,t,s,r,null),l=u.maxOutputSize,h=u.iouThreshold,c=u.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:f,validOutputs:g}=kx(d,p,l,h,c,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:os(f,"int32"),validOutputs:wt(g,"int32")}}const VF=BF;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UF(n,e,t=!1,s=!1){const r=W(n,"images","resizeBilinear");L(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),L(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),L(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=Z(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},u={alignCorners:t,halfPixelCenters:s,size:e},l=Y.runKernel($c,a,u);return o?Z(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Qv=J({resizeBilinear_:UF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GF(n,e,t=!1,s=!1){const r=W(n,"images","resizeNearestNeighbor");L(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),L(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),L(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),L(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=Z(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},u={alignCorners:t,halfPixelCenters:s,size:e},l=Y.runKernel(Ic,a,u);return o?Z(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Jv=J({resizeNearestNeighbor_:GF});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WF(n,e="binary",t=!1,s=.5){const r=W(n,"image","threshold"),i=.2989,o=.587,a=.114,u=r.shape[0]*r.shape[1];let l=q(os([s]),255),h,c,d,p;if(L(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),L(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),L(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),L(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[h,c,d]=gs(r,[1,1,1],-1);const m=q(h,i),b=q(c,o),x=q(d,a);p=we(we(m,b),x)}else p=n;if(e==="otsu"){const m=G_(Ne(Bv(p),"int32"),dv([]),256);l=HF(m,u)}const f=t?Su(p,l):ys(p,l);return Ne(q(f,255),"int32")}function HF(n,e){let t=os([-1]),s=os([0]),r=os([0]),i,o,a,u,l,h;for(let c=0;c<n.size-1;c++){i=Rt(n,0,c+1),o=Rt(n,c+1),l=We(Ge(i),e),h=We(Ge(o),e);const d=Ge(q(i,vl(0,i.size)));a=We(d,Ge(i));const p=Ip(o.shape,i.size),f=we(vl(0,o.size),p),g=q(o,f);u=We(Ge(g),Ge(o));const m=je(a,u),b=je(a,u),x=q(l,h);r=q(q(x,m),b);const v=ys(r,s);s=On(v,r,s),t=On(v,os([c]),t)}return t}const KF=J({threshold_:WF});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jF(n,e,t="nearest",s="constant",r=0,i){const o=W(n,"image","transform","float32"),a=W(e,"transforms","transform","float32");L(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),L(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),L(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const u={image:o,transforms:a},l={interpolation:t,fillMode:s,fillValue:r,outputShape:i};return Y.runKernel(gp,u,l)}const XF=J({transform_:jF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qF(n,e,t){const s=W(n,"a","bandPart");L(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);let a,u;typeof e=="number"?(L(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),L(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),a=W(e<0?i:e,"numLower","bandPart")):(L(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=On(Qh(e,0),i,wl(e,i))),typeof t=="number"?(L(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),L(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),u=W(t<0?o:t,"numUpper","bandPart")):(L(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=On(Qh(t,0),o,wl(t,o)));const l=Z(vl(0,i,1,"int32"),[-1,1]),h=vl(0,o,1,"int32"),c=je(l,h),d=qr(Su(c,a),To(c,jt(u))),p=rn([i,o],s.dtype);return Z(Yr(mo(Z(s,[-1,i,o])).map(f=>On(d,f,p))),r)}const YF=J({bandPart_:qF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZF(n){let e;if(Array.isArray(n)){e=!1,L(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)L(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else e=!0,n=gs(n,n.shape[0],0).map(r=>Mc(r,[0]));L(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(Y.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const a=q(Ge(q(t[o],i)),t[o]);i=je(i,a)}return We(i,kp(i,"euclidean"))}));return e?Yr(t,0):t}const QF=J({gramSchmidt_:ZF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JF(n,e=!1){if(L(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return jy(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((u,l)=>u*l),s=mo(Z(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(u=>{const[l,h]=jy(u,e);r.push(l),i.push(h)});const o=Z(Yr(r,0),n.shape),a=Z(Yr(i,0),n.shape);return[o,a]}}function jy(n,e=!1){return Y.tidy(()=>{L(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=tx(t),i=no(n);const o=ol([[1]],[1,1]);let a=no(o);const u=t>=s?s:t;for(let l=0;l<u;++l){const h=i,c=a,d=r;[a,i,r]=Y.tidy(()=>{const p=Rt(i,[l,l],[t-l,1]),f=kp(p),g=Rt(i,[l,l],[1,1]),m=On(ys(g,0),ol([[-1]]),ol([[1]])),b=je(g,q(m,f)),x=We(p,b);x.shape[0]===1?a=no(o):a=Xn([o,Rt(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);const v=jt(We(ft(m,b),f)),w=Rt(i,[l,0],[t-l,s]),S=q(v,a),k=mt(a);if(l===0)i=je(w,ft(S,ft(k,w)));else{const C=je(w,ft(S,ft(k,w)));i=Xn([Rt(i,[0,0],[l,s]),C],0)}const E=mt(S),I=Rt(r,[0,l],[t,r.shape[1]-l]);if(l===0)r=je(I,ft(ft(I,a),E));else{const C=je(I,ft(ft(I,a),E));r=Xn([Rt(r,[0,0],[t,l]),C],1)}return[a,i,r]}),ut([h,c,d])}return!e&&t>s&&(r=Rt(r,[0,0],[t,s]),i=Rt(i,[0,0],[s,s])),[r,i]})}const eP=J({qr_:JF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Br={flipLeftRight:xF,grayscaleToRGB:yF,resizeNearestNeighbor:Jv,resizeBilinear:Qv,rgbToGrayscale:vF,rotateWithOffset:SF,cropAndResize:mF,nonMaxSuppression:$F,nonMaxSuppressionAsync:AF,nonMaxSuppressionWithScore:PF,nonMaxSuppressionWithScoreAsync:OF,nonMaxSuppressionPadded:zF,nonMaxSuppressionPaddedAsync:VF,threshold:KF,transform:XF},tP={bandPart:YF,gramSchmidt:QF,qr:eP};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nP=new Map,sP=new Map;class $u{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Ts{constructor(){this.classNameMap={}}static getMap(){return Ts.instance==null&&(Ts.instance=new Ts),Ts.instance}static register(e){Ts.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function fe(n,e,t){L(n.className!=null,()=>"Class being registered does not have the static className property defined."),L(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),L(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return Ts.register(n),nP.set(r,n),sP.set(n,r),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ri extends $u{minimize(e,t=!1,s){const{value:r,grads:i}=this.computeGradients(e,s);if(s!=null){const o=s.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return ut(i),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return cA(e,t)}dispose(){this.iterations_!=null&&ut(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:wt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Ri,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e2 extends Ri{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=Y.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Y.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:se(()=>gt(i).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:se(()=>gt(i).variable(o))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const u=this.accumulatedGrads[r].variable,l=this.accumulatedUpdates[r].variable;se(()=>{const h=we(q(u,this.rho),q(Ft(a),1-this.rho)),c=q(We($n(we(l,this.epsilon)),$n(we(u,this.epsilon))),a),d=we(q(l,this.rho),q(Ft(c),1-this.rho));u.assign(h),l.assign(d);const p=we(q(c,-this.learningRate),i);i.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(ut(this.accumulatedGrads.map(e=>e.variable)),ut(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t2 extends Ri{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Y.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:se(()=>Ip(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const a=this.accumulatedGrads[r].variable;se(()=>{const u=we(a,Ft(o));a.assign(u);const l=we(q(We(o,$n(we(u,Y.backend.epsilon()))),-this.learningRate),i);i.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&ut(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n2 extends Ri{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],se(()=>{this.accBeta1=wt(t).variable(),this.accBeta2=wt(s).variable()}),r==null&&(this.epsilon=Y.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);se(()=>{const s=je(1,this.accBeta1),r=je(1,this.accBeta2);t.forEach((i,o)=>{const a=Y.registeredVariables[i],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:se(()=>gt(a).variable(u))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:se(()=>gt(a).variable(u))});const l=Array.isArray(e)?e[o].tensor:e[i];if(l==null)return;const h=this.accumulatedFirstMoment[o].variable,c=this.accumulatedSecondMoment[o].variable,d=we(q(h,this.beta1),q(l,1-this.beta1)),p=we(q(c,this.beta2),q(Ft(l),1-this.beta2)),f=We(d,s),g=We(p,r);h.assign(d),c.assign(p);const m=we(q(We(f,we($n(g),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(q(this.accBeta1,this.beta1)),this.accBeta2.assign(q(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&ut(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&ut(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),se(()=>{this.accBeta1.assign(po(this.beta1,this.iterations_+1)),this.accBeta2.assign(po(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s2 extends Ri{static get className(){return"Adamax"}constructor(e,t,s,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],se(()=>{this.iteration=wt(0).variable(),this.accBeta1=wt(t).variable()}),r==null&&(this.epsilon=Y.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);se(()=>{const s=je(1,this.accBeta1),r=We(-this.learningRate,we(q(this.iteration,this.decay),1));t.forEach((i,o)=>{const a=Y.registeredVariables[i],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:gt(a).variable(u)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:gt(a).variable(u)});const l=Array.isArray(e)?e[o].tensor:e[i];if(l==null)return;const h=this.accumulatedFirstMoment[o].variable,c=this.accumulatedWeightedInfNorm[o].variable,d=we(q(h,this.beta1),q(l,1-this.beta1)),p=q(c,this.beta2),f=_n(l),g=Ti(p,f);h.assign(d),c.assign(g);const m=we(q(We(r,s),We(d,we(g,this.epsilon))),a);a.assign(m)}),this.iteration.assign(we(this.iteration,1)),this.accBeta1.assign(q(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&ut(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&ut(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ex extends Ri{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const o=Y.registeredVariables[s];se(()=>{const a=we(q(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=wr(wt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r2 extends Ex{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=wt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Y.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:se(()=>gt(i).variable(!1))});const o=this.accumulations[r].variable,a=Array.isArray(e)?e[r].tensor:e[s];a!=null&&se(()=>{let u;const l=we(q(this.m,o),a);this.useNesterov?u=we(q(this.c,we(a,q(l,this.m))),i):u=we(q(this.c,l),i),o.assign(l),i.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&ut(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i2 extends Ri{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=Y.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Y.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:se(()=>gt(i).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:se(()=>gt(i).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:se(()=>gt(i).variable(o))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const u=this.accumulatedMeanSquares[r].variable,l=this.accumulatedMoments[r].variable;se(()=>{const h=we(q(u,this.decay),q(Ft(a),1-this.decay));if(this.centered){const c=this.accumulatedMeanGrads[r].variable,d=we(q(c,this.decay),q(a,1-this.decay)),p=We(q(a,this.learningRate),$n(je(h,we(Ft(d),this.epsilon)))),f=we(q(l,this.momentum),p);u.assign(h),c.assign(d),l.assign(f);const g=je(i,f);i.assign(g)}else{const c=we(q(u,this.decay),q(Ft(a),1-this.decay)),d=we(q(l,this.momentum),We(q(a,this.learningRate),$n(we(c,this.epsilon))));u.assign(c),l.assign(d);const p=je(i,d);i.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&ut(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&ut(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&ut(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rP=[e2,t2,n2,s2,r2,i2,Ex];function iP(){for(const n of rP)fe(n)}function Np(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(Q(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,i=r[r.length-1];let o=1;for(let c=0;c<r.length-1;++c)o*=r[c];const a=n.shape,u=r.slice();u.pop();let l=1;for(let c=i;c<t;++c)l*=a[c],u.push(a[c]);const h=[...Be(n.shape).map(c=>c/l),1].slice(0,i);return[u,o,l,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nm=-2,oP=-1;function _p(n,e,t){const s=n.shape.length;L(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),L(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)L(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function aP(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function Dp(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function o2(n,e,t,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<t;i++)i===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function a2(n,e,t){return t<=n?t:t-(e-1)}function u2(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function uP(n,e,t,s,r,i,o,a,u){const l=n.length;let h=new Array(l),c=new Array(l),d=new Array(l);if(e.length&&t>0){const p=e[0],f=t+1;h=l2(o,p,f,s,n),c=c2(a,p,f,r,n),d=o2(i,p,f,n)}else for(let p=0;p<l;p++)h[p]=d2(o,s,i,n,p,u),c[p]=p2(a,r,i,n,p,u),d[p]=h2(i,p,u);return{begin:h,end:c,strides:d}}function l2(n,e,t,s,r){const i=[...r],o=u2(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const u=a2(e,t,a);let l=s[u];n&1<<u&&(l=0),i[a]=l}return i}function c2(n,e,t,s,r){const i=[...r],o=u2(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const u=a2(e,t,a);let l=s[u];n&1<<u&&(l=Number.MAX_SAFE_INTEGER),i[a]=l}for(let a=0;a<i.length;a++){const u=r[a];i[a]<0&&(i[a]+=u),i[a]=oo(0,i[a],r[a])}return i}function h2(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function d2(n,e,t,s,r,i){let o=e[r];const a=t[r]||1;(n&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const u=s[r];return o<0&&(o+=u),o=oo(0,o,u-1),o}function p2(n,e,t,s,r,i){let o=e[r];const a=t[r]||1;(n&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const u=s[r];return o<0&&(o+=u),a>0?o=oo(0,o,u):o=oo(-1,o,u-1),o}function Rx(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function Nx(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function Bc(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(o=>{L(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(r).fill(-1):typeof t=="number"?i=[t,...new Array(r-1).fill(-1)]:t.length<r?i=t.concat(new Array(r-t.length).fill(-1)):i=t,i=i.map((o,a)=>o>=0?o:(L(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,i]}function Ap(n,e,t,s,r,i,o,a,u){let l;if(s==null?(l=new Array(e.length),l.fill(1)):l=s,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const c={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:l.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:u};for(let v=0;v<c.dims;v++)h&&1<<v&a&&c.numAddAxisAfterEllipsis++,1<<v&o&&(h=!0);h||(c.ellipsisMask|=1<<c.dims,c.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};lP(c,d);let p=!0,f=!0,g=!0;const m=[],b=[];for(let v=0;v<n.length;++v){if(d.strides[v]===0)throw Error(`strides[${v}] must be non-zero`);const w=!!(d.shrinkAxisMask&1<<v),S=n[v];if(S===-1){m.push(w?1:-1);continue}const k=[d.beginMask&1<<v,d.endMask&1<<v],E=[d.strides[v]>0?0:-1,d.strides[v]>0?S:S-1];if(w&&d.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&d.strides[v]===1;const I=!!(d.beginMask&1<<v&&d.endMask&1<<v);if(d.beginValid&&d.endValid){if(w){const P=d.begin[v]<0?S+d.begin[v]:d.begin[v];if(d.begin[v]=P,d.end[v]=d.begin[v]+1,P<0||P>=S)throw Error(`slice index ${d.begin[v]} of dimension ${v} out of bounds.`)}else d.begin[v]=Xy(d.begin[v],0,d.strides[v],S,k,E),d.end[v]=Xy(d.end[v],1,d.strides[v],S,k,E);const R=d.strides[v]===1&&d.begin[v]===0&&d.end[v]===S;p=p&&R,f=f&&(v===0&&d.strides[v]===1||R)}else p=p&&d.strides[v]===1&&I,f=f&&(v===0&&d.strides[v]===1||I);let C,T=!1;if(d.beginValid&&d.endValid?(C=d.end[v]-d.begin[v],T=!0):w?(C=1,T=!0):I&&S>=0&&(d.strides[v]<0?C=-S:C=S,T=!0),T){let R;C===0||C<0!=d.strides[v]<0?R=0:R=Math.trunc(C/d.strides[v])+(C%d.strides[v]!==0?1:0),m.push(R)}else m.push(-1)}for(let v=0;v<d.finalShapeGatherIndices.length;++v){const w=d.finalShapeGatherIndices[v];w>=0?b.push(m[w]):w===Nm&&b.push(1)}return{finalShapeSparse:b.filter((v,w)=>d.finalShapeGatherIndices[w]!==Nm),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function lP(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(Nm),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(oP),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function Xy(n,e,t,s,r,i){if(r[e])return t>0?i[e]:i[e+1&1];{const o=n<0?s+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const cP=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:_p,computeFlatOffset:Nx,computeOutShape:Dp,getNormalizedAxes:uP,isSliceContinous:Rx,maskToAxes:aP,parseSliceParams:Bc,sliceInfo:Ap,startForAxis:d2,startIndicesWithElidedDims:l2,stopForAxis:p2,stopIndicesWithElidedDims:c2,stridesForAxis:h2,stridesWithElidedDims:o2},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hP{static sgd(e){return new Ex(e)}static momentum(e,t,s=!1){return new r2(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,i=!1){return new i2(e,t,s,r,i)}static adam(e=.001,t=.9,s=.999,r=null){return new n2(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new e2(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,i=0){return new s2(e,t,s,r,i)}static adagrad(e,t=.1){return new t2(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ho=hP;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dP=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function f2(){return new Promise(n=>dP(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fp(n,e){const t=n[0].length;n.forEach((r,i)=>{L(r.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),L(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,i)=>{for(let o=0;o<t;o++)L(o===e||r[o]===s[o],()=>`Error in concat${t}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function qn(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Vs;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Vs||(Vs={}));function m2(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const i=t[r],o=s[s.length-t.length+r],a=s[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${a}`)}else s[o]=i}return s}function g2(n){const e={FIRST_DIM_SIZE:Vs.FIRST_DIM_SIZE,VALUE_ROWIDS:Vs.VALUE_ROWIDS,ROW_LENGTHS:Vs.ROW_LENGTHS,ROW_SPLITS:Vs.ROW_SPLITS,ROW_LIMITS:Vs.ROW_LIMITS,ROW_STARTS:Vs.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function x2(n){return n.length===0?0:n[0]===Vs.FIRST_DIM_SIZE?n.length-1:n.length}function b2(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const i=n[r],o=e[r+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _x=30;function Pp(n){return n<=_x?n:mm(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lp(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function No(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=e.length;for(let o=0;o<i;++o)r=r.concat([n[o+1]/e[o],e[o]]);r=r.concat(n.slice(i+1))}return r}function _o(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],i=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?i.push(o):r.push(o);s.push(...r),s.push(0),s.push(...i)}return s}function Do(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?s?r.push(e[i-1]*n[i]):r.push(n[i]/e[i-1]):r.push(n[i]);return r}function Op(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function Mp(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vc=1.7580993408473768,Uc=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zp=.3275911,Bp=.254829592,Vp=-.284496736,Up=1.421413741,Gp=-1.453152027,Wp=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qs(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function y2(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function w2(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function v2(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function Dx(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function C2(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function S2(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:t,imag:s}}function I2(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zf="->",pP=/->/g,qy=",",Yy="...";function Hp(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(pP,"").length)/zf.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${zf}").`);const[s,r]=n.split(zf);L(s.indexOf(Yy)===-1,()=>`The ellipsis notation ("${Yy}") is not supported yet.`);const i=s.split(qy),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<r.length;++d){const p=r[d];if(!i.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);a.indexOf(p)===-1&&a.push(p)}for(let d=0;d<s.length;++d){const p=s[d];a.indexOf(p)===-1&&p!==qy&&a.push(p)}const u=new Array(i.length);for(let d=0;d<o;++d){if(new Set(i[d].split("")).size!==i[d].length)throw new Error(`Found duplicate axes in input component ${i[d]}. Support for duplicate axes in input is not implemented yet.`);u[d]=[];for(let p=0;p<i[d].length;++p)u[d].push(a.indexOf(i[d][p]))}const l=a.length,h=r.length,c=[];for(let d=h;d<l;++d)c.push(d);return{allDims:a,summedDims:c,idDims:u}}function Kp(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function jp(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const i=t[r].shape;for(let o=0;o<e[r].length;++o)s[e[r][o]]===void 0?s[e[r][o]]=i[o]:L(s[e[r][o]]===i[o],()=>`Expected dimension ${s[e[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function Xp(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<t.length;++o){const a=t[o],u=fP(e,a);for(const l of u)i.indexOf(l)===-1&&(s[o].push(l),i.push(l))}return{path:t,steps:s}}function qp(n){return n.every((e,t)=>e===t)}function fP(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function Yp(n,e,t=0){let s=[];if(typeof e=="number")L(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);L(r<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const o=e.reduce((a,u)=>u>0?a+u:a);e[i]=n.shape[t]-o}L(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $2(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function k2(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function T2(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E2(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function R2(n,e){return`size ${n} must be non-negative, not ${e}`}function N2(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function _2(n,e){const t=Q(n),s=Q(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function D2(n,e){const t=Q(n),s=Q(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _m(){return"segment ids must be >= 0"}function A2(){return"segment ids are not increasing"}function F2(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function P2(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L2(n,e){let t=!1,s;for(n<=_x?(s=n,t=!0):s=mm(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=mm(n,s+1);return s}function Ax(n,e,t){const s=[],r=n.length;for(let i=0;i<r;i++)i!==e?s.push(n[i]):s.push(t);return s}function Zp(n,e,t,s){const r=e.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let c=0;c<s;++c)if(n.shape[c]!==e.shape[c])throw new Error(`x.shape[${c}]: ${n.shape[c]} should be equal to indices.shape[${c}]: ${e.shape[c]}.`);const o=n.shape[t],a=[];let u=1,l=1,h=1;for(let c=0;c<s;++c)a.push(n.shape[c]),u*=n.shape[c];for(let c=s;c<t;c++)a.push(n.shape[c]),l*=n.shape[c];for(let c=s;c<r;c++)a.push(e.shape[c]);for(let c=t+1;c<i;c++)a.push(n.shape[c]),h*=n.shape[c];return{batchSize:u,sliceSize:h,outerSize:l,dimSize:o,outputShape:a}}const mP=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:Zp,computeOutShape:Ax,segOpComputeOptimalWindowSize:L2},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ys(n){try{return n.map(e=>Xs(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function O2(n){return n.map(e=>Ur(e))}const gP=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Bp,ERF_A2:Vp,ERF_A3:Up,ERF_A4:Gp,ERF_A5:Wp,ERF_P:zp,PARALLELIZE_THRESHOLD:_x,get RowPartitionType(){return Vs},SELU_SCALE:Uc,SELU_SCALEALPHA:Vc,applyActivation:Ix,assertAndGetBroadcastShape:Ke,assertAxesAreInnerMostDims:tn,assertParamsConsistent:Fp,assignToTypedArray:C2,axesAreInnerMostDims:ex,calculateShapes:_r,checkEinsumDimSizes:jp,checkPadOnDimRoundingMode:Jn,combineLocations:Nv,combineRaggedTensorToTensorShapes:m2,complexWithEvenIndex:w2,complexWithOddIndex:v2,computeConv2DInfo:Ot,computeConv3DInfo:tr,computeDefaultPad:Xg,computeDilation2DInfo:ki,computeOptimalWindowSize:Pp,computeOutAndReduceShapes:Yt,computeOutShape:qn,computePool2DInfo:kn,computePool3DInfo:bs,convertConv2DDataFormat:hs,decodeEinsumEquation:Hp,eitherStridesOrDilationsAreOne:gn,expandShapeToKeepDim:qt,exponent:I2,exponents:S2,fromStringArrayToUint8:O2,fromUint8ToStringArray:Ys,getAxesPermutation:kt,getBroadcastDims:xi,getComplexWithIndex:Dx,getEinsumComputePath:Xp,getEinsumPermutation:Kp,getFusedBiasGradient:Sx,getFusedDyActivation:Cx,getImageCenter:Lp,getInnerMostAxes:_t,getPermuted:_o,getRaggedRank:x2,getReductionAxes:cn,getReshaped:No,getReshapedPermuted:Do,getRowPartitionTypesHelper:g2,getSliceBeginCoords:Op,getSliceSize:Mp,getSparseFillEmptyRowsIndicesDenseShapeMismatch:$2,getSparseFillEmptyRowsNegativeIndexErrorMessage:k2,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:T2,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:N2,getSparseReshapeInputOutputMismatchErrorMessage:D2,getSparseReshapeInputOutputMultipleErrorMessage:_2,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:E2,getSparseReshapeNegativeOutputDimErrorMessage:R2,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:P2,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:_m,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:A2,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:F2,getUndoAxesPermutation:Nr,isIdentityPermutation:qp,log:QR,mergeRealAndImagArrays:qs,prepareAndValidate:Np,prepareSplitSize:Yp,segment_util:mP,shouldFuse:$x,slice_util:cP,splitRealAndImagArrays:y2,stridesOrDilationsArePositive:co,tupleValuesAreOne:lo,upcastType:mn,validateDefaultValueShape:b2,validateInput:j3,validateUpdateShape:Xv,warn:ps},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */iP();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M2={kernelName:Ll,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,zc(Ne(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xP={kernelName:ka,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Ft(Ne(t,"float32")),r=$n(je(wt(1),s));return jt(We(n,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bP={kernelName:Ta,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=$n(je(Ft(Ne(t,"float32")),1));return We(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yP={kernelName:Io,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ke(t.shape,s.shape);return{a:()=>{let a=n;const u=cn(t.shape,r);return u.length>0&&(a=Ge(a,u)),Z(a,t.shape)},b:()=>{let a=n;const u=cn(s.shape,r);return u.length>0&&(a=Ge(a,u)),Z(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wP={kernelName:Pd,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vP={kernelName:Ol,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>gt(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CP={kernelName:Ml,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>gt(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SP={kernelName:Ea,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>We(n,$n(je(wt(1),Ft(Ne(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IP={kernelName:Ra,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=$n(we(wt(1),Ft(Ne(t,"float32"))));return We(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $P={kernelName:Da,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ke(t.shape,s.shape);return{a:()=>{const a=we(Ft(t),Ft(s));let u=q(n,We(s,a));const l=cn(t.shape,r);return l.length>0&&(u=Ge(u,l)),Z(u,t.shape)},b:()=>{const a=we(Ft(t),Ft(s));let u=jt(q(n,We(t,a)));const l=cn(s.shape,r);return l.length>0&&(u=Ge(u,l)),Z(u,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kP={kernelName:Na,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>We(n,we(Ft(Ne(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TP={kernelName:_a,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>We(n,je(wt(1),Ft(Ne(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EP(n,e,t,s,r,i){const o=W(n,"dy","avgPool3dGrad"),a=W(e,"input","avgPool3dGrad");let u=o,l=a,h=!1;a.rank===4&&(h=!0,u=Z(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),l=Z(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),L(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),L(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),Jn("avgPool3dGrad",r,i);const c={dy:u,input:l},d={filterSize:t,strides:s,pad:r,dimRoundingMode:i},p=Y.runKernel(zd,c,d);return h?Z(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const RP=J({avgPool3dGrad_:EP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NP={kernelName:Bl,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:o,dimRoundingMode:a}=t;return{x:()=>RP(n,s,r,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _P(n,e,t,s,r){const i=W(n,"dy","avgPoolGrad"),o=W(e,"input","avgPoolGrad");L(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,u=i,l=!1;o.rank===3&&(l=!0,a=Z(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=Z(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),L(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h={dy:u,input:a},c={filterSize:t,strides:s,pad:r},d=Y.runKernel(Md,h,c);return l?Z(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const DP=J({avgPoolGrad_:_P});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AP={kernelName:zl,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:o}=t;return{x:()=>DP(n,s,r,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FP={kernelName:Vl,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:i,transposeB:o}=t;return!i&&!o?{a:()=>ft(n,r,!1,!0),b:()=>ft(s,n,!0,!1)}:!i&&o?{a:()=>ft(n,r,!1,!1),b:()=>ft(n,s,!0,!1)}:i&&!o?{a:()=>ft(r,n,!1,!0),b:()=>ft(s,n,!1,!1)}:{a:()=>ft(r,n,!0,!0),b:()=>ft(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PP={kernelName:Ul,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>lx(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LP={kernelName:YR,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,i=s.shape,o=Array.from(i);for(let u=r.length-1;u>=0;u--)if(r[u]===i[u])o[u]=1;else if(r[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const a=[];for(let u=0;u<o.length;u++)o[u]>1&&a.push(u);return{x:()=>Ge(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OP={kernelName:Aa,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MP={kernelName:Fa,gradFunc:n=>({x:()=>gt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zP={kernelName:Pa,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=t;return{x:()=>On(qr(To(s,r),Su(s,i)),n,gt(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BP={kernelName:Gl,inputsToSave:["x"],gradFunc:M2.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VP={kernelName:Wl,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(u=>u.shape),{axis:r}=t,i=Qe(r,e[0].shape)[0],o=s.map(u=>u[i]);return gs(n,o,i).map(u=>()=>u)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UP={kernelName:Hl,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:i,strides:o,pad:a,dataFormat:u}=t;return L(lo(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>Zg(s.shape,n,r,o,a,u),filter:()=>vx(s,n,r.shape,o,a,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GP={kernelName:Kl,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:i,pad:o,dataFormat:a,dimRoundingMode:u}=t;return{dy:()=>ho(n,r,i,o,a,1,u),filter:()=>vx(n,s,r.shape,i,o,a,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WP(n,e,t,s,r){let i=n;n.rank===4&&(i=Z(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=Z(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),L(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),L(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),L(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),L(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),L(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:i,dy:o},u={strides:s,pad:r,filterShape:t};return Y.runKernel(Gd,a,u)}const HP=J({conv3DBackpropFilter_:WP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KP={kernelName:jl,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i}=t;L(lo(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,a]=e;return{x:()=>kv(o.shape,n,a,r,i),filter:()=>HP(o,n,a.shape,r,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jP={kernelName:La,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(jt(Wv(Ne(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XP={kernelName:Oa,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(Hv(Ne(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qP={kernelName:Xl,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:i,reverse:o}=t;return{x:()=>{const a=kt([r],s.rank);let u=Ev(n,r,i,!o);return a!=null&&(u=mt(u,a)),u}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YP={kernelName:ql,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=t,a=s??[1,1];L(lo(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[u,l]=e;return L(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),L(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),L(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),L(gn(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),Jn("depthwiseConv2d",i,o),{x:()=>dF(u.shape,n,l,r,i,a,o),filter:()=>cF(u,n,l.shape,r,i,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZP={kernelName:Yl,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,i={x:s,filter:r,dy:n},o={x:s,filter:r,dy:n};return{x:()=>Y.runKernel(Kh,i,t),filter:()=>Y.runKernel(jh,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QP={kernelName:za,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>Y.runKernel(Qd,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JP={kernelName:Ba,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=q($r(jt(Ft(t))),2/Math.sqrt(Math.PI));return{x:()=>q(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eL={kernelName:Va,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tL={kernelName:Ql,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>Z(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nL={kernelName:Ua,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,$r(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sL={kernelName:Ga,gradFunc:n=>({x:()=>gt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rL={kernelName:Wa,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ke(t.shape,s.shape);return{a:()=>{const a=We(n,Ne(s,"float32")),u=cn(t.shape,r);return u.length>0?Z(Ge(a,u),t.shape):a},b:()=>{let a=q(n,Ne(t,"float32"));const u=cn(s.shape,r);u.length>0&&(a=Z(Ge(a,u),s.shape));const l=Ft(s);return jt(We(a,Ne(l,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iL={kernelName:Jl,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,i,o,a]=e,u=a??wt(1),l=cn(i.shape,r.shape),h=[];if(i.rank===1){for(let w=0;w<r.shape.length-1;++w)h.push(r.shape[w]);h.push(1)}const c=je(r,i),d=q(n,u),p=Vv(we(o,wt(s))),f=q(q(q(p,p),p),wt(-.5));return{x:()=>i.rank===1?Z(q(q(n,Us(Z(p,[1,1,1,i.shape[0]]),h)),u),r.shape):Z(q(q(n,p),u),r.shape),mean:()=>{let w=q(q(p,wt(-1)),d);return i.rank===1&&(w=Ge(w,l)),Z(w,i.shape)},variance:()=>{let w=q(q(f,c),d);return i.rank===1&&(w=Ge(w,l)),Z(w,i.shape)},scale:()=>{const w=q(c,p);let S=q(n,w);return i.rank===1&&(S=Ge(S,l)),Z(S,i.shape)},offset:()=>{let w=n;return i.rank===1&&(w=Ge(w,l)),Z(w,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oL={kernelName:ec,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:i,batchDims:o}=t,a=Qe(i,s.shape)[0],u=(l,h,c)=>()=>{const d=l.shape,p=h.size,f=d.slice(0,a),g=f.length,m=d.slice(i,d.length).slice(1),b=m.length,x=Zy(0,g),v=Zy(g+1,g+1+b),w=Qy([f,[p],m]),S=Z(c,w),k=Z(h,[p]),E=Qy([[g],x,v]),I=mt(S,E);let C=Yv(I,k,l.shape[a]);const T=Nr(E);return C=mt(C,T),C};if(o===1){const l=s.shape[0],h=s.split(l,0);return{x:()=>Yr(h.map((p,f)=>u(p,r.slice(f,1),n.slice(f,1))())).reshape(s.shape),indices:()=>r}}else return{x:u(s,r,n),indices:()=>r}}};function Zy(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function Qy(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aL={kernelName:Ha,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>gt(t),b:()=>gt(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uL={kernelName:Ka,gradFunc:n=>({x:()=>Ne(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lL={kernelName:ja,gradFunc:n=>({x:()=>gt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cL={kernelName:Xa,gradFunc:n=>({x:()=>gt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hL={kernelName:qa,gradFunc:n=>({x:()=>gt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dL={kernelName:nc,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,i=ys(s,0);return{x:()=>On(i,n,q(n,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pL={kernelName:Za,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>We(n,we(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fL={kernelName:Ya,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>We(n,Ne(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mL={kernelName:ZR,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const o=$r(s);return je(n,q(Ge(n,r,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gL(n,e,t,s=5,r=1,i=1,o=.5){const a={x:n,y:e,dy:t},u={depthRadius:s,bias:r,alpha:i,beta:o};return Y.runKernel(rp,a,u)}const xL=J({localResponseNormalizationBackprop_:gL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bL={kernelName:uc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:i,bias:o,alpha:a,beta:u}=t;return{x:()=>xL(s,r,n,i,o,a,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2(n,e,t,s){return e.rank<t.rank&&(e=Z(e,qt(e.shape,s))),n.rank<t.rank&&(n=Z(n,qt(n.shape,s))),{x:()=>q(n,Ne(Ir(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jy={kernelName:lc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,i=e[0],o=e[1],a=Qe(r,i.shape),u=z2(n,o,i,a);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yL={kernelName:Qa,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>q(n,Ne(To(t,s),"float32")),b:()=>q(n,Ne(Qh(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wL(n,e,t,s,r,i,o){const a=W(n,"dy","maxPool3dGrad"),u=W(e,"input","maxPool3dGrad"),l=W(t,"output","maxPool3dGrad");let h=a,c=u,d=l,p=!1;u.rank===4&&(p=!0,h=Z(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),c=Z(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=Z(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),L(h.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),L(c.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),L(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),Jn("maxPool3dGrad",i,o);const f={dy:h,input:c,output:d},g={filterSize:s,strides:r,pad:i,dimRoundingMode:o},m=Y.runKernel(op,f,g);return p?Z(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const vL=J({maxPool3dGrad_:wL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CL={kernelName:hc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:u}=t;return{x:()=>vL(n,s,r,i,o,a,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SL(n,e,t,s,r,i,o){const a=W(n,"dy","maxPoolGrad"),u=W(e,"input","maxPoolGrad"),l=W(t,"output","maxPoolGrad");L(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`),L(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),L(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Jn("maxPoolGrad",i,o);const h={dy:a,input:u,output:l},c={filterSize:s,strides:r,pad:i,dimRoundingMode:o};return Y.runKernel(ip,h,c)}const IL=J({maxPoolGrad_:SL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $L={kernelName:cc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:o,pad:a}=t;return{x:()=>IL(n,s,r,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kL={kernelName:dc,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,i=Qe(r,s.shape),a=Yt(s.shape,i)[1],u=Q(a);return{x:()=>{const h=s.shape.slice();i.forEach(p=>{h[p]=1});const c=Z(n,h);return We(q(c,Ei(s.shape,"float32")),u)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TL={kernelName:pc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[i,o]=e,a=Qe(r,i.shape),u=z2(n,o,i,a);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EL={kernelName:Ja,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>q(n,Ne(Su(t,s),"float32")),b:()=>q(n,Ne(ys(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RL={kernelName:fc,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(o=>o[0]);return{x:()=>Rt(n,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NL={kernelName:eu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ke(t.shape,s.shape);return{a:()=>{const a=cn(t.shape,r);return a.length>0?Z(Ge(n,a),t.shape):n},b:()=>{const a=q(n,jt(Tp(We(t,s)))),u=cn(s.shape,r);return u.length>0?Z(Ge(a,u),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _L={kernelName:tu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ke(t.shape,s.shape);return{a:()=>{const a=q(n,Ne(s,"float32")),u=cn(t.shape,r);return u.length>0?Z(Ge(a,u),t.shape):a},b:()=>{const a=q(n,Ne(t,"float32")),u=cn(s.shape,r);return u.length>0?Z(Ge(a,u),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DL={kernelName:mc,gradFunc:n=>({x:()=>jt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AL={kernelName:bc,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>rn(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FL={kernelName:xc,gradFunc:n=>({x:()=>gt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PL={kernelName:yc,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return mo(n,s).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e0={kernelName:wc,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(o=>o[0]);return{x:()=>Rt(n,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LL={kernelName:nu,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,i=t,o=s,a=Ke(i.shape,o.shape);return{a:()=>{const h=Ne(o,"float32");let c=q(n,q(h,po(i,je(h,wt(1)))));const d=cn(i.shape,a);return d.length>0&&(c=Ge(c,d)),Z(c,i.shape)},b:()=>{const h=ys(i,0),c=On(h,kr(i),gt(i));let d=q(n,q(r,c));const p=cn(o.shape,a);return p.length>0&&(d=Ge(d,p)),Z(d,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OL={kernelName:vc,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=ys(t,0);return{x:()=>On(r,n,q(n,s)),alpha:()=>{let i=On(r,gt(n),q(n,t));const o=cn(s.shape,n.shape);return o.length>0&&(i=Ge(i,o)),Z(i,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ML(n,e,t){const s=n.shape.slice();s[t]=1;const r=Z(e,s),i=Em(n,t,!0,!1),o=Em(n,t,!0,!0),a=q(i,o);return q(r,a)}function zL(n,e,t){const s=n.shape.length,r=s-t.length,i=kt(t,s);let o=n;i!=null&&(o=mt(n,i));const a=o.shape.slice(),l=a.splice(s-t.length,t.length).reduce((d,p)=>d*p,1);a.push(l);const h=o.reshape(a);let c=ML(h,e,r);if(c=c.reshape(o.shape),i!=null){const d=Nr(i);c=mt(c,d)}return c}const BL={kernelName:Cc,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let i=[];return r==null?i=s.shape.map((o,a)=>a):typeof r=="number"?i=[r]:i=r,{x:()=>zL(s,n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VL={kernelName:Ma,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ke(t.shape,s.shape);return{a:()=>{const a=We(n,Ne(s,"float32")),u=cn(t.shape,r);return u.length>0?Z(Ge(a,u),t.shape):a},b:()=>{let a=q(n,Ne(t,"float32"));const u=cn(s.shape,r);u.length>0&&(a=Z(Ge(a,u),s.shape));const l=Ft(s);return jt(We(a,Ne(l,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UL={kernelName:su,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>We(n,jt(Ft(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GL={kernelName:iu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=q(Su(t,6),zc(t));return{x:()=>q(n,Ne(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WL={kernelName:ru,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,Ne(zc(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HL={kernelName:Sc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Z(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KL={kernelName:$c,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>Y.runKernel(dp,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jL={kernelName:Ic,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>Y.runKernel(hp,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XL={kernelName:kc,gradFunc:(n,e,t)=>{const{dims:s}=t,r=Qe(s,n.shape);return{x:()=>fo(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qL={kernelName:ou,gradFunc:n=>({x:()=>gt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YL={kernelName:au,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>jt(We(n,q(po(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZL={kernelName:Tc,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Ne(gt(t),"float32"),t:()=>q(n,Ne(t,n.dtype)),e:()=>q(n,Ne(ix(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QL={kernelName:uu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=ys(t,wt(0)),r=wt(Vc),i=wt(Uc),o=q(n,i),a=q(q(n,r),$r(Ne(t,"float32")));return On(s,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JL={kernelName:du,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,q(t,je(wt(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eO={kernelName:hu,gradFunc:n=>({x:()=>gt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tO={kernelName:lu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(Qg(Ne(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nO={kernelName:cu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(Tv(Ne(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sO={kernelName:Ec,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:i}=t,o=s.shape,[a,u]=Bc(s,r,i),l=[];for(let h=0;h<n.rank;h++)l.push([a[h],o[h]-a[h]-u[h]]);return{x:()=>ux(n,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rO={kernelName:Dc,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,i=!0,o=q(n,s);return{logits:()=>je(o,q(Ge(o,[r],i),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iO={kernelName:pu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,Cu(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t0={kernelName:Nc,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>Yg(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n0={kernelName:_c,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>Xn(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oO={kernelName:fu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>We(n,q($n(Ne(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aO={kernelName:pp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,q(Ne(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uO={kernelName:mu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=wt(2);return{a:()=>q(n,q(r,je(t,s))),b:()=>q(n,q(r,je(s,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lO={kernelName:wu,gradFunc:n=>({x:()=>gt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cO={kernelName:gu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ke(t.shape,s.shape);return{a:()=>{let a=n;const u=cn(t.shape,r);return u.length>0&&(a=Ge(a,u)),Z(a,t.shape)},b:()=>{let a=n;const u=cn(s.shape,r);return u.length>0&&(a=Ge(a,u)),Z(jt(a),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hO={kernelName:Rc,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:i}=t;Qe(i,s.shape).forEach(l=>{r[l]=1});const a=Z(n,r),u=q(a,Ei(s.shape,"float32"));return{x:()=>u}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dO={kernelName:xu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>We(n,Ft(Qg(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pO={kernelName:bu,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(je(wt(1),Ft(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fO={kernelName:yu,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let o=gt(s);if(s.rank===1)for(let a=0;a<r[0];++a)o=we(o,Rt(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<r[0];++a)for(let u=0;u<r[1];++u)o=we(o,Rt(n,[a*s.shape[0],u*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<r[0];++a)for(let u=0;u<r[1];++u)for(let l=0;l<r[2];++l)o=we(o,Rt(n,[a*s.shape[0],u*s.shape[1],l*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<r[0];++a)for(let u=0;u<r[1];++u)for(let l=0;l<r[2];++l)for(let h=0;h<r[3];++h)o=we(o,Rt(n,[a*s.shape[0],u*s.shape[1],l*s.shape[2],h*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mO={kernelName:to,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,i=Nr(r);return{x:()=>mt(n,i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gO={kernelName:Ac,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>Yr(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xO={kernelName:Fc,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bO(n,t)}}};function bO(n,e){const t=Ti(e,gt(e)),s=nx(n,t);let r=To(e,wt(0,"int32"));const i=s.rank-r.rank;for(let a=0;a<i;++a)r=Hn(r,a+1);r=qr(r,Ei(s.shape,"bool"));const o=gt(s);return On(r,s,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yO={kernelName:Pc,gradFunc:n=>({x:()=>gt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wO=[M2,xP,bP,yP,wP,vP,CP,SP,IP,$P,kP,TP,NP,AP,FP,PP,LP,OP,MP,zP,BP,VP,GP,UP,KP,jP,XP,qP,YP,ZP,VL,QP,JP,eL,tL,nL,rL,sL,iL,oL,aL,uL,lL,cL,hL,dL,pL,fL,mL,bL,Jy,Jy,yL,CL,$L,kL,TL,EL,RL,NL,_L,DL,AL,FL,PL,e0,e0,LL,OL,BL,UL,GL,WL,HL,KL,jL,XL,qL,YL,ZL,QL,JL,eO,tO,nO,sO,rO,iO,t0,t0,n0,n0,oO,uO,aO,lO,cO,hO,dO,pO,fO,mO,gO,xO,yO];for(const n of wO)JR(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.abs=function(){return this.throwIfDisposed(),_n(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.acos=function(){return this.throwIfDisposed(),n_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.acosh=function(){return this.throwIfDisposed(),r_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.add=function(n){return this.throwIfDisposed(),we(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.all=function(n,e){return this.throwIfDisposed(),Sv(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.any=function(n,e){return this.throwIfDisposed(),km(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.argMax=function(n){return this.throwIfDisposed(),xl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.argMin=function(n){return this.throwIfDisposed(),l_(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.asScalar=function(){return this.throwIfDisposed(),L(this.size===1,()=>"The array must have only 1 element."),Z(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.asType=function(n){return this.throwIfDisposed(),Ne(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.as1D=function(){return this.throwIfDisposed(),Z(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.as2D=function(n,e){return this.throwIfDisposed(),Z(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),Z(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),Z(this,[n,e,t,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),Z(this,[n,e,t,s,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.asin=function(){return this.throwIfDisposed(),h_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.asinh=function(){return this.throwIfDisposed(),p_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.atan=function(){return this.throwIfDisposed(),m_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.atan2=function(n){return this.throwIfDisposed(),x_(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.atanh=function(){return this.throwIfDisposed(),y_(this)};le().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),qg(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),Yg(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),Sp(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.broadcastTo=function(n){return this.throwIfDisposed(),il(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.cast=function(n){return this.throwIfDisposed(),Ne(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.ceil=function(){return this.throwIfDisposed(),K_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),xs(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof sn&&(n=[n]),Xn([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.conv1d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Iv(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),$v(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.conv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),ho(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.cos=function(){return this.throwIfDisposed(),Qg(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.cosh=function(){return this.throwIfDisposed(),Tv(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),Em(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),Ev(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),xD(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.depthwiseConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Jg(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),wD(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.divNoNan=function(n){return this.throwIfDisposed(),$D(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.div=function(n){return this.throwIfDisposed(),We(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.dot=function(n){return this.throwIfDisposed(),TD(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.elu=function(){return this.throwIfDisposed(),$p(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.equal=function(n){return this.throwIfDisposed(),Ir(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.erf=function(){return this.throwIfDisposed(),Rv(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),zD(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.exp=function(){return this.throwIfDisposed(),$r(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.expandDims=function(n){return this.throwIfDisposed(),Hn(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.expm1=function(){return this.throwIfDisposed(),GD(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.fft=function(){return this.throwIfDisposed(),jv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.flatten=function(){return this.throwIfDisposed(),Z(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.floor=function(){return this.throwIfDisposed(),Tp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.floorDiv=function(n){return this.throwIfDisposed(),Cv(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.gather=function(n,e,t){return this.throwIfDisposed(),nx(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.greaterEqual=function(n){return this.throwIfDisposed(),To(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.greater=function(n){return this.throwIfDisposed(),ys(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.ifft=function(){return this.throwIfDisposed(),Rm(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.irfft=function(){return this.throwIfDisposed(),F3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.isFinite=function(){return this.throwIfDisposed(),QD(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.isInf=function(){return this.throwIfDisposed(),eA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.isNaN=function(){return this.throwIfDisposed(),nA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.leakyRelu=function(n){return this.throwIfDisposed(),rx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.lessEqual=function(n){return this.throwIfDisposed(),Su(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.less=function(n){return this.throwIfDisposed(),Qh(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),aA(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logSigmoid=function(){return this.throwIfDisposed(),fA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logSoftmax=function(n){return this.throwIfDisposed(),Av(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),Fv(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.log=function(){return this.throwIfDisposed(),kr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.log1p=function(){return this.throwIfDisposed(),Dv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logicalAnd=function(n){return this.throwIfDisposed(),qr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logicalNot=function(){return this.throwIfDisposed(),ix(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logicalOr=function(n){return this.throwIfDisposed(),Pv(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logicalXor=function(n){return this.throwIfDisposed(),CA(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),ft(this,n,e,t)};le().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),ox(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.max=function(n,e){return this.throwIfDisposed(),Hs(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.maximum=function(n){return this.throwIfDisposed(),Ti(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.mean=function(n,e){return this.throwIfDisposed(),Jt(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.min=function(n,e){return this.throwIfDisposed(),Zh(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.minimum=function(n){return this.throwIfDisposed(),wl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),NA(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.mod=function(n){return this.throwIfDisposed(),DA(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.mul=function(n){return this.throwIfDisposed(),q(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.neg=function(){return this.throwIfDisposed(),jt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.norm=function(n,e,t){return this.throwIfDisposed(),kp(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.notEqual=function(n){return this.throwIfDisposed(),Jh(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),Lv(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.onesLike=function(){return this.throwIfDisposed(),Ps(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.pad=function(n,e){return this.throwIfDisposed(),ux(this,n,e)};le().prototype.pool=function(n,e,t,s,r,i){return this.throwIfDisposed(),UA(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.pow=function(n){return this.throwIfDisposed(),po(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.prelu=function(n){return this.throwIfDisposed(),cx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.prod=function(n,e){return this.throwIfDisposed(),HA(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.reciprocal=function(){return this.throwIfDisposed(),f3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.relu=function(){return this.throwIfDisposed(),Ro(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.relu6=function(){return this.throwIfDisposed(),zv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.reshapeAs=function(n){return this.throwIfDisposed(),Z(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.reshape=function(n){return this.throwIfDisposed(),Z(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),Qv(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),Jv(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.reverse=function(n){return this.throwIfDisposed(),fo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.rfft=function(){return this.throwIfDisposed(),O3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.round=function(){return this.throwIfDisposed(),Bv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.rsqrt=function(){return this.throwIfDisposed(),Vv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.selu=function(){return this.throwIfDisposed(),Uv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.separableConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Gv(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sigmoid=function(){return this.throwIfDisposed(),Cu(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sign=function(){return this.throwIfDisposed(),S3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sin=function(){return this.throwIfDisposed(),Wv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sinh=function(){return this.throwIfDisposed(),Hv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.slice=function(n,e){return this.throwIfDisposed(),Rt(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.softmax=function(n){return this.throwIfDisposed(),wx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.softplus=function(){return this.throwIfDisposed(),Lc(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),lx(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.split=function(n,e){return this.throwIfDisposed(),gs(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sqrt=function(){return this.throwIfDisposed(),$n(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.square=function(){return this.throwIfDisposed(),Ft(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.squaredDifference=function(n){return this.throwIfDisposed(),z3(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.squeeze=function(n){return this.throwIfDisposed(),Mc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof sn?[this,n]:[this,...n];return Yr(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.step=function(n){return this.throwIfDisposed(),zc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.stridedSlice=function(n,e,t,s,r,i,o,a){return this.throwIfDisposed(),W3(this,n,e,t,s,r,i,o,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sub=function(n){return this.throwIfDisposed(),je(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sum=function(n,e){return this.throwIfDisposed(),Ge(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.tan=function(){return this.throwIfDisposed(),K3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.tanh=function(){return this.throwIfDisposed(),Cp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.tile=function(n){return this.throwIfDisposed(),Us(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.toBool=function(){return this.throwIfDisposed(),Ne(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.toFloat=function(){return this.throwIfDisposed(),Ne(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.toInt=function(){return this.throwIfDisposed(),Ne(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.topk=function(n,e){return this.throwIfDisposed(),q3(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.transpose=function(n){return this.throwIfDisposed(),mt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.unique=function(n){return this.throwIfDisposed(),Q3(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),Yv(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.unstack=function(n){return this.throwIfDisposed(),mo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.where=function(n,e){return this.throwIfDisposed(),On(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.zerosLike=function(){return this.throwIfDisposed(),gt(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class hr extends Error{constructor(e){super(e),Object.setPrototypeOf(this,hr.prototype)}}class _s extends Error{constructor(e){super(e),Object.setPrototypeOf(this,_s.prototype)}}class j extends Error{constructor(e){super(e),Object.setPrototypeOf(this,j.prototype)}}class st extends Error{constructor(e){super(e),Object.setPrototypeOf(this,st.prototype)}}class Fx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Fx.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class B2{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function go(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function dr(n,e){if(!n)throw new Fx(e)}function s0(n,e){let t=0;for(const s of n)s===e&&t++;return t}function Kn(n){return n.length===1?n[0]:n}function Ct(n){return Array.isArray(n)?n:[n]}function Or(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Ki(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Ss={};function Px(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function Dm(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>Dm(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:Dm(s))}}}function Gc(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const i=n;let o;if(i in t)o=t[i];else if(i in Ss)o=Ss[i];else if(o=e[i],o==null)throw new j(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new j(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,u;if(o in t?[a,u]=t[o]:o in Ss?[a,u]=Ss.className:o in e&&([a,u]=e[o]),a==null)throw new j(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){const l={};for(const p of Object.keys(Ss))l[p]=Ss[p];for(const p of Object.keys(t))l[p]=t[p];const h=i.config;h.customObjects=l;const c=Object.assign({},Ss);for(const p of Object.keys(t))Ss[p]=t[p];Dm(i.config);const d=u(a,i.config,t,r);return Ss=Object.assign({},c),d}else{const l=Object.assign({},Ss);for(const c of Object.keys(t))Ss[c]=t[c];const h=new a(i.config);return Ss=Object.assign({},l),h}}}function vO(n,e){return n<e?-1:n>e?1:0}function xh(n,e){return-1*vO(n,e)}function pi(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function CO(n){if(n==null)throw new j(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function Ao(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new j(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function Lx(n,e,t=0,s=1/0){return dr(t>=0),dr(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function pn(n,e){Array.isArray(n)?(L(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>pn(t,`element ${s+1} of ${e}`))):L(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${V2(n)}.`)}function V2(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>V2(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function SO(n,e,t){let s=t!=null?t():Gn(),r;return(...o)=>{const a=t!=null?t():Gn();return a-s<e||(s=a,r=n(...o)),r}}function U2(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let IO=0;function G2(){return IO++}const bh={};function Qp(n=""){return n in bh||(bh[n]=0),bh[n]+=1,n+bh[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const $O=["channelsFirst","channelsLast"],kO=["nearest","bilinear"],TO=["valid","same","causal"],EO=["max","avg"],RO=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ko=new Map;function Zt(n){Ao($O,"DataFormat",n)}function NO(n){Ao(kO,"InterpolationFormat",n)}function ws(n){Ao(TO,"PaddingMode",n)}function W2(n){Ao(EO,"PoolMode",n)}const al=[],r0="/";function so(n,e){al.push(n);try{const t=e();return al.pop(),t}catch(t){throw al.pop(),t}}function _O(){return al.length===0?"":al.join(r0)+r0}function H2(n){if(!j2(n))throw new Error("Not a valid tensor name: '"+n+"'");return _O()+n}function K2(n){if(!j2(n))throw new Error("Not a valid tensor name: '"+n+"'");Ko.has(n)||Ko.set(n,0);const e=Ko.get(n);if(Ko.set(n,Ko.get(n)+1),e>0){const t=`${n}_${e}`;return Ko.set(t,1),t}else return n}const DO=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function j2(n){return!!n.match(DO)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function AO(n){return n===parseInt(n.toString(),10)}function fi(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function xa(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function bi(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function Zs(n,e){if(e<n)throw new j(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Bf;function on(){return Bf==null&&(Bf=kN().epsilon()),Bf}function Qs(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vr(n,e){return Ne(n,e)}function Wc(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),Z(n,t)}function FO(n,e){return se(()=>{if(n.shape.length!==2)throw new j(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=Wc(n,1);return Am(t,[1,e,1])})}function PO(n){const e=[fi(n.shape)];return Z(n,e)}function LO(n){if(n.rank<=1)throw new j(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],fi(n.shape,1)];return Z(n,e)}function ro(n,e,t){return se(()=>{switch(n.rank){case 1:return bx(n,e,t);case 2:return Kv(n,[e,0],[t,n.shape[1]]);case 3:return yx(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return td(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Rt(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Rt(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new j(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Vf(n,e,t){return se(()=>{switch(n.rank){case 1:return bx(n,e,t);case 2:return Kv(n,[0,e],[n.shape[0],t]);case 3:return yx(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return td(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new j(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function yh(n,e,t,s){return se(()=>{switch(n.rank){case 1:return bx(n,e,t);case 2:switch(s){case 1:return ro(n,e,t);case 2:return Vf(n,e,t);default:throw new j(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return ro(n,e,t);case 2:return yx(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return Vf(n,e,t);default:throw new j(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return ro(n,e,t);case 2:return td(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return td(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return Vf(n,e,t);default:throw new j(`The axis is not within the rank of the tensor ${s}`)}default:throw new j(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ox(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),Xn(n,e)}function i0(n,e){switch(n.rank){case 1:return q_([n,e]);case 2:return Z_([n,e],0);case 3:return J_([n,e],0);case 4:return tD([n,e],0);default:throw new j(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function Am(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new j(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return Us(n,e)}function Jp(n,e=0,t=1,s,r){return c3(n,e,t,s,r)}function Cr(n,e,t,s){if(n.rank<2||e.rank<2)throw new st(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(r!==i)throw new st(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return Hy({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?Fm(n.rank,s,Qs()):null,activation:t});{const r=n.shape.slice(),i=r.pop();n=Z(n,[-1,i]);const o=e.shape.slice(),a=o.pop(),u=o.pop(),l=[...o,a],h=Array.from({length:e.rank},(f,g)=>g===0?e.rank-2:g<=e.rank-2?g-1:g);e=Z(mt(e,h),[u,-1]);const c=[...r,...l];return Z(Hy({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?Fm(n.rank,s,Qs()):null,activation:t}),c)}}function X2(n,e,t){return se(()=>(Array.isArray(e)?e=os(e,"int32"):e=Ne(e,"int32"),nx(n,e,t)))}function Hc(n){return q(n,n)}function Fm(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new j(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?Z(e,[1,s[0],1,1,1]):Z(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?Z(e,[1,1,1,1,s[0]]):Z(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?Z(e,[1,s[0],1,1]):Z(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?Z(e,[1,1,1,s[0]]):Z(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?Z(e,[1,s[0],1]):Z(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?Z(e,[1,1,s[0]]):Z(e,[1].concat(s))}else if(n<3)return e;throw new j(`Unsupported input rank by biasAdd: ${e.rank}`)}function nr(n,e,t){return se(()=>(t==null&&(t=Qs()),Zt(t),we(n,Fm(n.rank,e,t))))}function OO(n,e=1){if(e!==1)throw new st(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return $p(n)}function MO(n){return se(()=>We(n,we(_n(n),1)))}function q2(n,e,t,s){return se(()=>iF(n,e,t,s))}function zO(n){return se(()=>{const e=we(.5,q(.2,n));return xs(e,0,1)})}function Kc(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const BO=["fanIn","fanOut","fanAvg"],VO=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function UO(n){Ao(BO,"FanMode",n)}function GO(n){Ao(VO,"Distribution",n)}class Ls extends $u{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Y2 extends Ls{apply(e,t){return rn(e,t)}}Y2.className="Zeros";fe(Y2);class Mx extends Ls{apply(e,t){return Ei(e,t)}}Mx.className="Ones";fe(Mx);class Z2 extends Ls{constructor(e){if(super(),typeof e!="object")throw new j(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new j(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return se(()=>q(wt(this.value),Ei(e,t)))}getConfig(){return{value:this.value}}}Z2.className="Constant";fe(Z2);class Q2 extends Ls{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Oc(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Q2.className="RandomUniform";fe(Q2);class J2 extends Ls{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new st(`randomNormal does not support dType ${t}.`);return Jp(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}J2.className="RandomNormal";fe(J2);class eC extends Ls{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new st(`truncatedNormal does not support dType ${t}.`);return qv(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}eC.className="TruncatedNormal";fe(eC);class tC extends Ls{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return se(()=>{if(e.length!==2||e[0]!==e[1])throw new j("Identity matrix initializer can only be used for 2D square matrices.");return q(this.gain,tx(e[0]))})}getConfig(){return{gain:this.gain}}}tC.className="Identity";fe(tC);function WO(n,e="channelsLast"){let t,s;if(Zt(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=fi(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=fi(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=fi(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class as extends Ls{constructor(e){if(super(),e.scale<0)throw new j(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,UO(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,GO(this.distribution),this.seed=e.seed}apply(e,t){const s=WO(e),r=s[0],i=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(r+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new st(`${this.getClassName()} does not support dType ${t}.`);return qv(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*o);return Oc(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}as.className="VarianceScaling";fe(as);class zx extends as{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return as.className}}zx.className="GlorotUniform";fe(zx);class Bx extends as{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return as.className}}Bx.className="GlorotNormal";fe(Bx);class Vx extends as{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return as.className}}Vx.className="HeNormal";fe(Vx);class Ux extends as{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return as.className}}Ux.className="HeUniform";fe(Ux);class Gx extends as{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return as.className}}Gx.className="LeCunNormal";fe(Gx);class Wx extends as{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return as.className}}Wx.className="LeCunUniform";fe(Wx);class nC extends Ls{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return se(()=>{if(e.length<2)throw new st("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=Q(e.slice(0,-1)),r=e[e.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(r,s),Math.min(r,s)],a=Jp(o,0,1,t,this.seed),u=tP.qr(a,!1);let l=u[0];const c=u[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return l=q(l,c.sign()),s<r&&(l=l.transpose()),q(wt(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}nC.className="Orthogonal";fe(nC);const o0={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function a0(n,e={}){return Gc(n,Ts.getMap().classNameMap,e,"initializer")}function Ut(n){return Px(n)}function zt(n){if(typeof n=="string"){const e=n in o0?o0[n]:n;if(e==="GlorotNormal")return new Bx;if(e==="GlorotUniform")return new zx;if(e==="HeNormal")return new Vx;if(e==="HeUniform")return new Ux;if(e==="LeCunNormal")return new Gx;if(e==="LeCunUniform")return new Wx;{const t={};return t.className=e,t.config={},a0(t)}}else return n instanceof Ls?n:a0(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Pm(n){return Array.isArray(n)&&Array.isArray(n[0])}function nd(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Ye(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new j(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function yt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new j(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sd(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const u0="Variable";class HO{constructor(e,t="float32",s=u0,r=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=G2(),s=s??u0,this.originalName=H2(s),this.name=K2(this.originalName),this.trainable_=r,this.constraint=i,this.val=tF(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),KO(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function KO(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function Lm(n){return n.map(e=>e.read())}function Hx(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class an{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Tr{constructor(e,t,s,r,i,o,a){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=a,this.id=G2(),o!=null&&(this.originalName=H2(o),this.name=K2(this.originalName)),this.rank=t.length}}let jO=0;class ef{constructor(e,t){this.callArgs=t,this.id=jO++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let XO=0;class at extends $u{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=XO++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=Or(s)+"_"+Qp(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),s=[i].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new _s(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new j(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Kn(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Kn(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new hr(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new hr(`Layer ${this.name} is not connected, no input to return.`);return Kn(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new hr(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new hr(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Kn(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Ct(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Ct(this.inputSpec);if(t.length!==s.length)throw new j(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const i=t[r],o=s[r];if(o==null)continue;const a=i.rank;if(o.ndim!=null&&a!==o.ndim)throw new j(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new j(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new j(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new j(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const u=i.shape;for(const l in o.axes){const h=Number(l),c=o.axes[l],d=h>=0?u[h]:u[u.length+h];if(c!=null&&[c,null].indexOf(d)===-1)throw new j(`Input ${r} is incompatible with layer ${this.name}: expected axis ${h} of input shape to have value ${c} but got shape ${u}.`)}}if(o.shape!=null)for(let u=0;u<o.shape.length;++u){const l=o.shape[u],h=i.shape[u];if(l!=null&&h!=null&&l!==h)throw new j(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=Ct(e),r=ZO(e),i=QO(e);if(r===i)throw new j("Arguments to apply() must be all SymbolicTensors or all Tensors");return so(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of Ct(e))o.push(a.shape);this.build(Kn(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let o=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,o);const a=Ct(o),u=[];for(let l of a)s.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(o=Kn(u),this.activityRegularizer!=null)throw new st("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=qO(e),a=this.computeOutputShape(o);let u;const l=YO(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?u=a.map((h,c)=>new Tr(l,h,this,Ct(e),t,this.name,c)):u=new Tr(l,a,this,Ct(e),t,this.name),this.addInboundNode(e,u,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new st("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new hr(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new hr(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new _s(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return sd(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Lm(e?this.trainableWeights:this.weights)}setWeights(e){se(()=>{const t=this.weights;if(t.length!==e.length)throw new j(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=Lm(t);for(let i=0;i<r.length;++i){const o=r[i],a=t[i],u=e[i];if(!ct(o.shape,u.shape))throw new j(`Layer weight shape ${o.shape} not compatible with provided weight shape ${u.shape}`);s.push([a,u])}Hx(s)})}addWeight(e,t,s,r,i,o,a,u){if(this._addedWeightNames.indexOf(e)!==-1)throw new j(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=u!=null?u():zt("zeros"));const l=r.apply(t,s),h=new HO(l,s,e,o,a);return l.dispose(),i!=null&&this.addLoss(()=>i.apply(h.read())),o==null&&(o=!0),o?this._trainableWeights.push(h):this._nonTrainableWeights.push(h),h}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Ct(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),i=Ct(t),o=Ct(r);if(i.length!==o.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let a=0;a<i.length;a++)i[a].kerasMask=o[a]}addInboundNode(e,t,s,r,i,o,a=null){const u=Ct(e);t=Ct(t),s=Ct(s),r=Ct(r),i=nd(i),o=nd(o);const l=[],h=[],c=[];for(const d of u)l.push(d.sourceLayer),h.push(d.nodeIndex),c.push(d.tensorIndex);new ef({outboundLayer:this,inboundLayers:l,nodeIndices:h,tensorIndices:c,inputTensors:u,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:o},a);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function qO(n){n=Ct(n);const e=[];for(const t of n)e.push(t.shape);return Kn(e)}function YO(n){return"float32"}function sC(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const o=s.inputTensors[i],a=s.inboundLayers[i],u=s.nodeIndices[i],l=sC(o,a,u);for(const h of l)r.indexOf(h)===-1&&r.push(h)}return r}}}function ZO(n){let e=!0;for(const t of Ct(n))if(!(t instanceof Tr)){e=!1;break}return e}function QO(n){let e=!0;for(const t of Ct(n))if(t instanceof Tr){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class jc extends at{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Qp("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new j("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new j("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new j("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new Tr(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new ef({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new j(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}jc.className="InputLayer";fe(jc);function JO(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new j("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new jc({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function eM(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Ne(e,n.dtype)}catch{throw new j(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class li{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof li)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=eM(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new j(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Tr){if(this.id2Value[e.id]==null)throw new j(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new j(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Tr){if(this.id2Value[e.id]==null)throw new j(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new j(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&ut(this.id2Mask)}}const rd=new B2,id=new B2;function tM(n){rd!=null&&rd.setMaxEntries(n),id!=null&&id.setMaxEntries(n)}function Ku(n,e,t,s){const r=t==null?!1:t.training,i=Array.isArray(n),o=i?n:[n],a=o.map(f=>f.name),u=[],l=e.names();for(const f of a)l.indexOf(f)!==-1?u.push(e.getValue(f)):u.push(null);const h=a.join(",")+"|"+e.names().sort().join(",");let c=rd.get(h),d;if(c==null){const f=nM(o,e);c=f.sorted,d=f.recipientCounts,rd.put(h,c),id.put(h,d)}d={},r||Object.assign(d,id.get(h));const p=new li(e);for(let f=0;f<c.length;++f){const g=c[f],m=g.sourceLayer;if(m instanceof jc)continue;const b=[],x=[],v=[];let w=!1;for(const C of g.inputs){const T=p.getValue(C),R=p.getMask(C);b.push(T),x.push(R),R!=null&&(w=!0),r||(d[C.name]--,d[C.name]===0&&!e.hasKey(C)&&a.indexOf(C.name)===-1&&!T.isDisposed&&C.sourceLayer.stateful!==!0&&v.push(T))}w&&(t=t||{},t.mask=x[0]);const S=Ct(m.apply(b,t));let k=null;m.supportsMasking&&(k=m.computeMask(b,x));const E=rM(g),I=Array.isArray(E)?E:[E];for(let C=0;C<I.length;++C){p.hasKey(I[C])||p.add(I[C],S[C],Array.isArray(k)?k[0]:k);const T=a.indexOf(I[C].name);T!==-1&&(u[T]=S[C])}r||ut(v)}return p.disposeMasks(),i?u:u[0]}function nM(n,e){L(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=l0(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:o,recipientMap:a}=l0(i,e);for(const u of o)r.has(u.name)||(t.push(u),r.add(u.name));for(const u in a)s[u]==null&&(s[u]=new Set),a[u].forEach(l=>s[u].add(l))}}return{sorted:t,recipientCounts:sM(s)}}function sM(n){const e={};for(const t in n)e[t]=n[t].size;return e}function l0(n,e){const t=new Set,s=[],r={};for(const a of e.names())t.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(t.has(a.name)){i.pop();continue}const u=o[o.length-1]===i.length-1;if(a.inputs.length===0||u)i.pop(),s.push(a),t.add(a.name),u&&o.pop();else{o.push(i.length-1);for(const l of a.inputs)r[l.name]==null&&(r[l.name]=new Set),r[l.name].add(a.name),!t.has(l.name)&&i.push(l)}}return{sorted:s,recipientMap:r}}function rM(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iM=ne();iM.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,tM);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Kx(n,e){return se(()=>$n(Ge(q(n,n),e,!0)))}class Xc extends $u{getConfig(){return{}}}class rC extends Xc{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return se(()=>{const t=Kx(e,this.axis),s=xs(t,0,this.maxValue);return q(e,We(s,we(on(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}rC.className="MaxNorm";fe(rC);class iC extends Xc{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return se(()=>We(e,we(on(),Kx(e,this.axis))))}getConfig(){return{axis:this.axis}}}iC.className="UnitNorm";fe(iC);class oC extends Xc{apply(e){return Ro(e)}}oC.className="NonNeg";fe(oC);class aC extends Xc{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return se(()=>{const t=Kx(e,this.axis),s=we(q(this.rate,xs(t,this.minValue,this.maxValue)),q(1-this.rate,t));return q(e,We(s,we(on(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}aC.className="MinMaxNorm";fe(aC);const c0={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function un(n){return Px(n)}function h0(n,e={}){return Gc(n,Ts.getMap().classNameMap,e,"constraint")}function ln(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in c0?c0[n]:n,config:{}};return h0(t)}else return n instanceof Xc?n:h0(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function zi(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const o=i;e.push(o.data()),t.push(r),s.push(o)}}if(e.length>0){const r=await Promise.all(e);for(let i=0;i<r.length;++i)n[t[i]]=r[i][0];ut(s)}}function uC(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var d0;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(d0||(d0={}));const oM=125;class Cl{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class aM{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class uM extends Cl{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const i=t[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const a=se(()=>we(this.totals[r],q(i,s)));this.totals[r]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:se(()=>{const r=q(We(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),wr(t[s])}))}}class lM extends Cl{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const u=o[a];e.push(u.data()),t.push(i),s.push(a)}}const r=await Promise.all(e);for(let i=0;i<r.length;++i)this.history[t[i]][s[i]].dispose(),this.history[t[i]][s[i]]=r[i][0]}}class cM extends Cl{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||f2,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=oM),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");pm(this.yieldEvery)&&(this.maybeWait=SO(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await zi(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await zi(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await zi(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await zi(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await zi(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):pm(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await zi(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await zi(e),await this.trainEnd(e))}}function lC(n,e){return n==null&&(n={}),n instanceof Cl?[n]:Array.isArray(n)&&n[0]instanceof Cl?n:Ct(n).map(s=>new cM(s,e))}class $s{constructor(){}static registerCallbackConstructor(e,t){L(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),$s.checkForDuplicate(t),$s.constructors[e]==null&&($s.constructors[e]=[]),$s.constructors[e].push(t)}static checkForDuplicate(e){for(const t in $s.constructors)$s.constructors[+t].forEach(r=>{if(r===e)throw new j("Duplicate callback constructor.")})}static clear(){$s.constructors={}}static createCallbacks(e){const t=[];for(const s in $s.constructors){const r=+s;e>=r&&t.push(...$s.constructors[r])}return t.map(s=>new s)}}$s.constructors={};function cC(n,e,t,s,r,i,o,a,u){const l=new lM,h=[new uM,...$s.createCallbacks(e)];n!=null&&h.push(...n),h.push(l);const c=new aM(h);return c.setParams({epochs:t,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:e,doValidation:a,metrics:u}),{callbackList:c,history:l}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Gr(n,e={},t=!1){return Gc(n,Ts.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function od(n,e){return se(()=>{n.dtype!=="float32"&&(n=Ne(n,"float32"));const t=Ge(Hc(n),e,!0),s=Ip(t.shape,on()),r=$n(Ti(t,s));return We(n,r)})}function tf(n,e){return se(()=>Jt(Hc(je(e,n)),-1))}function jx(n,e){return se(()=>Jt(_n(je(e,n)),-1))}function Xx(n,e){return se(()=>{const t=je(n,e),s=xs(_n(n),on(),Number.MAX_VALUE),r=_n(We(t,s));return q(100,Jt(r,-1))})}function hM(n,e){return se(()=>{const t=xs(e,on(),Number.MAX_VALUE),s=kr(we(1,t)),r=xs(n,on(),Number.MAX_VALUE),i=kr(we(1,r));return Jt(Hc(je(s,i)),-1)})}function dM(n,e){return se(()=>{const t=Ti(0,je(1,q(n,e)));return Jt(Hc(t),-1)})}function pM(n,e){return se(()=>{const t=Ti(0,je(1,q(n,e)));return Jt(t,-1)})}function fM(n,e){return se(()=>{const t=Ge(q(n,e),-1),s=Hs(q(je(1,n),e),-1);return Ti(0,we(1,je(s,t)))})}function mM(n,e){return se(()=>{const t=Math.log(2),s=je(e,n),r=je(we(s,Lc(q(-2,s))),t);return Jt(r,-1)})}function Sl(n,e,t=!1){return se(()=>{if(t)e=wx(e);else{const s=Ge(e,e.shape.length-1,!0);e=We(e,s)}return e=xs(e,on(),1-on()),jt(Ge(q(Ne(n,"float32"),kr(e)),e.shape.length-1))})}function ad(n,e,t=!1){return se(()=>{const s=Ne(Tp(PO(n)),"int32");e=xs(e,on(),1-on());const r=e.shape,i=Z(Lv(s,r[r.length-1]),r);return Sl(i,e,t)})}function gM(n,e){if(!ct(n.shape,e.shape))throw new j(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return se(()=>{const t=Ro(e),s=jt(_n(e));return we(je(t,q(e,n)),Dv($r(s)))})}function nf(n,e){return se(()=>{let t;return t=xs(e,on(),1-on()),t=kr(We(t,je(1,t))),Jt(gM(n,t),-1)})}function xM(n,e){return se(()=>{const t=xs(n,on(),1),s=xs(e,on(),1);return Ge(q(n,kr(We(t,s))),-1)})}function bM(n,e){return se(()=>{const t=kr(we(on(),e));return Jt(je(e,q(n,t)),-1)})}function hC(n,e){return se(()=>{const t=od(n,-1),s=od(e,-1),r=q(t,s);return jt(Ge(r,-1))})}const ud={meanSquaredError:tf,meanAbsoluteError:jx,meanAbsolutePercentageError:Xx,meanSquaredLogarithmicError:hM,squaredHinge:dM,hinge:pM,categoricalHinge:fM,logcosh:mM,categoricalCrossentropy:Sl,sparseCategoricalCrossentropy:ad,binaryCrossentropy:nf,kullbackLeiblerDivergence:xM,poisson:bM,cosineProximity:hC};function Uf(n){if(typeof n=="string"){if(n in ud)return ud[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new j(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function dC(n,e){return se(()=>{const t=q(.5,Ps(e)),s=vr(ys(e,t),n.dtype);return Jt(Ir(n,s),-1)})}function pC(n,e){return se(()=>vr(Ir(xl(n,-1),xl(e,-1)),"float32"))}function yM(n,e){return se(()=>Ne(Ge(qr(Ir(n,1),Ir(e,1))),"float32"))}function wM(n,e){return se(()=>Ne(Ge(qr(Ir(n,0),Ir(e,1))),"float32"))}function vM(n,e){return se(()=>{const t=yM(n,e),s=wM(n,e),r=we(t,s);return Ne(On(ys(r,0),We(t,r),0),"float32")})}function CM(n,e){return nf(n,e)}function SM(n,e){return n.rank===e.rank&&(n=Mc(n,[n.rank-1])),e=xl(e,-1),e.dtype!==n.dtype&&(e=Ne(e,n.dtype)),Ne(Ir(n,e),"float32")}const IM=tf,$M=tf,kM=jx,TM=jx,EM=Xx,RM=Xx,fC=Sl,NM=hC,mC=ad,ld={binaryAccuracy:dC,categoricalAccuracy:pC,precision:vM,categoricalCrossentropy:fC,sparseCategoricalCrossentropy:mC,mse:IM,MSE:$M,mae:kM,MAE:TM,mape:EM,MAPE:RM,cosine:NM};function _M(n){if(typeof n=="string"&&n in ld)return ld[n];if(typeof n!="string"&&n!=null)return n;throw new j(`Unknown metric ${n}`)}function wh(n){if(dr(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(ud))if(ud[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(ld))if(ld[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function DM(n){const e={Adagrad:()=>Ho.adagrad(.01),Adadelta:()=>Ho.adadelta(1,.95,on()),Adam:()=>Ho.adam(.001,.9,.999,on()),Adamax:()=>Ho.adamax(.002,.9,.999,on(),0),RMSProp:()=>Ho.rmsprop(.001,.9,0,on()),SGD:()=>Ho.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new j(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const p0=1*1024*1024;function f0(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!Om(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>p0&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${p0}.`)}}function Om(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!Om(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!Om(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function AM(n,e,t,s=console.log){const r=PM(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(h=>Math.floor(e*h)));let o;if(!r){i.push("Receives inputs"),o=[];for(const h in n.nodesByDepth)o.push(...n.nodesByDepth[h])}s("_".repeat(e)),cd(i,t,s),s("=".repeat(e));const a=n.layers;for(let h=0;h<a.length;++h)r?LM(a[h],t,s):OM(a[h],t,o,s),s((h===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const u=FM(n),l=sd(n.nonTrainableWeights);s(`Total params: ${u+l}`),s(`Trainable params: ${u}`),s(`Non-trainable params: ${l}`),s("_".repeat(e))}function FM(n){let e;return n.collectedTrainableWeights!=null?e=sd(n.collectedTrainableWeights):e=sd(n.trainableWeights),e}function PM(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let i=!1;for(const o of r.inboundNodes)if(s.indexOf(o)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function cd(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function LM(n,e,t){let s,r;try{r=n.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,o=n.getClassName(),a=[`${i} (${o})`,r,s,n.countParams().toString()];cd(a,e,t)}function OM(n,e,t,s){let r,i;try{i=n.inboundNodes.map(c=>JSON.stringify(c.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const o=[];for(const c of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(c)===-1))for(let d=0;d<c.inboundLayers.length;++d){const p=c.inboundLayers[d].name,f=c.nodeIndices[d],g=c.tensorIndices[d];o.push(`${p}[${f}][${g}]`)}const a=n.name,u=n.getClassName(),l=o.length===0?"":o[0],h=[`${a} (${u})`,i,r,n.countParams().toString(),l];cd(h,e,s);for(let c=1;c<o.length;++c)cd(["","","","",o[c]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gC(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function Mm(n,e){if(n===null)return null;if(typeof n=="string")return Ki(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];gC(e,r,i)?t.push(i):t.push(Mm(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const i=Ki(s);t[i]=Mm(r,i)}}return t}}function zm(n,e){if(n==null)return null;if(typeof n=="string")return Or(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];gC(e,r,i)?t.push(i):t.push(zm(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],i=Or(s);(s==="name"||s==="className")&&typeof r=="string"?t[i]=r:t[i]=zm(r,s)}return t}}/** @license See the LICENSE file. */const xC="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const MM=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class zs extends at{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const x=this.getClassName().toLowerCase();this.name=Qp(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],pi(this.inputs).length!==this.inputs.length)throw new j(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);pi(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const x of this.outputs){const v=x.sourceLayer,w=x.nodeIndex,S=x.tensorIndex;this.outputLayers.push(v),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(S)}for(const x of this.inputs){const v=x.sourceLayer,w=x.nodeIndex,S=x.tensorIndex;dr(w===0,"input layer has >1 nodes"),dr(S===0,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(S)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){const v=this.inputLayers[x];if(!(v instanceof jc))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${x} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(const x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);const t={},s={},r={},i={},o={},a=[],u=(x,v,w,S,k,E)=>{(S==null||k==null||E==null)&&(S=x.sourceLayer,k=x.nodeIndex,E=x.tensorIndex);const I=S.inboundNodes[k];if(w.indexOf(I)!==-1)throw new _s(`The tensor ${x.name} at layer "${S.name}" is part of a cycle.`);if(v.indexOf(I)!==-1)return;this.containerNodes.add(zs.nodeKey(S,k)),S.id in o||(o[S.id]=Object.keys(o).length),w.indexOf(I)===-1&&w.push(I);const C=I.inboundLayers.length;for(let T=0;T<C;T++){const R=I.inputTensors[T],P=I.inboundLayers[T],D=I.nodeIndices[T],F=I.tensorIndices[T];u(R,v,w,P,D,F)}for(v.push(I);w.indexOf(I)>=0;)w.splice(w.indexOf(I),1);a.push(I)},l=[],h=[];for(const x of this.outputs)u(x,l,h);const c=a.slice().reverse();for(const x of c){s[x.id]=x,x.id in t||(t[x.id]=0);let v=t[x.id];const w=r[x.outboundLayer.id]==null?0:r[x.outboundLayer.id];v=Math.max(v,w),r[x.outboundLayer.id]=v,i[x.outboundLayer.id]=x.outboundLayer,t[x.id]=v;for(let S=0;S<x.inboundLayers.length;S++){const k=x.inboundLayers[S],E=x.nodeIndices[S],I=k.inboundNodes[E],C=t[I.id]==null?0:t[I.id];t[I.id]=Math.max(v+1,C),s[I.id]=I}}const d={};for(const x in t){const v=t[x];v in d||(d[v]=[]),d[v].push(s[x])}const p={};for(const x in r){const v=r[x];v in p||(p[v]=[]),p[v].push(i[x])}let f=Object.keys(p).map(x=>parseInt(x,10)).sort(xh);this.layers=[];for(const x of f){const v=p[x];v.sort((w,S)=>{const k=o[w.id],E=o[S.id];return k<E?-1:k>E?1:0});for(const w of v)w instanceof zs&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=p,f=Object.keys(d).map(x=>parseInt(x,10)).sort(xh);const g=this.inputs.slice(),m=[];for(const x of f)for(const v of d[x]){const w=v.outboundLayer;if(w!=null){for(const S of v.inputTensors)if(g.indexOf(S)===-1)throw new _s(`Graph disconnected: cannot obtain value for tensor ${S} at layer "${w.name}". The following previous layers were accessed without issue: ${m}`);for(const S of v.outputTensors)g.push(S);m.push(w.name)}}this.nodesByDepth=d;const b=this.layers.map(x=>x.name);for(const x of b){const v=b.filter(w=>w===x).length;if(v!==1)throw new _s(`The name "${x}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new ef({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new j("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const i=MM(e);i&&this.parseWeights(e);for(const a of this.layers)for(const[u,l]of a.weights.entries()){const h=i?`${l.name.split("/").slice(0,-1).join("/")+"/"}${u}`:l.originalName;if(s[h]!=null)throw new j(`Duplicate weight name: ${h}`);s[h]=l,r++}const o=[];for(const a in e){let u=a;if(s[a]==null){const l=a.split("/");u=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(s[u]!=null)o.push([s[u],e[a]]);else if(t)throw new j(`Provided weight data has no target variable: ${a}`);delete s[u]}if(t){const a=[];for(const u in s)a.push(u);if(a.length>0)throw new j(`${a.length} of ${r} weights are not set: ${a}`)}Hx(o)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!r.includes(o)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${xC}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=zm(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return se(()=>{e=Ct(e);const s=new li;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return Ku(this.outputs,s,t)})}computeMask(e,t){return se(()=>{e=Ct(e);let s;return t==null?s=go(null,e.length):s=Ct(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=nd(e);if(t.length!==this.inputLayers.length)throw new j(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<t.length;a++){const u=this.inputLayers[a],l=t[a],h=u.name+"_0_0";s[h]=l}const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(xh);if(r.length>1)for(const a of r){const u=this.nodesByDepth[a];for(const l of u){const h=l.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(h.id)!==-1)continue;const c=[];for(let g=0;g<l.inboundLayers.length;g++){const m=l.inboundLayers[g],b=l.nodeIndices[g],x=l.tensorIndices[g],v=`${m.name}_${b}_${x}`,w=s[v];c.push(w)}const d=h.computeOutputShape(Kn(c)),p=nd(d),f=h.inboundNodes.indexOf(l);for(let g=0;g<p.length;g++){const m=`${h.name}_${f}_${g}`;s[m]=p[g]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const u=this.outputLayers[a],l=this.outputLayersNodeIndices[a],h=this.outputLayersTensorIndices[a],c=`${u.name}_${l}_${h}`;o.push(c)}for(let a=0;a<o.length;a++){const u=o[a];dr(u in s),i.push(s[u])}return Kn(i)}runInternalGraph(e,t){t==null&&(t=go(null,e.length));const s={};for(let u=0;u<this.inputs.length;++u){const l=this.inputs[u],h=e[u],c=t[u];s[l.id]=[h,c]}const r=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(xh);for(const u of r){const l=this.nodesByDepth[u];for(const h of l){const c=h.outboundLayer,d=h.inputTensors,p=h.outputTensors,f=new Array;for(const g of d)g.id in s&&f.push(s[g.id]);if(f.length===d.length){let g={},m,b,x,v;if(h.callArgs!=null&&(g=h.callArgs),f.length===1){const[w,S]=f[0];g.mask==null&&(g.mask=S),x=Ct(c.call(w,g)),v=Ct(c.computeMask(w,S)),m=[w],b=[S]}else m=f.map(w=>w[0]),b=f.map(w=>w[1]),g.mask==null&&(g.mask=b),x=Ct(c.call(m,g)),v=Ct(c.computeMask(m,b));if(c.activityRegularizer)throw new st("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<p.length;++w){const S=p[w],k=x[w],E=v[w];s[S.id]=[k,E]}}}}const i=[],o=[],a=[];for(const u of this.outputs){dr(u.id in s,`Could not compute output ${u.name} : ${u.id}`);const[l,h]=s[u.id];a.push(l.shape),i.push(l),o.push(h)}return[i,o,a]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof zs?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=zs.nodeKey(r,i);this.containerNodes.has(o)&&(t[o]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new j("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new j(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new j(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return se(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=zs.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const a=o.getClassName(),u=o.getConfig(),l=[];for(let c=0;c<o.inboundNodes.length;c++){const d=o.inboundNodes[c],p=zs.nodeKey(o,c);let f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){const g=[];for(let m=0;m<d.inboundLayers.length;m++){const b=d.inboundLayers[m],x=d.nodeIndices[m],v=d.tensorIndices[m],w=zs.nodeKey(b,x);let S=t[w];S==null&&(S=0),g.push([b.name,S,v,f])}l.push(g)}}}const h={};h.name=o.name,h.className=a,h.config=u,h.inboundNodes=l,s.push(h)}e.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],u=this.inputLayersNodeIndices[o],l=zs.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let h=t[l];h==null&&(h=0);const c=this.inputLayersTensorIndices[o];r.push([a.name,h,c])}e.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],u=this.outputLayersNodeIndices[o],l=zs.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let h=t[l];h==null&&(h=0);const c=this.outputLayersTensorIndices[o];i.push([a.name,h,c])}return e.outputLayers=i,e}static fromConfig(e,t,s={},r=!1){const i={},o={};function a(m,b){m.name in o?o[m.name].push(b):o[m.name]=[b]}function u(m,b){const x=[];let v;for(const w of b){const S=w[0],k=w[1],E=w[2];if(v=w[3]==null?{}:w[3],!(S in i)){a(m,b);return}const I=i[S];if(I.inboundNodes.length<=k){a(m,b);return}const C=I.inboundNodes[k];x.push(C.outputTensors[E])}x.length>0&&m.apply(Kn(x),v)}function l(m){const b=m.name,x=Gr(m,t.customObjects!=null?t.customObjects:{});x.setFastWeightInitDuringBuild(r),i[b]=x,m.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new j(`Corrupted configuration, expected array for nodeData: ${w}`);a(x,w)})}const h=t.name,c=t.layers;for(const m of c)l(m);for(;!CO(o);)for(const m of c){const b=i[m.name];if(b.name in o){const x=o[b.name];delete o[b.name];for(const v of x)u(b,v)}}const d=[],p=[],f=t.inputLayers;for(const m of f){const b=m[0],x=m[1],v=m[2];dr(b in i);const S=i[b].inboundNodes[x].outputTensors;d.push(S[v])}const g=t.outputLayers;for(const m of g){const b=m[0],x=m[1],v=m[2];dr(b in i);const S=i[b].inboundNodes[x].outputTensors;p.push(S[v])}return new e({inputs:d,outputs:p,name:h})}get stateful(){if(this._stateful)throw new j("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){se(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zM(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function bC(n,e){return zM(n,e,"classWeight")}async function yC(n,e,t,s){if(t!=null){const r=se(()=>{if(n.shape.length===1)return no(n);if(n.shape.length===2){if(n.shape[1]>1)return xl(n,1);if(n.shape[1]===1)return Z(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());ut(r);const o=[];return i.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(t[a])}),os(o,"float32")}else return null}function BM(n,e){return q(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const VM=32;function wC(n,e){let t,s;const r=e;t=r.xs,s=r.ys,L(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=m0("input",n.inputNames,t),o=m0("output",n.outputNames,s),a=i[0].shape[0];L(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),L(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let u=0;u<i.length;u++)L(i[u].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[u]} has ${i[u].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let u=0;u<o.length;u++)L(o[u].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[u]} has ${o[u].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function m0(n,e,t){if(t instanceof sn)return[t];if(Array.isArray(t))return L(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new j(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function UM(n){if(n.length===3)throw new st("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function GM(n,e,t){const s=t.batchesPerEpoch!=null;if(L(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),L(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),L(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),L(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),L(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let i,o;if(r)if(g0(t.validationData))L(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const m=UM(t.validationData);i=m.xs,o=m.ys}const a=n.makeTrainFunction(),u=n.getDedupedMetricsNames();let l;r?l=u.slice().concat(u.map(m=>"val_"+m)):l=u.slice();const h=lC(t.callbacks,t.yieldEvery),c=t.verbose==null?1:t.verbose,{callbackList:d,history:p}=cC(h,c,t.epochs,null,null,WM(e,t),null,r,l);d.setModel(n),n.history=p,await d.onTrainBegin(),n.stopTraining_=!1;let f=t.initialEpoch==null?0:t.initialEpoch,g=await e.iterator();for(;f<t.epochs;){const m={};await d.onEpochBegin(f);let b=0,x=0;for(s||(g=await e.iterator());!s||b<t.batchesPerEpoch;){const v=await g.next();if(s&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(v.value!=null){const{xs:w,ys:S}=wC(n,v.value),k={};k.batch=x,k.size=w[0].shape[0],await d.onBatchBegin(x,k);const E=[];if(t.classWeight!=null){const T=bC(t.classWeight,n.outputNames);for(let R=0;R<T.length;++R)E.push(await yC(S[R],null,T[R]))}const I=w.concat(S).concat(E),C=a(I);ut(I);for(let T=0;T<u.length;++T){const R=u[T],P=C[T];k[R]=P,wr(P)}await d.onBatchEnd(x,k),uC(k),x++,b++}if(s?b>=t.batchesPerEpoch:v.done){if(r){let w;g0(t.validationData)?w=Ct(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):w=Ct(n.evaluate(i,o,{batchSize:t.validationBatchSize==null?VM:t.validationBatchSize,verbose:0}));for(let S=0;S<n.metricsNames.length;++S)m[`val_${n.metricsNames[S]}`]=w[S]}break}if(n.stopTraining_)break}if(await d.onEpochEnd(f,m),f++,n.stopTraining_)break}return await d.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function WM(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function g0(n){return typeof n.iterator=="function"}function HM(n){return typeof n.next=="function"}async function KM(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let i=[];if(t.verbose>0)throw new st("Verbose mode is not implemented yet.");L(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=HM(e)?e:await e.iterator();let a=0,u=0;for(;!s||u<t.batches;){const l=await o.next();if(i=se(()=>{if(l.value){const{xs:h,ys:c}=wC(n,l.value),d=h.concat(c),p=se(()=>r(d));if(ut(d),u===0)for(let g=0;g<p.length;++g)i.push(wt(0));const f=d[0].shape[0];for(let g=0;g<p.length;++g){const m=p[g],b=i[g];i[g]=se(()=>we(i[g],q(f,m))),u>0&&ut(b)}ut(p),a+=f,++u}return i}),l.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<i.length;++l){const h=i[l];i[l]=We(i[l],a),ut(h)}return Kn(i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Gf(n){L(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Vu(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>ro(s,e,t-e)):ro(n,e,t-e)}function Bm(n,e){return se(()=>n==null?null:Array.isArray(n)?n.map(t=>Bm(t,e)):X2(n,e.dtype==="int32"?e:Ne(e,"int32")))}function Wf(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function vC(n){const e=[];n instanceof sn&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(Wc(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function Ms(n,e){if(n==null)return;const t=[];if(e instanceof sn)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const i=e[r];t.push(i.id)}const s=[];if(n instanceof sn)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];t.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function jM(n){return n instanceof sn}function Vm(n){return Array.isArray(n)}function x0(n){return!jM(n)&&!Vm(n)}function b0(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(Vm(n)&&n.length>0)o=!0;else if(x0(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new j(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let i;if(x0(n)){n=n,i=[];for(const o of e){if(n[o]==null)throw new j(`No data provided for "${o}". Need data for each key in: ${e}`);i.push(n[o])}}else if(Vm(n)){if(n=n,n.length!==e.length)throw new j(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new j(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=vC(i),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new j(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${a.shape}`);for(let u=0;u<t[o].length;++u){if(u===0&&!s)continue;const l=a.shape[u],h=t[o][u];if(h!=null&&h>=0&&l!==h)throw new j(`${r} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function XM(n,e,t){const s=pi(n.map(i=>i.shape[0]));s.sort();const r=pi(e.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new j(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new j(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!ct(s,r))throw new j(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function qM(n,e,t){const s=[tf,nf,Sl];for(let r=0;r<n.length;++r){const i=n[r],o=e[r],a=t[r];if(o!=null){if(o===Sl&&i.shape[i.shape.length-1]===1)throw new j(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const u=i.shape.slice(1),l=a.slice(1);for(let h=0;h<u.length;++h){const c=u[h],d=l[h];if(d!=null&&c!==d)throw new j(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function y0(n,e,t,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new j(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new j(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new j(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let u=0;u<t[o].length;++u){if(u===0&&!s)continue;const l=a.shape[u],h=t[o][u];if(h!=null&&h!==l)throw new j(`Error when checking ${r}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function YM(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let i=t.hasOwnProperty(r)?t[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const ZM="layers-model";class ua extends zs{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new j("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");AM(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=DM(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Ri))throw new j("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new j(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(Uf(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new j(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>Uf(a))}else{const o=Uf(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],u=this.outputNames[o];this.feedOutputNames.push(u),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],so("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=YM(e.metrics,this.outputNames),i=(o,a,u)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([u,o])};so("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=r[o];(l=>{const h="";let c,d,p;for(const f of l){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){const m=this.internalOutputShapes[o];m[m.length-1]===1||this.lossFunctions[o]===nf?["accuracy","acc"].indexOf(f)!==-1?d=dC:["crossentropy","ce"].indexOf(f)!==-1&&(d=CM):this.lossFunctions[o]===ad?["accuracy","acc"].indexOf(f)!==-1?d=SM:["crossentropy","ce"].indexOf(f)!==-1&&(d=mC):["accuracy","acc"].indexOf(f)!==-1?d=pC:["crossentropy","ce"].indexOf(f)!==-1&&(d=fC);let b;["accuracy","acc"].indexOf(f)!==-1?b="acc":["crossentropy","ce"].indexOf(f)!==-1&&(b="ce"),p=d,c=h+b}else p=_M(f),c=h+wh(f);let g;so(c,()=>{g=p}),i(o,c,g)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;Gf(r);const o=this.standardizeUserDataXY(e,t,!0,r);try{const a=o[0].concat(o[1]);this.makeTestFunction();const u=this.testFunction,l=this.testLoop(u,a,r,s.verbose,s.steps);return Kn(l)}finally{Ms(o[0],e),Ms(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),KM(this,e,t)}checkNumSamples(e,t,s,r="steps"){let i;if(s!=null){if(i=null,t!=null)throw new j(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new j(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new j("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],i=this.retrieveSymbolicTensors(r),o=new li;if(e instanceof sn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new j(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)o.add(this.inputs[u],e[u])}else for(const u of this.inputs){const l=e[u.name];if(l==null)throw new j(`No value is provided for the model's input ${u.name}`);o.add(u,l)}const a=Ku(i,o);return s?a:a[0]}retrieveSymbolicTensors(e){const t=go(null,e.length);let s=e.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],o=i.map(a=>a.name);for(let a=0;a<e.length;++a){const u=o.indexOf(e[a]);if(u!==-1&&(t[a]=i[u],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((i,o)=>{i==null&&r.push(e[o])}),new j(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return se(()=>{const r=this.checkNumSamples(e);if(s)throw new st("Verbose predictLoop() is not implemented yet.");const i=Wf(r,t),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)se(()=>{const l=i[a][0],h=i[a][1],c=Vu(e,l,h),d=[];if(Array.isArray(c))for(let f=0;f<c.length;++f)d.push({key:this.inputs[f],value:c[f]});else d.push({key:this.inputs[0],value:c});const p=new li(d);return Ku(this.outputs,p)}).forEach((l,h)=>o[h].push(l));return Kn(o.map(a=>Xn(a,0)))})}predict(e,t={}){const s=vC(e);y0(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return Gf(r),this.predictLoop(s,r)}finally{Ms(s,e)}}predictOnBatch(e){y0(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new _s("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===ad?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(e=b0(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=b0(t,this.feedOutputNames,i,!1,"target"),XM(e,t),qM(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new j(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,i=!0,o){const[a,u]=this.standardizeUserDataXY(e,t,i,o);if(s!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){const h=bC(r,this.outputNames);l=[];for(let c=0;c<h.length;++c)l.push(await yC(u[c],null,h[c]))}return[a,u,l]}testLoop(e,t,s,r=0,i){return se(()=>{const o=this.checkNumSamples(t,s,i,"steps"),a=[];if(r>0)throw new st("Verbose mode is not implemented yet.");if(i!=null)throw new st("steps mode in testLoop() is not implemented yet");{const u=Wf(o,s),l=os(Zs(0,o));for(let h=0;h<u.length;++h){const c=u[h][0],d=u[h][1],p=ro(l,c,d-c),f=Bm(t,p),g=e(f);if(h===0)for(let m=0;m<g.length;++m)a.push(wt(0));for(let m=0;m<g.length;++m){const b=g[m];a[m]=we(a[m],q(d-c,b))}}for(let h=0;h<a.length;++h)a[h]=We(a[h],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let i=r;if(s0(e,r)>1){const o=s0(e.slice(0,s),r);i+=`_${o}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const c=[];for(let g=0;g<this.inputs.length;++g)c.push({key:this.inputs[g],value:s[g]});const d=new li(c),p=Ku(this.outputs,d,{training:!0});let f;for(let g=0;g<this.lossFunctions.length;++g){const m=this.lossFunctions[g];let b=m(r[g],p[g]);i[g]!=null&&(b=BM(b,i[g]));const x=Jt(b);t.push(x),g===0?f=b:f=we(f,b)}for(let g=0;g<this.metricsTensors.length;++g){let m;if(this.outputs.length>1&&g<this.outputs.length)m=t[g];else{const b=this.metricsTensors[g][0],x=this.metricsTensors[g][1];m=Jt(b(r[x],p[x]))}wr(m),o.push(m)}return f=Jt(f),this.calculateLosses().forEach(g=>{f=we(f,g)}),f},u=this.collectedTrainableWeights.map(c=>c.read());return[this.optimizer_.minimize(a,!0,u)].concat(o)}}makeTestFunction(){this.testFunction=e=>se(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let l=0;l<this.inputs.length;++l)o.push({key:this.inputs[l],value:r[l]});const a=new li(o),u=Ku(this.outputs,a);for(let l=0;l<this.lossFunctions.length;++l){const h=this.lossFunctions[l],c=Jt(h(i[l],u[l]));l===0?s=c:s=we(s,c),t.push(s)}for(let l=0;l<this.metricsTensors.length;++l){const h=this.metricsTensors[l][0],c=this.metricsTensors[l][1],d=Jt(h(i[c],u[c]));t.push(d)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,o,a,u,l,h,c,d;try{const p=s.batchSize==null?32:s.batchSize;Gf(p);const g=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,p);r=g[0],i=g[1],d=g[2];let m=!1,b;if(s.validationData!=null&&s.validationData.length>0){if(m=!0,s.validationData.length===2)u=s.validationData[0],l=s.validationData[1];else throw s.validationData.length===3?new st("validationData including sample weights is not supported yet."):new j(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const T=await this.standardizeUserData(u,l,null,null,!0,p);h=T[0],c=T[1],b=h.concat(c)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){m=!0;const C=Math.floor(r[0].shape[0]*(1-s.validationSplit)),T=r[0].shape[0];h=Vu(r,C,T),o=r,r=Vu(r,0,C),c=Vu(i,C,T),a=i,i=Vu(i,0,C),b=h.concat(c)}else s.validationSteps!=null&&(m=!0);const x=r.concat(i).concat(d);this.checkTrainableWeightsConsistency();const v=this.makeTrainFunction(),w=this.getDedupedMetricsNames();let S,k;m?(this.makeTestFunction(),S=this.testFunction,k=w.slice().concat(w.map(C=>"val_"+C))):(S=null,b=[],k=w.slice());const E=lC(s.callbacks,s.yieldEvery);return await this.fitLoop(v,x,w,p,s.epochs,s.verbose,E,S,b,s.shuffle,k,s.initialEpoch,null,null)}finally{this.isTraining=!1,Ms(r,e),Ms(i,t),Ms(o,e),Ms(a,t),Ms(h,u),Ms(c,l),d!=null&&ut(d)}}async fitLoop(e,t,s,r,i,o,a,u,l,h,c,d,p,f){r==null&&(r=32),i==null&&(i=1),h==null&&(h=!0),d==null&&(d=0);let g=!1;if(u!=null&&l!=null&&(g=!0),f!=null&&(g=!0,p==null))throw new j("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,p,"steps_per_epoch");let b;m!=null&&(b=Zs(0,m)),o==null&&(o=1);const{callbackList:x,history:v}=cC(a,o,i,d,m,p,r,g,c);x.setModel(this),this.history=v,await x.onTrainBegin(),this.stopTraining_=!1;for(let w=d;w<i;++w){await x.onEpochBegin(w);const S={};if(p!=null)throw new st("stepsPerEpoch mode is not implemented yet.");{if(h==="batch")throw new st("batch shuffling is not implemneted yet");h&&zR(b);const k=os(b),E=Wf(m,r);for(let I=0;I<E.length;++I){const C={};if(await x.onBatchBegin(I,C),se(()=>{const T=E[I][0],R=E[I][1],P=ro(k,T,R-T);C.batch=I,C.size=R-T;const D=Bm(t,P),F=e(D);for(let z=0;z<s.length;++z){const _=s[z],B=F[z];C[_]=B,wr(B)}if(I===E.length-1&&g){const z=this.testLoop(u,l,r);for(let _=0;_<s.length;++_){const B=s[_],N=z[_];wr(N),S["val_"+B]=N}}}),await x.onBatchEnd(I,C),uC(C),this.stopTraining_)break}k.dispose()}if(await x.onEpochEnd(w,S),this.stopTraining_)break}return await x.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return GM(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],i=s[1],a=this.makeTrainFunction()(r.concat(i)),u=[];for(const l of a){const h=await l.data();u.push(h[0])}return ut(a),Ms(s[0],e),Ms(s[1],t),Kn(u)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let o=0;o<r.length;++o)s&&!r[o].trainable||t.push({name:r[o].originalName,tensor:i[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=zy().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-zy().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Or(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Or(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=Or(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Or(wh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Or(wh(e)));{const e={};for(const t in this.metrics)e[t]=Or(wh(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Mm(e.optimizer_config),s=Gr(t);let r;if(typeof e.loss=="string")r=Ki(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(o=>Ki(o));else if(e.loss!=null){r={};for(const o in e.loss)r[o]=Ki(e.loss[o])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(o=>Ki(o));else if(e.metrics!=null){i={};for(const o in e.metrics)i[o]=Ki(e.metrics[o])}this.compile({loss:r,metrics:i,optimizer:s})}async save(e,t){if(typeof e=="string"){const l=_N(e);if(l.length===0)throw new j(`Cannot find any save handlers for URL '${e}'`);if(l.length>1)throw new j(`Found more than one (${l.length}) save handlers for URL '${e}'`);e=l[0]}if(e.save==null)throw new j("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await Vy(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:ZM,generatedBy:`TensorFlow.js tfjs-layers v${xC}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const l="optimizer",{data:h,specs:c}=await Vy(await this.optimizer.getWeights(),l);s.specs.push(...c),s.data=NN([s.data,h])}return this.userDefinedMetadata!=null&&(f0(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,e.save(a)}setUserDefinedMetadata(e){f0(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}ua.className="Model";fe(ua);class CC extends ua{}CC.className="Functional";fe(CC);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Il extends ua{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Qp("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new j(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Il||e instanceof ua;let s;if(t){if(s=e,s.outputs.length!==1)throw new j("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new j("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new j("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=JO({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new j(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new j("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=sC(this.outputs[0])}this.inboundNodes=[],new ef({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:go(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(yt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ua({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new _s("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new _s("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new _s("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new _s("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let i,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new j("Legacy serialization format not supported yet.");i=t}else L(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,o=t;const a=new e(o);if(!(a instanceof Il))throw new st(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const u of i){const h=Gr(u,void 0,r);r&&h.setFastWeightInitDuringBuild(!0),a.add(h)}return a}set stopTraining(e){if(this.model==null)throw new j("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new j("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}Il.className="Sequential";fe(Il);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Tn=class extends $u{getConfig(){return{}}};class SC extends Tn{apply(e,t=1){return OO(e,t)}}SC.className="elu";fe(SC);class IC extends Tn{apply(e){return Uv(e)}}IC.className="selu";fe(IC);class $C extends Tn{apply(e){return Ro(e)}}$C.className="relu";fe($C);class kC extends Tn{apply(e){return se(()=>wl(6,Ro(e)))}}kC.className="relu6";fe(kC);class TC extends Tn{apply(e){return e}}TC.className="linear";fe(TC);class EC extends Tn{apply(e){return Cu(e)}}EC.className="sigmoid";fe(EC);class RC extends Tn{apply(e){return zO(e)}}RC.className="hardSigmoid";fe(RC);class NC extends Tn{apply(e){return Lc(e)}}NC.className="softplus";fe(NC);class _C extends Tn{apply(e){return MO(e)}}_C.className="softsign";fe(_C);class DC extends Tn{apply(e){return Cp(e)}}DC.className="tanh";fe(DC);let qx=class extends Tn{apply(e,t=-1){return wx(e,t)}};qx.className="softmax";fe(qx);class AC extends Tn{apply(e,t=-1){return Av(e,t)}}AC.className="logSoftmax";fe(AC);class FC extends Tn{apply(e){return se(()=>se(()=>{const t=Math.sqrt(2),s=q(.5,we(1,Rv(We(e,t))));return q(e,s)}))}}FC.className="gelu";fe(FC);class PC extends Tn{apply(e){return se(()=>q(.5,q(e,we(1,Cp(q($n(We(2,Math.PI)),we(e,q(.044715,po(e,3)))))))))}}PC.className="gelu_new";fe(PC);class LC extends Tn{apply(e){return se(()=>q(e,Cp(Lc(e))))}}LC.className="mish";fe(LC);class OC extends Tn{apply(e,t=1){return se(()=>q(Cu(q(e,t)),e))}}OC.className="swish";fe(OC);function yi(n){return n.getClassName()}function Hf(n,e={}){return Gc(n,Ts.getMap().classNameMap,e,"activation")}function wi(n){if(n==null){const e={};return e.className="linear",e.config={},Hf(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},Hf(e)}else return n instanceof Tn?n:Hf(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function QM(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class MC extends $u{}class zC extends MC{constructor(e){super(),QM(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return se(()=>{let t=rn([1]);return this.hasL1&&(t=we(t,Ge(q(this.l1,_n(e))))),this.hasL2&&(t=we(t,Ge(q(this.l2,Hc(e))))),Z(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}zC.className="L1L2";fe(zC);const w0={l1l2:"L1L2"};function Tt(n){return Px(n)}function v0(n,e={}){return Gc(n,Ts.getMap().classNameMap,e,"regularizer")}function Bt(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in w0?w0[n]:n,config:{}};return v0(t)}else return n instanceof MC?n:v0(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class BC extends at{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Ye(e);let s=Ro(e);return this.maxValue!=null&&(s=xs(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}BC.className="ReLU";fe(BC);class VC extends at{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Ye(e);return rx(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}VC.className="LeakyReLU";fe(VC);class UC extends at{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=zt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Bt(e.alphaRegularizer),this.alphaConstraint=ln(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new j(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=yt(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new an({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=Ye(e),cx(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Ut(this.alphaInitializer),alphaRegularizer:Tt(this.alphaRegularizer),alphaConstraint:un(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}UC.className="PReLU";fe(UC);let GC=class extends at{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new st(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Ye(e);return $p(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};GC.className="ELU";fe(GC);class WC extends at{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=Ye(e);return q(s,Ne(ys(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}WC.className="ThresholdedReLU";fe(WC);class HC extends at{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new qx().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return se(()=>{let s=Ye(e);const r=t.mask;if(r!=null){const i=q(je(Ei(s.shape),Ne(r,s.dtype)),wt(-1e9));s=we(s,i)}return this.axis instanceof Array?this.axis.length>1?$r(je(s,Fv(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}HC.className="Softmax";fe(HC);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function la(n,e,t){if(typeof n=="number")return go(n,e);if(n.length!==e)throw new j(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!AO(r))throw new j(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function Ks(n,e,t,s,r=1){if(n==null)return n;const i=e+(e-1)*(r-1);let o;return t==="same"?o=n:o=n-i+1,Math.floor((o+s-1)/s)}function pr(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+bi([t-e,0]);else if(s==="same")n=n*e;else throw new j(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Yx(n,e){return se(()=>(Zt(e),e==="channelsFirst"?mt(n,[0,2,3,1]):n))}function KC(n,e){return se(()=>(Zt(e),e==="channelsFirst"?mt(n,[0,2,3,4,1]):n))}function JM(n,e,t,s=1,r="valid",i,o=1){return se(()=>{if(i==null&&(i=Qs()),Zt(i),n.shape.length!==3)throw new j(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new j(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new j(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(i==="channelsFirst"&&(n=mt(n,[0,2,1])),r==="causal")throw new st("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=Iv(n,e,s,r==="same"?"same":"valid","NWC",o);return t!=null&&(a=nr(a,t)),a})}function C0(n,e,t,s=[1,1],r="valid",i,o,a=null){return se(()=>{if(i==null&&(i=Qs()),Zt(i),n.rank!==3&&n.rank!==4)throw new j(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new j(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let u=Yx(n,i);if(r==="causal")throw new st("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=uF({x:u,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:a}),i==="channelsFirst"&&(u=mt(u,[0,3,1,2])),u})}function ez(n,e,t,s=[1,1,1],r="valid",i,o){return se(()=>{if(i==null&&(i=Qs()),Zt(i),n.rank!==4&&n.rank!==5)throw new j(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new j(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=KC(n,i);if(r==="causal")throw new st("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=aD(a,e,s,r==="same"?"same":"valid","NDHWC",o),t!=null&&(a=nr(a,t)),i==="channelsFirst"&&(a=mt(a,[0,4,1,2,3])),a})}class sf extends at{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",sf.verifyArgs(t),this.rank=e,pn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new st(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=la(t.kernelSize,e,"kernelSize"),this.strides=la(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,ws(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Zt(this.dataFormat),this.activation=wi(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=zt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ln(t.biasConstraint),this.biasRegularizer=Bt(t.biasRegularizer),this.activityRegularizer=Bt(t.activityRegularizer),this.dilationRate=la(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new j(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new j(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new j(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(dr("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Lx(e.kernelSize,"number",1,3))throw new j(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:yi(this.activation),useBias:this.useBias,biasInitializer:Ut(this.biasInitializer),biasRegularizer:Tt(this.biasRegularizer),activityRegularizer:Tt(this.activityRegularizer),biasConstraint:un(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class ku extends sf{constructor(e,t){super(e,t),this.kernel=null,ku.verifyArgs(t),this.filters=t.filters,pn(this.filters,"filters"),this.kernelInitializer=zt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ln(t.kernelConstraint),this.kernelRegularizer=Bt(t.kernelRegularizer)}build(e){e=yt(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new j(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return se(()=>{e=Ye(e);let s;const r=this.bias==null?null:this.bias.read(),i=U2(this.activation.getClassName());if(i!=null&&this.rank===2)s=C0(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=JM(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=C0(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=ez(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new st("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=yt(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<s.length;++i){const o=Ks(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(o)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Ut(this.kernelInitializer),kernelRegularizer:Tt(this.kernelRegularizer),kernelConstraint:un(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new j(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class qc extends ku{constructor(e){super(2,e),qc.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Lx(e.kernelSize,"number",1,2))throw new j(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}qc.className="Conv2D";fe(qc);class Yc extends ku{constructor(e){super(3,e),Yc.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new j(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Yc.className="Conv3D";fe(Yc);class jC extends qc{constructor(e){if(super(e),this.inputSpec=[new an({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new j(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=yt(e),e.length!==4)throw new j("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new j("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new an({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return se(()=>{let s=Ye(e);if(s.shape.length!==4)throw new j(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const u=r[o],l=r[a],h=this.kernelSize[0],c=this.kernelSize[1],d=this.strides[0],p=this.strides[1],f=pr(u,d,h,this.padding),g=pr(l,p,c,this.padding),m=[i,f,g,this.filters];this.dataFormat!=="channelsLast"&&(s=mt(s,[0,2,3,1]));let b=$v(s,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(b=mt(b,[0,3,1,2])),this.bias!=null&&(b=nr(b,this.bias.read(),this.dataFormat)),this.activation!=null&&(b=this.activation.apply(b)),b})}computeOutputShape(e){e=yt(e);const t=e.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return t[s]=this.filters,t[r]=pr(t[r],u,o,this.padding),t[i]=pr(t[i],l,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}jC.className="Conv2DTranspose";fe(jC);class XC extends Yc{constructor(e){if(super(e),this.inputSpec=[new an({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new j(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=yt(e),e.length!==5)throw new j("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new j("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new an({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return se(()=>{let s=Ye(e);if(s.shape.length!==5)throw new j(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a,u;this.dataFormat==="channelsFirst"?(u=2,o=3,a=4):(u=1,o=2,a=3);const l=r[u],h=r[o],c=r[a],d=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],g=this.strides[0],m=this.strides[1],b=this.strides[2],x=pr(l,g,d,this.padding),v=pr(h,m,p,this.padding),w=pr(c,b,f,this.padding),S=[i,x,v,w,this.filters];this.dataFormat!=="channelsLast"&&(s=mt(s,[0,2,3,4,1]));let k=cD(s,this.kernel.read(),S,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(k=mt(k,[0,4,1,2,3])),this.bias!==null&&(k=nr(k,this.bias.read(),this.dataFormat)),this.activation!==null&&(k=this.activation.apply(k)),k})}computeOutputShape(e){e=yt(e);const t=e.slice();let s,r,i,o;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,o=4):(s=4,r=1,i=2,o=3);const a=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],h=this.strides[0],c=this.strides[1],d=this.strides[2];return t[s]=this.filters,t[r]=pr(t[r],h,a,this.padding),t[i]=pr(t[i],c,u,this.padding),t[o]=pr(t[o],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}XC.className="Conv3DTranspose";fe(XC);class qC extends ku{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new j("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new j("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new j(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=zt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Bt(t.depthwiseRegularizer),this.depthwiseConstraint=ln(t.depthwiseConstraint),this.pointwiseInitializer=zt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Bt(t.pointwiseRegularizer),this.pointwiseConstraint=ln(t.pointwiseConstraint)}build(e){if(e=yt(e),e.length<this.rank+2)throw new j(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new j(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new an({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return se(()=>{e=Ye(e);let s;if(this.rank===1)throw new st("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=mt(e,[0,2,3,1])),s=Gv(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=nr(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=mt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Ut(this.depthwiseInitializer),e.pointwiseInitializer=Ut(this.pointwiseInitializer),e.depthwiseRegularizer=Tt(this.depthwiseRegularizer),e.pointwiseRegularizer=Tt(this.pointwiseRegularizer),e.depthwiseConstraint=un(this.depthwiseConstraint),e.pointwiseConstraint=un(this.pointwiseConstraint),e}}qC.className="SeparableConv";class YC extends qC{constructor(e){super(2,e)}}YC.className="SeparableConv2D";fe(YC);class rf extends ku{constructor(e){super(1,e),rf.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Lx(e.kernelSize,"number",1,1))throw new j(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}rf.className="Conv1D";fe(rf);class ZC extends at{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return se(()=>{if(e=Ye(e),this.dataFormat==="channelsLast"){const s=yh(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return yh(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=yh(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return yh(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}ZC.className="Cropping2D";fe(ZC);class QC extends at{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Zt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,NO(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return se(()=>{let s=Ye(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=mt(s,[0,2,3,1]);const i=this.size[0]*r[2],o=this.size[1]*r[3],a=this.interpolation==="nearest"?Br.resizeNearestNeighbor(s,[i,o]):Br.resizeBilinear(s,[i,o]);return mt(a,[0,3,1,2])}else{const i=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?Br.resizeNearestNeighbor(s,[i,o]):Br.resizeBilinear(s,[i,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}QC.className="UpSampling2D";fe(QC);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tz(n,e,t=[1,1],s="valid",r,i){return se(()=>{r==null&&(r=Qs()),Zt(r);let o=Yx(n,r);if(n.rank!==4)throw new j(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new j(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=Jg(o,e,t,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(o=mt(o,[0,3,1,2])),o})}class JC extends sf{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=zt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ln(e.depthwiseConstraint),this.depthwiseRegularizer=Bt(e.depthwiseRegularizer)}build(e){if(e=yt(e),e.length<4)throw new j(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new j(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return se(()=>{e=Ye(e);let s=tz(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=nr(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=yt(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=Ks(t,this.kernelSize[0],this.padding,this.strides[0]),o=Ks(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,i,o]:[e[0],i,o,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Ut(this.depthwiseInitializer),e.depthwiseRegularizer=Tt(this.depthwiseRegularizer),e.depthwiseConstraint=un(this.depthwiseRegularizer),e}}JC.className="DepthwiseConv2D";fe(JC);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function eS(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new j("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function tS(n,e,t,s=!1,r,i,o=!1,a=!1){return se(()=>{const u=e.shape.length;if(u<3)throw new j(`Input should be at least 3D, but is ${u}D.`);const l=[1,0].concat(Zs(2,u));e=mt(e,l),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Ne(Ne(r,"bool"),"float32"),r.rank===u-1&&(r=Hn(r,-1)),r=mt(r,l)),s&&(e=fo(e,0),r!=null&&(r=fo(r,0)));const h=[];let c,d=t;const p=e.shape[0],f=mo(e);let g;r!=null&&(g=mo(r));for(let b=0;b<p;++b){const x=f[b],v=se(()=>n(x,d));if(r==null)c=v[0],d=v[1];else{const w=se(()=>{const S=g[b],k=je(Ps(S),S),E=we(q(v[0],S),q(d[0],k)),I=d.map((C,T)=>we(q(v[1][T],S),q(C,k)));return{output:E,newStates:I}});c=w.output,d=w.newStates}a&&h.push(c)}let m;return a&&(m=Yr(h,1)),[c,m,d]})}class Ni extends at{constructor(e){super(e);let t;if(e.cell==null)throw new j("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new Jx({cells:e.cell}):t=e.cell,t.stateSize==null)throw new j("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new an({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Zs(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Pm(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const i=[];for(const o of t)i.push([e[0],o]);return[r].concat(i)}else return r}computeMask(e,t){return se(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new st("Constants support is not implemented in RNN yet.");Pm(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new an({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!ct(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new j(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new an({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){se(()=>{if(!this.stateful)throw new hr("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new j("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>rn([s,r])):this.states_=[rn([s,this.cell.stateSize])];else if(e==null)ut(this.states_),this.keptStates!=null&&(ut(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>rn([s,r])):this.states_[0]=rn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new j(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):ut(this.states_);for(let r=0;r<this.states_.length;++r){const i=e[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[s,o];if(!ct(i.shape,a))throw new j(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>wr(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=eS(e,s,r,this.numConstants);e=i.inputs,s=i.initialState,r=i.constants;let o=[],a=[];if(s!=null){t.initialState=s,o=o.concat(s),this.stateSpec=[];for(const l of s)this.stateSpec.push(new an({shape:l.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(t.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof Tr){const l=[e].concat(o),h=this.inputSpec.concat(a),c=this.inputSpec;this.inputSpec=h;const d=super.apply(l,t);return this.inputSpec=c,d}else return super.apply(e,t)}call(e,t){return se(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let i=t==null?null:t.initialState;e=Ye(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new j(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},l=tS((f,g)=>{const m=this.cell.call([f].concat(g),a);return[m[0],m.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),h=l[0],c=l[1],d=l[2];this.stateful&&this.resetStates(d,r);const p=this.returnSequences?c:h;return this.returnState?[p].concat(d):p})}getInitialState(e){return se(()=>{let t=rn(e.shape);return t=Ge(t,[1,2]),t=Wc(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?Am(t,[1,s]):t):this.cell.stateSize>1?[Am(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Ni.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,i=Gr(r,s);return new e(Object.assign(t,{cell:i}))}}Ni.className="RNN";fe(Ni);class of extends at{}class Zx extends of{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,pn(this.units,"units"),this.activation=wi(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=zt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=zt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=zt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Bt(e.kernelRegularizer),this.recurrentRegularizer=Bt(e.recurrentRegularizer),this.biasRegularizer=Bt(e.biasRegularizer),this.kernelConstraint=ln(e.kernelConstraint),this.recurrentConstraint=ln(e.recurrentConstraint),this.biasConstraint=ln(e.biasConstraint),this.dropout=xa([1,bi([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=xa([1,bi([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=yt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return se(()=>{if(e=e,e.length!==2)throw new j(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=vi({ones:()=>Ps(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=vi({ones:()=>Ps(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=Cr(q(e,o),this.kernel.read()):i=Cr(e,this.kernel.read()),this.bias!=null&&(i=nr(i,this.bias.read())),a!=null&&(s=q(s,a));let u=we(i,Cr(s,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:yi(this.activation),useBias:this.useBias,kernelInitializer:Ut(this.kernelInitializer),recurrentInitializer:Ut(this.recurrentInitializer),biasInitializer:Ut(this.biasInitializer),kernelRegularizer:Tt(this.kernelRegularizer),recurrentRegularizer:Tt(this.recurrentRegularizer),biasRegularizer:Tt(this.biasRegularizer),activityRegularizer:Tt(this.activityRegularizer),kernelConstraint:un(this.kernelConstraint),recurrentConstraint:un(this.recurrentConstraint),biasConstraint:un(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}Zx.className="SimpleRNNCell";fe(Zx);class nS extends Ni{constructor(e){e.cell=new Zx(e),super(e)}call(e,t){return se(()=>{this.cell.dropoutMask!=null&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return new e(t)}}nS.className="SimpleRNN";fe(nS);class Qx extends of{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new j("GRUCell does not support reset_after parameter set to true.");this.units=e.units,pn(this.units,"units"),this.activation=wi(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=wi(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=zt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=zt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=zt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Bt(e.kernelRegularizer),this.recurrentRegularizer=Bt(e.recurrentRegularizer),this.biasRegularizer=Bt(e.biasRegularizer),this.kernelConstraint=ln(e.kernelConstraint),this.recurrentConstraint=ln(e.recurrentConstraint),this.biasConstraint=ln(e.biasConstraint),this.dropout=xa([1,bi([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=xa([1,bi([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=yt(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return se(()=>{if(e=e,e.length!==2)throw new j(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=vi({ones:()=>Ps(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=vi({ones:()=>Ps(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,u,l;0<this.dropout&&this.dropout<1&&(e=q(e,i[0]));let h=Cr(e,this.kernel.read());this.useBias&&(h=nr(h,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=q(r,o[0]));const c=this.recurrentKernel.read(),[d,p]=gs(c,[2*this.units,this.units],c.rank-1),f=Cr(r,d),[g,m,b]=gs(h,3,h.rank-1),[x,v]=gs(f,2,f.rank-1);a=this.recurrentActivation.apply(we(g,x)),u=this.recurrentActivation.apply(we(m,v));const w=Cr(q(u,r),p);l=this.activation.apply(we(b,w));const S=we(q(a,r),q(we(1,jt(a)),l));return[S,S]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:yi(this.activation),recurrentActivation:yi(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ut(this.kernelInitializer),recurrentInitializer:Ut(this.recurrentInitializer),biasInitializer:Ut(this.biasInitializer),kernelRegularizer:Tt(this.kernelRegularizer),recurrentRegularizer:Tt(this.recurrentRegularizer),biasRegularizer:Tt(this.biasRegularizer),activityRegularizer:Tt(this.activityRegularizer),kernelConstraint:un(this.kernelConstraint),recurrentConstraint:un(this.recurrentConstraint),biasConstraint:un(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}Qx.className="GRUCell";fe(Qx);class sS extends Ni{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Qx(e),super(e)}call(e,t){return se(()=>{this.cell.dropoutMask!=null&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}sS.className="GRU";fe(sS);class af extends of{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,pn(this.units,"units"),this.activation=wi(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=wi(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=zt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=zt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=zt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Bt(e.kernelRegularizer),this.recurrentRegularizer=Bt(e.recurrentRegularizer),this.biasRegularizer=Bt(e.biasRegularizer),this.kernelConstraint=ln(e.kernelConstraint),this.recurrentConstraint=ln(e.recurrentConstraint),this.biasConstraint=ln(e.biasConstraint),this.dropout=xa([1,bi([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=xa([1,bi([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=yt(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;r=new(t=class extends Ls{apply(u,l){const h=i.apply([o]),c=new Mx().apply([o]),d=i.apply([o*2]);return i0(i0(h,c),d)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return se(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new j(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=vi({ones:()=>Ps(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=vi({ones:()=>Ps(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let u,l,h,c;0<this.dropout&&this.dropout<1&&(e=q(e,o[0]));let d=Cr(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=q(r,a[0])),d=we(d,Cr(r,this.recurrentKernel.read())),this.useBias&&(d=nr(d,this.bias.read()));const[p,f,g,m]=gs(d,4,d.rank-1);u=this.recurrentActivation.apply(p),l=this.recurrentActivation.apply(f),h=we(q(l,i),q(u,this.activation.apply(g))),c=this.recurrentActivation.apply(m);const b=q(c,this.activation.apply(h));return[b,b,h]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:yi(this.activation),recurrentActivation:yi(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ut(this.kernelInitializer),recurrentInitializer:Ut(this.recurrentInitializer),biasInitializer:Ut(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Tt(this.kernelRegularizer),recurrentRegularizer:Tt(this.recurrentRegularizer),biasRegularizer:Tt(this.biasRegularizer),activityRegularizer:Tt(this.activityRegularizer),kernelConstraint:un(this.kernelConstraint),recurrentConstraint:un(this.recurrentConstraint),biasConstraint:un(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}af.className="LSTMCell";fe(af);class rS extends Ni{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new af(e),super(e)}call(e,t){return se(()=>{this.cell.dropoutMask!=null&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}rS.className="LSTM";fe(rS);class Jx extends of{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return se(()=>{e=e;let s=e.slice(1);const r=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(s.splice(0,a.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const u=this.cells[a];s=r[a],a===0?o=[e[0]].concat(s):o=[o[0]].concat(s),o=u.call(o,t),i.push(o.slice(1))}s=[];for(const a of i.slice().reverse())s.push(...a);return[o[0]].concat(s)})}build(e){Pm(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{so(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const i of t.cells)r.push(Gr(i,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Lm(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,i=e.splice(r);for(let o=0;o<s.weights.length;++o)t.push([s.weights[o],i[o]])}Hx(t)}}Jx.className="StackedRNNCells";fe(Jx);function vi(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:i}=n,o=()=>i!=null?i(e(),t):q2(e(),t),a=()=>Kc(o,e,s);return!r||r<=1?wr(a().clone()):Array(r).fill(void 0).map(a).map(l=>wr(l.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var nz=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class iS extends Ni{constructor(e){if(e.unroll)throw new st("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new st("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new an({ndim:5})]}call(e,t){return se(()=>{if(this.cell.dropoutMask!=null&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new j("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return se(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],o=rn(i);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){se(()=>{if(!this.stateful)throw new hr("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new j("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>rn(i)):this.states_=[rn(i)];else if(e==null)ut(this.states_),this.keptStates!=null&&(ut(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>rn(i)):this.states_[0]=rn(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new j(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):ut(this.states_);for(let a=0;a<this.states_.length;++a){const u=e[a],l=i;if(!ct(u.shape,l))throw new j(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[a]=u}}this.states_=this.states_.map(a=>wr(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:i,strides:o,dilationRate:a}=this.cell,u=t==="channelsFirst",l=e[u?3:2],h=e[u?4:3],c=Ks(l,r[0],i,o[0],a[0]),d=Ks(h,r[1],i,o[1],a[1]);return[...e.slice(0,2),...u?[s,c,d]:[c,d,s]]}}iS.className="ConvRNN2D";class eb extends af{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:i,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,pn(this.filters,"filters"),this.kernelSize=la(s,2,"kernelSize"),this.kernelSize.forEach(u=>pn(u,"kernelSize")),this.strides=la(r||1,2,"strides"),this.strides.forEach(u=>pn(u,"strides")),this.padding=i||"valid",ws(this.padding),this.dataFormat=o||"channelsLast",Zt(this.dataFormat),this.dilationRate=la(a||1,2,"dilationRate"),this.dilationRate.forEach(u=>pn(u,"dilationRate"))}build(e){var t;e=yt(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new j(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],i=4,o=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const l=this.biasInitializer,h=this.filters;u=new(t=class extends Ls{apply(d,p){const f=l.apply([h]),g=Ei([h]),m=l.apply([h*2]);return Ox([f,g,m])}},t.className="CustomInit",t)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return se(()=>{if(e.length!==3)throw new j(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],i=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=vi({ones:()=>Ps(r),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,l=(K,U,X)=>!U||!U[X]?K:q(U[X],K);let h=l(r,u,0),c=l(r,u,1),d=l(r,u,2),p=l(r,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=vi({ones:()=>Ps(i),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let g=l(i,f,0),m=l(i,f,1),b=l(i,f,2),x=l(i,f,3);const v=3,[w,S,k,E]=gs(this.kernel.read(),a,v),[I,C,T,R]=this.useBias?gs(this.bias.read(),a):[null,null,null,null];h=this.inputConv(h,w,I,this.padding),c=this.inputConv(c,S,C,this.padding),d=this.inputConv(d,k,T,this.padding),p=this.inputConv(p,E,R,this.padding);const[P,D,F,z]=gs(this.recurrentKernel.read(),a,v);g=this.recurrentConv(g,P),m=this.recurrentConv(m,D),b=this.recurrentConv(b,F),x=this.recurrentConv(x,z);const _=this.recurrentActivation.apply(we(h,g)),B=this.recurrentActivation.apply(we(c,m)),N=we(q(B,o),q(_,this.activation.apply(we(d,b)))),O=q(this.recurrentActivation.apply(we(p,x)),this.activation.apply(N));return[O,O,N]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=nz(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const i=ho(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?nr(i,s,this.dataFormat):i}recurrentConv(e,t){return ho(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}eb.className="ConvLSTM2DCell";fe(eb);class oS extends iS{constructor(e){const t=new eb(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}oS.className="ConvLSTM2D";fe(oS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class tb extends at{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=Ye(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,i=this.getNoiseShape(s);return Kc(()=>q2(s,this.rate,i,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}tb.className="Dropout";fe(tb);class aS extends tb{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}aS.className="SpatialDropout1D";fe(aS);class uS extends at{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,pn(this.units,"units"),this.activation=wi(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=zt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=zt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ln(e.kernelConstraint),this.biasConstraint=ln(e.biasConstraint),this.kernelRegularizer=Bt(e.kernelRegularizer),this.biasRegularizer=Bt(e.biasRegularizer),this.activityRegularizer=Bt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=yt(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=yt(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=Ye(e),r=U2(this.activation.getClassName());let i;return r!=null?i=Cr(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=Cr(s,this.kernel.read()),this.bias!=null&&(i=nr(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:yi(this.activation),useBias:this.useBias,kernelInitializer:Ut(this.kernelInitializer),biasInitializer:Ut(this.biasInitializer),kernelRegularizer:Tt(this.kernelRegularizer),biasRegularizer:Tt(this.biasRegularizer),activityRegularizer:Tt(this.activityRegularizer),kernelConstraint:un(this.kernelConstraint),biasConstraint:un(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}uS.className="Dense";fe(uS);class lS extends at{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=yt(e);for(const t of e.slice(1))if(t==null)throw new j(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],fi(e,1)]}call(e,t){return se(()=>{this.invokeCallHook(e,t);let s=Ye(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=mt(s,r)}return LO(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}lS.className="Flatten";fe(lS);class cS extends at{constructor(e){super(e),this.supportsMasking=!0,this.activation=wi(e.activation)}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=Ye(e);return this.activation.apply(s)})}getConfig(){const e={activation:yi(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}cS.className="Activation";fe(cS);class hS extends at{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return se(()=>(e=Ye(e),FO(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}hS.className="RepeatVector";fe(hS);class dS extends at{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let i=1,o=null;for(let u=0;u<r.length;++u){const l=r[u];if(this.isUnknown(l))if(o===null)o=u;else throw new j("Can only specifiy one unknown dimension.");else i*=l}const a=fi(e);if(o!==null){if(i===0||a%i!==0)throw new j(s);r[o]=a/i}else if(a!==i)throw new j(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=Ye(e),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Z(s,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}dS.className="Reshape";fe(dS);class pS extends at{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Zs(1,e.dims.length+1);if(!ct(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new an({ndim:this.dims.length+1})]}computeOutputShape(e){e=yt(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return mt(Ye(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}pS.className="Permute";fe(pS);class fS extends at{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=Ye(e);return km(Jh(s,this.maskValue),-1)}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=Ye(e),o=km(Jh(s,this.maskValue),-1,!0);return q(s,Ne(o,s.dtype))})}}fS.className="Masking";fe(fS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class mS extends at{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Ct(e.inputLength))}this.inputDim=e.inputDim,pn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,pn(this.outputDim,"outputDim"),this.embeddingsInitializer=zt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Bt(e.embeddingsRegularizer),this.activityRegularizer=Bt(e.activityRegularizer),this.embeddingsConstraint=ln(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return se(()=>this.maskZero?(e=Ye(e),Jh(e,gt(e))):null)}computeOutputShape(e){if(e=yt(e),this.inputLength==null)return[...e,this.outputDim];const t=Ct(this.inputLength);if(t.length!==e.length-1)throw new j(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const i=t[r],o=e[r+1];if(i!=null&&o!=null&&i!==o)throw new j(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[s]=o),s++}}return[e[0],...t,this.outputDim]}call(e,t){return se(()=>{this.invokeCallHook(e,t);let s=Ye(e);s.dtype!=="int32"&&(s=vr(s,"int32"));const r=X2(this.embeddings.read(),Z(s,[s.size]));return Z(r,yt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ut(this.embeddingsInitializer),embeddingsRegularizer:Tt(this.embeddingsRegularizer),activityRegularizer:Tt(this.activityRegularizer),embeddingsConstraint:un(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}mS.className="Embedding";fe(mS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Fo extends at{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new st}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const i=e[e.length-t.length+r],o=t[r];if(i==null||o==null||i<0||o<0)s.push(null);else if(i===1)s.push(o);else if(o===1)s.push(i);else{if(i!==o)throw new j("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(i)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[yt(e)]),e=e,e.length<2)throw new j(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=pi(t),t.length>1)throw new j(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const o=e[i]==null?null:e[i].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=e.map(i=>i.length);e.indexOf(null)===-1&&pi(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return se(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(i=>i.rank);if(r.indexOf(null)===-1){const i=bi(r);for(let o of e){const a=o.rank;for(let u=0;u<i-a;++u)o=Wc(o,1);s.push(o)}return this.mergeFunction(s)}else{let i=!1;for(const u of e){const l=u.rank;if(l==null){const h=u.shape,c=h[0],d=h.slice(1).concat([c]);let p=Z(u,[c].concat(fi(h.slice(1))));p=mt(p,[1,0]),p=Z(p,d),s.push(p),i=!0}else if(l>1){const h=Zs(1,l).concat([0]);s.push(mt(u,h)),i=!0}else s.push(u)}let o=this.mergeFunction(s);const a=o.rank;if(i){if(a==null){const u=o.shape,l=u.length,h=u[l-1],c=[h].concat(u.slice(0,u.length-1));o=Z(mt(Z(o,[-1,h]),[1,0]),c)}else if(a>1){const u=[a-1].concat(Zs(0,a-1));o=mt(o,u)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const i=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=pi(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return se(()=>{if(t==null)return null;if(!Array.isArray(t))throw new j("`mask` should be an Array");if(!Array.isArray(e))throw new j("`inputs` should be an Array");if(t.length!==e.length)throw new j(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Hn(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=qr(s,t[r]);return s})}}class gS extends Fo{constructor(e){super(e)}mergeFunction(e){return se(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=we(t,e[s]);return t})}}gS.className="Add";fe(gS);class xS extends Fo{constructor(e){super(e)}mergeFunction(e){return se(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=q(t,e[s]);return t})}}xS.className="Multiply";fe(xS);class bS extends Fo{constructor(e){super(e)}mergeFunction(e){return se(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=we(t,e[s]);return q(1/e.length,t)})}}bS.className="Average";fe(bS);class yS extends Fo{constructor(e){super(e)}mergeFunction(e){return se(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Ti(t,e[s]);return t})}}yS.className="Maximum";fe(yS);class wS extends Fo{constructor(e){super(e)}mergeFunction(e){return se(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=wl(t,e[s]);return t})}}wS.className="Minimum";fe(wS);class vS extends Fo{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new j("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const i=e[r].slice();i.splice(this.axis,1);let o=!1;for(const a of s)if(ct(a,i)){o=!0;break}o||s.push(i)}if(s.length>1)throw new j("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return se(()=>Ox(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new j("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of t.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new j("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new j("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new j(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return se(()=>{let s=!0;if(t.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const r=[];for(let o=0;o<e.length;++o)t[o]==null?r.push(Ne(Ps(e[o]),"bool")):t[o].rank<e[o].rank?r.push(Hn(t[o],-1)):r.push(t[o]);const i=Xn(r,this.axis);return Sv(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}vS.className="Concatenate";fe(vS);function Uu(n,e){for(;n<0;)n+=e;return n}function sz(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new st("batchDot is not implemented for tensors of 4D or higher rank yet");if(L(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),L(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new st("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const i=t;return se(()=>{let o;if(s>r){o=s-r;const u=[];for(let l=0;l<o;++l)u.push(1);e=Z(e,e.shape.concat(u))}else if(r>s){o=r-s;const u=[];for(let l=0;l<o;++l)u.push(1);n=Z(n,n.shape.concat(u))}else o=0;let a;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?a=Ge(q(n,e),i[0]):a=Ge(q(mt(n,[1,0]),e),i[1]);else{const u=i[0]!==n.shape.length-1,l=i[1]===e.shape.length-1;a=ft(n,e,u,l)}if(o>0){let u;s>r?u=s+r-3:u=s-1;const l=[];for(let h=u;h<u+o;++h)l.push(h);a=Mc(a,l)}return a.shape.length===1&&(a=Hn(a,1)),a})}class CS extends Fo{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){L(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new st("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new j(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new j(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,o)=>Uu(i,e[o].shape.length)):r=[Uu(this.axes,t.shape.length),Uu(this.axes,s.shape.length)],this.normalize&&(t=od(t,r[0]),s=od(s,r[1])),sz(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[Uu(this.axes,e.length),Uu(this.axes,t.length)],s}computeOutputShape(e){L(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new st("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=t.concat(s);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}CS.className="Dot";fe(CS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class SS extends at{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=Ye(e);return Kc(()=>we(Jp(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}SS.className="GaussianNoise";fe(SS);class IS extends at{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=Ye(e);return this.rate>0&&this.rate<1?Kc(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return q(s,Jp(s.shape,1,i))},()=>s,t.training||!1):s})}}IS.className="GaussianDropout";fe(IS);class $S extends at{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ye(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return se(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Kc(()=>{const i=Ye(e),a=-1.6732632423543772*1.0507009873554805;let u=To(Oc(s),this.rate);u=vr(u,"float32");const l=((1-this.rate)*(1+this.rate*a**2))**-.5,h=-l*a*this.rate,c=we(q(i,u),q(we(u,-1),a));return we(q(c,l),h)},()=>Ye(e),t.training||!1)}return e})}}$S.className="AlphaDropout";fe($S);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $l(n,e,t,s,r,i=.001){let o;if(n.rank===2)o=O_(n,e,t,s,r,i);else if(n.rank===3)o=z_(n,e,t,s,r,i);else if(n.rank===4)o=V_(n,e,t,s,r,i);else throw new st(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function rz(n,e,t,s,r=.001){return se(()=>{const i=ax(n,s),o=i.mean,a=i.variance;return[$l(n,o,a,t,e,r),o,a]})}function iz(n,e,t,s,r=.001){return se(()=>{const i=ax(n,s),o=i.mean,a=i.variance,u=[];for(const f of Zs(0,n.rank))s.indexOf(f)!==-1?u.push(1):u.push(n.shape[f]);const l=Z(o,u),h=Z(a,u),c=e==null?null:Z(e,u),d=t==null?null:Z(t,u);return[$l(n,l,h,d,c,r),o,a]})}function oz(n,e,t,s,r=.001){return ct(s.slice().sort(),Zs(0,n.rank-1))?rz(n,e,t,s,r):iz(n,e,t,s,r)}class kS extends at{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=zt(e.betaInitializer||"zeros"),this.gammaInitializer=zt(e.gammaInitializer||"ones"),this.movingMeanInitializer=zt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=zt(e.movingVarianceInitializer||"ones"),this.betaConstraint=ln(e.betaConstraint),this.gammaConstraint=ln(e.gammaConstraint),this.betaRegularizer=Bt(e.betaRegularizer),this.gammaRegularizer=Bt(e.gammaRegularizer)}build(e){e=yt(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new j(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new an({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return se(()=>{const s=t.training==null?!1:t.training,r=Ye(e),i=r.shape,o=i.length,a=Zs(0,o),u=this.axis>=0?this.axis:this.axis+o;a.splice(u,1);const l=go(1,o);l[u]=i[u];const h=a.slice();h.sort();const c=!ct(h,Zs(0,o).slice(0,o-1)),d=()=>{if(c){const x=Z(this.movingMean.read(),l),v=Z(this.movingVariance.read(),l),w=this.center?Z(this.beta.read(),l):null,S=this.scale?Z(this.gamma.read(),l):null;return $l(r,x,v,w,S,this.epsilon)}else return $l(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return d();const[p,f,g]=oz(r,this.gamma.read(),this.beta.read(),a,this.epsilon),m=(x,v,w)=>{se(()=>{const S=1-w,k=x.read(),E=q(je(k,v),S);x.write(je(k,E))})};return(()=>{m(this.movingMean,f,this.momentum),m(this.movingVariance,g,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ut(this.betaInitializer),gammaInitializer:Ut(this.gammaInitializer),movingMeanInitializer:Ut(this.movingMeanInitializer),movingVarianceInitializer:Ut(this.movingVarianceInitializer),betaRegularizer:Tt(this.betaRegularizer),gammaRegularizer:Tt(this.gammaRegularizer),betaConstraint:un(this.betaConstraint),gammaConstraint:un(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}kS.className="BatchNormalization";fe(kS);class TS extends at{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=zt(e.betaInitializer||"zeros"),this.gammaInitializer=zt(e.gammaInitializer||"ones"),this.betaRegularizer=Bt(e.betaRegularizer),this.gammaRegularizer=Bt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=yt(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==pi(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=Ye(e),r=s.shape,i=r.length;return se(()=>{let{mean:a,variance:u}=ax(s,this.axis,!0);const l=go(1,i);for(const g of this.axis)l[g]=r[g];const h=g=>g!=null&&g.shape.length!==i?Z(g,l):g;let c=this.scale?h(this.gamma.read()):null,d=this.center?h(this.beta.read()):null;const p=[],f=[];for(let g=0;g<i;++g)this.axis.indexOf(g)!==-1?(p.push(r[g]),f.push(1)):(p.push(1),f.push(r[g]));return a=Us(a,p),u=Us(u,p),c!=null&&(c=Us(c,f)),d!=null&&(d=Us(d,f)),$l(s,a,u,d,c,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ut(this.betaInitializer),gammaInitializer:Ut(this.gammaInitializer),betaRegularizer:Tt(this.betaRegularizer),gammaRegularizer:Tt(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}TS.className="LayerNormalization";fe(TS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function az(n,e,t){return se(()=>{if(n.rank!==4)throw new j(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new j("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Qs()),t!=="channelsLast"&&t!=="channelsFirst")throw new j(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],ux(n,s)})}class ES extends at{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Qs():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new j(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new j(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new j(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new an({ndim:4})]}computeOutputShape(e){e=yt(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return se(()=>az(Ye(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}ES.className="ZeroPadding2D";fe(ES);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function uf(n,e,t,s,r,i){return se(()=>{Zt(r),W2(i),ws(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=Qs()),i==null&&(i="max"),n=Yx(n,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=ox(n,e,t,a):o=qg(n,e,t,a),r==="channelsFirst"&&(o=mt(o,[0,3,1,2])),o})}function RS(n,e,t,s,r,i){return se(()=>{Zt(r),W2(i),ws(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Qs()),i==null&&(i="max"),n=KC(n,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=$A(n,e,t,a):o=T_(n,e,t,a),r==="channelsFirst"&&(o=mt(o,[0,4,1,2,3])),o})}class NS extends at{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new j(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(pn(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new j(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);pn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,ws(this.padding),this.inputSpec=[new an({ndim:3})]}computeOutputShape(e){e=yt(e);const t=Ks(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return se(()=>{this.invokeCallHook(e,t),e=Wc(Ye(e),2);const s=this.poolingFunction(Ye(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Mc(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class _S extends NS{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Zt(i),ws(r),uf(e,t,s,r,i,"max")}}_S.className="MaxPooling1D";fe(_S);class DS extends NS{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Zt(i),ws(r),uf(e,t,s,r,i,"avg")}}DS.className="AveragePooling1D";fe(DS);class AS extends at{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new j(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];pn(this.poolSize,"poolSize"),pn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Zt(this.dataFormat),ws(this.padding),this.inputSpec=[new an({ndim:4})]}computeOutputShape(e){e=yt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Ks(t,this.poolSize[0],this.padding,this.strides[0]),s=Ks(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return se(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ye(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class FS extends AS{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Zt(i),ws(r),uf(e,t,s,r,i,"max")}}FS.className="MaxPooling2D";fe(FS);class PS extends AS{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Zt(i),ws(r),uf(e,t,s,r,i,"avg")}}PS.className="AveragePooling2D";fe(PS);class LS extends at{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new j(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];pn(this.poolSize,"poolSize"),pn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Zt(this.dataFormat),ws(this.padding),this.inputSpec=[new an({ndim:5})]}computeOutputShape(e){e=yt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Ks(t,this.poolSize[0],this.padding,this.strides[0]),s=Ks(s,this.poolSize[1],this.padding,this.strides[1]),r=Ks(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return se(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ye(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class OS extends LS{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Zt(i),ws(r),RS(e,t,s,r,i,"max")}}OS.className="MaxPooling3D";fe(OS);class MS extends LS{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Zt(i),ws(r),RS(e,t,s,r,i,"avg")}}MS.className="AveragePooling3D";fe(MS);class zS extends at{constructor(e){super(e),this.inputSpec=[new an({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new st}}class BS extends zS{constructor(e){super(e||{})}call(e,t){return se(()=>{const s=Ye(e);return Jt(s,1)})}}BS.className="GlobalAveragePooling1D";fe(BS);class VS extends zS{constructor(e){super(e||{})}call(e,t){return se(()=>{const s=Ye(e);return Hs(s,1)})}}VS.className="GlobalMaxPooling1D";fe(VS);class US extends at{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Zt(this.dataFormat),this.inputSpec=[new an({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new st}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class GS extends US{call(e,t){return se(()=>{const s=Ye(e);return this.dataFormat==="channelsLast"?Jt(s,[1,2]):Jt(s,[2,3])})}}GS.className="GlobalAveragePooling2D";fe(GS);class WS extends US{call(e,t){return se(()=>{const s=Ye(e);return this.dataFormat==="channelsLast"?Hs(s,[1,2]):Hs(s,[2,3])})}}WS.className="GlobalMaxPooling2D";fe(WS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class HS extends at{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,i=Gr(r,s);delete t.layer;const o={layer:i};return Object.assign(o,t),new e(o)}}class KS extends HS{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=yt(e),e.length<3)throw new j(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=yt(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return se(()=>(e=Ye(e),tS((o,a)=>[Ye(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}KS.className="TimeDistributed";fe(KS);function uz(n){Ao(RO,"BidirectionalMergeMode",n)}const lz="concat";class jS extends HS{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=Gr(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Gr(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?lz:e.mergeMode,uz(this.mergeMode),e.weights)throw new st("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,i;return this.returnState&&(i=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):Kn(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=eS(e,s,r,this.numConstants);if(e=i.inputs,s=i.initialState,r=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const o=[],a=[];if(s!=null){const l=s.length;if(l%2>0)throw new j("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,o.push(...s);const h=s.map(c=>new an({shape:c.shape}));this.forwardLayer.stateSpec=h.slice(0,l/2),this.backwardLayer.stateSpec=h.slice(l/2),a.push(...h)}if(r!=null)throw new st("Support for constants in Bidirectional layers is not implemented yet.");const u=o[0]instanceof Tr;for(const l of o)if(l instanceof Tr!==u)throw new j("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const l=[e].concat(o),h=this.inputSpec.concat(a),c=this.inputSpec;this.inputSpec=h;const d=super.apply(l,t);return this.inputSpec=c,d}else return super.apply(e,t)}call(e,t){return se(()=>{const s=t.initialState;let r,i;if(s==null)r=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const u=s.slice(0,s.length/2),l=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:u})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=fo(i,1));let a;return this.mergeMode==="concat"?a=Ox([r,i]):this.mergeMode==="sum"?a=we(r,i):this.mergeMode==="ave"?a=q(.5,we(r,i)):this.mergeMode==="mul"?a=q(r,i):this.mergeMode==null&&(a=[r,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){so(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),so(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=Gr(t.layer);if(delete t.layer,t.numConstants!=null)throw new st("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}jS.className="Bidirectional";fe(jS);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class XS extends at{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return se(()=>(e=Ye(e),e.dtype!=="float32"&&(e=vr(e,"float32")),we(q(e,this.scale),this.offset)))}}XS.className="Rescaling";fe(XS);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:cz,cropAndResize:hz}=Br;class qS extends at{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,i,o,a,u){return se(()=>{let l,h=!1;const c=t/o,d=s/a,p=(r+t)/o,f=(i+s)/a,g=[c,d,p,f],m=[];e.rank===3?(h=!0,l=Yr([e])):l=e;for(let S=0;S<l.shape[0];S++)m.push(g);const b=dv(m,[m.length,4]),x=vl(0,m.length,1,"int32"),w=hz(l,b,x,[r,i],"nearest");return vr(h?Ye(mo(w)):w,u)})}upsize(e,t,s,r){return se(()=>{const i=cz(e,[t,s]);return vr(i,r)})}call(e,t){return se(()=>{const s=Ye(e),r=s.dtype,i=s.shape,o=i[i.length-3],a=i[i.length-2];let u=0;o!==this.height&&(u=Math.floor((o-this.height)/2));let l=0;return a!==this.width&&(l=Math.floor((a-this.width)/2),l===0&&(l=1)),u>=0&&l>=0?this.centerCrop(s,u,l,this.height,this.width,o,a,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=yt(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}qS.className="CenterCrop";fe(qS);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function dz(n,e,t,s){let r=Ye(n);if(r.dtype!=="int32"&&(r=vr(r,"int32")),e==="int")return r;const i=r.shape;if(r.rank===0&&(r=Hn(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=Hn(r,-1)),r.rank>2)throw new j(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(e),a=r;let u;if(typeof s<"u"&&e==="count"?u=Wy(a,s,t,o):u=Wy(a,[],t,o),e!=="tfIdf")return u;if(s)return q(u,s);throw new j("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class YS extends at{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=yt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return se(()=>{e=Ye(e),e.dtype!=="int32"&&(e=vr(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new j(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=Ye(t.countWeights)}const r=Hs(e),i=Zh(e),o=ys(this.numTokens,r).bufferSync().get(0),a=To(i,0).bufferSync().get(0);if(!(o&&a))throw new j(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return dz(e,this.outputMode,this.numTokens,s)})}}YS.className="CategoryEncoding";fe(YS);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const pz=["bilinear","nearest"],S0=new Set(pz);class ZS extends at{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(S0.has(e.interpolation))this.interpolation=e.interpolation;else throw new j(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=yt(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return se(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Br.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Br.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...S0]} are supported`)})}}ZS.className="Resizing";fe(ZS);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class QS{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}QS.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class JS extends at{constructor(e){super(e),this.randomGenerator=new QS(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}JS.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const fz=["bilinear","nearest"],I0=new Set(fz);class eI extends JS{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new j(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new j(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new j(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(I0.has(s))this.interpolation=s;else throw new j(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=yt(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return se(()=>{const s=Ye(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=Oc([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Br.resizeBilinear(e,o);case"nearest":return Br.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...I0]} are supported`)}})}}eI.className="RandomWidth";fe(eI);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mz=ne();mz.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var $0;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})($0||($0={}));var k0;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(k0||(k0={}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var T0;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(T0||(T0={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Me(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&L(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gz=Zv;class lf extends Ad{nextDataId(){return lf.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new yg(this,ds())}write(e,t,s){this.firstUse&&(this.firstUse=!1,ne().get("IS_NODE")&&ps(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Ia(s[0])){const i=s.map(o=>Ur(o));r=this.write(i,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,i){this.data.set(e,{values:t,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return qs(r,i)}return Fh(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Xs(r));return Je(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Je(e.shape,e.dtype,t)}makeOutput(e,t,s){return ds().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Gn();return e(),{kernelMs:Gn()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Me([e],"where");const t=this.readSync(e.dataId);return gz(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}lf.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tI(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const xz=n=>{const{x:e}=n.inputs,t=n.backend;Me(e,"abs");let s=new Float32Array(Q(e.shape));const r=t.data.get(e.dataId).values;return s=tI(r),t.makeOutput(s,e.shape,e.dtype)},bz={kernelName:Ll,backendName:"cpu",kernelFunc:xz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qt(n){return(e,t,s,r,i)=>{const o=Ke(e,t),a=o.length,u=Be(o),l=Q(o),h=fn(i,l),c=e.length,d=t.length,p=Be(e),f=Be(t),g=xi(e,o),m=xi(t,o);if(g.length+m.length===0)for(let b=0;b<h.length;++b)h[b]=n(s[b%s.length],r[b%r.length]);else for(let b=0;b<h.length;++b){const x=$a(b,a,u),v=x.slice(-c);g.forEach(E=>v[E]=0);const w=yr(v,c,p),S=x.slice(-d);m.forEach(E=>S[E]=0);const k=yr(S,d,f);h[b]=n(s[w],r[k])}return[h,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rs(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,a=t.makeTensorInfo(s.shape,"complex64"),u=t.data.get(a.dataId);return u.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",i),imag:t.makeTensorInfo(r.shape,"float32",o)},a}const yz={kernelName:Vd,backendName:"cpu",kernelFunc:rs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hd(n,e,t="float32"){if(t==="complex64"){const r=hd(n,e,"float32"),i=hd(n,e,"float32");return rs({inputs:{real:r,imag:i},backend:n})}const s=Cn(Q(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Er(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const wz={kernelName:Ka,backendName:"cpu",kernelFunc:Er};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xo(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const vz={kernelName:cp,backendName:"cpu",kernelFunc:xo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nI(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=ko([0],t),[i,o]=Qt((a,u)=>a!==u?1:0)(e,[],n,r,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function Ci(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Er({inputs:{x:r},backend:t});const h=hd(t,r.shape,r.dtype),c=Ci({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),d=rs({inputs:{real:c,imag:h},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(c),d}if(r.dtype==="complex64"){const h=xo({inputs:{input:r},backend:t}),c=Ci({inputs:{x:h},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(h),c}if(!Cg(r.dtype,i)){const h=Er({inputs:{x:r},backend:t});return{dataId:h.dataId,shape:h.shape,dtype:i}}const o=t.data.get(r.dataId).values,[a,u,l]=nI(o,r.shape,r.dtype,i);return t.makeTensorInfo(a,u,l)}const Cz={kernelName:Aa,backendName:"cpu",kernelFunc:Ci};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hn(n,e,t,s){return t==null?({inputs:r,backend:i})=>{const{a:o,b:a}=r,u=i;Me([o,a],n);const l=u.data.get(o.dataId).values,h=u.data.get(a.dataId).values,c=o.dtype==="string"?Ys(l):l,d=o.dtype==="string"?Ys(h):h,p=s||o.dtype,[f,g]=e(o.shape,a.shape,c,d,p);return u.makeTensorInfo(g,p,f)}:({inputs:r,backend:i})=>{const{a:o,b:a}=r,u=i;if(o.dtype==="complex64"||a.dtype==="complex64"){const l=Ci({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),h=u.data.get(l.dataId),c=h.complexTensorInfos.real,d=h.complexTensorInfos.imag,p=u.data.get(c.dataId).values,f=u.data.get(d.dataId).values,g=Ci({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),m=u.data.get(g.dataId),b=m.complexTensorInfos.real,x=m.complexTensorInfos.imag,v=u.data.get(b.dataId).values,w=u.data.get(x.dataId).values,[S,k,E]=t(o.shape,a.shape,p,f,v,w),I=u.makeTensorInfo(E,"float32",S),C=u.makeTensorInfo(E,"float32",k),T=rs({inputs:{real:I,imag:C},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(I),u.disposeIntermediateTensorInfo(C),T}else{const l=u.data.get(o.dataId).values,h=u.data.get(a.dataId).values,c=s||o.dtype,[d,p]=e(o.shape,a.shape,l,h,c);return u.makeTensorInfo(p,c,d)}}}function nb(n){return(e,t,s,r,i,o)=>{const a=Ke(e,t),u=Q(a),l=a.length,h=Be(a),c=fn("float32",u),d=fn("float32",u),p=xi(e,a),f=xi(t,a),g=qs(s,r),m=qs(i,o),b=e.length,x=Be(e),v=t.length,w=Be(t);if(p.length+f.length===0)for(let S=0;S<c.length;S++){const k=S%g.length,E=S%m.length,I=n(g[k*2],g[k*2+1],m[E*2],m[E*2+1]);c[S]=I.real,d[S]=I.imag}else for(let S=0;S<c.length;S++){const k=$a(S,l,h),E=k.slice(-b);p.forEach(P=>E[P]=0);const I=yr(E,b,x),C=k.slice(-v);f.forEach(P=>C[P]=0);const T=yr(C,v,w),R=n(g[I*2],g[I*2+1],m[T*2],m[T*2+1]);c[S]=R.real,d[S]=R.imag}return[c,d,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sI=Qt((n,e)=>n+e),Sz=nb((n,e,t,s)=>({real:n+t,imag:e+s})),ba=hn(Io,sI,Sz),Iz={kernelName:Io,backendName:"cpu",kernelFunc:ba};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sb(n,e,t,s,r){const i=Q(s),o=Cn(r,t);for(let a=0;a<n.length;a++){const u=n[a];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(i>0?o[u]+=e[a]:o[u]+=1)}return o}function rI(n,e,t,s=!1){const r=n.shape[0],i=n.shape[1],o=Je([r,t],e.dtype);for(let a=0;a<r;a++)for(let u=0;u<i;u++){const l=n.get(a,u);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(s?o.set(1,a,l):e.size>0?o.set(o.get(a,l)+e.get(a,u),a,l):o.set(o.get(a,l)+1,a,l))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iI=Qt((n,e)=>n&e),$z=hn(kg,iI),kz={kernelName:kg,backendName:"cpu",kernelFunc:$z};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dr(n){return(e,t,s)=>{const r=Wt(t,e.length);for(let i=0;i<e.length;++i)r[i]=n(e[i],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function It(n,e,t){const s=Dr(e);return _i(n,s,t)}function _i(n,e,t){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;Me(o,n);const a=i,u=a.data.get(o.dataId).values;let l;if(o.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");l=Ys(u)}else l=u;const h=t||o.dtype,c=e(l,h,r);return a.makeTensorInfo(o.shape,h,c)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oI=Dr(n=>Math.ceil(n)),Tz=_i(Fa,oI),Ez={kernelName:Fa,backendName:"cpu",kernelFunc:Tz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aI(n,e,t,s){const r=Wt(t,Q(e));if(s&&t!=="string"){let i=0;n.forEach(o=>{const a=Q(o.shape);r.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a=t==="string"?Ys(o.vals):o.vals;let u=0;for(let l=0;l<o.shape[0];++l){const h=l*e[1]+i;for(let c=0;c<o.shape[1];++c)r[h+c]=a[u++]}i+=o.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uI=Qt((n,e)=>n===e?1:0),lI=hn(Zl,uI,null,"bool"),Rz={kernelName:Zl,backendName:"cpu",kernelFunc:lI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cI=Dr(n=>Math.exp(n)),hI=_i(Va,cI,"float32"),Nz={kernelName:Va,backendName:"cpu",kernelFunc:hI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dI=Dr(n=>Math.expm1(n)),_z=_i(Ua,dI),Dz={kernelName:Ua,backendName:"cpu",kernelFunc:_z};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pI=Dr(n=>Math.floor(n)),Az=_i(Ga,pI),Fz={kernelName:Ga,backendName:"cpu",kernelFunc:Az};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fI=Qt((n,e)=>Math.floor(n/e)),Pz=hn(Wa,fI,null,"int32"),Lz={kernelName:Wa,backendName:"cpu",kernelFunc:Pz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mI(n,e,t,s,r,i,o,a,u){const l=Je([s,i],t);for(let h=0;h<s;h++){const c=[];let d=0;for(let p=0;p<r;p++){const f=n[h*r+p];d+=f*o[p],c.push(f)}if(d<0||d>=u/i)throw new Error(`Invalid indices: ${c} does not index into ${a}`);for(let p=0;p<i;p++)l.values[h*i+p]=e.get(...e.indexToLoc(d*i+p))}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gI(n,e,t){const s=Je(t,n.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),a=o[0],u=o[2],l=e.locToIndex([a,u]);o[2]=e.values[l];const h=n.locToIndex(o);0<=h&&h<n.values.length&&(s.values[r]=n.values[h])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xI=Qt((n,e)=>n>e?1:0),Oz=hn(tc,xI,null,"bool"),Mz={kernelName:tc,backendName:"cpu",kernelFunc:Oz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bI=Qt((n,e)=>n>=e?1:0),zz=hn(Ha,bI,null,"bool"),Bz={kernelName:Ha,backendName:"cpu",kernelFunc:zz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yI=Qt((n,e)=>n<e?1:0),Vz=hn(sc,yI,null,"bool"),Uz={kernelName:sc,backendName:"cpu",kernelFunc:Vz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wI=Qt((n,e)=>n<=e?1:0),Gz=hn(rc,wI,null,"bool"),Wz={kernelName:rc,backendName:"cpu",kernelFunc:Gz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vI(n,e,t){const s=(e-n)/(t-1),r=Cn(t,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CI=Dr(n=>Math.log(n)),Hz=_i(Ya,CI),Kz={kernelName:Ya,backendName:"cpu",kernelFunc:Hz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SI(n,e,t,s){const r=fn(s,Q(t));for(let i=0;i<r.length;++i){const o=i*e;let a=n[o];for(let u=0;u<e;++u){const l=n[o+u];(Number.isNaN(l)||l>a)&&(a=l)}r[i]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const II=Qt((n,e)=>Math.max(n,e)),jz=hn(Qa,II),Xz={kernelName:Qa,backendName:"cpu",kernelFunc:jz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $I=Qt((n,e)=>Math.min(n,e)),qz=hn(Ja,$I),Yz={kernelName:Ja,backendName:"cpu",kernelFunc:qz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rb=Qt((n,e)=>n*e),Zz=nb((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t})),cf=hn(tu,rb,Zz),Qz={kernelName:tu,backendName:"cpu",kernelFunc:cf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kI(n,e,t){const s=$i(-1,t);return rb([],e,s,n,t)}function Jz(n){const{inputs:e,backend:t}=n,{x:s}=e;Me(s,"neg");const r=t.data.get(s.dataId).values,[i,o]=kI(r,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,i)}const eB={kernelName:mc,backendName:"cpu",kernelFunc:Jz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TI=Qt((n,e)=>n!==e?1:0),tB=hn(gc,TI,null,"bool"),nB={kernelName:gc,backendName:"cpu",kernelFunc:tB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ib(n,e,t,s,r){const i=e.length,o=Q(e),a=Be(e),u=Be(r),l=fn(t,Q(r));for(let h=0;h<o;++h){const c=$a(h,i,a),d=new Array(c.length);for(let f=0;f<d.length;f++)d[f]=c[s[f]];const p=yr(d,i,u);l[p]=n[h]}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qn(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:i}=t;Me(r,"transpose");const o=r.shape.length,a=new Array(o);for(let c=0;c<a.length;c++)a[c]=r.shape[i[c]];const u=s.data.get(r.dataId).values,l=ib(u,r.shape,r.dtype,i,a);return{dataId:s.write(l,a,r.dtype),shape:a,dtype:r.dtype}}const sB={kernelName:to,backendName:"cpu",kernelFunc:Qn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(n,e,t,s){const[r,i]=Yt(n,s),o=mn(e,"int32"),a=Cn(Q(r),o),u=Q(i);for(let l=0;l<a.length;++l){const h=l*u;let c=1;for(let d=0;d<u;++d)c*=t[h+d];a[l]=c}return{outVals:a,outShape:r,outDtype:o}}function rB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Me(r,"prod");const a=r.shape.length,u=Qe(i,r.shape),l=kt(u,a);let h=u,c=r;const d=[];l!=null&&(c=Qn({inputs:{x:r},backend:t,attrs:{perm:l}}),d.push(c),h=_t(h.length,a));const p=t.data.get(c.dataId).values,{outVals:f,outShape:g,outDtype:m}=EI(c.shape,c.dtype,p,h);let b=g;return o&&(b=qt(g,u)),d.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.makeTensorInfo(b,m,f)}const iB={kernelName:Cc,backendName:"cpu",kernelFunc:rB};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oB(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const i=$a(r,e.length,Be(e)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${t})`)}})}function aB(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function uB(n,e,t,s){const r=[];let i=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);aB(t,s);let u=1;for(let l=0;l<e.length-1;++l){u*=e[l];const h=e[l+1];for(let c=1;c<u+1;++c)a[l].push(c*h)}for(let l=0;l<n.length;++l){let h=n[l],c=n[l]+1;for(let d=0;d<t.length;++d){const p=t[d],f=d+e.length-1;if(f>=0){const g=a[f],m=g[g.length-1]-p[h];for(let b=h;b<c;++b)a[f].push(p[b+1]+m)}h=p[h],c=p[c]}c!==h&&(r.push([h,c]),i+=c-h)}return{outSplits:a,valueSlices:r,numValues:i}}function lB(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=Wt("int32",s);e.push(r),n[t].forEach((i,o)=>r[o]=i)}return e}function E0(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function cB(n,e,t,s,r,i){const o=E0(e,2)[1],a=E0(i,2)[1];let u=0;for(const l of t)for(let h=l[0];h<l[1];++h){for(let c=0;c<s;++c)r[u*a+c]=n[h*o+c];++u}}function hB(n,e,t,s,r){const i=e.slice();i[0]=r;const o=Wt(t,Q(i)),a=n.length,u=a===0?0:a/e[0];return cB(n,e,s,u,o,i),[o,i]}function RI(n,e,t,s,r,i,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(oB(i,o,u),s.length===0)throw new Error("params.rank must be nonzero");const l=s[0],{outSplits:h,valueSlices:c,numValues:d}=uB(i,o,n,l),p=lB(h),f=hB(t,s,r,c,d);return[p,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R0=2147483647;function NI(n,e,t,s,r,i,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,u=r.length===0,l=o.length===0,h=[];a||h.push(e[0]),u||h.push(r[0]),l||h.push(o[0]);for(let m=1;m<h.length;++m)if(h[m]!==h[m-1])throw new Error("starts, limits, and deltas must have the same shape");const c=h.length===0?1:h[0],d=Wt("int32",c+1);d[0]=0;for(let m=0;m<c;++m){const b=a?n[0]:n[m],x=u?s[0]:s[m],v=l?i[0]:i[m];if(v===0)throw new Error("Requires delta != 0");let w;if(v>0&&x<b||v<0&&x>b)w=0;else if(w=Math.ceil(Math.abs((x-b)/v)),w>R0)throw new Error(`Requires ((limit - start) / delta) <= ${R0}`);d[m+1]=d[m]+w}const p=d[c],f=Wt(t,p);let g=0;for(let m=0;m<c;++m){const b=d[m+1]-d[m];let x=a?n[0]:n[m];const v=l?i[0]:i[m];for(let w=0;w<b;++w)f[g++]=x,x+=v}return[d,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Is=Vs;class dd{constructor(e,t,s,r,i,o,a,u,l,h){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=g2(h),this.raggedRank=x2(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Is.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Is.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Is.VALUE_ROWIDS:return dd.getMaxWidthValueRowID(t);case Is.ROW_SPLITS:return dd.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Is[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const i=e[r+1]-e[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],i=0;for(let o=1;o<t;++o){const a=e[o];a!==r&&(r=a,i=Math.max(o-s,i),s=o)}return Math.max(t-s,i)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return _0(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;b2(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=m2(this.raggedRank,r,t);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),i=[];let o=0;for(let a=0;a<r;++a,o+=t)i.push(o);for(let a=r;a<e;++a)i.push(-1);return L(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,s,r){const i=e.length,o=[];for(let a=0;a<i-1;++a){const u=e[a+1]-e[a];let l=Math.min(r,u),h=t[a];h===-1&&(l=0);for(let c=0;c<l;++c)o.push(h),h+=s;for(let c=0;c<u-l;++c)o.push(-1)}if(i>0&&o.length!==e[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,s,r){const i=e.length,o=[];if(i===0)return[];let a=0,u=e[0];if(u>=t.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${t.length}`);let l=t[u];o.push(l);for(let h=1;h<i;++h){const c=e[h];if(c===u)l>=0&&(++a,a<r?l+=s:l=-1);else{if(a=0,u=c,c>=t.length)throw new Error(`Got nextValueRowId=${c} which is not less than ${t.length}`);l=t[c]}o.push(l)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,s,r){const i=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case Is.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,s,r);case Is.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,s,r);default:throw new Error(`Unsupported partition type: ${Is[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Is.FIRST_DIM_SIZE:return e[0];case Is.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Is.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Is[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*s[u+1];const i=_0(s,!1),o=Wt(this.valuesDType,Q(i));if(r[0]*s[0]>0){let u=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let l=1;l<=this.raggedRank;++l)u=this.calculateOutputIndex(l-1,u,r[l],s[l]);this.setOutput(this.raggedRank,u,o,i)}return[i,o]}setOutput(e,t,s,r){if(s.length===0)return;const i=this.values,o=s;let a=r.slice();a=a.slice(e+1);const u=Q(a),l=t.length;let h=this.defaultValue;if(h.length!==u&&h.length!==1){const f=this.defaultValueShape;se(()=>{const g=Z(h,f);h=il(g,a).dataSync()})}let c=0,d=0,p=0;for(let f=0;f<=l;++f){let g=f<l?t[f]:-1;if(g===p){++p;continue}if(d<p){const m=i.subarray(c*u),b=o.subarray(d*u),x=(p-d)*u;N0(b,m,x)}if(f>=l){const m=s.length;g=Math.floor(m/u)}if(g>p)if(this.defaultValue.length===1)o.subarray(p*u,g*u).fill(this.defaultValue[0]),p=g;else for(;g>p;){const m=o.slice(p*u);N0(m,h,u),++p}g<0?(c=f+1,d=p):(c=f,d=p,p=d+1)}}}function N0(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function _0(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function _I(n,e,t,s,r,i,o,a,u,l){return new dd(n,e,t,s,r,i,o,a,u,l).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DI(n,e,t,s){const r=n===e,i=n<e&&t<0,o=e<n&&t>1;if(r||i||o)return Cn(0,s);const a=Math.abs(Math.ceil((e-n)/t)),u=Cn(a,s);e<n&&t===1&&(t=-1),u[0]=n;for(let l=1;l<u.length;l++)u[l]=u[l-1]+t;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AI=Dr(n=>1/Math.sqrt(n)),dB=_i(au,AI),pB={kernelName:au,backendName:"cpu",kernelFunc:dB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zi(n,e,t,s,r,i,o,a,u,l){const h=[s/r,r],c=n.values,d=e.values;if(s===0)return Je(t,e.dtype);const p=u instanceof vn?u:Je(h,e.dtype);typeof u=="string"||typeof u=="number"?p.values.fill(u):typeof u=="boolean"&&p.values.fill(+u);for(let f=0;f<i;f++){const g=[];let m=0;for(let b=0;b<o;b++){const x=c[f*o+b];g.push(x),m+=x*a[b]}if(m<0||m>=s/r)throw new Error(`Invalid indices: ${g} does not index into ${t}`);for(let b=0;b<r;b++)l?p.values[m*r+b]+=d[f*r+b]:p.values[m*r+b]=e.rank===0?d[0]:d[f*r+b]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fB=Dr(n=>1/(1+Math.exp(-n))),FI=It(du,n=>1/(1+Math.exp(-n))),mB={kernelName:du,backendName:"cpu",kernelFunc:FI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PI(n,e,t,s,r){const i=Rx(s,e,t),o=Q(t),a=Be(s);if(i){const c=Nx(e,a);return r==="string"?n.slice(c,c+o):n.subarray(c,c+o)}const u=r==="string"?Ys(n):n,l=Je(s,r,u),h=Je(t,r);for(let c=0;c<h.size;++c){const d=h.indexToLoc(c),p=d.map((f,g)=>f+e[g]);h.set(l.get(...p),...d)}return r==="string"?O2(h.values):h.values}function bo(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:o}=s;Me(r,"slice");const[a,u]=Bc(r,i,o);_p(r,a,u);const l=t.data.get(r.dataId).values,h=PI(l,a,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,h)}const gB={kernelName:Ec,backendName:"cpu",kernelFunc:bo};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LI(n,e,t,s,r,i,o){const a=e[0],u=i[0],l=new Array(u),h=new Array(a),c=e[1];if(u===0){if(a!==0)throw new Error($2(a));const m=Wt(t,0),b=Wt(r,0);return[m,[0,c],b,l,h]}let d=!0,p=0;const f=new Array(u).fill(0);for(let m=0;m<a;++m){const b=n[m*c];if(b<0)throw new Error(k2(m,b));if(b>=u)throw new Error(T2(m,b,u));++f[b],d=d&&b>=p,p=b}let g=!0;for(let m=0;m<u;++m){const b=f[m]===0;l[m]=b,g=g&&!b,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&d){const m=n,b=s;for(let x=0;x<a;++x)h[x]=x;return[m,[a,c],b,l,h]}else{const m=f[u-1],b=Wt(t,m*c),x=Wt(r,m),v=new Array(u).fill(0);for(let w=0;w<a;++w){const S=n[w*c],k=v[S],E=(S===0?0:f[S-1])+k;v[S]++;for(let I=0;I<c;++I)b[E*c+I]=n[w*c+I];x[E]=s[w],h[w]=E}for(let w=0;w<u;++w)if(v[w]===0){const k=w===0?0:f[w-1];b[k*c+0]=w;for(let E=1;E<c;++E)b[k*c+E]=0;x[k]=o}return[b,[m,c],x,l,h]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OI(n,e,t,s,r){const i=Q(s),o=e[0],a=r.length,u=[];let l=1,h=-1;for(let m=0;m<a;++m){const b=r[m];if(b===-1){if(h!==-1)throw new Error(E2(h,m));h=m,u.push(1)}else{if(b<0)throw new Error(R2(m,b));l*=b,u.push(b)}}if(h!==-1){if(l<=0)throw new Error(N2());const m=Math.trunc(i/l);if(l*m!==i)throw new Error(_2(s,u));u[h]=m}if(Q(u)!==i)throw new Error(D2(s,u));const d=s.length,p=[];if(d>0){p[d-1]=1;for(let m=d-2;m>=0;--m)p[m]=p[m+1]*s[m+1]}const f=[];if(a>0){f[a-1]=1;for(let m=a-2;m>=0;--m)f[m]=f[m+1]*u[m+1]}const g=Wt(t,o*a);for(let m=0;m<o;++m){let b=0;for(let x=0;x<d;++x)b+=n[m*d+x]*p[x];for(let x=0;x<a;++x)g[m*a+x]=Math.trunc(b/f[x]),b%=f[x]}return[g,[o,a],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ob(n,e,t,s,r,i=!1,o=0){const a=s.length,u=[e[0],n.length/e[0]],l=u[1],c=a>0?r[a-1]+1:0;if(c<0)throw new Error(_m());const d=e.slice();d[0]=c;const p=d.reduce((v,w)=>v*w,1),f=Wt(t,p);if(a===0)return c>0&&f.fill(o),[f,d];if(c<=0)throw new Error(_m());let g=0,m=1,b=0,x=r[g];for(;;){let v=0;if(m<a){if(v=r[m],x===v){++m;continue}if(x>=v)throw new Error(A2())}if(x<0||x>=c)throw new Error(F2(x,c));x>b&&f.fill(o,b*l,x*l);for(let w=g;w<m;++w){const S=s[w];if(S<0||S>=u[0])throw new Error(P2(w,s[w],u[0]));for(let k=0;k<l;k++)f[x*l+k]+=n[S*l+k]}if(i)for(let w=0;w<l;w++)f[x*l+w]/=m-g;if(g=m,++m,b=x+1,x=v,m>a)break}return b<c&&f.fill(o,b*l,c*l),[f,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xB=Dr(n=>Math.sqrt(n)),bB=It(fu,n=>Math.sqrt(n)),yB={kernelName:fu,backendName:"cpu",kernelFunc:bB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MI=Qt((n,e)=>{const t=n-e;return t*t}),wB=hn(mu,MI),vB={kernelName:mu,backendName:"cpu",kernelFunc:wB};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zI=Dr((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),CB=_i(Bg,zI),SB={kernelName:Bg,backendName:"cpu",kernelFunc:CB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BI(n,e,t,s){const r=Je(n,e.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),a=new Array(o.length);for(let u=0;u<a.length;u++)a[u]=o[u]*t[u]+s[u];r.set(e.get(...a),...o)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IB{constructor(e,t,s,r,i,o){this.separator=Ur(e),this.nGramWidths=t,this.leftPad=Ur(s),this.rightPad=Ur(r),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,i,o){for(let a=0;a<i;++a){const u=this.getPadWidth(o),l=Math.max(0,u-a),h=Math.max(0,u-(i-(a+1))),c=o-(l+h),d=t+(l>0?0:a-u);let p=0;p+=l*this.leftPad.length;for(let x=0;x<c;++x)p+=e[d+x].length;p+=h*this.rightPad.length;const f=l+h+c-1;p+=f*this.separator.length,s[r+a]=new Uint8Array(p);const g=s[r+a];let m=0;const b=x=>x.forEach(v=>g[m++]=v);for(let x=0;x<l;++x)b(this.leftPad),b(this.separator);for(let x=0;x<c-1;++x)b(e[d+x]),b(this.separator);if(c>0){b(e[d+c-1]);for(let x=0;x<h;++x)b(this.separator),b(this.rightPad)}else{for(let x=0;x<h-1;++x)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<r;++l){let h=t[l]>=u;if(h=h&&t[l]<=s,!h)throw new Error(`Invalid split value ${t[l]}, must be in [${u}, ${s}]`);u=t[l]}if(u!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${u}`)}const i=r-1,o=Wt("int32",r);if(s===0||r===0){const u=new Array(s);for(let l=0;l<=i;++l)o[l]=0;return[u,o]}o[0]=0;for(let u=1;u<=i;++u){const l=t[u]-t[u-1];let h=0;this.nGramWidths.forEach(c=>{h+=this.getNumNGrams(l,c)}),this.preserveShort&&l>0&&h===0&&(h=1),o[u]=o[u-1]+h}const a=new Array(o[i]);for(let u=0;u<i;++u){const l=t[u];let h=o[u];if(this.nGramWidths.forEach(c=>{const d=t[u+1]-t[u],p=this.getNumNGrams(d,c);this.createNGrams(e,l,a,h,p,c),h+=p}),this.preserveShort&&h===o[u]){const c=t[u+1]-t[u];if(c===0)continue;const d=c+2*this.padWidth;this.createNGrams(e,l,a,h,1,d)}}return[a,o]}}function VI(n,e,t,s,r,i,o,a){return new IB(t,s,r,i,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $B(n,e,t,s){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let o=n.indexOf(i);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&s.push(a),n=n.subarray(o+1),o=n.indexOf(i)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const o=n.subarray(r,i);(!t||o.length!==0)&&s.push(o),r=i+1}}function UI(n,e,t){const s=n.length,r=[];let i=0,o=0;const a=new Array(s);for(let d=0;d<s;++d){const p=r.length;$B(n[d],e,t,r);const f=r.length-p;a[d]=f,i+=f,o=Math.max(o,f)}const u=Wt("int32",i*2),l=new Array(i),h=[s,o];let c=0;for(let d=0;d<s;++d)for(let p=0;p<a[d];++p)u[c*2]=d,u[c*2+1]=p,l[c]=r[c],++c;return[u,l,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GI(n,e){const t=Wt("int32",n.length);for(let s=0;s<n.length;++s)t[s]=oN(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WI=Qt((n,e)=>n-e),kB=nb((n,e,t,s)=>({real:n-t,imag:e-s})),ab=hn(gu,WI,kB),TB={kernelName:gu,backendName:"cpu",kernelFunc:ab};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HI(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=Je(t,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),o=new Array(n.rank);for(let u=0;u<o.length;u++)o[u]=i[u]%n.shape[u];const a=n.locToIndex(o);s.values[r]=n.values[a]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ju=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function KI(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const a=s-t+1,u=e-t+1,l=Math.log(a),h=.5*Math.exp(2*l/3),c=.5*Math.sqrt(l*h*(a-h)/a)*Math.sign(u-a/2),d=Math.max(t,Math.floor(e-u*h/a+c)),p=Math.min(s,Math.floor(e+(a-u)*h/a+c));KI(n,e,d,p)}const r=n[e];let i=t,o=s;for(Qo(n,t,e),ju(n[s],r)>0&&Qo(n,t,s);i<o;){for(Qo(n,i,o),i++,o--;ju(n[i],r)<0;)i=i+1;for(;ju(n[o],r)>0;)o=o-1}ju(n[t],r)===0?Qo(n,t,o):(o=o+1,Qo(n,o,s)),o<=e&&(t=o+1),e<=o&&(s=o-1)}}function jI(n,e,t,s,r){const i=e[e.length-1],[o,a]=[n.length/i,i],u=fn(t,o*s),l=fn("int32",o*s);for(let c=0;c<o;c++){const d=c*a,p=n.subarray(d,d+a);let f=new Array(p.length);p.forEach((x,v)=>f[v]={value:x,index:v}),s<f.length&&(KI(f,s),f=f.slice(0,s)),r&&f.sort(ju);const g=c*s,m=u.subarray(g,g+s),b=l.subarray(g,g+s);for(let x=0;x<s;x++)m[x]=f[x].value,b[x]=f[x].index}const h=e.slice();return h[h.length-1]=s,[Je(h,t,u),Je(h,"int32",l)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XI(n,e,t,s){const r=Qe(e,t)[0],i=[1,t[0],1];for(let f=0;f<r;f++)i[0]*=t[f];i[1]=t[r];for(let f=r+1;f<t.length;f++)i[2]*=t[f];const o=new Map,a=new Int32Array(t[r]),u=new vn(i,s,n),l=[],h=i[0]===1&&i[2]===1;for(let f=0;f<t[r];f++){let g;if(h)g=n[f].toString();else{const b=[];for(let x=0;x<i[0];x++)for(let v=0;v<i[2];v++)b.push(u.get(x,f,v));g=b.join(",")}const m=o.get(g);if(m!=null)a[f]=m;else{const b=o.size;o.set(g,b),a[f]=b,l.push(f)}}const c=i.slice();c[1]=o.size;const d=new vn(c,s);l.forEach((f,g)=>{for(let m=0;m<i[0];m++)for(let b=0;b<i[2];b++)d.set(u.get(m,f,b),m,g,b)});const p=t.slice();return p[r]=c[1],{outputValues:d.values,outputShape:p,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qI=Object.freeze(Object.defineProperty({__proto__:null,addImpl:sI,bincountImpl:sb,bincountReduceImpl:rI,bitwiseAndImpl:iI,castImpl:nI,ceilImpl:oI,concatImpl:aI,equalImpl:uI,expImpl:cI,expm1Impl:dI,floorDivImpl:fI,floorImpl:pI,gatherNdImpl:mI,gatherV2Impl:gI,greaterEqualImpl:bI,greaterImpl:xI,lessEqualImpl:wI,lessImpl:yI,linSpaceImpl:vI,logImpl:CI,maxImpl:SI,maximumImpl:II,minimumImpl:$I,multiplyImpl:rb,negImpl:kI,notEqualImpl:TI,prodImpl:EI,raggedGatherImpl:RI,raggedRangeImpl:NI,raggedTensorToTensorImpl:_I,rangeImpl:DI,rsqrtImpl:AI,scatterImpl:Zi,sigmoidImpl:fB,simpleAbsImpl:tI,sliceImpl:PI,sparseFillEmptyRowsImpl:LI,sparseReshapeImpl:OI,sparseSegmentReductionImpl:ob,sqrtImpl:xB,squaredDifferenceImpl:MI,staticRegexReplaceImpl:zI,stridedSliceImpl:BI,stringNGramsImpl:VI,stringSplitImpl:UI,stringToHashBucketFastImpl:GI,subImpl:WI,tileImpl:HI,topKImpl:jI,transposeImpl:ib,uniqueImpl:XI},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kg("cpu",()=>new lf,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YI=It(za,n=>n>=0?n:Math.exp(n)-1),EB={kernelName:za,backendName:"cpu",kernelFunc:YI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s;Me([r],"leakyRelu");const o=Q(r.shape),a=t.data.get(r.dataId).values,u=fn("float32",o);for(let l=0;l<a.length;l++)u[l]=a[l]<0?i*a[l]:a[l];return t.makeTensorInfo(r.shape,"float32",u)}const RB={kernelName:nc,backendName:"cpu",kernelFunc:ZI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NB=Qt((n,e)=>n<0?e*n:n);function QI(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;Me([s,r],"prelu");const i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,[a,u]=NB(s.shape,r.shape,i,o,"float32");return t.makeTensorInfo(u,"float32",a)}const _B={kernelName:vc,backendName:"cpu",kernelFunc:QI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JI=It(ru,n=>Math.max(0,n)),DB={kernelName:ru,backendName:"cpu",kernelFunc:JI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e$=It(iu,n=>Math.min(Math.max(0,n),6)),AB={kernelName:iu,backendName:"cpu",kernelFunc:e$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pd(n,e,t,s,r){if(t==="linear")return Er({inputs:{x:e},backend:n});if(t==="relu")return JI({inputs:{x:e},backend:n});if(t==="elu")return YI({inputs:{x:e},backend:n});if(t==="relu6")return e$({inputs:{x:e},backend:n});if(t==="prelu")return QI({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return ZI({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return FI({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nt(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,o=Q(r.shape),a=vg(i,o),u=Q(a);L(o===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const l=t.data.get(r.dataId);if(l.complexTensorInfos!=null){const h=l.complexTensorInfos.real,c=l.complexTensorInfos.imag;h.shape=a,c.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const FB={kernelName:Sc,backendName:"cpu",kernelFunc:Nt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t$(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;Me([r,i],"matMul");const u=r.shape.length,l=i.shape.length,h=o?r.shape[u-2]:r.shape[u-1],c=a?i.shape[l-1]:i.shape[l-2],d=o?r.shape[u-1]:r.shape[u-2],p=a?i.shape[l-2]:i.shape[l-1],f=r.shape.slice(0,-2),g=i.shape.slice(0,-2),m=Q(f),b=Q(g),v=Ke(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([d,p]);L(h===c,()=>`Error in matMul: inner shapes (${h}) and (${c}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const w=o?[m,h,d]:[m,d,h],S=a?[b,p,c]:[b,c,p],k=Nt({inputs:{x:r},backend:t,attrs:{shape:w}}),E=Nt({inputs:{x:i},backend:t,attrs:{shape:S}}),I=o?k.shape[1]:k.shape[2],C=o?k.shape[2]:k.shape[1],T=a?E.shape[1]:E.shape[2],R=Math.max(m,b),P=t.data.get(k.dataId).values,D=t.data.get(E.dataId).values,F=Be(k.shape),z=Be(E.shape),[_,B,N]=o?[F[0],1,F[1]]:[F[0],F[1],1],[O,K,U]=a?[1,z[1],z[0]]:[z[1],1,z[0]],X=C*T,te=Je([R,C,T],k.dtype),ie=te.values,re=t.blockSize;for(let he=0;he<R;he++){const Se=he%m,xe=he%b;for(let Ce=0;Ce<C;Ce+=re){const De=Math.min(Ce+re,C);for(let Ue=0;Ue<T;Ue+=re){const V=Math.min(Ue+re,T);for(let G=0;G<I;G+=re){const ee=Math.min(G+re,I);for(let ue=Ce;ue<De;ue++)for(let ae=Ue;ae<V;ae++){let ce=0;for(let me=G;me<ee;me++){const ye=P[Se*_+ue*B+me*N],ge=D[me*O+ae*K+xe*U];ce+=ye*ge}ie[he*X+(ue*T+ae)]+=ce}}}}}return t.disposeIntermediateTensorInfo(k),t.disposeIntermediateTensorInfo(E),t.makeTensorInfo(v,te.dtype,te.values)}const PB={kernelName:Vl,backendName:"cpu",kernelFunc:t$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LB(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:h,leakyreluAlpha:c}=s;let d,p,f;const g=[];d=t$({inputs:{a:r,b:i},attrs:{transposeA:u,transposeB:l},backend:t}),o&&(p=ba({inputs:{a:d,b:o},backend:t}),g.push(d),d=p),h&&(f=pd(t,d,h,a,c),g.push(d),d=f);for(const b of g)t.disposeIntermediateTensorInfo(b);return d}const OB={kernelName:ml,backendName:"cpu",kernelFunc:LB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MB=It(ka,n=>Math.acos(n)),zB={kernelName:ka,backendName:"cpu",kernelFunc:MB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BB=It(Ta,n=>Math.acosh(n)),VB={kernelName:Ta,backendName:"cpu",kernelFunc:BB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UB(n){const{inputs:e,backend:t}=n,s=e;Me(e,"addN");const r=s.map(a=>t.data.get(a.dataId).values),i=Je(s[0].shape,s[0].dtype),o=i.values;for(let a=0;a<s.length;a++){const u=r[a];for(let l=0;l<o.length;l++)o[l]+=u[l]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const GB={kernelName:Pd,backendName:"cpu",kernelFunc:UB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Me(r,"all");const a=Qe(i,r.shape);let u=a;const l=kt(u,r.shape.length);let h=r;l!=null&&(h=Qn({inputs:{x:r},backend:t,attrs:{perm:l}}),u=_t(u.length,r.shape.length)),tn("all",u,h.shape.length);const[c,d]=Yt(h.shape,u),p=Q(d),f=Cn(Q(c),h.dtype),g=t.data.get(h.dataId).values;for(let b=0;b<f.length;++b){const x=b*p;let v=g[x];for(let w=0;w<p;++w){const S=g[x+w];v=v&&S}f[b]=v}l!=null&&t.disposeIntermediateTensorInfo(h);const m=t.makeTensorInfo(c,h.dtype,f);if(o){const b=qt(c,a),x=Nt({inputs:{x:m},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(m),x}return m}const HB={kernelName:Ld,backendName:"cpu",kernelFunc:WB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Me(r,"any");const a=Qe(i,r.shape);let u=a;const l=kt(u,r.shape.length);let h=r;l!=null&&(h=Qn({inputs:{x:r},backend:t,attrs:{perm:l}}),u=_t(u.length,r.shape.length)),tn("any",u,h.shape.length);const[c,d]=Yt(h.shape,u),p=Q(d),f=Cn(Q(c),h.dtype),g=t.data.get(h.dataId).values;for(let b=0;b<f.length;++b){const x=b*p;let v=g[x];for(let w=0;w<p;++w){const S=g[x+w];v=v||S}f[b]=v}l!=null&&t.disposeIntermediateTensorInfo(h);const m=t.makeTensorInfo(c,h.dtype,f);if(o){const b=qt(c,a),x=Nt({inputs:{x:m},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(m),x}return m}const jB={kernelName:Od,backendName:"cpu",kernelFunc:KB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;Me(r,"argMax");let o=Qe(i,r.shape);const a=kt(o,r.shape.length);let u=r;const l=[];a!=null&&(u=Qn({inputs:{x:r},backend:t,attrs:{perm:a}}),l.push(u),o=_t(o.length,u.shape.length)),o=[o[0]],tn("argMax",o,u.shape.length);const[h,c]=Yt(u.shape,o),d=Q(h),p=Cn(d,"int32"),f=Q(c),g=t.data.get(u.dataId).values;for(let m=0;m<p.length;++m){const b=m*f;let x=g[b],v=0;for(let w=0;w<f;++w){const S=g[b+w];S>x&&(x=S,v=w)}p[m]=v}return l.forEach(m=>t.disposeIntermediateTensorInfo(m)),t.makeTensorInfo(h,"int32",p)}const qB={kernelName:Ol,backendName:"cpu",kernelFunc:XB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;Me(r,"argMin");let o=Qe(i,r.shape);const a=kt(o,r.shape.length);let u=r;const l=[];a!=null&&(u=Qn({inputs:{x:r},backend:t,attrs:{perm:a}}),l.push(u),o=_t(o.length,u.shape.length)),o=[o[0]],tn("argMin",o,u.shape.length);const[h,c]=Yt(u.shape,o),d=Q(h),p=Cn(d,"int32"),f=Q(c),g=t.data.get(u.dataId).values;for(let m=0;m<p.length;++m){const b=m*f;let x=g[b],v=0;for(let w=0;w<f;++w){const S=g[b+w];S<x&&(x=S,v=w)}p[m]=v}return l.forEach(m=>t.disposeIntermediateTensorInfo(m)),t.makeTensorInfo(h,"int32",p)}const ZB={kernelName:Ml,backendName:"cpu",kernelFunc:YB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QB=It(Ea,n=>Math.asin(n)),JB={kernelName:Ea,backendName:"cpu",kernelFunc:QB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eV=It(Ra,n=>Math.asinh(n)),tV={kernelName:Ra,backendName:"cpu",kernelFunc:eV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nV=It(Na,n=>Math.atan(n)),sV={kernelName:Na,backendName:"cpu",kernelFunc:nV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rV=Qt((n,e)=>Math.atan2(n,e)),iV=hn(Da,rV),oV={kernelName:Da,backendName:"cpu",kernelFunc:iV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aV=It(_a,n=>Math.atanh(n)),uV={kernelName:_a,backendName:"cpu",kernelFunc:aV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ub(n,e,t,s,r,i){const o=r.strideHeight,a=r.strideWidth,u=r.dilationHeight,l=r.dilationWidth,h=r.effectiveFilterHeight,c=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Je(r.outShape,t),m=g.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],x=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let w=0;w<r.batchSize;++w){const S=w*b,k=w*s[0];for(let E=0;E<r.inChannels;++E)for(let I=0;I<r.outHeight;++I){const C=I*o-d,T=Math.max(0,C),R=Math.min(r.inHeight,h+C),P=S+I*x;for(let D=0;D<r.outWidth;++D){const F=D*a-p,z=Math.max(0,F),_=Math.min(r.inWidth,c+F);let B=f,N=0,O=0;for(let U=T;U<R;U+=u){const X=k+U*s[1];for(let te=z;te<_;te+=l){const ie=X+te*s[2],re=n[ie+E];i==="max"&&re>B?B=re:i==="avg"&&(N+=re,O++)}if(isNaN(B))break}const K=P+D*v+E;m[K]=i==="avg"?N/O:B}}}return g}function n$(n,e,t,s,r=!1,i=!1){const o=Je(s.outShape,"int32"),a=s.strideHeight,u=s.strideWidth,l=s.dilationHeight,h=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,g=Je(e,t,n);for(let m=0;m<s.batchSize;++m)for(let b=0;b<s.inChannels;++b)for(let x=0;x<s.outHeight;++x){const v=x*a-p;let w=v;for(;w<0;)w+=l;const S=Math.min(s.inHeight,c+v);for(let k=0;k<s.outWidth;++k){const E=k*u-f;let I=E;for(;I<0;)I+=h;const C=Math.min(s.inWidth,d+E);let T=Number.NEGATIVE_INFINITY,R=-1;for(let P=w;P<S;P+=l){const D=P-v;for(let F=I;F<C;F+=h){const z=F-E,_=g.get(m,P,F,b);_>T&&(T=_,r?R=i?((m*s.inHeight+P)*s.inWidth+F)*s.inChannels+b:(P*s.inWidth+F)*s.inChannels+b:R=D*d+z)}}o.set(R,m,x,k,b)}}return o}function s$(n,e,t,s,r,i){const o=r.strideDepth,a=r.strideHeight,u=r.strideWidth,l=r.dilationDepth,h=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,g=r.padInfo.front,m=r.padInfo.top,b=r.padInfo.left,x=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Je(r.outShape,t),w=v.values,S=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],E=r.outShape[3]*r.outShape[4],I=r.outShape[4];for(let C=0;C<r.batchSize;++C){const T=C*S,R=C*s[0];for(let P=0;P<r.inChannels;++P)for(let D=0;D<r.outDepth;++D){const F=D*o-g;let z=F;for(;z<0;)z+=l;const _=Math.min(r.inDepth,d+F),B=T+D*k;for(let N=0;N<r.outHeight;++N){const O=N*a-m;let K=O;for(;K<0;)K+=h;const U=Math.min(r.inHeight,p+O),X=B+N*E;for(let te=0;te<r.outWidth;++te){const ie=te*u-b;let re=ie;for(;re<0;)re+=c;const he=Math.min(r.inWidth,f+ie),Se=X+te*I;let xe=x,Ce=0,De=0;for(let V=z;V<_;V+=l){const G=R+V*s[1];for(let ee=K;ee<U;ee+=h){const ue=G+ee*s[2];for(let ae=re;ae<he;ae+=c){const ce=ue+ae*s[3],me=n[ce+P];if(i==="max"&&me>xe?xe=me:i==="avg"&&(Ce+=me,De++),isNaN(xe))break}if(isNaN(xe))break}if(isNaN(xe))break}const Ue=Se+P;w[Ue]=i==="avg"?Ce/Math.max(De,1):xe}}}}return v}function lV(n,e){const t=Je(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterDepth,h=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let g=0;g<e.batchSize;++g)for(let m=0;m<e.inChannels;++m)for(let b=0;b<e.outDepth;++b){const x=b*s-d;let v=x;for(;v<0;)v+=o;const w=Math.min(e.inDepth,l+x);for(let S=0;S<e.outHeight;++S){const k=S*r-p;let E=k;for(;E<0;)E+=a;const I=Math.min(e.inHeight,h+k);for(let C=0;C<e.outWidth;++C){const T=C*i-f;let R=T;for(;R<0;)R+=u;const P=Math.min(e.inWidth,c+T);let D=Number.NEGATIVE_INFINITY,F=-1;for(let z=v;z<w;z+=o){const _=z-x;for(let B=E;B<I;B+=a){const N=B-k;for(let O=R;O<P;O+=u){const K=O-T,U=n.get(g,z,B,O,m);U>=D&&(D=U,F=_*h*c+N*h+K)}}}t.set(F,g,b,S,C,m)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Me(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:u}=s,l=1;L(gn(o,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const h=kn(r.shape,i,o,l,a,u);let c;if(h.filterWidth===1&&h.filterHeight===1&&ct(h.inShape,h.outShape))c=Er({inputs:{x:r},backend:t});else{const d=t.data.get(r.dataId).values,p=Be(r.shape),f=ub(d,r.shape,r.dtype,p,h,"avg");c=t.makeTensorInfo(h.outShape,r.dtype,f.values)}return c}const hV={kernelName:zl,backendName:"cpu",kernelFunc:cV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:u,dataFormat:l}=s;Me(r,"avgPool3d");const h=bs(r.shape,i,o,1,a,u,l),c=t.data.get(r.dataId).values,d=s$(c,r.shape,r.dtype,Be(r.shape),h,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}const pV={kernelName:Bl,backendName:"cpu",kernelFunc:dV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fV(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:o,strides:a,pad:u,dimRoundingMode:l}=s;Me([r,i],"avgPool3DGrad");const h=bs(i.shape,o,a,1,u,l),c=h.strideDepth,d=h.strideHeight,p=h.strideWidth,f=h.filterDepth,g=h.filterHeight,m=h.filterWidth,b=h.dilationDepth,x=h.dilationHeight,v=h.dilationWidth,w=h.effectiveFilterDepth,S=h.effectiveFilterHeight,k=h.effectiveFilterWidth,E=w-1-h.padInfo.front,I=k-1-h.padInfo.left,C=S-1-h.padInfo.top,T=Je(i.shape,"float32"),R=1/(f*g*m),P=t.bufferSync(r);for(let D=0;D<h.batchSize;++D)for(let F=0;F<h.inChannels;++F)for(let z=0;z<h.inDepth;++z)for(let _=0;_<h.inHeight;++_)for(let B=0;B<h.inWidth;++B){const N=z-E,O=_-C,K=B-I;let U=0;for(let X=0;X<w;X+=b){const te=(N+X)/c;if(!(te<0||te>=h.outDepth||Math.floor(te)!==te))for(let ie=0;ie<S;ie+=x){const re=(O+ie)/d;if(!(re<0||re>=h.outHeight||Math.floor(re)!==re))for(let he=0;he<k;he+=v){const Se=(K+he)/p;if(Se<0||Se>=h.outWidth||Math.floor(Se)!==Se)continue;const xe=P.get(D,te,re,Se,F);U+=xe}}}T.set(U*R,D,z,_,B,F)}return t.makeTensorInfo(T.shape,T.dtype,T.values)}const mV={kernelName:zd,backendName:"cpu",kernelFunc:fV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gV(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i;Me([r,i],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=s,h=kn(o.shape,a,u,1,l),c=h.strideHeight,d=h.strideWidth,p=h.filterHeight,f=h.filterWidth,g=h.dilationHeight,m=h.dilationWidth,b=h.effectiveFilterHeight,x=h.effectiveFilterWidth,v=x-1-h.padInfo.left,w=b-1-h.padInfo.top,S=Je(o.shape,"float32"),k=1/(p*f),E=t.data.get(r.dataId).values,I=Je(r.shape,"float32",E);for(let C=0;C<h.batchSize;++C)for(let T=0;T<h.inChannels;++T)for(let R=0;R<h.inHeight;++R)for(let P=0;P<h.inWidth;++P){const D=R-w,F=P-v;let z=0;for(let _=0;_<b;_+=g){const B=(D+_)/c;if(!(B<0||B>=h.outHeight||Math.floor(B)!==B))for(let N=0;N<x;N+=m){const O=(F+N)/d;if(O<0||O>=h.outWidth||Math.floor(O)!==O)continue;const K=I.get(C,B,O,T);z+=K}}S.set(z*k,C,R,P,T)}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const xV={kernelName:Md,backendName:"cpu",kernelFunc:gV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:i,offset:o,mean:a,variance:u}=e;L(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),L(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),L(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Me([r,a,u,i,o],"batchNorm");let{varianceEpsilon:l}=s;l==null&&(l=.001);const h=t.data.get(r.dataId).values,c=t.data.get(a.dataId).values,d=t.data.get(u.dataId).values,p=i?t.data.get(i.dataId).values:new Float32Array([1]),f=o?t.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(h.length),m=f.length,b=p.length,x=d.length,v=c.length;let w=0,S=0,k=0,E=0;for(let I=0;I<h.length;++I)g[I]=f[w++]+(h[I]-c[S++])*p[k++]/Math.sqrt(d[E++]+l),w>=m&&(w=0),S>=v&&(S=0),k>=b&&(k=0),E>=x&&(E=0);return t.makeTensorInfo(r.shape,r.dtype,g)}const yV={kernelName:Jl,backendName:"cpu",kernelFunc:bV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:o}=s;Me([r],"batchToSpaceND");const a=i.reduce((b,x)=>b*x),u=No(r.shape,i,a),l=_o(u.length,i.length),h=Do(r.shape,i,a),c=Op(o,i.length),d=Mp(h,o,i.length),p=Nt({inputs:{x:r},backend:t,attrs:{shape:u}}),f=Qn({inputs:{x:p},backend:t,attrs:{perm:l}}),g=Nt({inputs:{x:f},backend:t,attrs:{shape:h}}),m=bo({inputs:{x:g},backend:t,attrs:{begin:c,size:d}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),m}const vV={kernelName:Ul,backendName:"cpu",kernelFunc:wV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o}=s,a=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,l=sb(a,u,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,l)}const SV={kernelName:Bd,backendName:"cpu",kernelFunc:CV};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IV(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,a=Ke(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const $V={kernelName:Tg,backendName:"cpu",kernelFunc:IV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kV=It(Pa,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),TV={kernelName:Pa,backendName:"cpu",kernelFunc:kV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EV=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(Q(e.shape)),r=t.data.get(e.dataId),i=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,a=t.data.get(i.dataId).values,u=t.data.get(o.dataId).values;for(let l=0;l<a.length;l++){const h=a[l],c=u[l];s[l]=Math.hypot(h,c)}return t.makeOutput(s,e.shape,"float32")},RV={kernelName:Gl,backendName:"cpu",kernelFunc:EV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ya(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const NV={kernelName:sp,backendName:"cpu",kernelFunc:ya};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wa(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=Qe(r,e[0].shape)[0],o=e.map(g=>g.shape);Fp(o,i);let a=qn(e.map(g=>g.shape),i);if(Q(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const u=e.filter(g=>Q(g.shape)>0);if(u.length===1)return Er({inputs:{x:u[0]},backend:t});if(u[0].dtype==="complex64"){const g=u.map(w=>xo({inputs:{input:w},backend:t})),m=u.map(w=>ya({inputs:{input:w},backend:t})),b=wa({inputs:g,backend:t,attrs:{axis:i}}),x=wa({inputs:m,backend:t,attrs:{axis:i}}),v=rs({inputs:{real:b,imag:x},backend:t});return g.forEach(w=>t.disposeIntermediateTensorInfo(w)),m.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),v}const l=u.map(g=>{const b=[-1,Q(g.shape.slice(i))];return Nt({inputs:{x:g},backend:t,attrs:{shape:b}})}),h=l.map(g=>({vals:t.data.get(g.dataId).values,shape:g.shape}));a=qn(l.map(g=>g.shape),1);const c=l[0].shape[0]===1,d=aI(h,a,e[0].dtype,c),p=qn(u.map(g=>g.shape),i),f=t.makeTensorInfo(p,e[0].dtype,d);return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const _V={kernelName:Wl,backendName:"cpu",kernelFunc:wa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r$(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:u,dilations:l,dimRoundingMode:h}=s;Me([r,i],"conv2d");const c=hs(u),d=Ot(r.shape,i.shape,o,l,a,h,!1,c),p=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,m=d.dilationWidth,b=d.padInfo.left,x=d.padInfo.top,v=d.dataFormat==="channelsLast",w=new vn(d.outShape,r.dtype),S=Be(r.shape),k=Be(i.shape),E=S[0],I=v?S[1]:S[2],C=v?S[2]:1,T=v?1:S[1],R=w.strides[0],P=v?w.strides[1]:w.strides[2],D=v?w.strides[2]:1,F=v?1:w.strides[1],z=t.data.get(r.dataId).values,_=t.data.get(i.dataId).values,B=w.values;for(let N=0;N<d.batchSize;++N){const O=N*E,K=N*R;for(let U=0;U<d.outHeight;++U){const X=K+U*P,te=U*d.strideHeight-x;for(let ie=0;ie<p;++ie){const re=te+ie*g;if(re<0||re>=d.inHeight)continue;const he=ie*k[0],Se=O+re*I;for(let xe=0;xe<d.outWidth;++xe){const Ce=X+xe*D,De=xe*d.strideWidth-b;for(let Ue=0;Ue<f;++Ue){const V=De+Ue*m;if(V<0||V>=d.inWidth)continue;const G=he+Ue*k[1],ee=Se+V*C;let ue=G;for(let ae=0;ae<d.inChannels;++ae){const ce=z[ee+ae*T];for(let me=0;me<d.outChannels;++me)B[Ce+me*F]+=ce*_[ue+me];ue+=d.outChannels}}}}}}return t.makeTensorInfo(w.shape,w.dtype,B)}const DV={kernelName:Hl,backendName:"cpu",kernelFunc:r$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:h}=s;Me([r,i],"conv2dBackpropFilter");const c=hs(u),d=Ot(r.shape,h,o,1,a,l,!1,c),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=d,b=d.dataFormat==="channelsLast",x=new vn(d.filterShape,"float32"),v=d.padInfo.left,w=d.padInfo.top,S=t.data.get(r.dataId).values,k=t.data.get(i.dataId).values,E=new vn(r.shape,r.dtype,S),I=new vn(i.shape,i.dtype,k);for(let C=0;C<g;++C){const T=Math.max(0,Math.ceil((w-C)/p)),R=Math.min(d.outHeight,(d.inHeight+w-C)/p);for(let P=0;P<m;++P){const D=Math.max(0,Math.ceil((v-P)/f)),F=Math.min(d.outWidth,(d.inWidth+v-P)/f);for(let z=0;z<d.inChannels;++z)for(let _=0;_<d.outChannels;++_){let B=0;for(let N=0;N<d.batchSize;++N)for(let O=T;O<R;++O){const K=C+O*p-w;for(let U=D;U<F;++U){const X=P+U*f-v;b?B+=E.get(N,K,X,z)*I.get(N,O,U,_):B+=E.get(N,z,K,X)*I.get(N,_,O,U)}}x.set(B,C,P,z,_)}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const FV={kernelName:Ud,backendName:"cpu",kernelFunc:AV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PV(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:u,dataFormat:l,dimRoundingMode:h}=s;Me([r,i],"conv2dBackpropInput");const c=Be(i.shape),d=Be(r.shape);let p=hs(l);const f=Ot(o,i.shape,a,1,u,h,!1,p),g=new vn(f.inShape,"float32"),m=g.values,b=t.data.get(r.dataId).values,x=t.data.get(i.dataId).values,[v,w,S]=c,{batchSize:k,filterHeight:E,filterWidth:I,inChannels:C,inHeight:T,inWidth:R,outChannels:P,outHeight:D,outWidth:F,strideHeight:z,strideWidth:_}=f;p=f.dataFormat;const B=E-1-f.padInfo.top,N=I-1-f.padInfo.left,O=p==="channelsLast",K=g.strides[0],U=O?g.strides[1]:g.strides[2],X=O?g.strides[2]:1,te=O?1:g.strides[1],ie=d[0],re=O?d[1]:d[2],he=O?d[2]:1,Se=O?1:d[1];for(let xe=0;xe<k;++xe)for(let Ce=0;Ce<C;++Ce)for(let De=0;De<T;++De){const Ue=De-B,V=Math.max(0,Math.ceil(Ue/z)),G=Math.min(D,(E+Ue)/z);for(let ee=0;ee<R;++ee){const ue=ee-N,ae=Math.max(0,Math.ceil(ue/_)),ce=Math.min(F,(I+ue)/_);let me=0;for(let ge=V;ge<G;++ge){const pe=ge*z-Ue;for(let Le=ae;Le<ce;++Le){const be=Le*_-ue,Ae=ie*xe+re*ge+he*Le,Pe=v*(E-1-pe)+w*(I-1-be)+S*Ce;for(let et=0;et<P;++et){const ot=b[Ae+Se*et],ke=x[Pe+et];me+=ot*ke}}}const ye=K*xe+U*De+X*ee+te*Ce;m[ye]=me}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const LV={kernelName:Kl,backendName:"cpu",kernelFunc:PV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:u}=s;Me([r,i],"conv3d");const l=tr(r.shape,i.shape,o,u,a),{filterDepth:h,filterHeight:c,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=l,b=m.front,x=m.left,v=m.top,w=new vn(l.outShape,r.dtype),S=t.data.get(r.dataId).values,k=t.data.get(i.dataId).values,E=w.values,I=Be(r.shape),C=Be(i.shape);for(let T=0;T<l.batchSize;++T){const R=T*I[0],P=T*w.strides[0];for(let D=0;D<l.outDepth;++D){const F=P+D*w.strides[1],z=D*l.strideDepth-b;for(let _=0;_<h;++_){const B=z+_*p;if(B<0||B>=l.inDepth)continue;const N=_*C[0],O=R+B*I[1];for(let K=0;K<l.outHeight;++K){const U=F+K*w.strides[2],X=K*l.strideHeight-v;for(let te=0;te<c;++te){const ie=X+te*f;if(ie<0||ie>=l.inHeight)continue;const re=N+te*C[1],he=O+ie*I[2];for(let Se=0;Se<l.outWidth;++Se){const xe=U+Se*l.outChannels,Ce=Se*l.strideWidth-x;for(let De=0;De<d;++De){const Ue=Ce+De*g;if(Ue<0||Ue>=l.inWidth)continue;const V=re+De*C[2],G=he+Ue*l.inChannels;let ee=V;for(let ue=0;ue<l.inChannels;++ue){const ae=S[G+ue];for(let ce=0;ce<l.outChannels;++ce)E[xe+ce]+=ae*k[ee+ce];ee+=l.outChannels}}}}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const MV={kernelName:jl,backendName:"cpu",kernelFunc:OV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:u}=s;Me([r,i],"conv3dBackpropFilterV2");const l=Be(r.shape),h=Be(i.shape),c=tr(r.shape,u,o,1,a),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,g=c.filterDepth,m=c.filterHeight,b=c.filterWidth,x=new vn(c.filterShape,"float32"),v=x.values,[w,S,k,E]=x.strides,I=t.data.get(i.dataId).values,[C,T,R,P]=h,D=t.data.get(r.dataId).values,[F,z,_,B]=l,N=c.padInfo.front,O=c.padInfo.left,K=c.padInfo.top;for(let U=0;U<g;++U){const X=Math.max(0,Math.ceil((N-U)/d)),te=Math.min(c.outDepth,(c.inDepth+N-U)/d),ie=U*w;for(let re=0;re<m;++re){const he=Math.max(0,Math.ceil((K-re)/p)),Se=Math.min(c.outHeight,(c.inHeight+K-re)/p),xe=re*S+ie;for(let Ce=0;Ce<b;++Ce){const De=Math.max(0,Math.ceil((O-Ce)/f)),Ue=Math.min(c.outWidth,(c.inWidth+O-Ce)/f),V=Ce*k+xe;for(let G=0;G<c.inChannels;++G){const ee=G*E+V;for(let ue=0;ue<c.outChannels;++ue){let ae=0;for(let ce=0;ce<c.batchSize;++ce){const me=ce*F,ye=ce*C;for(let ge=X;ge<te;++ge){const Le=(U+ge*d-N)*z+me,be=ge*T+ye;for(let Ae=he;Ae<Se;++Ae){const et=(re+Ae*p-K)*_+Le,ot=Ae*R+be;for(let ke=De;ke<Ue;++ke){const nn=(Ce+ke*f-O)*B+et,Rn=ke*P+ot;ae+=D[nn+G]*I[Rn+ue]}}}}v[ee+ue]=ae}}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const BV={kernelName:Gd,backendName:"cpu",kernelFunc:zV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VV(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:o,strides:a,inputShape:u}=s;Me([r],"conv3dBackpropInputV2");const l=Be(r.shape),h=Be(i.shape),c=tr(u,i.shape,a,1,o),d=new vn(c.inShape,"float32"),p=d.values,[f,g,m,b]=d.strides,x=t.data.get(r.dataId).values,[v,w,S,k]=l,E=t.data.get(i.dataId).values,[I,C,T,R]=h,{batchSize:P,filterDepth:D,filterHeight:F,filterWidth:z,inChannels:_,inDepth:B,inHeight:N,inWidth:O,outChannels:K,outDepth:U,outHeight:X,outWidth:te,strideDepth:ie,strideHeight:re,strideWidth:he}=c,Se=D-1-c.padInfo.front,xe=F-1-c.padInfo.top,Ce=z-1-c.padInfo.left;for(let De=0;De<P;++De)for(let Ue=0;Ue<_;++Ue)for(let V=0;V<B;++V){const G=V-Se,ee=Math.max(0,Math.ceil(G/ie)),ue=Math.min(U,(D+G)/ie);for(let ae=0;ae<N;++ae){const ce=ae-xe,me=Math.max(0,Math.ceil(ce/re)),ye=Math.min(X,(F+ce)/re);for(let ge=0;ge<O;++ge){const pe=ge-Ce,Le=Math.max(0,Math.ceil(pe/he)),be=Math.min(te,(z+pe)/he);let Ae=0;for(let Pe=ee;Pe<ue;++Pe){const et=Pe*ie-G;for(let ot=me;ot<ye;++ot){const ke=ot*re-ce;for(let Vt=Le;Vt<be;++Vt){const nn=Vt*he-pe,Rn=v*De+w*Pe+S*ot+k*Vt,bn=I*(D-1-et)+C*(F-1-ke)+T*(z-1-nn)+R*Ue;for(let es=0;es<K;++es){const Fi=x[Rn+es],Mt=E[bn+es];Ae+=Fi*Mt}}}}p[f*De+g*V+m*ae+b*ge+Ue]=Ae}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}const UV={kernelName:Wd,backendName:"cpu",kernelFunc:VV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GV=It(La,n=>Math.cos(n)),WV={kernelName:La,backendName:"cpu",kernelFunc:GV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HV=It(Oa,n=>Math.cosh(n)),KV={kernelName:Oa,backendName:"cpu",kernelFunc:HV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jV(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:u,extrapolationValue:l}=s,[h,c,d,p]=r.shape,f=i.shape[0],[g,m]=a,b=Je([f,g,m,p],"float32"),x=t.data.get(i.dataId).values,v=t.data.get(o.dataId).values,w=t.data.get(r.dataId).values,S=Be(r.shape),k=Be(b.shape);for(let E=0;E<f;E++){const I=E*4,C=x[I],T=x[I+1],R=x[I+2],P=x[I+3],D=v[E];if(D>=h)continue;const F=g>1?(R-C)*(c-1)/(g-1):0,z=m>1?(P-T)*(d-1)/(m-1):0;for(let _=0;_<g;_++){const B=g>1?C*(c-1)+_*F:.5*(C+R)*(c-1);if(B<0||B>c-1){for(let N=0;N<m;N++)for(let O=0;O<p;O++){const K=O+N*k[2]+_*k[1]+E*k[0];b.values[K]=l}continue}if(u==="bilinear"){const N=Math.floor(B),O=Math.ceil(B),K=B-N;for(let U=0;U<m;U++){const X=m>1?T*(d-1)+U*z:.5*(T+P)*(d-1);if(X<0||X>d-1){for(let he=0;he<p;he++){const Se=he+U*k[2]+_*k[1]+E*k[0];b.values[Se]=l}continue}const te=Math.floor(X),ie=Math.ceil(X),re=X-te;for(let he=0;he<p;he++){let Se=he+te*S[2]+N*S[1]+D*S[0];const xe=w[Se];Se=he+ie*S[2]+N*S[1]+D*S[0];const Ce=w[Se];Se=he+te*S[2]+O*S[1]+D*S[0];const De=w[Se];Se=he+ie*S[2]+O*S[1]+D*S[0];const Ue=w[Se],V=xe+(Ce-xe)*re,G=De+(Ue-De)*re;Se=he+U*k[2]+_*k[1]+E*k[0],b.values[Se]=V+(G-V)*K}}}else for(let N=0;N<m;++N){const O=m>1?T*(d-1)+N*z:.5*(T+P)*(d-1);if(O<0||O>d-1){for(let X=0;X<p;X++){const te=X+N*k[2]+_*k[1]+E*k[0];b.values[te]=l}continue}const K=Math.round(O),U=Math.round(B);for(let X=0;X<p;X++){const te=X+K*S[2]+U*S[1]+D*S[0],ie=X+N*k[2]+_*k[1]+E*k[0];b.values[ie]=w[te]}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const XV={kernelName:Kd,backendName:"cpu",kernelFunc:jV};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;Me(r,"cumprod");const u=kt([i],r.shape.length);let l=r;u!=null&&(l=Qn({inputs:{x:r},backend:t,attrs:{perm:u}}));const h=_t(1,r.shape.length)[0];if(h!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${h}`);const c=mn(l.dtype,"int32"),d=Sg(Q(l.shape),c),p=t.data.get(l.dataId).values,f=l.shape[l.shape.length-1],g=a?(b,x)=>b+f-x-1:(b,x)=>b+x;for(let b=0;b<p.length;b+=f)for(let x=0;x<f;x++){const v=g(b,x);if(x===0)d[v]=o?1:p[v];else{const w=g(b,x-1);d[v]=o?p[w]*d[w]:p[v]*d[w]}}const m=t.makeTensorInfo(l.shape,c,d);if(u!=null){const b=Nr(u),x=Qn({inputs:{x:m},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(l),x}return m}const YV={kernelName:Hd,backendName:"cpu",kernelFunc:qV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;Me(r,"cumsum");const u=kt([i],r.shape.length);let l=r;u!=null&&(l=Qn({inputs:{x:r},backend:t,attrs:{perm:u}}));const h=_t(1,r.shape.length)[0];if(h!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${h}`);const c=mn(l.dtype,"int32"),d=Cn(Q(l.shape),c),p=t.data.get(l.dataId).values,f=l.shape[l.shape.length-1],g=a?(b,x)=>b+f-x-1:(b,x)=>b+x;for(let b=0;b<p.length;b+=f)for(let x=0;x<f;x++){const v=g(b,x);if(x===0)d[v]=o?0:p[v];else{const w=g(b,x-1);d[v]=o?p[w]+d[w]:p[v]+d[w]}}const m=t.makeTensorInfo(l.shape,c,d);if(u!=null){const b=Nr(u),x=Qn({inputs:{x:m},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(l),x}return m}const QV={kernelName:Xl,backendName:"cpu",kernelFunc:ZV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const u=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,h=sb(u,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,h)}else if(r.shape.length===2){const u=t.bufferSync(r),l=t.bufferSync(i),h=rI(u,l,o,a);return t.makeTensorInfo(h.shape,i.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const e4={kernelName:jd,backendName:"cpu",kernelFunc:JV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:o}=s;L(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=r.shape[0],u=r.shape[1],l=r.shape[2],h=r.shape[3],c=u*i,d=l*i,p=h/(i*i),f=t.data.get(r.dataId).values,g=new Float32Array(a*c*d*p);let m=0;for(let b=0;b<a;++b)for(let x=0;x<c;++x){const v=Math.floor(x/i),w=x%i;for(let S=0;S<d;++S){const k=Math.floor(S/i),E=S%i,I=(w*i+E)*p;for(let C=0;C<p;++C){const R=C+I+h*(k+l*(v+u*b));g[m++]=f[R]}}}return t.makeTensorInfo([a,c,d,p],r.dtype,g)}const n4={kernelName:Xd,backendName:"cpu",kernelFunc:t4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i$(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:u,dimRoundingMode:l}=s;Me([r,i],"depthwiseConv2DNative");const h=Be(r.shape),c=Be(i.shape);let d=u;d==null&&(d=[1,1]),L(gn(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=Ot(r.shape,i.shape,o,d,a,l,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:b,padInfo:x}=p,v=x.left,w=x.top,S=p.outChannels/p.inChannels,k=new vn(p.outShape,r.dtype),E=t.data.get(r.dataId).values,I=t.data.get(i.dataId).values,C=k.values;for(let T=0;T<p.batchSize;++T){const R=T*h[0],P=T*k.strides[0];for(let D=0;D<p.outHeight;++D){const F=P+D*k.strides[1],z=D*p.strideHeight-w;for(let _=0;_<f;++_){const B=z+_*m;if(B<0||B>=p.inHeight)continue;const N=_*c[0],O=R+B*h[1];for(let K=0;K<p.outWidth;++K){const U=F+K*k.strides[2],X=K*p.strideWidth-v;for(let te=0;te<g;++te){const ie=X+te*b;if(ie<0||ie>=p.inWidth)continue;const re=N+te*c[1],he=O+ie*p.inChannels;let Se=U,xe=re;for(let Ce=0;Ce<p.inChannels;++Ce){const De=E[he+Ce];for(let Ue=0;Ue<S;++Ue)C[Se+Ue]+=De*I[xe+Ue];Se+=S,xe+=S}}}}}}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const s4={kernelName:ql,backendName:"cpu",kernelFunc:i$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,dilations:a,pad:u,dimRoundingMode:l,filterShape:h}=s;Me([r,i],"depthwiseConv2dNativeBackpropFilter");const c=Ot(r.shape,h,o,a,u,l,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:g}=c,m=new vn(c.filterShape,"float32"),b=c.padInfo.left,x=c.padInfo.top,v=c.outChannels/c.inChannels,w=t.data.get(r.dataId).values,S=new vn(r.shape,r.dtype,w),k=t.data.get(i.dataId).values,E=new vn(i.shape,i.dtype,k);for(let I=0;I<f;++I){const C=Math.max(0,Math.ceil((x-I)/d)),T=Math.min(c.outHeight,(c.inHeight+x-I)/d);for(let R=0;R<g;++R){const P=Math.max(0,Math.ceil((b-R)/p)),D=Math.min(c.outWidth,(c.inWidth+b-R)/p);for(let F=0;F<c.outChannels;++F){const z=Math.trunc(F/v),_=F%v;let B=0;for(let N=0;N<c.batchSize;++N)for(let O=C;O<T;++O){const K=I+O*d-x;for(let U=P;U<D;++U){const X=R+U*p-b;B+=S.get(N,K,X,z)*E.get(N,O,U,F)}}m.set(B,I,R,z,_)}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const i4={kernelName:qd,backendName:"cpu",kernelFunc:r4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o4(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:u,dimRoundingMode:l,inputShape:h}=s;Me([r,i],"depthwiseConv2DNativeBackpropInput");const c=Be(r.shape),d=Be(i.shape),p=Ot(h,i.shape,o,a,u,l,!0),f=new vn(p.inShape,"float32"),g=f.values,[m,b,x]=f.strides,v=t.data.get(r.dataId).values,[w,S,k]=c,E=t.data.get(i.dataId).values,[I,C,T]=d,{batchSize:R,filterHeight:P,filterWidth:D,inChannels:F,inHeight:z,inWidth:_,outChannels:B,outHeight:N,outWidth:O,strideHeight:K,strideWidth:U}=p,X=P-1-p.padInfo.top,te=D-1-p.padInfo.left,ie=B/F;for(let re=0;re<R;++re)for(let he=0;he<F;++he)for(let Se=0;Se<z;++Se){const xe=Se-X,Ce=Math.max(0,Math.ceil(xe/K)),De=Math.min(N,(P+xe)/K);for(let Ue=0;Ue<_;++Ue){const V=Ue-te,G=Math.max(0,Math.ceil(V/U)),ee=Math.min(O,(D+V)/U);let ue=0;for(let ae=Ce;ae<De;++ae){const ce=ae*K-xe;for(let me=G;me<ee;++me){const ye=me*U-V,ge=w*re+S*ae+k*me,pe=I*(P-1-ce)+C*(D-1-ye)+T*he;for(let Le=0;Le<ie;++Le){const be=he*ie+Le,Ae=v[ge+be],Pe=E[pe+Le];ue+=Ae*Pe}}}g[m*re+b*Se+x*Ue+he]=ue}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const a4={kernelName:Yd,backendName:"cpu",kernelFunc:o4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u4(n){const{inputs:e,backend:t}=n,{x:s}=e,r=Q(s.shape),i=t.data.get(s.dataId).values,o=Je([r,r],s.dtype),a=o.values;for(let l=0;l<i.length;l++)a[l*r+l]=i[l];const u=[...s.shape,...s.shape];return t.makeTensorInfo(u,o.dtype,o.values)}const l4={kernelName:Eg,backendName:"cpu",kernelFunc:u4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c4={kernelName:Yl,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:i,pad:o,dilations:a}=t,u=e,l=u.data.get(s.dataId).values,h=s.shape.length,c=u.data.get(r.dataId).values,d=r.shape.length,{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:x,padInfo:v,strideHeight:w,strideWidth:S,filterHeight:k,filterWidth:E,dilationHeight:I,dilationWidth:C,outShape:T}=ki(s.shape,r.shape,i,o,"NHWC",a),R=Q(T),P=T.length,D=Wt(s.dtype,R);for(let z=0;z<p;++z)for(let _=0;_<b;++_){const B=_*w-v.top;for(let N=0;N<x;++N){const O=N*S-v.left;for(let K=0;K<m;++K){let U=Number.MIN_SAFE_INTEGER;for(let te=0;te<k;++te){const ie=B+te*I;if(ie>=0&&ie<f)for(let re=0;re<E;++re){const he=O+re*C;if(he>=0&&he<g){const Se=yr([z,ie,he,K],h,Be(s.shape)),xe=yr([te,re,K],d,Be(r.shape)),Ce=l[Se]+c[xe];Ce>U&&(U=Ce)}}}const X=yr([z,_,N,K],P,Be(T));D[X]=U}}}return{dataId:u.write(ko(D,s.dtype),T,s.dtype),shape:T,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h4={kernelName:jh,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:a,dilations:u}=t,l=e,h=Ws(s.shape,l.data.get(s.dataId).values),c=Ws(r.shape,l.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:b,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:S,filterWidth:k,dilationHeight:E,dilationWidth:I,outShape:C}=ki(s.shape,r.shape,o,a,"NHWC",u);L(i.rank===C.length,()=>`Error in ${jh}, dy must have the same rank as output ${C.length}, but got ${i.rank}`);const T=Ws(C,l.data.get(i.dataId).values),R=Fw(r.shape,r.dtype);for(let D=0;D<d;++D)for(let F=0;F<m;++F){const z=F*v-x.top;for(let _=0;_<b;++_){const B=_*w-x.left;for(let N=0;N<g;++N){let O=Number.MIN_SAFE_INTEGER,K=0,U=0;for(let X=0;X<S;++X){const te=z+X*E;if(te>=0&&te<p)for(let ie=0;ie<k;++ie){const re=B+ie*I;if(re>=0&&re<f){const he=h[D][te][re][N]+c[X][ie][N];he>O&&(O=he,K=X,U=ie)}}}R[K][U][N]+=T[D][F][_][N]}}}return{dataId:l.write(ko(R,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d4={kernelName:Kh,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:a,dilations:u}=t,l=e,h=Ws(s.shape,l.data.get(s.dataId).values),c=Ws(r.shape,l.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:b,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:S,filterWidth:k,dilationHeight:E,dilationWidth:I,outShape:C}=ki(s.shape,r.shape,o,a,"NHWC",u);L(i.rank===C.length,()=>`Error in ${Kh}, dy must have the same rank as output ${C.length}, but got ${i.rank}`);const T=Ws(C,l.data.get(i.dataId).values),R=Fw(s.shape,s.dtype);for(let D=0;D<d;++D)for(let F=0;F<m;++F){const z=F*v-x.top;for(let _=0;_<b;++_){const B=_*w-x.left;for(let N=0;N<g;++N){let O=Number.MIN_SAFE_INTEGER,K=z<0?0:z,U=B<0?0:B;for(let X=0;X<S;++X){const te=z+X*E;if(te>=0&&te<p)for(let ie=0;ie<k;++ie){const re=B+ie*I;if(re>=0&&re<f){const he=h[D][te][re][N]+c[X][ie][N];he>O&&(O=he,K=te,U=re)}}}R[D][K][U][N]+=T[D][F][_][N]}}}return{dataId:l.write(ko(R,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p4(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:o}=s,{contextOptions:a,imageOptions:u}=o||{},l=(u==null?void 0:u.alpha)||1,h=(a==null?void 0:a.contextType)||"2d";if(h!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const c=i.getContext(h,(a==null?void 0:a.contextAttributes)||{});if(c==null)throw new Error(`Could not get the context with ${h} type.`);const[d,p]=r.shape.slice(0,2),f=r.shape.length===2?1:r.shape[2],g=t.data.get(r.dataId).values,m=r.dtype==="float32"?255:1,b=new Uint8ClampedArray(p*d*4);for(let v=0;v<d*p;++v){const w=[0,0,0,255*l];for(let k=0;k<f;k++){const E=g[v*f+k];if(r.dtype==="float32"){if(E<0||E>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${E}.`)}else if(r.dtype==="int32"&&(E<0||E>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${E}.`);f===1?(w[0]=E*m,w[1]=E*m,w[2]=E*m):w[k]=E*m}const S=v*4;b[S+0]=Math.round(w[0]),b[S+1]=Math.round(w[1]),b[S+2]=Math.round(w[2]),b[S+3]=Math.round(w[3])}i.width=p,i.height=d;const x=new ImageData(b,p,d);return c.putImageData(x,0,0),r}const f4={kernelName:Ow,backendName:"cpu",kernelFunc:p4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zc(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Me(r,"sum");let a;r.dtype==="bool"?a=Ci({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):a=Er({inputs:{x:r},backend:t});const u=a.shape.length,l=Qe(i,a.shape),h=kt(l,u);let c=l,d=a;h!=null&&(d=Qn({inputs:{x:a},backend:t,attrs:{perm:h}}),c=_t(c.length,u)),tn("sum",c,d.shape.length);const[p,f]=Yt(d.shape,c),g=mn(d.dtype,"int32");let m=hd(t,p,g);const b=Q(f),x=t.data.get(m.dataId).values,v=t.data.get(d.dataId).values;for(let w=0;w<x.length;++w){const S=w*b;let k=0;for(let E=0;E<b;++E)k+=v[S+E];x[w]=k}if(o){const w=qt(m.shape,l),S=m;m=Nt({inputs:{x:m},backend:t,attrs:{shape:w}}),t.disposeIntermediateTensorInfo(S)}return t.disposeIntermediateTensorInfo(a),h!=null&&t.disposeIntermediateTensorInfo(d),m}const m4={kernelName:Rc,backendName:"cpu",kernelFunc:Zc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g4(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:u}=Hp(r,i.length);jp(o.length,u,i);const{path:l,steps:h}=Xp(a,u),c=h.length;let d=null,p=o.length;const f=[];for(let g=0;g<c;++g){for(const m of h[g]){const{permutationIndices:b,expandDims:x}=Kp(p,u[m]);let v;qp(b)?v=i[m]:(v=Qn({inputs:{x:i[m]},backend:t,attrs:{perm:b}}),f.push(v));const w=v.shape.slice();for(let S=0;S<x.length;++S)w.splice(x[S],0,1);ct(v.shape,w)||(v=Nt({inputs:{x:v},backend:t,attrs:{shape:w}}),f.push(v)),d===null?d=v:(d=cf({inputs:{a:v,b:d},backend:t}),f.push(d))}g<c-1&&(l[g]>=0&&(d=Zc({inputs:{x:d},backend:t,attrs:{axis:l[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&t.disposeIntermediateTensorInfo(g);return d}const x4={kernelName:Zd,backendName:"cpu",kernelFunc:g4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b4(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;Me([s,r],"eluGrad");const i=new Float32Array(Q(r.shape)),o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values;for(let u=0;u<o.length;++u){const l=o[u];l>=0?i[u]=a[u]:i[u]=a[u]*(l+1)}return t.makeTensorInfo(r.shape,"float32",i)}const y4={kernelName:Qd,backendName:"cpu",kernelFunc:b4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w4=zp,v4=Bp,C4=Vp,S4=Up,I4=Gp,$4=Wp,k4=It(Ba,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+w4*t);return e*(1-(((($4*s+I4)*s+S4)*s+C4)*s+v4)*s*Math.exp(-t*t))}),T4={kernelName:Ba,backendName:"cpu",kernelFunc:k4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fd(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:i}=s,o=r.shape.length,a=r.shape.slice();let u=i;return i<0&&(L(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+i+1),a.splice(u,0,1),Nt({inputs:{x:r},backend:t,attrs:{shape:a}})}const E4={kernelName:Ql,backendName:"cpu",kernelFunc:fd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R4=Qt((n,e)=>n/e),lb=hn(Ma,R4),Um={kernelName:Ma,backendName:"cpu",kernelFunc:lb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o$(n,e,t){const s=n.shape,r=s[0],i=s[1],o=t.data.get(n.dataId),a=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,l=[r,i],h=Q(l),c=fn("float32",h),d=fn("float32",h);for(let m=0;m<r;m++){const b=bo({inputs:{x:a},backend:t,attrs:{begin:[m,0],size:[1,i]}}),x=bo({inputs:{x:u},backend:t,attrs:{begin:[m,0],size:[1,i]}}),v=rs({inputs:{real:b,imag:x},backend:t}),{real:w,imag:S}=N4(v,e,t),k=qs(w,S);for(let E=0;E<i;E++){const I=Dx(k,E);c[m*i+E]=I.real,d[m*i+E]=I.imag}t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(v)}const p=t.makeTensorInfo(l,"float32",c),f=t.makeTensorInfo(l,"float32",d),g=rs({inputs:{real:p,imag:f},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),g}function N4(n,e,t){const s=Q(n.shape),r=t.data.get(n.dataId),i=t.data.get(r.complexTensorInfos.real.dataId).values,o=t.data.get(r.complexTensorInfos.imag.dataId).values;if(_4(s)){const a=Gm(i,o,s,e,t),u=[n.shape[0],n.shape[1]];if(e){const l=t.makeTensorInfo(u,"float32",a.real),h=t.makeTensorInfo(u,"float32",a.imag),c=t.makeTensorInfo([],"float32",$i(s,"float32")),d=Er({inputs:{x:c},backend:t}),p=Um.kernelFunc({inputs:{a:l,b:c},backend:t}),f=Um.kernelFunc({inputs:{a:h,b:d},backend:t}),g=t.data.get(p.dataId).values,m=t.data.get(f.dataId).values;return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),{real:g,imag:m}}return a}else{const a=qs(i,o),u=D4(a,s,e);return y2(u)}}function _4(n){return(n&n-1)===0}function Gm(n,e,t,s,r){if(t===1)return{real:n,imag:e};const i=qs(n,e),o=t/2,a=w2(i),u=a.real,l=a.imag,h=[u.length],c=r.makeTensorInfo(h,"float32",u),d=r.makeTensorInfo(h,"float32",l),p=rs({inputs:{real:c,imag:d},backend:r}),f=v2(i),g=f.real,m=f.imag,b=[g.length],x=r.makeTensorInfo(b,"float32",g),v=r.makeTensorInfo(b,"float32",m),w=rs({inputs:{real:x,imag:v},backend:r}),S=Gm(u,l,o,s,r),k=S.real,E=S.imag,I=[k.length],C=r.makeTensorInfo(I,"float32",k),T=r.makeTensorInfo(I,"float32",E),R=rs({inputs:{real:C,imag:T},backend:r}),P=Gm(g,m,o,s,r),D=P.real,F=P.imag,z=[D.length],_=r.makeTensorInfo(z,"float32",D),B=r.makeTensorInfo(z,"float32",F),N=rs({inputs:{real:_,imag:B},backend:r}),O=S2(t,s),K=[O.real.length],U=r.makeTensorInfo(K,"float32",O.real),X=r.makeTensorInfo(K,"float32",O.imag),te=rs({inputs:{real:U,imag:X},backend:r}),ie=cf({inputs:{a:te,b:N},backend:r}),re=ba({inputs:{a:R,b:ie},backend:r}),he=ab({inputs:{a:R,b:ie},backend:r}),Se=xo({inputs:{input:re},backend:r}),xe=xo({inputs:{input:he},backend:r}),Ce=ya({inputs:{input:re},backend:r}),De=ya({inputs:{input:he},backend:r}),Ue=wa({inputs:[Se,xe],backend:r,attrs:{axis:0}}),V=wa({inputs:[Ce,De],backend:r,attrs:{axis:0}}),G=r.data.get(Ue.dataId).values,ee=r.data.get(V.dataId).values;return r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(X),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(ie),r.disposeIntermediateTensorInfo(re),r.disposeIntermediateTensorInfo(he),r.disposeIntermediateTensorInfo(Se),r.disposeIntermediateTensorInfo(Ce),r.disposeIntermediateTensorInfo(xe),r.disposeIntermediateTensorInfo(De),r.disposeIntermediateTensorInfo(Ue),r.disposeIntermediateTensorInfo(V),{real:G,imag:ee}}function D4(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let i=0,o=0;for(let a=0;a<e;a++){const u=I2(r*a,e,t),l=Dx(n,a);i+=l.real*u.real-l.imag*u.imag,o+=l.real*u.imag+l.imag*u.real}t&&(i/=e,o/=e),C2(s,i,o,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A4(n){const{inputs:e,backend:t}=n,{input:s}=e,r=Q(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=Nt({inputs:{x:s},backend:t,attrs:{shape:[o,i]}}),u=o$(a,!1,t),l=Nt({inputs:{x:u},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),l}const F4={kernelName:Jd,backendName:"cpu",kernelFunc:A4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cb(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:i}=t,o=i||So(r),a=Wt(o,Q(s));return L4(a,r,o),e.makeTensorInfo(s,o,a)}const P4={kernelName:ep,backendName:"cpu",kernelFunc:cb};function L4(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O4={kernelName:tp,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,i=fn(s.dtype,Q(s.shape)),[o,a,u,l]=s.shape,h=r.data.get(s.dataId).values;for(let d=0;d<o;d++){const p=d*u*a*l;for(let f=0;f<a;f++){const g=f*(u*l);for(let m=0;m<u;m++){const b=m*l;for(let x=0;x<l;x++){const v=Math.round(u-m-1),w=p+g+b+x;let S=h[w];if(v>=0&&v<u){const k=v*l,E=p+g+k+x;S=h[E]}i[w]=S}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:h,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let g=r$({inputs:{x:r,filter:i},backend:t,attrs:{strides:u,pad:l,dataFormat:h,dilations:c,dimRoundingMode:d}});if(o){const m=g;if(h==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const b=Nt({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});g=ba({inputs:{a:g,b},backend:t}),t.disposeIntermediateTensorInfo(b)}else g=ba({inputs:{a:g,b:o},backend:t});t.disposeIntermediateTensorInfo(m)}if(p){const m=g;if(h==="NCHW"&&p==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const b=Nt({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});g=pd(t,g,p,b,f),t.disposeIntermediateTensorInfo(b)}else g=pd(t,g,p,a,f);t.disposeIntermediateTensorInfo(m)}return g}const z4={kernelName:gl,backendName:"cpu",kernelFunc:M4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:h,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let g=i$({inputs:{x:r,filter:i},backend:t,attrs:{strides:u,pad:l,dataFormat:h,dilations:c,dimRoundingMode:d}});if(o){const m=g;g=ba({inputs:{a:g,b:o},backend:t}),t.disposeIntermediateTensorInfo(m)}if(p){const m=g;g=pd(t,g,p,a,f),t.disposeIntermediateTensorInfo(m)}return g}const V4={kernelName:Gg,backendName:"cpu",kernelFunc:B4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U4(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=Q(s.shape),o=r.shape,a=o[o.length-1],[u,l,h,c]=Np(s,r);if(l===0)return t.makeTensorInfo(u,s.dtype,[]);const d=t.data.get(r.dataId).values,p=t.bufferSync(s),f=mI(d,p,s.dtype,l,a,h,c,s.shape,i);return t.makeTensorInfo(u,s.dtype,f.values)}const G4={kernelName:Rg,backendName:"cpu",kernelFunc:U4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:o,batchDims:a}=s;Me([r,i],"gatherV2");const u=Qe(o,r.shape)[0],l=t.data.get(i.dataId).values,h=r.shape[u];for(let w=0;w<l.length;++w){const S=l[w];L(S<=h-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${h-1}]`)}let c=a;a==null&&(c=0);const d=Q(i.shape),p=Zp(r,i,u,c),f=Nt({inputs:{x:r},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=Nt({inputs:{x:i},backend:t,attrs:{shape:[p.batchSize,d/p.batchSize]}}),m=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],b=t.bufferSync(g),x=t.bufferSync(f),v=gI(x,b,m);return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),t.makeTensorInfo(p.outputShape,v.dtype,v.values)}const H4={kernelName:ec,backendName:"cpu",kernelFunc:W4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K4(n){const{inputs:e,backend:t}=n,{input:s}=e,r=Q(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=Nt({inputs:{x:s},backend:t,attrs:{shape:[o,i]}}),u=o$(a,!0,t),l=Nt({inputs:{x:u},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),l}const j4={kernelName:np,backendName:"cpu",kernelFunc:K4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X4=It(ja,n=>Number.isFinite(n)?1:0,"bool"),q4={kernelName:ja,backendName:"cpu",kernelFunc:X4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y4=It(Xa,n=>Math.abs(n)===1/0?1:0,"bool"),Z4={kernelName:Xa,backendName:"cpu",kernelFunc:Y4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q4=It(qa,n=>Number.isNaN(n)?1:0,"bool"),J4={kernelName:qa,backendName:"cpu",kernelFunc:Q4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eU(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,o=vI(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const tU={kernelName:Ng,backendName:"cpu",kernelFunc:eU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nU=It(Za,n=>Math.log1p(n)),sU={kernelName:Za,backendName:"cpu",kernelFunc:nU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rU=Qt((n,e)=>n&&e),iU=hn(ic,rU,null,"bool"),oU={kernelName:ic,backendName:"cpu",kernelFunc:iU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aU=It(oc,n=>n?0:1,"bool"),uU={kernelName:oc,backendName:"cpu",kernelFunc:aU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lU=Qt((n,e)=>n||e),cU=hn(ac,lU,null,"bool"),hU={kernelName:ac,backendName:"cpu",kernelFunc:cU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:u}=s;Me(r,"LRN");const l=r.shape[3],h=l-1,c=t.data.get(r.dataId).values,d=Q(r.shape),p=new Float32Array(d);function f(g){const m=g%l;let b=g-m+Math.max(0,m-i);const x=g-m+Math.min(m+i,h);let v=0;for(;b<=x;b++){const w=c[b];v+=w*w}return v}for(let g=0;g<d;g++){const m=f(g),b=c[g]*Math.pow(o+a*m,-u);p[g]=b}return t.makeTensorInfo(r.shape,r.dtype,p)}const pU={kernelName:uc,backendName:"cpu",kernelFunc:dU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:u,alpha:l,beta:h}=s;Me(o,"LRNGrad");const c=Q(o.shape),d=o.shape[3],p=t.data.get(o.dataId).values,f=t.data.get(r.dataId).values,g=t.data.get(i.dataId).values,m=new Float32Array(c),b=c;for(let x=0;x<b;x++){const v=x%d,w=x-v+Math.max(0,v-a),S=x-v+Math.min(d,v+a+1);let k=0;for(let E=w;E<S;E++)k+=Math.pow(f[E],2);k=l*k+u;for(let E=w;E<S;E++){let I=-2*l*h*f[E]*g[x]/k;x===E&&(I+=Math.pow(k,-h)),I*=p[x],m[E]+=I}}return t.makeTensorInfo(o.shape,r.dtype,m)}const mU={kernelName:rp,backendName:"cpu",kernelFunc:fU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:o}=s,a=t;let u=r.shape;const l=u.length,h=Qe(i,u);let c=h;const d=kt(c,l);let p=a.data.get(r.dataId).values;if(d!=null){const w=new Array(l);for(let S=0;S<w.length;S++)w[S]=u[d[S]];p=ib(p,u,r.dtype,d,w),c=_t(c.length,l),u=w}Me(r,"max"),tn("max",c,l);const[f,g]=Yt(u,c),m=Q(g),b=SI(p,m,f,r.dtype),x=a.write(b,f,r.dtype);let v=f;return o&&(v=qt(f,h)),{dataId:x,shape:v,dtype:r.dtype}}const gU={kernelName:lc,backendName:"cpu",kernelFunc:a$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Me(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:u}=s,l=1;L(gn(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const h=kn(r.shape,i,o,l,a,u);let c;if(h.filterWidth===1&&h.filterHeight===1&&ct(h.inShape,h.outShape))c=Er({inputs:{x:r},backend:t});else{const d=t.data.get(r.dataId).values,p=Be(r.shape),f=ub(d,r.shape,r.dtype,p,h,"max");c=t.makeTensorInfo(h.outShape,r.dtype,f.values)}return c}const bU={kernelName:cc,backendName:"cpu",kernelFunc:xU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:u,dataFormat:l}=s;Me(r,"maxPool3d");const h=bs(r.shape,i,o,1,a,u,l),c=t.data.get(r.dataId).values,d=s$(c,r.shape,r.dtype,Be(r.shape),h,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}const wU={kernelName:hc,backendName:"cpu",kernelFunc:yU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vU(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:o,strides:a,pad:u,dimRoundingMode:l}=s;Me([r,i],"maxPool3DGrad");const h=bs(i.shape,o,a,1,u,l),c=t.bufferSync(i),d=lV(c,h),p=h.strideDepth,f=h.strideHeight,g=h.strideWidth,m=h.dilationDepth,b=h.dilationHeight,x=h.dilationWidth,v=h.effectiveFilterDepth,w=h.effectiveFilterHeight,S=h.effectiveFilterWidth,k=v-1-h.padInfo.front,E=S-1-h.padInfo.left,I=w-1-h.padInfo.top,C=Je(i.shape,"float32"),T=t.bufferSync(r);for(let R=0;R<h.batchSize;++R)for(let P=0;P<h.inChannels;++P)for(let D=0;D<h.inDepth;++D)for(let F=0;F<h.inHeight;++F)for(let z=0;z<h.inWidth;++z){const _=D-k,B=F-I,N=z-E;let O=0;for(let K=0;K<v;K+=m){const U=(_+K)/p;if(!(U<0||U>=h.outDepth||Math.floor(U)!==U))for(let X=0;X<w;X+=b){const te=(B+X)/f;if(!(te<0||te>=h.outHeight||Math.floor(te)!==te))for(let ie=0;ie<S;ie+=x){const re=(N+ie)/g;if(re<0||re>=h.outWidth||Math.floor(re)!==re)continue;const he=v*w*S-1-d.get(R,U,te,re,P),Se=K*w*S+X*S+ie,xe=he===Se?1:0;if(xe===0)continue;const Ce=T.get(R,U,te,re,P);O+=Ce*xe}}}C.set(O,R,D,F,z,P)}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const CU={kernelName:op,backendName:"cpu",kernelFunc:vU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SU(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:o}=e,a=i;Me([i,o],"maxPoolGrad");const{filterSize:u,strides:l,pad:h,dimRoundingMode:c}=s,d=kn(a.shape,u,l,1,h,c),p=t.data.get(a.dataId).values,f=Je(d.outShape,a.dtype,n$(p,a.shape,a.dtype,d).values),g=d.strideHeight,m=d.strideWidth,b=d.dilationHeight,x=d.dilationWidth,v=d.effectiveFilterHeight,w=d.effectiveFilterWidth,S=w-1-d.padInfo.left,k=v-1-d.padInfo.top,E=Je(a.shape,"float32"),I=t.data.get(r.dataId).values,C=Je(r.shape,"float32",I);for(let T=0;T<d.batchSize;++T)for(let R=0;R<d.inChannels;++R)for(let P=0;P<d.inHeight;++P)for(let D=0;D<d.inWidth;++D){const F=P-k,z=D-S;let _=0;for(let B=0;B<v;B+=b){const N=(F+B)/g;if(!(N<0||N>=d.outHeight||Math.floor(N)!==N))for(let O=0;O<w;O+=x){const K=(z+O)/m;if(K<0||K>=d.outWidth||Math.floor(K)!==K)continue;const U=v*w-1-f.get(T,N,K,R),X=B*w+O,te=U===X?1:0;if(te===0)continue;const ie=C.get(T,N,K,R);_+=ie*te}}E.set(_,T,P,D,R)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const IU={kernelName:ip,backendName:"cpu",kernelFunc:SU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $U(n,e,t,s,r){const i=Be(e),o=ub(n,e,t,i,r,"max"),a=n$(n,e,t,r,!0,s);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kU={kernelName:_g,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=e,u=t;Me(s,"MaxPoolWithArgmax");const l=u.data.get(s.dataId).values,h=kn(s.shape,r,i,[1,1],o),[c,d]=$U(l,s.shape,s.dtype,a,h),p=u.write(c,h.outShape,s.dtype),f=u.write(d,h.outShape,s.dtype);return[{dataId:p,shape:h.outShape,dtype:s.dtype},{dataId:f,shape:h.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=Qe(i,r.shape),l=Yt(r.shape,a)[1],h=Q(l),c=[],d=t.makeTensorInfo([],"float32",new Float32Array([h]));c.push(d);const p=Ci({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});c.push(p);const f=lb({inputs:{a:p,b:d},backend:t});c.push(f);const g=Zc({inputs:{x:f},backend:t,attrs:{axis:i,keepDims:o}});return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),g}const EU={kernelName:dc,backendName:"cpu",kernelFunc:TU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Me(r,"min");const a=Qe(i,r.shape);let u=a;const l=kt(u,r.shape.length);let h=r;l!=null&&(h=Qn({inputs:{x:r},backend:t,attrs:{perm:l}}),u=_t(u.length,r.shape.length)),tn("min",u,h.shape.length);const[c,d]=Yt(h.shape,u),p=Q(d),f=Cn(Q(c),h.dtype),g=t.data.get(h.dataId).values;for(let b=0;b<f.length;++b){const x=b*p;let v=g[x];for(let w=0;w<p;++w){const S=g[x+w];(Number.isNaN(S)||S<v)&&(v=S)}f[b]=v}l!=null&&t.disposeIntermediateTensorInfo(h);const m=t.makeTensorInfo(c,h.dtype,f);if(o){const b=qt(c,a),x=Nt({inputs:{x:m},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(m),x}return m}const NU={kernelName:pc,backendName:"cpu",kernelFunc:RU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _U(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,mode:o}=s;Me(r,"mirrorPad");const a=i.map((v,w)=>v[0]+r.shape[w]+v[1]),u=i.map(v=>v[0]),l=i.map((v,w)=>v[0]+r.shape[w]),h=o==="reflect"?0:1,c=t.data.get(r.dataId).values,d=r.shape.length,p=Be(r.shape),f=Q(a),g=a.length,m=Be(a),b=fn(r.dtype,f);for(let v=0;v<f;v++){let w=$a(v,g,m);for(let k=0;k<g;k++)w[k]<u[k]?w[k]=u[k]*2-w[k]-h:w[k]>=l[k]&&(w[k]=(l[k]-1)*2-w[k]+h);w=w.map((k,E)=>k-u[E]);const S=yr(w,d,p);b[v]=c[S]}return{dataId:t.write(b,a,r.dtype),shape:a,dtype:r.dtype}}const DU={kernelName:fc,backendName:"cpu",kernelFunc:_U};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AU=Qt((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),FU=hn(eu,AU),PU={kernelName:eu,backendName:"cpu",kernelFunc:FU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u$(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,o=r.shape.length;let a=i;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const u=Qe([a],r.shape),l=a$({inputs:{x:r},backend:t,attrs:{reductionIndices:u,keepDims:!1}}),h=qt(l.shape,u),c=Nt({inputs:{x:l},backend:t,attrs:{shape:h}}),d=ab({inputs:{a:r,b:c},backend:t}),p=hI({inputs:{x:d},backend:t}),f=Zc({inputs:{x:p},backend:t,attrs:{axis:u,keepDims:!1}}),g=Nt({inputs:{x:f},backend:t,attrs:{shape:h}}),m=lb({inputs:{a:p,b:g},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),m}const LU={kernelName:Dc,backendName:"cpu",kernelFunc:u$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OU(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s;Me(r,"multinomial");const u=a?r:u$({inputs:{logits:r},backend:t,attrs:{dim:-1}}),l=u.shape[0],h=u.shape[1],c=t.data.get(u.dataId).values,d=[l,i],p=Cn(Q(d),"int32");for(let f=0;f<l;++f){const g=f*h,m=new Float32Array(h-1);m[0]=c[g];for(let v=1;v<m.length;++v)m[v]=m[v-1]+c[g+v];const b=xx.alea(o.toString()),x=f*i;for(let v=0;v<i;++v){const w=b();p[x+v]=m.length;for(let S=0;S<m.length;S++)if(w<m[S]){p[x+v]=S;break}}}return a||t.disposeIntermediateTensorInfo(u),t.makeTensorInfo(d,"int32",p)}const MU={kernelName:Dg,backendName:"cpu",kernelFunc:OU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zU=Ep;function BU(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u}=s;Me(r,"NonMaxSuppression");const l=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,{selectedIndices:c}=zU(l,h,o,a,u);return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}const VU={kernelName:ap,backendName:"cpu",kernelFunc:BU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UU=kx;function GU(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=s;Me(r,"NonMaxSuppressionPadded");const h=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=UU(h,c,o,a,u,l);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const WU={kernelName:Ag,backendName:"cpu",kernelFunc:GU};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HU=Rp;function KU(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=s;Me(r,"NonMaxSuppressionWithScore");const h=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,d=o,p=a,f=u,g=l,{selectedIndices:m,selectedScores:b}=HU(h,c,d,p,f,g);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const jU={kernelName:up,backendName:"cpu",kernelFunc:KU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XU(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:o,onValue:a,offValue:u}=s;Me(r,"oneHot");const l=Q(r.shape),h=new Float32Array(l*o);h.fill(u);const c=t.data.get(r.dataId).values;for(let d=0;d<l;++d)c[d]>=0&&c[d]<o&&(h[d*o+c[d]]=a);return t.makeTensorInfo([...r.shape,o],i,h)}const qU={kernelName:bc,backendName:"cpu",kernelFunc:XU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function md(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=xo({inputs:{input:s},backend:t}),i=md({inputs:{x:r},backend:t}),o=ya({inputs:{input:s},backend:t}),a=md({inputs:{x:o},backend:t}),u=rs({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),u}else return cb({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const YU={kernelName:Pc,backendName:"cpu",kernelFunc:md};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=xo({inputs:{input:s},backend:t}),i=l$({inputs:{x:r},backend:t}),o=ya({inputs:{input:s},backend:t}),a=md({inputs:{x:o},backend:t}),u=rs({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),u}else return cb({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const ZU={kernelName:xc,backendName:"cpu",kernelFunc:l$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c$(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return fd({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(h=>{Fd(i,h.shape,"All tensors passed to stack must have matching shapes"),L(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=e.map(h=>{const c=fd({inputs:{input:h},backend:t,attrs:{dim:r}});return a.push(c),c}),l=wa({inputs:u,backend:t,attrs:{axis:r}});return a.forEach(h=>t.disposeIntermediateTensorInfo(h)),l}const QU={kernelName:yc,backendName:"cpu",kernelFunc:c$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:o}=s;Me(r,"pad");const a=i.map((x,v)=>x[0]+r.shape[v]+x[1]),u=i.map(x=>x[0]),l=t.data.get(r.dataId).values,h=Q(r.shape),c=r.shape.length,d=Be(r.shape),p=Q(a),f=a.length,g=Be(a),m=fn(r.dtype,p);o!==0&&m.fill(o);for(let x=0;x<h;x++){const w=$a(x,c,d).map((k,E)=>k+u[E]),S=yr(w,f,g);m[S]=l[x]}return{dataId:t.write(m,a,r.dtype),shape:a,dtype:r.dtype}}const h$={kernelName:wc,backendName:"cpu",kernelFunc:JU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eG=Qt((n,e)=>Math.pow(n,e)),tG=hn(nu,eG),nG={kernelName:nu,backendName:"cpu",kernelFunc:tG};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sG(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=s,u=r.map(b=>t.data.get(b.dataId).values),l=r.map(b=>b.shape),h=t.data.get(i.dataId).values,c=t.data.get(o.dataId).values,[d,p,f]=RI(u,l,h,i.shape,i.dtype,c,o.shape),g=d.map(b=>t.makeTensorInfo([b.length],"int32",b)),m=t.makeTensorInfo(f,i.dtype,p);return g.concat([m])}const rG={kernelName:Mw,backendName:"cpu",kernelFunc:sG};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iG(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,[l,h]=NI(o,s.shape,s.dtype,a,r.shape,u,i.shape),c=t.makeTensorInfo([l.length],"int32",l),d=t.makeTensorInfo([h.length],s.dtype,h);return[c,d]}const oG={kernelName:zw,backendName:"cpu",kernelFunc:iG};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aG(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:u}=s,l=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,c=t.data.get(o.dataId).values,d=a.map(m=>t.data.get(m.dataId).values),p=a.map(m=>m.shape),[f,g]=_I(l,r.shape,h,i.shape,i.dtype,c,o.shape,d,p,u);return t.makeTensorInfo(f,i.dtype,g)}const uG={kernelName:Bw,backendName:"cpu",kernelFunc:aG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lG(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:i,step:o}=t,a=DI(s,r,o,i);return e.makeTensorInfo([a.length],i,a)}const cG={kernelName:lp,backendName:"cpu",kernelFunc:lG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hG=It(su,n=>1/n),dG={kernelName:su,backendName:"cpu",kernelFunc:hG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pG(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s;Me(r,"resizeBilinear");const u=Be(r.shape),[l,h]=a,[c,d,p,f]=r.shape,g=t.data.get(r.dataId).values,m=new Float32Array(Q([c,l,h,f])),b=[i&&l>1?d-1:d,i&&h>1?p-1:p],x=[i&&l>1?l-1:l,i&&h>1?h-1:h];let v=0;const w=b[0]/x[0],S=b[1]/x[1];for(let k=0;k<c;k++)for(let E=0;E<l;E++){let I;o?I=w*(E+.5)-.5:I=w*E;const C=Math.max(0,Math.floor(I)),T=I-C,R=Math.min(d-1,Math.ceil(I)),P=k*u[0]+C*u[1],D=k*u[0]+R*u[1];for(let F=0;F<h;F++){let z;o?z=S*(F+.5)-.5:z=S*F;const _=Math.max(0,Math.floor(z)),B=z-_,N=Math.min(p-1,Math.ceil(z)),O=P+_*u[2],K=D+_*u[2],U=P+N*u[2],X=D+N*u[2];for(let te=0;te<f;te++){const ie=g[O+te],re=g[K+te],he=g[U+te],Se=g[X+te],xe=ie+(he-ie)*B,Ce=re+(Se-re)*B,De=xe+(Ce-xe)*T;m[v++]=De}}}return t.makeTensorInfo([c,l,h,f],"float32",m)}const fG={kernelName:$c,backendName:"cpu",kernelFunc:pG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mG(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s;Me([i,r],"resizeBilinearGrad");const a=Be(r.shape),[u,l,h,c]=r.shape,[,d,p]=i.shape,f=new Float32Array(u*l*h*c),g=[o&&d>1?l-1:l,o&&p>1?h-1:h],m=[o&&d>1?d-1:d,o&&p>1?p-1:p],b=g[0]/m[0],x=g[1]/m[1],v=t.data.get(i.dataId).values;let w=0;for(let S=0;S<u;S++){const k=S*a[0];for(let E=0;E<d;E++){const I=E*b,C=Math.floor(I),T=Math.min(Math.ceil(I),l-1),R=k+C*a[1],P=k+T*a[1],D=I-C,F=1-D;for(let z=0;z<p;z++){const _=z*x,B=Math.floor(_),N=Math.min(Math.ceil(_),h-1),O=_-B,K=1-O,U=R+B*a[2],X=R+N*a[2],te=P+B*a[2],ie=P+N*a[2],re=F*K,he=F*O,Se=D*K,xe=D*O;for(let Ce=0;Ce<c;Ce++){const De=v[w++];f[U+Ce]+=De*re,f[X+Ce]+=De*he,f[te+Ce]+=De*Se,f[ie+Ce]+=De*xe}}}}return t.makeTensorInfo([u,h,l,c],"float32",f)}const gG={kernelName:dp,backendName:"cpu",kernelFunc:mG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xG(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s;Me(r,"resizeNearestNeighbor");const u=Be(r.shape),[l,h]=a,[c,d,p,f]=r.shape,g=t.data.get(r.dataId).values,m=new Float32Array(c*l*h*f),b=[i&&l>1?d-1:d,i&&h>1?p-1:p],x=[i&&l>1?l-1:l,i&&h>1?h-1:h],v=b[0]/x[0],w=b[1]/x[1];let S=0;for(let k=0;k<c;k++){const E=k*u[0];for(let I=0;I<l;I++){const C=o?v*(I+.5):v*I;let T=Math.min(d-1,i?Math.round(C):Math.floor(C));o&&(T=Math.max(0,T));const R=E+T*u[1];for(let P=0;P<h;P++){const D=o?w*(P+.5):w*P;let F=Math.min(p-1,i?Math.round(D):Math.floor(D));o&&(F=Math.max(0,F));const z=R+F*u[2];for(let _=0;_<f;_++){const B=g[z+_];m[S++]=B}}}}return t.makeTensorInfo([c,l,h,f],r.dtype,m)}const bG={kernelName:Ic,backendName:"cpu",kernelFunc:xG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yG(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s;Me([i,r],"resizeNearestNeighborGrad");const a=Be(r.shape),u=Be(i.shape),[l,h,c,d]=r.shape,[,p,f]=i.shape,g=new Float32Array(l*h*c*d),m=t.data.get(i.dataId).values,b=[o&&p>1?h-1:h,o&&f>1?c-1:c],x=[o&&p>1?p-1:p,o&&f>1?f-1:f],v=b[0]/x[0],w=b[1]/x[1],S=1/v,k=1/w,E=Math.ceil(S)*2+2,I=Math.ceil(k)*2+2;for(let C=0;C<l;C++){const T=C*a[0];for(let R=0;R<h;R++){const P=T+R*a[1],D=Math.floor(R*S),F=Math.floor(D-E/2);for(let z=0;z<c;z++){const _=P+z*a[2],B=Math.floor(z*k),N=Math.floor(B-I/2);for(let O=0;O<d;O++){let K=0;for(let U=0;U<E;U++){const X=U+F;if(X<0||X>=p)continue;const te=T+X*u[1],ie=X*v,re=Math.min(h-1,o?Math.round(ie):Math.floor(ie));if(R===re)for(let he=0;he<I;he++){const Se=he+N;if(Se<0||Se>=f)continue;const xe=te+Se*u[2],Ce=Se*w,De=Math.min(c-1,o?Math.round(Ce):Math.floor(Ce));z===De&&(K+=m[xe+O])}}g[_+O]=K}}}}return t.makeTensorInfo(r.shape,r.dtype,g)}const wG={kernelName:hp,backendName:"cpu",kernelFunc:yG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s;Me(r,"reverse");const o=r.shape.length,a=Qe(i,r.shape);if(o===0)return Er({inputs:{x:r},backend:t});const u=new vn(r.shape,r.dtype),l=t.bufferSync(r);for(let h=0;h<u.size;h++){const c=u.indexToLoc(h),d=c.slice();a.forEach(p=>d[p]=r.shape[p]-1-d[p]),u.set(l.get(...d),...c)}return t.makeTensorInfo(u.shape,u.dtype,u.values)}const CG={kernelName:kc,backendName:"cpu",kernelFunc:vG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG={kernelName:xp,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=e,a=t,u=fn(s.dtype,Q(s.shape)),[l,h,c,d]=s.shape,[p,f]=Lp(o,h,c),g=255,m=Math.sin(r),b=Math.cos(r),x=a.data.get(s.dataId).values;for(let w=0;w<l;w++){const S=w*c*h*d;for(let k=0;k<h;k++){const E=k*(c*d);for(let I=0;I<c;I++){const C=I*d;for(let T=0;T<d;T++){const R=[l,k,I,T],P=R[2],D=R[1];let F=(P-p)*b-(D-f)*m,z=(P-p)*m+(D-f)*b;F=Math.round(F+p),z=Math.round(z+f);let _=i;if(typeof i!="number"&&(T===3?_=g:_=i[T]),F>=0&&F<c&&z>=0&&z<h){const N=z*(c*d),O=F*d,K=S+N+O+T;_=x[K]}const B=S+E+C+T;u[B]=_}}}}return{dataId:a.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IG=It(ou,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),$G={kernelName:ou,backendName:"cpu",kernelFunc:IG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kG(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:u,sliceSize:l,strides:h,outputSize:c}=_r(i,r,o),d=!0,p=t.bufferSync(r),f=t.bufferSync(i),g=Zi(p,f,o,c,l,u,a,h,0,d);return t.makeTensorInfo(o,g.dtype,g.values)}const TG={kernelName:Fg,backendName:"cpu",kernelFunc:kG};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EG(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function RG(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function NG(n,e,t,s,r,i){const o=Wt("int32",t*r);for(let a=0;a<t;++a){const u=n.slice(a*s,(a+1)*s),l=a*r;for(let h=0;h<r;++h)o[l+h]=i==="left"?EG(u,e[h+l]):RG(u,e[h+l])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _G(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:o}=s,a=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,l=NG(a,u,r.shape[0],r.shape[1],i.shape[1],o);return t.makeTensorInfo(i.shape,"int32",l)}const DG={kernelName:Lg,backendName:"cpu",kernelFunc:_G};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AG(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e;Me([s,r,i],"select");const o=s.shape.length,a=t.data.get(s.dataId).values,u=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,h=mn(r.dtype,i.dtype),c=Cn(Q(r.shape),h);let d=0;const p=o===0||o>1||r.shape.length===1?1:Q(r.shape.slice(1));for(let f=0;f<a.length;f++)for(let g=0;g<p;g++)a[f]===1?c[d++]=u[f]:c[d++]=l[f];return t.makeTensorInfo(r.shape,h,c)}const FG={kernelName:Tc,backendName:"cpu",kernelFunc:AG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PG=Vc,LG=Uc,OG=It(uu,n=>n>=0?LG*n:PG*(Math.exp(n)-1)),MG={kernelName:uu,backendName:"cpu",kernelFunc:OG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zG=It(hu,n=>n<0?-1:n>0?1:0),BG={kernelName:hu,backendName:"cpu",kernelFunc:zG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VG=It(lu,n=>Math.sin(n)),UG={kernelName:lu,backendName:"cpu",kernelFunc:VG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GG=It(cu,n=>Math.sinh(n)),WG={kernelName:cu,backendName:"cpu",kernelFunc:GG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HG=11920928955078125e-23,D0=Math.log(HG)+2,KG=It(pu,n=>{const e=n>-D0,t=n<D0,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),jG={kernelName:pu,backendName:"cpu",kernelFunc:KG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:o}=s;Me([r],"spaceToBatchND");const a=Q(i),u=[[0,0]];u.push(...o);for(let k=1+i.length;k<r.shape.length;++k)u.push([0,0]);const l=h$.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),h=No(l.shape,i,a,!1),c=_o(h.length,i.length,!1),d=Do(l.shape,i,a,!1),g=Nt({inputs:{x:l},backend:t,attrs:{shape:h}}),x=Qn({inputs:{x:g},backend:t,attrs:{perm:c}}),S=Nt({inputs:{x},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),S}const qG={kernelName:Nc,backendName:"cpu",kernelFunc:XG};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YG(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.data.get(s.dataId).values,u=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,h=t.data.get(o.dataId).values[0],[c,d,p,f,g]=LI(a,s.shape,s.dtype,u,r.dtype,l,h);return[t.makeTensorInfo(d,s.dtype,c),t.makeTensorInfo([d[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),t.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const ZG={kernelName:Vw,backendName:"cpu",kernelFunc:YG};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QG(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.data.get(r.dataId).values),a=t.data.get(s.dataId).values,u=Array.from(t.data.get(i.dataId).values),[l,h,c]=OI(a,s.shape,s.dtype,o,u);return[t.makeTensorInfo(h,s.dtype,l),t.makeTensorInfo([c.length],i.dtype,new Int32Array(c))]}const JG={kernelName:Uw,backendName:"cpu",kernelFunc:QG};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eW(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,[l,h]=ob(o,s.shape,s.dtype,a,u,!0);return t.makeTensorInfo(h,s.dtype,l)}const tW={kernelName:Og,backendName:"cpu",kernelFunc:eW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nW(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,[l,h]=ob(o,s.shape,s.dtype,a,u);return t.makeTensorInfo(h,s.dtype,l)}const sW={kernelName:Mg,backendName:"cpu",kernelFunc:nW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rW(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:u,numUpdates:l,sliceSize:h,strides:c,outputSize:d}=_r(i,r,a),p=!1,f=t.bufferSync(r);let g;switch(i.dtype){case"bool":{const m=t.bufferSync(i),b=!!t.data.get(o.dataId).values[0];g=Zi(f,m,a,d,h,l,u,c,b,p);break}case"float32":{const m=t.bufferSync(i),b=t.data.get(o.dataId).values[0];g=Zi(f,m,a,d,h,l,u,c,b,p);break}case"int32":{const m=t.bufferSync(i),b=t.data.get(o.dataId).values[0];g=Zi(f,m,a,d,h,l,u,c,b,p);break}case"string":{const m=t.bufferSync(i),b=Xs(t.data.get(o.dataId).values[0]);g=Zi(f,m,a,d,h,l,u,c,b,p);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(a,g.dtype,g.values)}const iW={kernelName:zg,backendName:"cpu",kernelFunc:rW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=Qe(o,r.shape)[0],u=Yp(r,i,a),l=new Array(r.shape.length).fill(0),h=r.shape.slice();return u.map(c=>{const d=[...h];d[a]=c;const p=bo({inputs:{x:r},backend:t,attrs:{begin:l,size:d}});return l[a]+=c,p})}const aW={kernelName:_c,backendName:"cpu",kernelFunc:oW};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uW={kernelName:pp,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;Me(t,"square");const r=s.data.get(t.dataId).values,i=new Float32Array(r.length);for(let a=0;a<r.length;++a){const u=r[a];i[a]=u*u}return{dataId:s.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lW=It(wu,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),cW={kernelName:wu,backendName:"cpu",kernelFunc:lW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:o,strides:a,beginMask:u,endMask:l,ellipsisMask:h,newAxisMask:c,shrinkAxisMask:d}=s;Me(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:x,end:v,strides:w}=Ap(r.shape,i,o,a,u,l,h,c,d);let S;if(g)S=Nt({inputs:{x:r},backend:t,attrs:{shape:f}});else if(m||b){L(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const k=Dp(x,v,w),E=bo({inputs:{x:r},backend:t,attrs:{begin:x,size:k}});S=Nt({inputs:{x:E},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(E)}else{const k=t.bufferSync(r),E=BI(p,k,w,x);S=t.makeTensorInfo(f,E.dtype,E.values)}return S}const dW={kernelName:fp,backendName:"cpu",kernelFunc:hW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pW(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:u,preserveShortSequences:l}=s,{data:h,dataSplits:c}=e,d=t.data.get(h.dataId).values,p=t.data.get(c.dataId).values,[f,g]=VI(d,p,r,i,o,a,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(c.shape,"int32",g)]}const fW={kernelName:Vg,backendName:"cpu",kernelFunc:pW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mW(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.data.get(i.dataId).values,u=t.data.get(o.dataId).values[0],[l,h,c]=UI(a,u,r),d=h.length;return[t.makeTensorInfo([d,2],"int32",l),t.makeTensorInfo([d],"string",h),t.makeTensorInfo([2],"int32",new Int32Array(c))]}const gW={kernelName:Gw,backendName:"cpu",kernelFunc:mW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xW(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(i.dataId).values,a=GI(o,r);return t.makeTensorInfo(i.shape,"int32",a)}const bW={kernelName:Ww,backendName:"cpu",kernelFunc:xW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yW=It(xu,n=>Math.tan(n)),wW={kernelName:xu,backendName:"cpu",kernelFunc:yW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vW=It(bu,n=>Math.tanh(n)),CW={kernelName:bu,backendName:"cpu",kernelFunc:vW};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SW(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:i}=e,{sliceRank:o,numUpdates:a,sliceSize:u,strides:l,outputSize:h}=_r(i,r,s.shape),c=!1,d=t.bufferSync(r),p=t.bufferSync(i),f=t.bufferSync(s),g=Zi(d,p,s.shape,h,u,a,o,l,f,c);return t.makeTensorInfo(s.shape,g.dtype,g.values)}const IW={kernelName:Pg,backendName:"cpu",kernelFunc:SW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $W(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;Me(r,"tile");const o=HI(t.bufferSync(r),i);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const kW={kernelName:yu,backendName:"cpu",kernelFunc:$W};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:o}=s;Me(r,"topk");const a=t.data.get(r.dataId).values,[u,l]=jI(a,r.shape,r.dtype,i,o);return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}const EW={kernelName:mp,backendName:"cpu",kernelFunc:TW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RW(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:u,outputShape:l}=t,[h,c,d,p]=r.shape,[f,g]=l??[c,d],m=[h,f,g,p],b=Be(r.shape),x=b[0],v=b[1],w=b[2],S=Be(m),k=S[0],E=S[1],I=S[2],C=fn(r.dtype,Q(m));C.fill(u);const T=s.data.get(r.dataId).values,R=s.data.get(i.dataId).values;for(let D=0;D<h;++D){const F=i.shape[0]===1?R:R.subarray(D*8,D*8+8);for(let z=0;z<f;++z)for(let _=0;_<g;++_)for(let B=0;B<p;++B){let N;const O=F[6]*_+F[7]*z+1;if(O===0)continue;const K=(F[0]*_+F[1]*z+F[2])/O,U=(F[3]*_+F[4]*z+F[5])/O,X=A0(K,d,a),te=A0(U,c,a);switch(o){case"nearest":N=PW(T,c,d,x,v,w,D,te,X,B,u);break;case"bilinear":N=LW(T,c,d,x,v,w,D,te,X,B,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const ie=D*k+z*E+_*I+B;C[ie]=N}return s.makeTensorInfo(m,r.dtype,C)}return{dataId:s.write(C,m,r.dtype),shape:r.shape,dtype:r.dtype}}const NW={kernelName:gp,backendName:"cpu",kernelFunc:RW};function A0(n,e,t){switch(t){case"reflect":return _W(n,e);case"wrap":return DW(n,e);case"nearest":return FW(n,e);case"constant":default:return AW(n)}}function _W(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return oo(0,t,e-1)}function DW(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return oo(0,t,e-1)}function AW(n,e){return n}function FW(n,e){return oo(0,n,e-1)}function Xu(n,e,t,s,r,i,o,a,u,l,h){const c=o*s+a*r+u*i+l;return 0<=a&&a<e&&0<=u&&u<t?n[c]:h}function PW(n,e,t,s,r,i,o,a,u,l,h){const c=Math.round(a),d=Math.round(u);return Xu(n,e,t,s,r,i,o,c,d,l,h)}function LW(n,e,t,s,r,i,o,a,u,l,h){const c=Math.floor(a),d=Math.floor(u),p=c+1,f=d+1,g=(f-u)*Xu(n,e,t,s,r,i,o,c,d,l,h)+(u-d)*Xu(n,e,t,s,r,i,o,c,f,l,h),m=(f-u)*Xu(n,e,t,s,r,i,o,p,d,l,h)+(u-d)*Xu(n,e,t,s,r,i,o,p,f,l,h);return(p-a)*g+(a-c)*m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OW(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;Me(i,"unique");const o=s.data.get(i.dataId).values,{outputValues:a,outputShape:u,indices:l}=XI(o,r,i.shape,i.dtype);return[s.makeTensorInfo(u,i.dtype,a),s.makeTensorInfo([l.length],"int32",l)]}const MW={kernelName:Ug,backendName:"cpu",kernelFunc:OW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zW(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r.shape.length,a=r.shape[i],u=new Array(o-1);let l=0;for(let p=0;p<o;p++)p!==i&&(u[l++]=r.shape[p]);const h=new Array(o).fill(0),c=r.shape.slice();c[i]=1;const d=new Array(a);for(let p=0;p<d.length;p++){h[i]=p;const f=bo({inputs:{x:r},backend:t,attrs:{begin:h,size:c}});d[p]=Nt({inputs:{x:f},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(f)}return d}const BW={kernelName:Ac,backendName:"cpu",kernelFunc:zW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:o}=s;Me(r,"unsortedSegmentSum");const a=r.shape.length,u=i.shape.length,l=[],h=[],c=a-u;let d=i;for(let f=0;f<c;++f){const g=fd({inputs:{input:d},backend:t,attrs:{dim:f+1}});d=g,h.push(g)}for(let f=0;f<o;++f){const g=$i(f,"int32"),m=t.makeTensorInfo([],"int32",g),b=lI({inputs:{a:m,b:d},backend:t}),x=Ci({inputs:{x:b},backend:t,attrs:{dtype:"float32"}}),v=cf({inputs:{a:x,b:r},backend:t}),w=Zc({inputs:{x:v},backend:t,attrs:{axis:0,keepDims:!1}});l.push(w),h.push(m),h.push(b),h.push(x),h.push(v),h.push(w)}const p=c$({inputs:l,backend:t,attrs:{axis:0}});return h.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const UW={kernelName:Fc,backendName:"cpu",kernelFunc:VW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GW=[OB,bz,zB,VB,Iz,GB,HB,jB,qB,ZB,JB,tV,sV,oV,uV,hV,pV,mV,xV,PB,yV,vV,SV,kz,$V,Cz,Ez,TV,yz,RV,_V,DV,FV,LV,MV,BV,UV,WV,KV,XV,YV,QV,e4,n4,s4,i4,a4,l4,c4,h4,d4,f4,x4,EB,y4,Rz,T4,Nz,E4,Dz,F4,P4,O4,Fz,Lz,z4,V4,G4,H4,Mz,Bz,wz,j4,NV,q4,Z4,J4,RB,Uz,Wz,tU,Kz,sU,oU,uU,hU,pU,mU,gU,Xz,bU,wU,CU,IU,kU,EU,NU,Yz,DU,PU,MU,Qz,eB,VU,WU,jU,nB,qU,ZU,QU,h$,nG,_B,iB,rG,oG,uG,cG,vz,Um,dG,DB,AB,FB,fG,gG,bG,wG,CG,SG,$G,pB,TG,DG,FG,MG,mB,BG,UG,WG,gB,LU,jG,qG,ZG,JG,tW,sW,iW,aW,yB,uW,vB,SB,cW,dW,fW,gW,bW,TB,m4,wW,CW,IW,kW,EW,NW,sB,MW,BW,UW,YU];for(const n of GW)Wg(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ji={},vh={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function WW(n,e){ji[n]=e}function Js(n,e){if(!(n in ji)||e!=null){const s=KW(n,e);if(s!==null)ji[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=ji[n];return t==null||t.isContextLost()?(delete ji[n],Js(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),ji[n])}function HW(n){if(!ne().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function KW(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??HW(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete ji[n]},!1),ne().getBool("SOFTWARE_WEBGL_ENABLED")&&(vh.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",vh)||t.getContext("experimental-webgl",vh):t.getContext("webgl2",vh)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var kl;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(kl||(kl={}));var ms;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(ms||(ms={}));var wn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(wn||(wn={}));function Qc(n,e){return[e,n]}function jW(n,e){return n*e}function Ch(n){const e=Q(n),t=Math.ceil(e/4);return dm(t)}function Tu(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function XW(n,e){const[t,s]=Tu(n,e);return t*s*4}function hb(n,e){const t=n;let s,r,i,o,a,u,l,h,c,d;return ne().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,i=t.RGBA16F,o=t.RGBA32F,a=t.RED,l=4,h=1,c=t.HALF_FLOAT,d=t.FLOAT,u=t.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,o=t.RGBA,a=n.RGBA,l=4,h=4,c=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,u=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:h,textureTypeHalfFloat:c,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Re(n,e){const t=e();return ne().getBool("DEBUG")&&qW(n),t}function qW(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+JW(n,e))}const YW=596e-10,ZW=65504;function QW(n){return!!(ne().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||YW<Math.abs(n)&&Math.abs(n)<ZW)}function JW(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Sh(n,e){return Jr(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function eH(n,e){const t=Jr(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Re(n,()=>n.shaderSource(t,e)),Re(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function tH(n,e){const t=Jr(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Re(n,()=>n.shaderSource(t,e)),Re(n,()=>n.compileShader(t)),ne().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw d$(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const nH=/ERROR: [0-9]+:([0-9]+):/g;function d$(n,e){const t=nH.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),i=r.length.toString().length+2,o=r.map((c,d)=>oa((d+1).toString(),i)+c);let a=0;for(let c=0;c<o.length;c++)a=Math.max(o[c].length,a);const u=o.slice(0,s-1),l=o.slice(s-1,s),h=o.slice(s);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${oa(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function sH(n){return Jr(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function rH(n,e){if(Re(n,()=>n.linkProgram(e)),!ne().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Kf(n,e){if(Re(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function iH(n,e){const t=Jr(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Re(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Re(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function oH(n,e){const t=Jr(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Re(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Re(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function aH(n){return Jr(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function uH(n,e){const t=ne().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function lH(n){return Jr(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function F0(n,e,t,s,r,i,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(Re(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),Re(n,()=>n.vertexAttribPointer(a,r,n.FLOAT,!1,i,o)),Re(n,()=>n.enableVertexAttribArray(a)),!0)}function cH(n,e,t){mH(n,t),Re(n,()=>n.activeTexture(n.TEXTURE0+t)),Re(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function hH(n,e,t){return Jr(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function dH(n,e,t){return n.getUniformLocation(e,t)}function pH(n,e,t,s){Re(n,()=>cH(n,e,s)),Re(n,()=>n.uniform1i(t,s))}function jf(n,e,t){Re(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Re(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function P0(n,e){Re(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Re(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Ih(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+fH(n,e))}function fH(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Jr(n,e,t){const s=Re(n,()=>e());if(s==null)throw new Error(t);return s}function mH(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function va(n,e=2){return Q(n.slice(0,n.length-e))}function Ca(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function $h(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[va(n),...Ca(n)]),e}function gH(n,e=!1){let t=ne().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ne().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ne().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((a,u)=>u>=n.length-2?wg(n[u]):n[u]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Ii(n).newShape);let r=Q(n),i=null;n.length<=1&&r<=t?i=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const o=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||o)if(e){const a=va(n);let u=2,l=2;n.length&&([u,l]=Ca(n)),r=a*(u/2)*(l/2),i=dm(r).map(h=>h*2)}else i=dm(r);return i}function kh(n){return n%2===0}function gd(n,e){if(n=n.slice(-2),e=e.slice(-2),ct(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||kh(t)&&kh(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&kh(n[0])&&kh(e[0])}let Xf,qf;function xH(n){if(Xf==null){const e=Js(n);Xf=e.getParameter(e.MAX_TEXTURE_SIZE)}return Xf}function bH(n){if(qf==null){const e=Js(n);qf=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,qf)}function yH(n){if(n===0)return 0;let e;const t=Js(n);return Ds(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:Ds(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Ds(n,e){return n.getExtension(e)!=null}function L0(n){try{if(Js(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function wH(n){if(n===0)return!1;const e=Js(n);if(n===1){if(!Ds(e,"OES_texture_float"))return!1}else if(!Ds(e,"EXT_color_buffer_float"))return!1;return Wm(e)}function vH(n){if(n===0)return!1;const e=Js(n);if(n===1){if(!Ds(e,"OES_texture_float")||!Ds(e,"WEBGL_color_buffer_float"))return!1}else{if(Ds(e,"EXT_color_buffer_float"))return Wm(e);const s="EXT_color_buffer_half_float";if(Ds(e,s)){const r=e.getExtension(s);return CH(e,r)}return!1}return Wm(e)}function Wm(n){const e=hb(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),o}function CH(n,e){const t=hb(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),a}function SH(n){return n!==2?!1:Js(n).fenceSync!=null}function Jc(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&L(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ze=ne();ze.registerFlag("HAS_WEBGL",()=>ze.getNumber("WEBGL_VERSION")>0);ze.registerFlag("WEBGL_VERSION",()=>L0(2)?2:L0(1)?1:0);ze.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ze.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ze.get("WEBGL_VERSION")===2);ze.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ze.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ze.registerFlag("WEBGL_PACK",()=>ze.getBool("HAS_WEBGL"));ze.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_CLIP",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_REDUCE",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_LAZILY_UNPACK",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_CONV_IM2COL",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>xH(ze.getNumber("WEBGL_VERSION")));ze.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>bH(ze.getNumber("WEBGL_VERSION")));ze.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=ze.getNumber("WEBGL_VERSION");return n===0?0:yH(n)});ze.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ze.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!uv());ze.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>wH(ze.getNumber("WEBGL_VERSION")));ze.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ze.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ze.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ze.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>vH(ze.getNumber("WEBGL_VERSION")));ze.registerFlag("WEBGL_FENCE_API_ENABLED",()=>SH(ze.getNumber("WEBGL_VERSION")));ze.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ze.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ze.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});ze.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>uv()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});ze.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ze.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ze.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ze.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ze.registerFlag("WEBGL_EXP_CONV",()=>!1);ze.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ze.getBool("IS_TEST"));ze.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ze.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ze.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ze.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bn(){let n,e,t,s,r,i,o,a,u,l;return ne().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",a=ne().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Po(n,e,t="index"){const s=Be(e);return s.map((r,i)=>{const o=`int ${n[i]} = ${t} / ${r}`,a=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${o}; ${a};`}).join("")}function hf(n,e,t="index"){const s=Be(e);return s.map((r,i)=>{const o=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,a=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function IH(n,e){const t=n.length,s=n.map(i=>`${e}[${i}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let i=t-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function $H(n,e,t="index"){const s=n.map((i,o)=>o),r=IH(s,e);return r.map((i,o)=>{const a=`int ${n[o]} = ${t} / ${r[o]}`,u=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`;return`${a}; ${u};`}).join("")}function db(n){const e=Be(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function pb(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const p$=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:f$}=gP;function kH(n,e,t){const s=[];if(n.forEach(p=>{const f=Q(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),t.enableShapeUniforms){const{uniformShape:g}=fb(t.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(g.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`);break}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(p=>TH(p,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=Bn(),u=NH(a);let l,h,c=AH(a);return e.isPacked?(l=EH(e.logicalShape,o,t.enableShapeUniforms),h=DH(a)):(l=RH(e.logicalShape,o,t.enableShapeUniforms),h=_H(a)),t.packedInputs&&(c+=OH),[c,u,h,r,l,i,t.userCode].join(`
`)}function Eu(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return qH(n,e);case 1:return ZH(n,e);case 2:return JH(n,e);case 3:return tK(n,e);case 4:return sK(n,e);case 5:return rK(n);case 6:return iK(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function m$(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return XH(n);case 1:return YH(n,e);case 2:return QH(n,e);case 3:return eK(n,e);default:return nK(n,e)}}function TH(n,e,t=!1,s){let r="";t?r+=m$(n,s):r+=Eu(n,s);const i=n.shapeInfo.logicalShape,o=e.logicalShape;return i.length<=o.length&&(t?r+=oK(n,e):r+=aK(n,e)),r}function EH(n,e,t){switch(n.length){case 0:return g$();case 1:return MH(n,e,t);case 2:return KH(n,e,t);case 3:return BH(n,e,t);default:return UH(n,e,t)}}function RH(n,e,t){switch(n.length){case 0:return g$();case 1:return zH(n,e,t);case 2:return jH(n,e,t);case 3:return VH(n,e,t);case 4:return GH(n,e,t);case 5:return WH(n,e);case 6:return HH(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function NH(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function _H(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function DH(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function AH(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${FH}
    ${PH}
    ${LH}
  `}const FH=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,PH=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,LH=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,OH=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function g$(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function MH(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function zH(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function BH(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function VH(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${hf(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Po(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function UH(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let o=i,a="",u="b, r, c";for(let l=2;l<n.length-1;l++)o*=n[n.length-l-1],a=`
      int b${l} = index / ${o};
      index -= b${l} * ${o};
    `+a,u=`b${l}, `+u;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${u});
    }
  `}function GH(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${hf(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Po(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function WH(n,e){const t=Po(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function HH(n,e){const t=Po(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function KH(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(ct(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function jH(n,e,t){return ct(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Lo(n){return`offset${n}`}function XH(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Bn();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function qH(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Lo(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,u]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function YH(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,i=Bn();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function ZH(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Ru(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],o=r[1];if(o===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=Lo(t);return o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function QH(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],u=Bn();if(i!=null&&ct(t,i))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${u.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${u.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;const l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],h=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function JH(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&ct(t,i)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const d=i[0],p=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:a}=Ii(t),u=o;if(u.length<t.length){const d=Nu(n,u),p=["row","col"];return`
      ${Eu(d,e)}
      float ${r}(int row, int col) {
        return ${r}(${_u(p,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Ru(n)}
      }
    `;const l=i[0],h=i[1],c=Lo(s);return h===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${c}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${c}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${s}, uv);
    }
  `:l===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${c}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${c}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${c};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${c};
    vec2 uv = uvFromFlat(${l}, ${h}, index);
    return sampleTexture(${s}, uv);
  }
`}function eK(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const d=t.slice(1),p=[1,2],f=Nu(n,d),g=["b","row","col"];return`
        ${m$(f,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${_u(g,p)});
        }
      `}const a=Bn();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const u=o[0],l=o[1],h=Math.ceil(t[2]/2),c=h*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${c}, ${h}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function tK(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[1]*t[2],o=t[2],{newShape:a,keptDims:u}=Ii(t),l=a;if(l.length<t.length){const g=Nu(n,l),m=["row","col","depth"];return`
        ${Eu(g,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${_u(m,u)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${Ru(n)}
      }
    `;const h=n.shapeInfo.texShape,c=h[0],d=h[1],p=n.shapeInfo.flatOffset;if(d===i&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${c}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(d===o&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `;const f=Lo(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${c}, ${d}, index);
        return sampleTexture(${s}, uv);
      }
  `}function nK(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Bn();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=u[0],h=u[1],c=Math.ceil(i[o-1]/2);let d=c*Math.ceil(i[o-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${c} + (col / 2)`;for(let g=2;g<o-1;g++)p=`int b${g}, `+p,d*=i[o-g-1],f=`b${g} * ${d} + `+f;return`
    vec4 ${s}(${p}) {
      int index = ${f};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${l});
      return ${r.texture2D}(${t}, uv);
    }
  `}function sK(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[3],o=t[2]*i,a=t[1]*o,{newShape:u,keptDims:l}=Ii(t);if(u.length<t.length){const x=Nu(n,u),v=["row","col","depth","depth2"];return`
      ${Eu(x,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${_u(v,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${Ru(n)}
      }
    `;const h=n.shapeInfo.flatOffset,c=n.shapeInfo.texShape,d=c[0],p=c[1],f=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,m=`int stride0 = ${s}Shape[1] * stride1;`;if(p===a&&h==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(p===i&&h==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;const b=Lo(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${g}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${b});
      return sampleTexture(${s}, uv);
    }
  `}function rK(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],i=e[3]*r,o=e[2]*i,a=e[1]*o,{newShape:u,keptDims:l}=Ii(e);if(u.length<e.length){const g=Nu(n,u),m=["row","col","depth","depth2","depth3"];return`
      ${Eu(g)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${_u(m,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${r})) +
          depth3;
        ${Ru(n)}
      }
    `;const h=n.shapeInfo.flatOffset,c=n.shapeInfo.texShape,d=c[0],p=c[1];if(p===a&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===r&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=Lo(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function iK(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:i}=Ii(e);if(r.length<e.length){const m=Nu(n,r),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${Eu(m)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${_u(b,i)});
      }
    `}const o=e[5],a=e[4]*o,u=e[3]*a,l=e[2]*u,h=e[1]*l;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${l}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Ru(n)}
      }
    `;const c=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],f=d[1];if(f===h&&c==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&c==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=Lo(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${l} + depth * ${u} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${g};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Ru(n){const e=n.name,t=Q(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function oK(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=f$(n.shapeInfo.logicalShape,e.logicalShape),u=$t(o),l=o-i;let h;const c=["x","y","z","w","u","v"];i===0?h="":o<2&&a.length>=1?h="coords = 0;":h=a.map(x=>`coords.${c[x+l]} = 0;`).join(`
`);let d="";o<2&&i>0?d="coords":d=n.shapeInfo.logicalShape.map((x,v)=>`coords.${c[v+l]}`).join(", ");let p="return outputValue;";const g=Q(n.shapeInfo.logicalShape)===1,b=Q(e.logicalShape)===1;if(i===1&&!g&&!b)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!b)o===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(a.length){const x=i-2,v=i-1;a.indexOf(x)>-1&&a.indexOf(v)>-1?p="return vec4(outputValue.x);":a.indexOf(x)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(v)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${h}
      vec4 outputValue = get${s}(${d});
      ${p}
    }
  `}function aK(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===u&&n.shapeInfo.flatOffset==null&&ct(o,i))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const l=$t(u),h=f$(n.shapeInfo.logicalShape,e.logicalShape),c=u-a;let d;const p=["x","y","z","w","u","v"];a===0?d="":u<2&&h.length>=1?d="coords = 0;":d=h.map(g=>`coords.${p[g+c]} = 0;`).join(`
`);let f="";return u<2&&a>0?f="coords":f=n.shapeInfo.logicalShape.map((g,m)=>`coords.${p[m+c]}`).join(", "),`
    float ${r}() {
      ${l} coords = getOutputCoords();
      ${d}
      return get${s}(${f});
    }
  `}function $t(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function fb(n,e,t){const{newShape:s,keptDims:r}=Ii(e),i=e.length,o=n&&i===3&&e[0]===1,a=o?e.slice(1):s,u=!n&&i>1&&!ct(e,t)&&s.length<i||o;return{useSqueezeShape:u,uniformShape:u?a:e,keptDims:r}}function Nu(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function _u(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uK(n,e,t,s){const r=t.map((h,c)=>{const d={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:h.isUniform?!1:h.texData.isPacked,flatOffset:null};return h.texData!=null&&h.texData.slice!=null&&h.texData.slice.flatOffset>0&&(d.flatOffset=h.texData.slice.flatOffset),{name:e.variableNames[c],shapeInfo:d}}),i=r.map(h=>h.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=kH(r,o,e),u=tH(n.gl,a),l=n.createProgram(u);return ne().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(l),Object.assign({program:e,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:i,outShapeInfo:o},x$(n,e,l)))}function x$(n,e,t){const s=[],r=[];let i,o,a,u=null,l=null;l=n.getUniformLocation(t,"NAN",!1),ne().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(t,"INFINITY",!1));const h=!1;for(const c of e.variableNames){const d={name:c,uniform:n.getUniformLocation(t,c,h),offset:n.getUniformLocation(t,`offset${c}`,h)};e.enableShapeUniforms&&(d.shape=n.getUniformLocation(t,`${c}Shape`,h),d.texShape=n.getUniformLocation(t,`${c}TexShape`,h)),s.push(d)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",h),a=n.getUniformLocation(t,"outShapeStrides",h),o=n.getUniformLocation(t,"outTexShape",h)),e.customUniforms)for(const c of e.customUniforms)r.push(n.getUniformLocation(t,c.name,h));return{variablesLocations:s,customUniformLocations:r,infLoc:u,nanLoc:l,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function O0(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,i=e[s],o=i.shape;if(!ct(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(t.isUniform&&i.isUniform)return;const a=t.texShape,u=i.isUniform?null:i.texData.texShape;if(!ct(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function lK(n,e,t,s,r){e.program.enableShapeUniforms||(O0(e.inShapeInfos,t),O0([e.outShapeInfo],[s]));const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),ne().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let u=0;u<t.length;++u){const l=t[u],{uniform:h,offset:c,shape:d,texShape:p}=e.variablesLocations[u];if(d){const{uniformShape:f}=fb(e.program.packedInputs,l.shape,l.texData.texShape);switch(f.length){case 1:n.gl.uniform1iv(d,new Int32Array(f));break;case 2:n.gl.uniform2iv(d,new Int32Array(f));break;case 3:n.gl.uniform3iv(d,new Int32Array(f));break;case 4:n.gl.uniform4iv(d,new Int32Array(f));break}}if(p&&n.gl.uniform2i(p,l.texData.texShape[0],l.texData.texShape[1]),h!=null){if(l.isUniform){if(Q(l.shape)<2)n.gl.uniform1f(h,l.uniformValues[0]);else{let f=l.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),n.gl.uniform1fv(h,f)}continue}l.texData.slice!=null&&c!=null&&n.gl.uniform1i(c,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,h,u)}}const a=e.outShapeLocation;if(a)switch(s.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const u=Be(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let u=0;u<e.program.customUniforms.length;++u){const l=e.program.customUniforms[u],h=e.customUniformLocations[u],c=r[u];if(l.type==="float")n.gl.uniform1fv(h,c);else if(l.type==="vec2")n.gl.uniform2fv(h,c);else if(l.type==="vec3")n.gl.uniform3fv(h,c);else if(l.type==="vec4")n.gl.uniform4fv(h,c);else if(l.type==="int")n.gl.uniform1iv(h,c);else if(l.type==="ivec2")n.gl.uniform2iv(h,c);else if(l.type==="ivec3")n.gl.uniform3iv(h,c);else if(l.type==="ivec4")n.gl.uniform4iv(h,c);else throw Error(`uniform type ${l.type} is not supported yet.`)}n.executeProgram()}function cK(n,e,t){let s="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const u=o.texData.texShape,{useSqueezeShape:l,uniformShape:h,keptDims:c}=fb(n.packedInputs,o.shape,u);let d="",p="",f="";if(h.length===1&&n.packedInputs){const S=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];d=`${S[0]>1}_${S[1]>1}`}else if(h.length===2&&!n.packedInputs)p=`${h[0]>1}_${h[1]>1}`;else if(h.length>2&&!n.packedInputs){const S=Be(h);f=`${S[0]===u[1]}_${S[S.length-1]===u[1]}`}const g=o.shape.length,m=h.length===2&&ct(o.shape,u),b=Q(o.shape)===1,x=xi(o.shape,t.shape),v=!n.packedInputs&&g===t.shape.length&&ct(u,t.texData.texShape),w=n.packedInputs||h.length>2?"":`${u[0]>1}_${u[1]>1}`;s+=`${g}_${v}_${l?c:""}_${h.length}_${b}_${x}_${m}_${d}_${p}_${f}_${w}_${a}`}else{const u=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${u}_${a}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${ne().getNumber("WEBGL_VERSION")}`,i}function En(n){return ne().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hK{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=kl.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Bn();this.outputShape=e,this.enableShapeUniforms=En(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?hf(["r","c","d"],e):Po(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dK{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=kl.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Bn();this.outputShape=e,this.enableShapeUniforms=En(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?hf(["r","c","d"],e):Po(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pK{constructor(e){this.variableNames=["A"],this.outTexUsage=ms.DOWNLOAD;const t=Bn();this.outputShape=e,this.userCode=`
      ${p$}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fK{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ms.DOWNLOAD;const t=Bn();this.outputShape=e,this.userCode=`
      ${p$}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mK={R:0,G:1,B:2,A:3};class M0{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Bn();this.outputShape=e,this.enableShapeUniforms=En(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<s.length;a++){const u=s[a];o+=`
          if(offset == ${a}) {
            result = values[${mK[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?pb():db(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gK{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Bn();this.outputShape=e,this.enableShapeUniforms=En(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const u=o*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?pb():db(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xK(n){const e=Bn(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return eH(n,t)}function bK(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return iH(n,e)}function yK(n){const e=new Uint16Array([0,1,2,2,1,3]);return oH(n,e)}function eh(n,e,t,s,r,i){uH(e,t);const o=aH(n),a=n.TEXTURE_2D;return Re(n,()=>n.bindTexture(a,o)),Re(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Re(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Re(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),Re(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),ne().getNumber("WEBGL_VERSION")===1?Re(n,()=>n.texImage2D(a,0,s,e,t,0,r,i,null)):Re(n,()=>n.texStorage2D(a,1,s,e,t)),Re(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function b$(n){return n.internalFormatFloat}function wK(n,e,t,s){const[r,i]=Qc(e,t);return eh(n,r,i,b$(s),s.textureFormatFloat,n.FLOAT)}function y$(n){return n.internalFormatHalfFloat}function vK(n,e,t,s){const[r,i]=Qc(e,t);return eh(n,r,i,y$(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function w$(n){return n.downloadTextureFormat}function CK(n,e,t,s){const[r,i]=Qc(e,t);return eh(n,r,i,w$(s),n.RGBA,n.UNSIGNED_BYTE)}function v$(n){return n.internalFormatPackedFloat}function SK(n,e,t,s){const[r,i]=Tu(e,t);return eh(n,r,i,v$(s),n.RGBA,n.FLOAT)}function C$(n){return n.internalFormatPackedHalfFloat}function IK(n,e,t,s){const[r,i]=Tu(e,t);return eh(n,r,i,C$(s),n.RGBA,s.textureTypeHalfFloat)}function $K(n,e,t){return Re(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),F0(n,e,"clipSpacePos",t,3,20,0)&&F0(n,e,"uv",t,2,20,12)}function kK(n,e,t,s,r,i){Re(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,u;r instanceof Uint8Array?(o=new Uint8Array(t*s*4),a=n.UNSIGNED_BYTE,u=n.RGBA):(o=new Float32Array(t*s*4),a=n.FLOAT,u=i.internalFormatPackedFloat),o.set(r),ne().getNumber("WEBGL_VERSION")===2?Re(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,a,o)):Re(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,t,s,0,n.RGBA,a,o)),Re(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function TK(n,e,t){Re(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ne().getNumber("WEBGL_VERSION")===2?Re(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Re(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ne().getNumber("WEBGL_VERSION")===2?Re(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Re(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Re(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function EK(n,e,t,s){const r=n.createBuffer();Re(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const a=4*4*e*t;return Re(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),Re(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Re(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function RK(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function NK(n,e,t,s){const[r,i]=Qc(e,t),o=4,a=new Uint8Array(jW(e*t,o));return Re(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function _K(n,e,t,s,r,i,o,a){const u=n,l=new Float32Array(XW(i,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function DK(n,e,t){const s=new Float32Array(e*t*4);return Re(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yf{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ne().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,WW(t,e)):this.gl=Js(t),e=this.gl,ne().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>Re(i,()=>i.createVertexArray()),this.bindVertexArray=o=>Re(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>Re(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>Re(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Re(e,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>Re(e,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Re(e,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>Re(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ne().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Sh(this.gl,i),Ds(this.gl,o))this.textureHalfFloatExtension=Sh(this.gl,o);else if(ne().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),Ds(this.gl,r))this.colorBufferHalfFloatExtension=Sh(this.gl,r);else if(ne().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",Ds(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(Ds(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=bK(this.gl),this.indexBuffer=yK(this.gl),this.framebuffer=lH(this.gl),this.textureConfig=hb(this.gl,this.textureHalfFloatExtension)}get debug(){return ne().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Re(e,()=>e.finish()),Re(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Re(e,()=>e.deleteFramebuffer(this.framebuffer)),Re(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Re(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Re(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),wK(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),vK(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),CK(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),TK(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),kK(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),IK(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),SK(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(P0(this.gl,this.framebuffer),this.outputTexture=null),Re(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>NK(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,i,o){return _K(this.gl,e,t,s,r,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return RK(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=EK(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(ne().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},t=i}else ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>DK(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=xK(t));const s=sH(t);Re(t,()=>t.attachShader(s,this.vertexShader)),Re(t,()=>t.attachShader(s,e)),rH(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Kf(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Re(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),$K(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Re(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Kf(this.gl,this.program),Re(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?hH(this.gl,e,t):dH(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Re(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),pH(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,i]=Tu(t,s);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Kf(this.gl,this.program),Ih(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Re(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Re(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Sh(this.gl,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Iy(()=>this.disposed||this.isQueryAvailable(e,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=AK(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ne().platform&&(s=ne().platform.setTimeoutCustom.bind(ne().platform)),Iy(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),jf(this.gl,e,this.framebuffer),this.debug&&Ih(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(jf(this.gl,this.outputTexture,this.framebuffer),this.debug&&Ih(this.gl)):P0(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;jf(r,e,this.framebuffer),this.debug&&Ih(r),this.outputTexture=e,Re(r,()=>r.viewport(0,0,t,s)),Re(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),Re(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function AK(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:FK,bincountImpl:S$,bincountReduceImpl:PK,bitwiseAndImpl:LK,castImpl:OK,ceilImpl:MK,concatImpl:zK,equalImpl:BK,expImpl:VK,expm1Impl:UK,floorImpl:GK,gatherNdImpl:WK,gatherV2Impl:HK,greaterImpl:KK,greaterEqualImpl:jK,lessImpl:XK,lessEqualImpl:qK,linSpaceImpl:YK,logImpl:ZK,maxImpl:QK,maximumImpl:JK,minimumImpl:e6,multiplyImpl:t6,negImpl:n6,notEqualImpl:s6,prodImpl:r6,raggedGatherImpl:i6,raggedRangeImpl:o6,raggedTensorToTensorImpl:a6,rangeImpl:u6,rsqrtImpl:l6,scatterImpl:c6,sigmoidImpl:h6,simpleAbsImpl:I$,sliceImpl:d6,sparseFillEmptyRowsImpl:p6,sparseReshapeImpl:f6,sparseSegmentReductionImpl:$$,sqrtImpl:m6,staticRegexReplaceImpl:g6,stridedSliceImpl:x6,stringNGramsImpl:b6,stringSplitImpl:y6,stringToHashBucketFastImpl:w6,subImpl:v6,tileImpl:C6,topKImpl:S6,transposeImpl:mb,uniqueImpl:I6}=qI;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k$(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Fn(n,e){return e===1?[n]:k$(n,e)}function $6(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k6{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=En(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Fn("rc",this.rank),s=$t(this.rank),r=this.getOutOfBoundsCondition(t),i=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${e[e.length-1-o]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T${constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=En(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${T6(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?pb():db(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function T6(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?$H(["r","c","d"],"inputShape"):Po(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let E6=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=B0(t,s),i=V0(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=z0(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const u=this.freeTextures[i].pop();return this.usedTextures[i].push(u),u}let a;return r===wn.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===wn.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===wn.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===wn.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===wn.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const i=B0(s,r),o=V0(t,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const a=z0(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=ne().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const l=this.usedTextures[o],h=l&&l.indexOf(e);if(h==null||h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[h]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function R6(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function z0(n,e,t,s,r){const i=N6(e,s);let o;if(r){const[u,l]=Tu(n[0],n[1]);o=u*l}else{const[u,l]=Qc(n[0],n[1]);o=u*l}const a=R6(t,i);return o*a}function N6(n,e){switch(n){case wn.PACKED_2X2_FLOAT32:return v$(e);case wn.PACKED_2X2_FLOAT16:return C$(e);case wn.UNPACKED_FLOAT32:return b$(e);case wn.UNPACKED_FLOAT16:return y$(e);case wn.PACKED_4X1_UNSIGNED_BYTE:return w$(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function _6(n){return ne().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?wn.PACKED_2X2_FLOAT32:wn.UNPACKED_FLOAT32:n?wn.PACKED_2X2_FLOAT16:wn.UNPACKED_FLOAT16}function B0(n,e){if(n===ms.UPLOAD)return wn.PACKED_2X2_FLOAT32;if(n===ms.RENDER||n==null)return _6(e);if(n===ms.DOWNLOAD||n===ms.PIXELS)return wn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function V0(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xr=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=En(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const Os="if (isnan(x)) return x;",D6="return x;",U0="return abs(x);",A6="return (x >= 0.0) ? x : (exp(x) - 1.0);",F6=Os+`
  return (x < 0.0) ? 0.0 : x;
`,P6=Os+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ii="return x;",L6="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O6="return x;",M6=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,z6=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,B6=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,V6="return 1.0 / (1.0 + exp(-1.0 * x));";class ci{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=En(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U6{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=En(this.outputShape.length);const t=e.length,s=Fn("rc",t),r=$t(t),i=$6(t,s),o=s.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G6=Zv,W6=1e-7,H6=1e-4,Th={};function K6(n){return n in Th||(Th[n]={}),Th[n]}const j6=ne().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),X6=600;function q6(){return ne().global.screen==null?1024:ne().global.screen.height*ne().global.screen.width*window.devicePixelRatio*X6/1024/1024}class df extends Ad{nextDataId(){return df.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ne().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Yf)t=e;else{const s=Js(ne().getNumber("WEBGL_VERSION"),e);t=new Yf(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Js(ne().getNumber("WEBGL_VERSION"));t=new Yf(s),this.binaryCache=K6(ne().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new E6(this.gpgpu),this.numMBBeforeWarning=q6(),this.texData=new yg(this,ds())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,i,o){const a=this.makeTensorInfo(t,s),u=this.texData.get(a.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[r,i]},u.texShape=[r,i];const l=$h(t),h=new M0(l,!1,o),c=this.runWebGLProgram(h,[a],s,[[r,i]]);return c.shape=t,u.texture=null,this.disposeIntermediateTensorInfo(a),c.dataId}write(e,t,s){if((ne().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ne().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:ms.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,i){if(ne().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:ms.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:i,slice:o,shape:a,isPacked:u}=t;if(o!=null){let d;u?d=new ci(a,ii):d=new xr(a,ii);const p=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const l=this.activeTimers!=null;let h;l&&(h=Gn());let c;if(r==="complex64"){const d=this.readSync(i.real.dataId),p=this.readSync(i.imag.dataId);c=qs(d,p)}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=Gn()-h),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(g=>f.push(g))}const t=this.texData.get(e),{values:s,shape:r,slice:i,dtype:o,complexTensorInfos:a,isPacked:u}=t;if(i!=null){let f;u?f=new ci(r,ii):f=new xr(r,ii);const g=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:o}],o),m=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),m}if(s!=null)return this.convertAndCacheOnCPU(e);if(ne().getBool("DEBUG")&&!ne().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ne().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,h;if(o!=="complex64"&&ne().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(e);const f=this.texData.get(h.dataId);l=this.gpgpu.createBufferFromTexture(f.texture.texture,...Ch(r))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let c;if(o==="complex64"){const f=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),g=f[0],m=f[1];c=qs(g,m)}else if(l==null)c=this.getValuesFromTexture(e);else{const f=Q(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(l,f)}if(h!=null&&this.disposeIntermediateTensorInfo(h),l!=null){const f=this.gpgpu.gl;Re(f,()=>f.deleteBuffer(l))}const d=this.convertAndCacheOnCPU(e,c),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ds().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:i,slice:o,dtype:a,isPacked:u,texture:l}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let p;u?p=new ci(i,ii):p=new xr(i,ii);const f=this.runWebGLProgram(p,[{dataId:e,shape:i,dtype:a}],a),g=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),g}if(l==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(e,t.customTexShape),c=ds().makeTensorFromTensorInfo(h),d=this.texData.get(h.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Xs(r));return Je(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Je(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!QW(s))throw ne().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),i=Q(t);if(ne().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...Ch(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(d),f}const o=ne().getBool("WEBGL_PACK")&&r===!0,a=o?$h(t):t,u=o?new fK(a):new pK(a),l=this.runWebGLProgram(u,[{shape:a,dtype:s,dataId:e}],"float32"),h=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=Xr(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),o=Xr(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(i);a.kernelMs=_w(u),a.getExtraProfileInfo=()=>u.map((l,h)=>({name:o[h],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Gn(),endMs:null}}endTimer(e){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Gn(),e)}async getQueryTime(e){if(ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:i,isPacked:o,slice:a}=this.texData.get(e),u=a&&a.origDataId||e,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,i,o)));const h=this.texData.get(e);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=j6){return ne().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&Q(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){ps("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return G6(e.shape,t)}packedUnaryOp(e,t,s){const r=new ci(e.shape,t),i=this.compileAndRun(r,[e],s);return ds().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=I$(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(ne().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,U0,e.dtype);const t=new xr(e.shape,U0),s=this.compileAndRun(t,[e]);return ds().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Ia(s[0])){const i=s.map(o=>Ur(o));r=this.write(i,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return ds().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new U6(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new k6(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[va(e.shape),...Ca(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[va(t),...Ca(t)],o=new T$(i,s),a=!0,u=[s],l=this.runWebGLProgram(o,[r],e.dtype,u,a);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:i,dtype:o}=s;if(t!=null){const d=Q(i),p=t[0]*t[1]*4;L(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=$h(i);let u;r?u=new dK(a):u=new hK(a);const l=!0,h=[t??Ch(a)],c=this.runWebGLProgram(u,[{shape:a,dtype:o,dataId:e}],o,h,l,t);return{dtype:o,shape:i,dataId:c.dataId}}runWebGLProgram(e,t,s,r,i=!1,o){const a=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(a.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===kl.DENSE){const b=o??Ch(e.outputShape);u.texShape=b.map(x=>x*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),Q(a.shape)===0)return u.values=fn(a.dtype,0),a;const l=[],h=t.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(b.dataId);if(x.texture==null){if(!e.packedInputs&&Q(b.shape)<=ne().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:x.values};e.packedInputs&&(x.isPacked=!0,x.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!x.isPacked!=!!e.packedInputs)b=x.isPacked?this.unpackTensor(b):this.packTensor(b),l.push(b),x=this.texData.get(b.dataId);else if(x.isPacked&&!gd(x.shape,b.shape)){const v=b,w=b.shape;b.shape=x.shape,b=this.packedReshape(b,w),l.push(b),x=this.texData.get(b.dataId),v.shape=w}return{shape:b.shape,texData:x,isUniform:!1}});this.uploadToGPU(a.dataId);const c={shape:a.shape,texData:u,isUniform:!1},d=cK(e,h,c),p=this.getAndSaveBinary(d,()=>uK(this.gpgpu,e,h,c)),f=this.activeTimers!=null;let g;f&&(g=this.startTimer()),ne().get("ENGINE_COMPILE_ONLY")||lK(this.gpgpu,p,h,c,r),l.forEach(b=>this.disposeIntermediateTensorInfo(b)),f&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const m=ne().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const b=Gn();b-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!ne().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&i===!1){const b=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),b}return a}compileAndRun(e,t,s,r,i=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ne().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=se(()=>{if(!ne().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ne().getBool("DEBUG");ne().set("DEBUG",!1);const t=this.abs(wt(1e-8)).dataSync()[0];if(ne().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?W6:H6}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:i,texture:o,usage:a,isPacked:u}=t;if(o!=null)return;const l=this.activeTimers!=null;let h;l&&(h=Gn());let c=t.texShape;if(c==null&&(c=gH(s,u),t.texShape=c),i!=null){const d=$h(s);let p,f=c[1],g=c[0];const m=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!m)&&([f,g]=Tu(c[0],c[1])),u?p=new gK(d,m):p=new M0(d,m);const b=m?[g,f]:c,x=this.makeTensorInfo(b,r),v=this.texData.get(x.dataId);m?v.usage=ms.PIXELS:v.usage=ms.UPLOAD,v.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),f,g,i);const w=[[g,f]],k=this.runWebGLProgram(p,[x],r,w,!0),E=this.texData.get(k.dataId);t.texShape=E.texShape,t.isPacked=E.isPacked,t.usage=E.usage,ne().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(t.texture=E.texture,t.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo(x),l&&(this.uploadWaitMs+=Gn()-h)}else{const d=this.acquireTexture(c,a,r,u);t.texture=d}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=Y6(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Hh(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(i){throw i}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await f2(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(d$(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:u}=x$(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=o,e.outShapeStridesLocation=a,e.outTexShapeLocation=u}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:i,width:o,channels:a}=e,u=ds().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=u.writeTexture(r,t,s,i,o,a);return ds().makeTensorFromDataId(l,t,s,u)}}df.nextDataId=0;function Y6(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */lv()&&Kg("webgl",()=>new df,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gb=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let yo=class{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Ke(t,s),this.enableShapeUniforms=En(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oo=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Du{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ke(t,s);const i=this.outputShape.length;this.enableShapeUniforms=En(i);let o="";if(r)if(i===0||Q(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${$t(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=Fn("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${u[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${u[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${u[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${u[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function us(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Z6={kernelName:Ka,backendName:"webgl",kernelFunc:us};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Di(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),o=t.texData.get(i.dataId),a=us({inputs:{x:s},backend:t}),u=us({inputs:{x:r},backend:t});return o.complexTensorInfos={real:a,imag:u},i}const Q6={kernelName:Vd,backendName:"webgl",kernelFunc:Di};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E$="return (a < 0.) ? b * a : a;",R$=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function J6(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,o=t.makeTensorInfo([],"float32",$i(i,"float32")),a=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Du(R$,r.shape,o.shape):new yo(E$,r.shape,o.shape),u=t.runWebGLProgram(a,[r,o],"float32");return t.disposeIntermediateTensorInfo(o),u}const e5={kernelName:nc,backendName:"webgl",kernelFunc:J6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N$="return (a < 0.) ? b * a : a;",_$=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function t5(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Du(_$,s.shape,r.shape):new yo(N$,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],"float32")}const n5={kernelName:vc,backendName:"webgl",kernelFunc:t5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Au="if (isnan(x)) return x;";function xt({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,a=i,u=s||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const c=a.texData.get(o.dataId),d=t(c.values,u);return a.makeTensorInfo(o.shape,u,d)}const l=ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let h;return l?h=new ci(o.shape,e):h=new xr(o.shape,n),a.runWebGLProgram(h,[o],u)}}function Sn({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:a})=>{const{a:u,b:l}=o,h=a;if(s&&u.dtype==="complex64"){const f=h.texData.get(u.dataId),g=h.texData.get(l.dataId),[m,b]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(v=>{const[w,S]=v,k={dataId:w.dataId,dtype:w.dtype,shape:u.shape},E={dataId:S.dataId,dtype:S.dtype,shape:l.shape},I=new yo(n,u.shape,l.shape);return h.runWebGLProgram(I,[k,E],mn(w.dtype,S.dtype))}),x=Di({inputs:{real:m,imag:b},backend:h});return h.disposeIntermediateTensorInfo(m),h.disposeIntermediateTensorInfo(b),x}const c=i||mn(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||h.shouldExecuteOnCPU([u,l]))&&r!=null){const f=h.texData.get(u.dataId).values,g=h.texData.get(l.dataId).values,m=u.dtype==="string"?Ys(f):f,b=u.dtype==="string"?Ys(g):g,[x,v]=r(u.shape,l.shape,m,b,c),w=h.makeTensorInfo(v,c),S=h.texData.get(w.dataId);return S.values=x,w}const d=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return d?p=new Du(e,u.shape,l.shape,t):p=new yo(n,u.shape,l.shape),h.runWebGLProgram(p,[u,l],c)}}function Tl(n,e=!1){if(n==="linear")return e?O6:D6;if(n==="relu")return e?z6:F6;if(n==="elu")return e?M6:A6;if(n==="relu6")return e?B6:P6;if(n==="prelu")return e?_$:N$;if(n==="leakyrelu")return e?R$:E$;if(n==="sigmoid")return e?V6:L6;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let D$=class{constructor(e,t,s,r=!1,i=!1,o=!1,a=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=En(this.outputShape.length);const h=r?e[1]:e[2],c=Math.ceil(h/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=i?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",b="";a&&(u?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:m=`vec4 activation(vec4 x) {
          ${a}
        }`,b="result = activation(result);");const x=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let v="rc.x",w="rc.x";e[0]<t[0]?v=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(w=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${v};
        int batchB = ${w};
        for (int i = 0; i < ${c}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${g[0]});
          result += (${f[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${b}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G0={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let W0=class{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ke(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H0="return a * b;";function xb(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=mn(s.dtype,r.dtype);if(s.dtype==="complex64"){const a=t.texData.get(s.dataId),u=t.texData.get(r.dataId),l=new W0(G0.REAL,s.shape,r.shape),h=new W0(G0.IMAG,s.shape,r.shape),c=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],d=t.runWebGLProgram(l,c,"float32"),p=t.runWebGLProgram(h,c,"float32"),f=Di({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}if(t.shouldExecuteOnCPU([s,r])){const a=t.texData.get(s.dataId),u=t.texData.get(r.dataId),[l,h]=t6(s.shape,r.shape,a.values,u.values,i),c=t.makeTensorInfo(h,i),d=t.texData.get(c.dataId);return d.values=l,c}let o;return ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new Du(H0,s.shape,r.shape):o=new yo(H0,s.shape,r.shape),t.runWebGLProgram(o,[s,r],i)}const s5={kernelName:tu,backendName:"webgl",kernelFunc:xb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r5(n,e,t){const s=[va(n.shape),...Ca(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[va(e),...Ca(e)],o=new T$(i,s),a=!0,u=[s],l=t.runWebGLProgram(o,[r],n.dtype,u,a);return{dataId:l.dataId,shape:e,dtype:l.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Te(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,o=t,a=Q(r.shape),u=vg(i,a),l=Q(u);L(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const h=o.texData.get(r.dataId);return h.isPacked&&!gd(r.shape,u)&&!(h.texture!==null&&gd(h.shape,u))?r5(r,u,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}const i5={kernelName:Sc,backendName:"webgl",kernelFunc:Te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K0{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];const a=Math.floor(s/4)*4,u=s%4;let l="sumValue += dot(values, ones);";if(t!=null){const c=1/t;l=`sumValue += dot(values * ${da(c)?c.toPrecision(2):c}, ones);`}let h="";i%s>0&&(h=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let o5=class{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];let a="0.0",u="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",u="min"):t==="max"&&(a="-1.0 / 1e-20",u="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");const h=Math.floor(s/4)*4,c=s%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";i%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${h};
        if (${c===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${c===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${c===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a5(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=Pp(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Mo(n,e,t,s){const r=a5(n.shape);let i=n;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:u,outSize:l}=r[o];let h,c;t==="mean"?h=o===0?new K0({windowSize:u,inSize:a,batchSize:n.shape[0],outSize:l},a):new K0({windowSize:u,inSize:a,batchSize:n.shape[0],outSize:l}):h=new o5({windowSize:u,inSize:a,batchSize:n.shape[0],outSize:l},t),c=i,i=s.runWebGLProgram(h,[i],e),c.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(c)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let u5=class{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[t[o]];this.outputShape=s,this.rank=s.length;const r=$t(this.rank),i=l5(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}};function l5(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c5{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let h=0;h<s.length;h++)s[h]=e[t[h]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=$t(this.rank),i=k$("rc",this.rank),o=new Array(this.rank);for(let h=0;h<t.length;h++)o[t[h]]=i[h];const a=`vec2(${o.slice(-2).join()})`,u=`++${i[this.rank-1]} < ${s[this.rank-1]}`,l=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pf(n,e,t){const s=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new c5(n.shape,e):new u5(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h5(n,e,t,s){const r=e,i=n.shape.length,o=Qe(r,n.shape);let a=o;const u=kt(a,i),l=u!=null;let h=n;l&&(h=pf(n,u,s),a=_t(a.length,i)),tn("sum",a,i);const[c,d]=Yt(h.shape,a);let p=c;t&&(p=qt(c,o));const f=Q(d),m=Q(n.shape)/f,b=Te({inputs:{x:h},attrs:{shape:[m,f]},backend:s}),x=yp(n.dtype),v=Mo(b,x,"sum",s),w=Te({inputs:{x:v},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(v),l&&s.disposeIntermediateTensorInfo(h),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ff(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;return h5(r,i,o,t)}const d5={kernelName:Rc,backendName:"webgl",kernelFunc:ff};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zn(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,o=t,a=r.shape.length,u=new Array(a);for(let h=0;h<u.length;h++)u[h]=r.shape[i[h]];let l;if(o.shouldExecuteOnCPU([r])){const c=o.texData.get(r.dataId).values,d=mb(c,r.shape,r.dtype,i,u);l=o.makeTensorInfo(u,r.dtype);const p=o.texData.get(l.dataId);p.values=d}else l=pf(r,i,o);return l}const p5={kernelName:to,backendName:"webgl",kernelFunc:zn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A$=1e3;function xd({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:u=null}){const l=n.shape.length,h=e.shape.length,c=t?n.shape[l-2]:n.shape[l-1],d=s?e.shape[h-1]:e.shape[h-2],p=t?n.shape[l-1]:n.shape[l-2],f=s?e.shape[h-2]:e.shape[h-1],g=n.shape.slice(0,-2),m=e.shape.slice(0,-2),b=Q(g),x=Q(m),w=Ke(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);L(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const S=t?[b,c,p]:[b,p,c],k=s?[x,f,d]:[x,d,f],E=Te({inputs:{x:n},backend:r,attrs:{shape:S}}),I=Te({inputs:{x:e},backend:r,attrs:{shape:k}}),C=[E,I],T=Math.max(b,x),R=t?E.shape[1]:E.shape[2],P=i!=null,D=o!=null,F=u==="leakyrelu",z=u!=null?Tl(u,!0):null,_=P||D||F||z!=null;let B;if((p===1||f===1)&&R>A$&&_===!1){let O=E,K=I;t&&(O=zn({inputs:{x:E},backend:r,attrs:{perm:[0,2,1]}}),C.push(O)),s&&(K=zn({inputs:{x:I},backend:r,attrs:{perm:[0,2,1]}}),C.push(K));const U=f!==1,X=f===1;let te=O;U&&(te=Te({inputs:{x:O},backend:r,attrs:{shape:[T,R,1]}}),C.push(te));const ie=f===1?2:1;let re=K;X&&(re=Te({inputs:{x:K},backend:r,attrs:{shape:[T,1,R]}}),C.push(re));const he=xb({inputs:{a:te,b:re},backend:r});B=ff({inputs:{x:he},backend:r,attrs:{axis:ie,keepDims:!0}}),C.push(he)}else{const O=mn(n.dtype,e.dtype),K=new D$(S,k,[T,p,f],t,s,P,z,D,F),U=[E,I];if(i!=null&&U.push(i),D&&U.push(o),F){const X=r.makeTensorInfo([],"float32",$i(a,"float32"));U.push(X),C.push(X)}B=r.runWebGLProgram(K,U,O)}const N=Te({inputs:{x:B},backend:r,attrs:{shape:w}});C.push(B);for(const O of C)r.disposeIntermediateTensorInfo(O);return N}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f5(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:h,leakyreluAlpha:c}=s;return xd({a:r,b:i,transposeA:u,transposeB:l,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:c,activation:h})}const m5={kernelName:ml,backendName:"webgl",kernelFunc:f5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j0="return abs(x);";function g5(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=t.texData.get(s.dataId),o=I$(i.values);return t.makeTensorInfo(s.shape,s.dtype,o)}let r;return ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new ci(s.shape,j0):r=new xr(s.shape,j0),t.runWebGLProgram(r,[s],s.dtype)}const x5={kernelName:Ll,backendName:"webgl",kernelFunc:g5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b5=Os+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,y5=xt({opSnippet:b5}),w5={kernelName:ka,backendName:"webgl",kernelFunc:y5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v5=Os+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,C5=xt({opSnippet:v5}),S5={kernelName:Ta,backendName:"webgl",kernelFunc:C5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X0="return a + b;",I5=Sn({opSnippet:X0,packedOpSnippet:X0,supportsComplex:!0,cpuKernelImpl:FK}),$5={kernelName:Io,backendName:"webgl",kernelFunc:I5};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k5{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let T5=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lh(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return us({inputs:{x:s[0]},backend:t});if(s.length>ne().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(s.length/2),l=Lh({inputs:s.slice(0,u),backend:t}),h=Lh({inputs:s.slice(u),backend:t});return Lh({inputs:[l,h],backend:t})}const r=s.map(u=>u.dtype).reduce((u,l)=>mn(u,l)),i=s.map(u=>u.shape),a=ne().getBool("WEBGL_PACK")?new T5(s[0].shape,i):new k5(s[0].shape,i);return t.runWebGLProgram(a,s,r)}const E5={kernelName:Pd,backendName:"webgl",kernelFunc:Lh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,u=Qe(i,r.shape);let l=u;const h=kt(l,a);let c=r;h!=null&&(c=zn({inputs:{x:r},backend:t,attrs:{perm:h}}),l=_t(l.length,a)),tn("all",l,a);const[d,p]=Yt(c.shape,l),f=Q(p),g=Te({inputs:{x:c},backend:t,attrs:{shape:[-1,f]}}),m=Mo(g,g.dtype,"all",t);let b;if(o){const x=qt(d,u);b=Te({inputs:{x:m},backend:t,attrs:{shape:x}})}else b=Te({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),h!=null&&t.disposeIntermediateTensorInfo(c),b}const N5={kernelName:Ld,backendName:"webgl",kernelFunc:R5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,u=Qe(i,r.shape);let l=u;const h=kt(l,a);let c=r;h!=null&&(c=zn({inputs:{x:r},backend:t,attrs:{perm:h}}),l=_t(l.length,a)),tn("any",l,a);const[d,p]=Yt(c.shape,l),f=Q(p),g=Te({inputs:{x:c},backend:t,attrs:{shape:[-1,f]}}),m=Mo(g,g.dtype,"any",t);let b;if(o){const x=qt(d,u);b=Te({inputs:{x:m},backend:t,attrs:{shape:x}})}else b=Te({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),h!=null&&t.disposeIntermediateTensorInfo(c),b}const D5={kernelName:Od,backendName:"webgl",kernelFunc:_5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let A5=class{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=t==="max"?">":"<",u=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F5{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,L(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],o=Math.ceil(i/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,u=a.length,l=$t(u),h=Fn("coords",u);let c,d;if(o===1){d=u+1;const I=$t(d);c=`
        ${I} sourceLocR = ${I}(${h.join()}, 0);
        ++${h[u-1]};
        ${I} sourceLocG = ${I}(${h.join()}, 0);
        ++${h[u-2]};
        ${I} sourceLocA = ${I}(${h.join()}, 0);
        --${h[u-1]};
        ${I} sourceLocB = ${I}(${h.join()}, 0);
        --${h[u-2]};`}else d=u,c=`
        ${l} sourceLocR = coords;
        ++${h[u-1]};
        ${l} sourceLocG = coords;
        ++${h[u-2]};
        ${l} sourceLocA = coords;
        --${h[u-1]};
        ${l} sourceLocB = coords;
        --${h[u-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],g=p.map(I=>"int "+I),m=Fn("sourceLocR",d-1).concat("inIdx.r"),b=Fn("sourceLocG",d-1).concat("inIdx.g"),x=Fn("sourceLocB",d-1).concat("inIdx.b"),v=Fn("sourceLocA",d-1).concat("inIdx.a"),w=s==="max"?"greaterThan":"lessThan",S=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${v.join()})));`,k=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,E=r?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${E}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${h[u-1]} < ${a[u-1]-1};
        bool hasNextRow = ${h[u-2]} < ${a[u-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${S}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F$(n,e,t,s=null){let r=e.shape[0],i=e.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const o=Pp(i),a={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},u=new A5(a,t,s==null),l=[e];s!=null&&l.push(s);const h=n.runWebGLProgram(u,l,"int32");if(h.shape[1]===1)return h;const c=F$(n,e,t,h);return n.disposeIntermediateTensorInfo(h),c}function P$(n,e,t,s=null){const r=s!=null?s.shape:e.shape,i=r[r.length-1],o=Pp(i),a=new F5(r,o,t,s==null),u=s==null?[e]:[e,s],l=n.runWebGLProgram(a,u,"int32");if(l.shape.length===e.shape.length){const h=P$(n,e,t,l);return n.disposeIntermediateTensorInfo(l),h}return l}function L$(n,e,t,s){const r=[t];if(tn("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!ne().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let u=e;a&&(u=n.unpackTensor(e),i.push(u));const[l,h]=Yt(u.shape,r),c=Q(h),d=Te({inputs:{x:u},backend:n,attrs:{shape:[-1,c]}});i.push(d);const p=F$(n,d,s);i.push(p);const f=Te({inputs:{x:p},backend:n,attrs:{shape:l}});return i.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}return P$(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=Qe(i,r.shape);const a=kt(o,r.shape.length);let u=r;const l=[];a!=null&&(u=zn({inputs:{x:r},backend:t,attrs:{perm:a}}),l.push(u),o=_t(o.length,u.shape.length)),tn("argMax",[o[0]],u.shape.length);const h=L$(t,u,o[0],"max");return l.forEach(c=>t.disposeIntermediateTensorInfo(c)),h}const L5={kernelName:Ol,backendName:"webgl",kernelFunc:P5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=Qe(i,r.shape);const a=kt(o,r.shape.length);let u=r;const l=[];a!=null&&(u=zn({inputs:{x:r},backend:t,attrs:{perm:a}}),l.push(u),o=_t(o.length,u.shape.length)),tn("argMin",[o[0]],u.shape.length);const h=L$(t,u,o[0],"min");return l.forEach(c=>t.disposeIntermediateTensorInfo(c)),h}const M5={kernelName:Ml,backendName:"webgl",kernelFunc:O5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z5=Os+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,B5=xt({opSnippet:z5}),V5={kernelName:Ea,backendName:"webgl",kernelFunc:B5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U5=Os+"return log(x + sqrt(x * x + 1.0));",G5=xt({opSnippet:U5}),W5={kernelName:Ra,backendName:"webgl",kernelFunc:G5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H5=Os+`
  return atan(x);
`,K5=xt({opSnippet:H5}),j5={kernelName:Na,backendName:"webgl",kernelFunc:K5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X5=gb+`
  return atan(a, b);
`,q5=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Oo+`
  return result;
`,Y5=Sn({opSnippet:X5,packedOpSnippet:q5}),Z5={kernelName:Da,backendName:"webgl",kernelFunc:Y5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q5=Os+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,J5=xt({opSnippet:Q5}),ej={kernelName:_a,backendName:"webgl",kernelFunc:J5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let El=class{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,h=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const g=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,b=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let x="0.0";if(g||(x="-1.0 / 1e-20"),s){const I=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${h}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?m:b:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const v="max";let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / max(count, 1.0)");const S=Math.floor(o/4)*4,k=o%4,E=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${S}; wC += 4) {
            int xC = xCCorner + wC * ${h};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              getValue(batch, xR, xC + 3 * ${h}, d)
            );

            ${E}
          }

          int xC = xCCorner + ${S};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              initializationValue
            );

            ${E}
          }
        }
        setOutput(${w});
      }
    `}},bb=class{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,u=e.strideHeight,l=e.strideWidth,h=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,f=e.effectiveFilterHeight,g=e.effectiveFilterWidth,m=e.padInfo.front,b=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const v=t==="avg";let w="0.0";if(v||(w="-1.0 / 1e-20"),s){const T=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${u}, ${l});
        const ivec3 pads = ivec3(${m}, ${b}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${h}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${T} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / max(count, 1.0)");const E=Math.floor(o/4)*4,I=o%4,C=`
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${u}, ${l});
      const ivec3 pads = ivec3(${m}, ${b}, ${x});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${h}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${E}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${C}
            }

            int xC = xCCorner + ${E};
            if (${I===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${C}
            } else if (${I===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${C}
            } else if (${I===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${C}
            }
          }
        }
        setOutput(${k});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Jc(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:u}=s,l=1;L(gn(o,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const h=kn(r.shape,i,o,l,a,u);if(h.filterWidth===1&&h.filterHeight===1&&ct(h.inShape,h.outShape))return us({inputs:{x:r},backend:t});const c=new El(h,"avg",!1);return t.runWebGLProgram(c,[r],"float32")}const nj={kernelName:zl,backendName:"webgl",kernelFunc:tj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:u,dataFormat:l}=s,h=[1,1,1],c=bs(r.shape,i,o,h,a,u,l),d=new bb(c,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}const rj={kernelName:Bl,backendName:"webgl",kernelFunc:sj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ij=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,h=u-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${h}, ${c});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},oj=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,h=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=c-1-e.padInfo.front,g=d-1-e.padInfo.top,m=p-1-e.padInfo.left,b=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${g}, ${m});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aj(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:a,strides:u,pad:l,dimRoundingMode:h}=s,c=[1,1,1],d=bs(o.shape,a,u,c,l,h),p=new oj(d);return t.runWebGLProgram(p,[r],o.dtype)}const uj={kernelName:zd,backendName:"webgl",kernelFunc:aj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lj(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i;Jc([r,i],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=s,h=kn(o.shape,a,u,1,l),c=new ij(h);return t.runWebGLProgram(c,[r],o.dtype)}const cj={kernelName:Md,backendName:"webgl",kernelFunc:lj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hj(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;return xd({a:r,b:i,transposeA:o,transposeB:a,backend:t})}const dj={kernelName:Vl,backendName:"webgl",kernelFunc:hj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pj=class{constructor(e,t,s,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Ke(e,t),Ke(e,s);let a="0.0";r!=null&&(Ke(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";i!=null&&(Ke(e,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fj{constructor(e,t,s,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ke(e,t),Ke(e,s);let a="vec4(0.0)";r!=null&&(Ke(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";i!=null&&(Ke(e,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mj=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:i,offset:o,scale:a}=n;L(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),L(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),L(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);const l=[s,r,i];let h=null;o!=null&&(h=o.shape,l.push(o));let c=null;a!=null&&(c=a.shape,l.push(a));const d=ne().getBool("WEBGL_PACK_NORMALIZATION")?new fj(s.shape,r.shape,i.shape,h,c,u):new pj(s.shape,r.shape,i.shape,h,c,u);return e.runWebGLProgram(d,l,l[0].dtype)},gj={kernelName:Jl,backendName:"webgl",kernelFunc:mj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xj=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=$t(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=bj(this.rank);let r;const i=e.map((o,a)=>`sourceLoc.${Hm[a]} = start[${a}] + coords.${Hm[a]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}};const Hm=["x","y","z","w","u","v"];function bj(n){if(n===1)return"sourceLoc";if(n<=6)return Hm.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yj{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=$t(this.rank),s=Fn("coords",this.rank),r=Fn("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((h,c)=>`start[${c}]`).join()});`:e.map((h,c)=>`${r[c]} = ${s[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wj(n,e,t,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(t,n.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=Nx(e,Be(n.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||n.dataId};const u=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,u+1),i}function Fu(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:o}=s,[a,u]=Bc(r,i,o);if(_p(r,a,u),Q(u)===0)return t.makeTensorInfo(u,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const c=t.texData.get(r.dataId),d=d6(c.values,a,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,d)}const{isPacked:l}=t.texData.get(r.dataId),h=Rx(r.shape,a,u);if(l||!h){const c=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yj(u):new xj(u),d=[a];return t.runWebGLProgram(c,[r],r.dtype,d)}return t.uploadToGPU(r.dataId),wj(r,a,u,t)}const vj={kernelName:Ec,backendName:"webgl",kernelFunc:Fu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cj=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:o}=s;L(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((x,v)=>x*v),u=No(r.shape,i,a),l=_o(u.length,i.length),h=Do(r.shape,i,a),c=Op(o,i.length),d=Mp(h,o,i.length),p=[],f=Te({inputs:{x:r},backend:t,attrs:{shape:u}}),g=zn({inputs:{x:f},backend:t,attrs:{perm:l}}),m=Te({inputs:{x:g},backend:t,attrs:{shape:h}}),b=Fu({inputs:{x:m},backend:t,attrs:{begin:c,size:d}});return p.push(f),p.push(g),p.push(m),p.forEach(x=>t.disposeIntermediateTensorInfo(x)),b},Sj={kernelName:Ul,backendName:"webgl",kernelFunc:Cj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ij(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o}=s,a=t.readSync(r.dataId),u=t.readSync(i.dataId),l=S$(a,u,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,l)}const $j={kernelName:Bd,backendName:"webgl",kernelFunc:Ij};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kj=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Tj=`
  return float(int(a.r) & int(b.r));
`;function Ej(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=ne().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||o===1){const u=t.texData.get(s.dataId).values,l=t.texData.get(r.dataId).values,[h,c]=LK(s.shape,r.shape,u,l,s.dtype),d=t.makeTensorInfo(c,s.dtype),p=t.texData.get(d.dataId);return p.values=h,d}let a;return i?a=new Du(kj,s.shape,r.shape,!1):a=new yo(Tj,s.shape,r.shape),t.runWebGLProgram(a,[s,r],s.dtype)}const Rj={kernelName:kg,backendName:"webgl",kernelFunc:Ej};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nj(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.readSync(s.dataId),o=t.readSync(r.dataId),a=Ke(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const _j={kernelName:Tg,backendName:"webgl",kernelFunc:Nj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dj="return float(a != b);",O$=Sn({opSnippet:Dj,cpuKernelImpl:s6,dtype:"bool"}),Aj={kernelName:gc,backendName:"webgl",kernelFunc:O$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function th(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return us({inputs:{x:r.complexTensorInfos.real},backend:t})}const Fj={kernelName:cp,backendName:"webgl",kernelFunc:th};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pj="return float(int(x));";function Lj(n,e){const t=new xr(n.shape,Pj),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Km(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return us({inputs:{x:r},backend:t});const o=rn(r.shape),a=Km({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),u=Di({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),u}if(r.dtype==="complex64"){const o=th({inputs:{input:r},backend:t}),a=Km({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(o),a}if(!Cg(r.dtype,i)){const o=us({inputs:{x:r},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const o=t.texData.get(r.dataId).values,[a,u,l]=OK(o,r.shape,r.dtype,i);return t.makeTensorInfo(a,u,l)}if(i==="int32")return Lj(r,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",fn("bool",1)),u=O$({inputs:{a:r,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const Oj={kernelName:Aa,backendName:"webgl",kernelFunc:Km};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q0="return ceil(x);",Mj=xt({opSnippet:q0,packedOpSnippet:q0,cpuKernelImpl:MK}),zj={kernelName:Fa,backendName:"webgl",kernelFunc:Mj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Bj=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vj{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:o}=s;let a;ne().getBool("WEBGL_PACK_CLIP")?a=new Vj(r.shape):a=new Bj(r.shape);const u=[[i],[o]];return t.runWebGLProgram(a,[r],r.dtype,u)}const Gj={kernelName:Pa,backendName:"webgl",kernelFunc:Uj};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Wj=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y0(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function Hj(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),i=new Wj(s.shape),o=[Y0(s,r.complexTensorInfos.real),Y0(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(i,o,o[0].dtype)}const Kj={kernelName:Gl,backendName:"webgl",kernelFunc:Hj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let jj=class{constructor(e){this.outputShape=[],this.outputShape=qn(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];s.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const r=t.length,i=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xj{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=qn(e,t);const s=this.outputShape,r=s.length,i=$t(r),o=Fn("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((g,m)=>`T${m}`);const u=new Array(e.length-1);u[0]=e[0][t];for(let g=1;g<u.length;g++)u[g]=u[g-1]+e[g][t];const l=a[t],h=a.slice(-2),c=a.join();let d=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${c}), vec2(${h.join()}));
        }`;for(let g=1;g<u.length;g++){const m=u[g-1];d+=`
        if (${l} < ${u[g]}  && ${l} >= ${u[g-1]}) {
          return getChannel(
            getT${g}(${Eh(a,l,m)}),
            vec2(${Eh(h,l,m)}));
        }`}const p=u.length,f=u[u.length-1];d+=`
        return getChannel(
          getT${p}(${Eh(a,l,f)}),
          vec2(${Eh(h,l,f)}));`,this.userCode=`
      float getValue(${a.map(g=>"int "+g)}) {
        ${d}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${s[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${s[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${s[r-2]} &&
            ${o[r-1]} < ${s[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function Eh(n,e,t){const s=n.indexOf(e);return n.map((i,o)=>o===s?`${i} - ${t}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mf(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return us({inputs:{x:r.complexTensorInfos.imag},backend:t})}const qj={kernelName:sp,backendName:"webgl",kernelFunc:mf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qu(n,e,t){const s=n[0].dtype;if(s==="complex64"){const p=n.map(x=>th({inputs:{input:x},backend:t})),f=n.map(x=>mf({inputs:{input:x},backend:t})),g=qu(p,e,t),m=qu(f,e,t),b=Di({inputs:{real:g,imag:m},backend:t});return p.forEach(x=>t.disposeIntermediateTensorInfo(x)),f.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),b}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const p=n.map(w=>{const k=[-1,Q(w.shape.slice(e))];return Te({inputs:{x:w},backend:t,attrs:{shape:k}})}),f=p.map(w=>({vals:t.readSync(w.dataId),shape:w.shape})),g=qn(p.map(w=>w.shape),1),m=p[0].shape[0]===1,b=zK(f,g,s,m),x=qn(n.map(w=>w.shape),e),v=t.makeTensorInfo(x,s,b);return p.forEach(w=>t.disposeIntermediateTensorInfo(w)),v}const i=n.filter(p=>Q(p.shape)>0),o=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const p=o?new xr(n[0].shape,ii):new ci(n[0].shape,ii);return t.runWebGLProgram(p,n,s)}const a=ne().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const p=[];for(let g=0;g<i.length;g+=a){const m=i.slice(g,g+a);p.push(qu(m,e,t))}const f=qu(p,e,t);for(const g of p)t.disposeIntermediateTensorInfo(g);return f}if(o){const p=new Xj(i.map(f=>f.shape),e);return t.runWebGLProgram(p,i,s)}const{tensors2D:u,outShape:l}=Yj(i,e,t),h=new jj(u.map(p=>p.shape)),c=t.runWebGLProgram(h,u,s);u.forEach(p=>t.disposeIntermediateTensorInfo(p));const d=Te({inputs:{x:c},attrs:{shape:l},backend:t});return t.disposeIntermediateTensorInfo(c),d}function Yj(n,e,t){const s=qn(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>Te({inputs:{x:i},attrs:{shape:[-1,Q(i.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M$(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=Qe(r,e[0].shape)[0],o=e.map(l=>l.shape);Fp(o,i);const a=qn(e.map(l=>l.shape),i);if(Q(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const u=e.filter(l=>Q(l.shape)>0);return u.length===1?us({inputs:{x:u[0]},backend:t}):qu(u,i,t)}const Zj={kernelName:Wl,backendName:"webgl",kernelFunc:M$};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z${constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,h=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,m=e.dataFormat==="channelsLast",b=m?1:2,x=m?2:3,v=m?3:1;let w="",S="";s&&(r?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:w=`
          float activation(float x) {
            ${s}
          }
        `,S="result = activation(result);");const k=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${v}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${h};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${S}
        setOutput(result);
      }
    `}}class Qj{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,h=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${h};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B${constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=En(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,h=e.filterWidth,c=h;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<h;m++)d+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<h;m++)d+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(c+1)/2;m++){const b=m*2;if(d+=`
           xC = xCCorner + ${b*u};
           `,a===1){if(b<h&&(o%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,u===1&&b>0?d+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<h)){const x=o%2===0?wg(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${x};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,u>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:d+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):x===1?d+=`
                     xC${b+1} = xTexelC${b};
                     `:d+=`
                     xCOffset = xC + ${x};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<h&&(o%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<h&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<h&&(d+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<h&&(d+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<h&&(d+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",f="";s&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:p=`vec4 activation(vec4 x) {
           ${s}
         }`,f="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jj{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=En(this.outputShape.length);const{dataFormat:s}=t,r=Bn(),i=s==="channelsLast",o=i?1:2,a=i?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let h=0;h<=1;h++)for(let c=0;c<=1;c++)l+=`
          blockIndex = rc.z + ${c};
          pos = rc.y + ${h};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${h*2+c}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${h*2+c}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bd(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function V$({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const u=n.shape,l=s.texData.get(n.dataId),h=t.inChannels,c=u[0]*u[1]*u[2],d=t.outChannels,p=t.dataFormat==="channelsLast",f=!1,g=!1;let m;const b=[];if(i!=null){const w=bd(i.shape,p);w!=null&&(i=Te({inputs:{x:i},backend:s,attrs:{shape:w}}),b.push(i))}if(r!=null){const w=bd(r.shape,p);w!=null&&(r=Te({inputs:{x:r},backend:s,attrs:{shape:w}}),b.push(r))}if(!((c===1||d===1)&&h>A$)&&l.isPacked&&p&&l.texture!=null&&u[2]%2!==0&&ct(l.shape.slice(-3),u.slice(-3))){const w=u[0]*u[1]*(u[2]+1),S={dataId:n.dataId,shape:[1,w,t.inChannels],dtype:n.dtype},k=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,L(gd(l.shape,S.shape),()=>`packed reshape ${l.shape} to ${S.shape} isn't free`);const E=Te({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});b.push(E);const I=xd({a:S,b:E,backend:s,transposeA:f,transposeB:g,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),C=s.texData.get(I.dataId);L(C.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=k,C.shape=t.outShape,m=us({inputs:{x:I},backend:s}),m.shape=t.outShape,b.push(I)}else{const w=t.outHeight*t.outWidth,S=Te({inputs:{x:n},backend:s,attrs:{shape:p?[t.batchSize,w,t.inChannels]:[t.batchSize,t.inChannels,w]}}),k=Te({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),E=xd({a:p?S:k,b:p?k:S,transposeA:!p,transposeB:g,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o});m=Te({inputs:{x:E},backend:s,attrs:{shape:t.outShape}}),b.push(S),b.push(k),b.push(E)}for(const w of b)s.disposeIntermediateTensorInfo(w);return m}function U$({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:h,outWidth:c,outHeight:d,dataFormat:p}=t,f=p==="channelsLast",g=u*l*h,m=d*c,b=[t.batchSize,g,m],x=!0,v=!1,w=[];if(i!=null){const N=bd(i.shape,f);N!=null&&(i=Te({inputs:{x:i},backend:s,attrs:{shape:N}}),w.push(i))}if(r!=null){const N=bd(r.shape,f);N!=null&&(r=Te({inputs:{x:r},backend:s,attrs:{shape:N}}),w.push(r))}const S=Te({inputs:{x:e},backend:s,attrs:{shape:[1,g,Q(e.shape)/g]}});w.push(S);const k=new Jj(b,t),E=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],I=s.runWebGLProgram(k,[n],"float32",E),C=Te({inputs:{x:I},backend:s,attrs:{shape:b}});w.push(I),w.push(C);const T=r!=null,R=i!=null,P=a==="leakyrelu",D=a?Tl(a,!0):null,F=new D$(f?C.shape:S.shape,f?S.shape:C.shape,f?[t.batchSize,m,t.outChannels]:[t.batchSize,t.outChannels,m],x,v,T,D,R,P),z=f?[C,S]:[S,C];if(r&&z.push(r),R&&z.push(i),P){const N=s.makeTensorInfo([],"float32",$i(o,"float32"));z.push(N),w.push(N)}const _=s.runWebGLProgram(F,z,"float32"),B=Te({inputs:{x:_},backend:s,attrs:{shape:t.outShape}});w.push(_);for(const N of w)s.disposeIntermediateTensorInfo(N);return B}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:u,dilations:l,dimRoundingMode:h}=s,c=hs(u),d=Ot(r.shape,i.shape,o,l,a,h,!1,c);let p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=V$({x:r,filter:i,convInfo:d,backend:t});else if(d.strideWidth<=2&&c==="channelsLast"&&ne().getBool("WEBGL_EXP_CONV")){const g=new B$(d),m=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=t.runWebGLProgram(g,[r,i],"float32",m)}else if(ne().getBool("WEBGL_CONV_IM2COL"))p=U$({x:r,filter:i,convInfo:d,backend:t});else{const g=new z$(d);p=t.runWebGLProgram(g,[r,i],"float32")}const f=Te({inputs:{x:p},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(p),f}const t8={kernelName:Hl,backendName:"webgl",kernelFunc:e8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let n8=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},s8=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,u=s-1-e.padInfo.left,l=o?1:2,h=o?2:3,c=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${h}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},r8=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},i8=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,u=t-1-e.padInfo.front,l=s-1-e.padInfo.top,h=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:h}=s,c=hs(u),d=Ot(r.shape,h,o,1,a,l,!1,c),p=new n8(d);return t.runWebGLProgram(p,[r,i],"float32")}const a8={kernelName:Ud,backendName:"webgl",kernelFunc:o8};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u8{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=En(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,i=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l8(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:u,dataFormat:l,dimRoundingMode:h}=s,c=hs(l),d=Ot(o,i.shape,a,1,u,h,!1,c);if(ne().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&c==="channelsLast"){const p=[[d.strideHeight,d.strideWidth]],f=new u8(d);return t.runWebGLProgram(f,[r,i],"float32",p)}else{const p=new s8(d);return t.runWebGLProgram(p,[r,i],"float32")}}const c8={kernelName:Kl,backendName:"webgl",kernelFunc:l8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:u}=s,l=tr(r.shape,i.shape,o,u,a),h=new Qj(l);return t.runWebGLProgram(h,[r,i],"float32")}const d8={kernelName:jl,backendName:"webgl",kernelFunc:h8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:u}=s,l=tr(r.shape,u,o,1,a),h=new r8(l);return t.runWebGLProgram(h,[r,i],"float32")}const f8={kernelName:Gd,backendName:"webgl",kernelFunc:p8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m8(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:o,strides:a,inputShape:u}=s,l=tr(u,i.shape,a,1,o),h=new i8(l);return t.runWebGLProgram(h,[r,i],"float32")}const g8={kernelName:Wd,backendName:"webgl",kernelFunc:m8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x8=Au+`
  return cos(x);
`,b8=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Oo}
  return result;
`,y8=xt({opSnippet:x8,packedOpSnippet:b8}),w8={kernelName:La,backendName:"webgl",kernelFunc:y8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v8=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,C8=xt({opSnippet:v8}),S8={kernelName:Oa,backendName:"webgl",kernelFunc:C8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let I8=class{constructor(e,t,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,u,l]=e,[h]=t,[c,d]=s;this.outputShape=[h,c,d,l];const p=r==="bilinear"?1:0,[f,g]=[`${a-1}.0`,`${u-1}.0`],[m,b,x]=c>1?[`${(a-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[v,w,S]=d>1?[`${(u-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${v});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${w};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${S};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $8=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:u,extrapolationValue:l}=s,h=new I8(r.shape,i.shape,a,u,l);return t.runWebGLProgram(h,[r,i,o],"float32")},k8={kernelName:Kd,backendName:"webgl",kernelFunc:$8};var Rl;(function(n){n.Prod="*",n.Sum="+"})(Rl||(Rl={}));let Z0=class{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===Rl.Prod?"1.0":"0.0",a=s?o:`getX(${Q0(i,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let l="",h="";s?(l=r?`end != ${u-1}`:"end != 0",h=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${u}`:"end >= pow2",h=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${$t(i)} coords = getOutputCoords();
        int end = ${J0(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${h};
          ${J0(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${Q0(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function Q0(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function J0(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$(n,e,t,s,r,i){const o=e.shape.length,a=kt([s],o);let u=e;a!=null&&(u=zn({inputs:{x:e},backend:t,attrs:{perm:a}}));const l=_t(1,o)[0];if(l!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const h=u.shape[l];let c=us({inputs:{x:u},backend:t});for(let d=0;d<=Math.ceil(Math.log2(h))-1;d++){const p=new Z0(n,u.shape,!1,i),f=[[d]],g=c;c=t.runWebGLProgram(p,[c],c.dtype,f),t.disposeIntermediateTensorInfo(g)}if(r){const d=new Z0(n,u.shape,r,i),p=c;c=t.runWebGLProgram(d,[c],c.dtype),t.disposeIntermediateTensorInfo(p)}if(a!=null){const d=Nr(a),p=zn({inputs:{x:c},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),p}return c}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;return G$(Rl.Prod,r,t,i,o,a)}const E8={kernelName:Hd,backendName:"webgl",kernelFunc:T8};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;return G$(Rl.Sum,r,t,i,o,a)}const N8={kernelName:Xl,backendName:"webgl",kernelFunc:R8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const u=t.readSync(r.dataId),l=t.readSync(i.dataId),h=S$(u,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,h)}else if(r.shape.length===2){const u=t.bufferSync(r),l=t.bufferSync(i),h=PK(u,l,o,a);return t.makeTensorInfo(h.shape,i.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const D8={kernelName:jd,backendName:"webgl",kernelFunc:_8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let A8=class{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:o}=s,a=r.shape[0],u=o==="NHWC"?r.shape[1]:r.shape[2],l=o==="NHWC"?r.shape[2]:r.shape[3],h=o==="NHWC"?r.shape[3]:r.shape[1],c=u*i,d=l*i,p=h/(i*i),f=o==="NHWC"?[a,c,d,p]:[a,p,c,d],g=new A8(f,i,o);return t.runWebGLProgram(g,[r],r.dtype)}const P8={kernelName:Xd,backendName:"webgl",kernelFunc:F8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let W$=class{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=En(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,u=e.outChannels/e.inChannels;let l="",h="";s&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:l=`
          float activation(float x) {
            ${s}
          }
        `,h="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${h}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H${constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=En(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,h=e.filterHeight,c=e.filterWidth,d=c;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<c;b++)p+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;p+=`
    for (int r = 0; r < ${h}; r++) {
      `;for(let b=0;b<c;b++)p+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(d+1)/2;b++){const x=b*2;if(p+=`
          xC = xCCorner + ${x*l};
          `,u===1){if(x<c&&(a%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,l===1&&x>0?p+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<c)){const v=a%2===0?wg(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${v};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,l>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                    } else {
                     xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                    }
                    `:p+=`
                    xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                    `):v===1?p+=`
                    xC${x+1} = xTexelC${x};
                    `:p+=`
                    xCOffset = xC + ${v};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<c&&(a%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<c&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<c&&(p+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<c&&(p+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<c&&(p+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",g="";s&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:f=`vec4 activation(vec4 x) {
          ${s}
        }`,g="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:u,dimRoundingMode:l}=s;let h=u;h==null&&(h=[1,1]),L(gn(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const c=Ot(r.shape,i.shape,o,h,a,l,!0);let d;ne().getBool("WEBGL_PACK_DEPTHWISECONV")&&c.strideWidth<=2&&c.outChannels/c.inChannels===1?d=new H$(c):d=new W$(c);const p=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];return t.runWebGLProgram(d,[r,i],"float32",p)}const O8={kernelName:ql,backendName:"webgl",kernelFunc:L8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let M8=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},z8=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.top,a=s-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,dilations:a,pad:u,dimRoundingMode:l,filterShape:h}=s,c=Ot(r.shape,h,o,a,u,l,!0),d=new M8(c);return t.runWebGLProgram(d,[r,i],"float32")}const V8={kernelName:qd,backendName:"webgl",kernelFunc:B8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U8(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:u,dimRoundingMode:l,inputShape:h}=s,c=Ot(h,i.shape,o,a,u,l,!0),d=new z8(c);return t.runWebGLProgram(d,[r,i],"float32")}const G8={kernelName:Yd,backendName:"webgl",kernelFunc:U8};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let W8=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H8(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=Q(s.shape),o=Te({inputs:{x:s},backend:t,attrs:{shape:[i]}}),a=new W8(i),u=t.runWebGLProgram(a,[o],o.dtype),l=Te({inputs:{x:u},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(u),l}const K8={kernelName:Eg,backendName:"webgl",kernelFunc:H8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let j8=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:u,dilationHeight:l,dilationWidth:h}=e,{top:c,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${c}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${h};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:u}=s,l=ki(r.shape,i.shape,o,a,"NHWC",u);let h;const c=new j8(l);h=t.runWebGLProgram(c,[r,i],"float32");const d=Te({inputs:{x:h},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(h),d}const q8={kernelName:Yl,backendName:"webgl",kernelFunc:X8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y8(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:u}=Hp(r,i.length);jp(o.length,u,i);const{path:l,steps:h}=Xp(a,u),c=h.length;let d=null,p=o.length;const f=[];for(let g=0;g<c;++g){for(const m of h[g]){const{permutationIndices:b,expandDims:x}=Kp(p,u[m]);let v;qp(b)?v=i[m]:(v=zn({inputs:{x:i[m]},backend:t,attrs:{perm:b}}),f.push(v));const w=v.shape.slice();for(let S=0;S<x.length;++S)w.splice(x[S],0,1);ct(v.shape,w)||(v=Te({inputs:{x:v},backend:t,attrs:{shape:w}}),f.push(v)),d===null?d=v:(d=xb({inputs:{a:v,b:d},backend:t}),f.push(d))}g<c-1&&(l[g]>=0&&(d=ff({inputs:{x:d},backend:t,attrs:{axis:l[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&t.disposeIntermediateTensorInfo(g);return d}const Z8={kernelName:Zd,backendName:"webgl",kernelFunc:Y8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q8="return (x >= 0.0) ? x : (exp(x) - 1.0);",J8=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,eX=xt({opSnippet:Q8,packedOpSnippet:J8}),tX={kernelName:za,backendName:"webgl",kernelFunc:eX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nX="return (b >= 0.0) ? a : a * (b + 1.0);",sX=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,rX=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Du(sX,s.shape,r.shape):new yo(nX,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],s.dtype)},iX={kernelName:Qd,backendName:"webgl",kernelFunc:rX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oX=`
  return vec4(equal(a, b));
`,aX="return float(a == b);",uX=Sn({opSnippet:aX,packedOpSnippet:oX,dtype:"bool",cpuKernelImpl:BK}),lX={kernelName:Zl,backendName:"webgl",kernelFunc:uX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cX=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${zp};
  float a1 = ${Bp};
  float a2 = ${Vp};
  float a3 = ${Up};
  float a4 = ${Gp};
  float a5 = ${Wp};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,hX=xt({opSnippet:cX}),dX={kernelName:Ba,backendName:"webgl",kernelFunc:hX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pX=Au+`
  return exp(x);
`,fX=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,K$=xt({opSnippet:pX,packedOpSnippet:fX,cpuKernelImpl:VK,dtype:"float32"}),mX={kernelName:Va,backendName:"webgl",kernelFunc:K$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jm(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,o=i.shape.length,a=i.shape.slice();let u=r;return r<0&&(L(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+r+1),a.splice(u,0,1),Te({inputs:{x:i},backend:s,attrs:{shape:a}})}const gX={kernelName:Ql,backendName:"webgl",kernelFunc:jm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e1="return exp(x) - 1.0;",xX=xt({opSnippet:e1,packedOpSnippet:e1,cpuKernelImpl:UK}),bX={kernelName:Ua,backendName:"webgl",kernelFunc:xX};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let t1=class{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j$(n,e,t){const s=t.texData.get(n.dataId),r=Q(n.shape),i=n.shape[n.shape.length-1],o=r/i,a=Te({inputs:{x:n},backend:t,attrs:{shape:[o,i]}}),u=a.shape,l=new t1("real",u,e),h=new t1("imag",u,e),c=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],d=t.runWebGLProgram(l,c,"float32"),p=t.runWebGLProgram(h,c,"float32"),f=Di({inputs:{real:d,imag:p},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p);const g=Te({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(f),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yX(n){const{inputs:e,backend:t}=n,{input:s}=e;return j$(s,!1,t)}const wX={kernelName:Jd,backendName:"webgl",kernelFunc:yX};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vX=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nh(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||So(r),i==="string"){const o=Wt(i,Q(s));return o.fill(r),e.makeTensorInfo(s,i,o)}else{const o=new vX(s,r),a=[[r]];return e.runWebGLProgram(o,[],i,a)}}const CX={kernelName:ep,backendName:"webgl",kernelFunc:nh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SX=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IX={kernelName:tp,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new SX(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n1="return floor(x);",$X=xt({opSnippet:n1,packedOpSnippet:n1,cpuKernelImpl:GK}),kX={kernelName:Ga,backendName:"webgl",kernelFunc:$X};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TX=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,EX=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,RX=Sn({opSnippet:TX,packedOpSnippet:EX,dtype:"int32"}),NX={kernelName:Wa,backendName:"webgl",kernelFunc:RX};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _X=class{constructor(e){this.variableNames=["A"];const t=Bn(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DX{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Bn(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AX={kernelName:Hw,backendName:"webgl",kernelFunc:FX};let jo,Zf=ne().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function FX(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,l]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],h=[l,u],c=[l,u,i];if(a||o){const g=ne().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(jo==null||g!==Zf)&&(Zf=g,jo=document.createElement("canvas").getContext("2d",{willReadFrequently:Zf})),jo.canvas.width=u,jo.canvas.height=l,jo.drawImage(r,0,0,u,l),r=jo.canvas}const d=t.makeTensorInfo(h,"int32");t.texData.get(d.dataId).usage=ms.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),r);const p=ne().getBool("WEBGL_PACK")?new DX(c):new _X(c),f=t.runWebGLProgram(p,[d],"int32");return t.disposeData(d.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:h,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,g=hs(h),m=Ot(r.shape,i.shape,u,c,l,d,!1,g);let b;const x=[],v=o!=null,w=a!=null,S=p==="leakyrelu",k=()=>{const I=[r,i],C=(T,R)=>{if(R==="NCHW"&&T.shape.length===1&&T.shape[0]!==1){const P=Te({inputs:{x:T},backend:t,attrs:{shape:[T.shape[0],1,1]}});return x.push(P),P}return T};if(v&&I.push(C(o,h)),w&&I.push(C(a,h)),S){const T=t.makeTensorInfo([],"float32",$i(f,"float32"));I.push(T),x.push(T)}return I};if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))b=V$({x:r,filter:i,convInfo:m,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else if(m.strideWidth<=2&&g==="channelsLast"&&ne().getBool("WEBGL_EXP_CONV")){const I=p?Tl(p,!0):null,C=new B$(m,v,I,w,S),T=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],R=k();b=t.runWebGLProgram(C,R,"float32",T)}else if(ne().getBool("WEBGL_CONV_IM2COL"))b=U$({x:r,filter:i,convInfo:m,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const I=p?Tl(p,!1):null,C=new z$(m,v,I,w,S),T=k();b=t.runWebGLProgram(C,T,"float32")}const E=Te({inputs:{x:b},backend:t,attrs:{shape:m.outShape}});return x.push(b),x.forEach(I=>t.disposeIntermediateTensorInfo(I)),E}const LX={kernelName:gl,backendName:"webgl",kernelFunc:PX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:h,dimRoundingMode:c,activation:d,leakyreluAlpha:p}=s,f=[];let g=h;g==null&&(g=[1,1]),L(gn(u,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${g}'`);const m=Ot(r.shape,i.shape,u,g,l,c,!0),b=ne().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,x=d?Tl(d,b):null,v=[r,i],w=o!=null,S=a!=null,k=d==="leakyrelu";if(w&&v.push(o),S&&v.push(a),k){const T=t.makeTensorInfo([],"float32",$i(p,"float32"));v.push(T),f.push(T)}let E;b?E=new H$(m,w,x,S,k):E=new W$(m,w,x,S,k);const I=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],C=t.runWebGLProgram(E,v,"float32",I);return f.forEach(T=>t.disposeIntermediateTensorInfo(T)),C}const MX={kernelName:Gg,backendName:"webgl",kernelFunc:OX};let zX=class{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=$t(s.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BX(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,o=i[i.length-1],a=Q(s.shape),[u,l,h,c]=Np(s,r),d=Te({inputs:{x:r},backend:t,attrs:{shape:[l,o]}}),p=Te({inputs:{x:s},backend:t,attrs:{shape:[Q(s.shape)/h,h]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const b=t.readSync(r.dataId),x=t.bufferSync(s),v=WK(b,x,s.dtype,l,o,h,c,s.shape,a);return t.makeTensorInfo(u,s.dtype,v.values)}const f=new zX(o,c,[l,h],s.shape),g=t.runWebGLProgram(f,[p,d],p.dtype),m=Te({inputs:{x:g},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),m}const VX={kernelName:Rg,backendName:"webgl",kernelFunc:BX};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let UX=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=$t(this.rank),r=GX(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function GX(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:o,batchDims:a}=s,u=Qe(o,r.shape)[0];if(ne().get("DEBUG")){const x=t.readSync(i.dataId),v=r.shape[u];for(let w=0;w<x.length;++w){const S=x[w];L(S<=v-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${v-1}]`)}}const l=Zp(r,i,u,a),h=Q(i.shape),c=[],d=Te({inputs:{x:r},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=Te({inputs:{x:i},backend:t,attrs:{shape:[l.batchSize,h/l.batchSize]}});c.push(d),c.push(p);const f=[l.batchSize,l.outerSize,h/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const x=t.bufferSync(p),v=t.bufferSync(d),w=HK(v,x,f);return c.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.makeTensorInfo(l.outputShape,w.dtype,w.values)}const g=new UX(d.shape,f),m=t.runWebGLProgram(g,[d,p],d.dtype);c.push(m);const b=Te({inputs:{x:m},backend:t,attrs:{shape:l.outputShape}});return c.forEach(x=>t.disposeIntermediateTensorInfo(x)),b}const WX={kernelName:ec,backendName:"webgl",kernelFunc:X$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HX="return float(a > b);",KX=`
  return vec4(greaterThan(a, b));
`,jX=Sn({opSnippet:HX,packedOpSnippet:KX,cpuKernelImpl:KK,dtype:"bool"}),XX={kernelName:tc,backendName:"webgl",kernelFunc:jX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qX="return float(a >= b);",YX=`
  return vec4(greaterThanEqual(a, b));
`,ZX=Sn({opSnippet:qX,packedOpSnippet:YX,dtype:"bool",cpuKernelImpl:jK}),QX={kernelName:Ha,backendName:"webgl",kernelFunc:ZX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JX(n){const{inputs:e,backend:t}=n,{input:s}=e;return j$(s,!0,t)}const e9={kernelName:np,backendName:"webgl",kernelFunc:JX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t9="return float(!isnan(x) && !isinf(x));",n9=xt({opSnippet:t9,dtype:"bool"}),s9={kernelName:ja,backendName:"webgl",kernelFunc:n9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r9="return float(isinf(x));",i9=xt({opSnippet:r9,dtype:"bool"}),o9={kernelName:Xa,backendName:"webgl",kernelFunc:i9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a9="return float(isnan(x));",u9=xt({opSnippet:a9,dtype:"bool"}),l9={kernelName:qa,backendName:"webgl",kernelFunc:u9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c9="return float(a < b);",h9=`
  return vec4(lessThan(a, b));
`,d9=Sn({opSnippet:c9,packedOpSnippet:h9,cpuKernelImpl:XK,dtype:"bool"}),p9={kernelName:sc,backendName:"webgl",kernelFunc:d9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f9="return float(a <= b);",m9=`
  return vec4(lessThanEqual(a, b));
`,g9=Sn({opSnippet:f9,packedOpSnippet:m9,cpuKernelImpl:qK,dtype:"bool"}),x9={kernelName:rc,backendName:"webgl",kernelFunc:g9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b9(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,o=YK(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const y9={kernelName:Ng,backendName:"webgl",kernelFunc:b9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w9=Au+`
  return x < 0.0 ? 0./0. : log(x);
`,v9=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,C9=xt({opSnippet:w9,packedOpSnippet:v9,cpuKernelImpl:ZK}),S9={kernelName:Ya,backendName:"webgl",kernelFunc:C9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I9=Au+`
  return log(1.0 + x);
`,$9=xt({opSnippet:I9}),k9={kernelName:Za,backendName:"webgl",kernelFunc:$9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T9="return float(a >= 1.0 && b >= 1.0);",E9=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,R9=Sn({opSnippet:T9,packedOpSnippet:E9,dtype:"bool"}),N9={kernelName:ic,backendName:"webgl",kernelFunc:R9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _9="return float(!(x >= 1.0));",D9=xt({opSnippet:_9}),A9={kernelName:oc,backendName:"webgl",kernelFunc:D9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F9="return float(a >= 1.0 || b >= 1.0);",P9=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,L9=Sn({opSnippet:F9,packedOpSnippet:P9,dtype:"bool"}),O9={kernelName:ac,backendName:"webgl",kernelFunc:L9};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let M9=class{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let u;const l=`float(${s}) + float(${r}) * sum`;i===.5?u=`inversesqrt(${l})`:i===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z9{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let u;const l=`float(${s}) + float(${r}) * sum`;i===.5?u=`inversesqrt(${l})`:i===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B9=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:u}=s,l=ne().getBool("WEBGL_PACK_NORMALIZATION")?new z9(r.shape,i,o,a,u):new M9(r.shape,i,o,a,u);return t.runWebGLProgram(l,[r],r.dtype)},V9={kernelName:uc,backendName:"webgl",kernelFunc:B9};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let U9=class{constructor(e,t,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G9=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:u,alpha:l,beta:h}=s,c=new U9(r.shape,a,u,l,h);return t.runWebGLProgram(c,[r,i,o],r.dtype)},W9={kernelName:rp,backendName:"webgl",kernelFunc:G9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H9(n,e,t,s){const r=Q(e),o=Q(n.shape)/r,a=Te({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),u=Mo(a,n.dtype,"max",s),l=Te({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(u),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:o}=s,a=r.shape.length,u=Qe(i,r.shape);let l=u;const h=kt(l,a),c=h!=null,d=t.shouldExecuteOnCPU([r]);let p=r;if(c){if(d){const v=t.texData.get(p.dataId).values,w=new Array(a);for(let E=0;E<w.length;E++)w[E]=r.shape[h[E]];const S=mb(v,r.shape,r.dtype,h,w);p=t.makeTensorInfo(w,r.dtype);const k=t.texData.get(p.dataId);k.values=S}else p=pf(r,h,t);l=_t(l.length,a)}tn("max",l,a);const[f,g]=Yt(p.shape,l);let m=f;o&&(m=qt(f,u));let b;if(d){const v=t.texData.get(p.dataId).values,w=QK(v,Q(g),m,r.dtype);b=t.makeTensorInfo(m,r.dtype);const S=t.texData.get(b.dataId);S.values=w}else b=H9(p,g,m,t);return c&&t.disposeIntermediateTensorInfo(p),b}const K9={kernelName:lc,backendName:"webgl",kernelFunc:q$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j9=gb+`
  return max(a, b);
`,X9=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Oo+`
  return result;
`,q9=Sn({opSnippet:j9,packedOpSnippet:X9,cpuKernelImpl:JK}),Y9={kernelName:Qa,backendName:"webgl",kernelFunc:q9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Jc(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:u}=s,l=1;L(gn(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const h=kn(r.shape,i,o,l,a,u);if(h.filterWidth===1&&h.filterHeight===1&&ct(h.inShape,h.outShape))return us({inputs:{x:r},backend:t});const c=new El(h,"max",!1);return t.runWebGLProgram(c,[r],r.dtype)}const Q9={kernelName:cc,backendName:"webgl",kernelFunc:Z9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dataFormat:u,dimRoundingMode:l}=s,h=[1,1,1],c=bs(r.shape,i,o,h,a,l,u),d=new bb(c,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}const e7={kernelName:hc,backendName:"webgl",kernelFunc:J9};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let t7=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=i-1-e.padInfo.top,u=o-1-e.padInfo.left,l=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},n7=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterDepth,l=e.effectiveFilterHeight,h=e.effectiveFilterWidth,c=u-1-e.padInfo.front,d=l-1-e.padInfo.top,p=h-1-e.padInfo.left,f=u*l*h-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${h} +
                  wR * ${h} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s7(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:a,strides:u,pad:l,dimRoundingMode:h}=s,c=[1,1,1],d=bs(o.shape,a,u,c,l,h),p=new bb(d,"max",!0),f=t.runWebGLProgram(p,[o],o.dtype),g=new n7(d),m=t.runWebGLProgram(g,[r,f],o.dtype);return t.disposeIntermediateTensorInfo(f),m}const r7={kernelName:op,backendName:"webgl",kernelFunc:s7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i7(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:o}=e,a=i;Jc([i,o],"maxPoolGrad");const{filterSize:u,strides:l,pad:h,dimRoundingMode:c}=s,d=kn(a.shape,u,l,1,h,c),p=!0,f=new El(d,"max",p),g=t.runWebGLProgram(f,[a],a.dtype),m=new t7(d),b=t.runWebGLProgram(m,[r,g],a.dtype);return t.disposeIntermediateTensorInfo(g),b}const o7={kernelName:ip,backendName:"webgl",kernelFunc:i7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a7(n,e,t,s){let r=new El(t,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new El(t,"max",!0,!0,e);const o=s.runWebGLProgram(r,[n],"float32");return[i,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u7={kernelName:_g,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=e,u=t;L(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const l=[1,1];L(gn(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const h=kn(s.shape,r,i,l,o),[c,d]=a7(s,a,h,u);return[c,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l7(n,e,t,s){const r=Q(e),o=Q(n.shape)/r,a=Te({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),u=Mo(a,"float32","mean",s),l=Te({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(u),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c7={kernelName:dc,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:i}=e,o=t,a=s.shape.length,u=Qe(i,s.shape);let l=u;const h=kt(l,a),c=h!=null,d=o.shouldExecuteOnCPU([s]),p=[];let f=s;if(c){if(d){const w=o.texData.get(f.dataId).values,S=new Array(a);for(let I=0;I<S.length;I++)S[I]=s.shape[h[I]];const k=mb(w,s.shape,s.dtype,h,S);f=o.makeTensorInfo(S,s.dtype);const E=o.texData.get(f.dataId);E.values=k}else f=pf(s,h,o);p.push(f),l=_t(l.length,a)}tn("sum",l,a);const[g,m]=Yt(f.shape,l);let b=g;r&&(b=qt(g,u));const x=l7(f,m,b,o);for(const v of p)o.disposeIntermediateTensorInfo(v);return x}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,u=Qe(i,r.shape);let l=u;const h=kt(l,a);let c=r;h!=null&&(c=zn({inputs:{x:r},backend:t,attrs:{perm:h}}),l=_t(l.length,r.shape.length)),tn("min",l,a);const[d,p]=Yt(c.shape,l),f=Q(p),g=Te({inputs:{x:c},backend:t,attrs:{shape:[-1,f]}}),m=Mo(g,g.dtype,"min",t);let b;if(o){const x=qt(d,u);b=Te({inputs:{x:m},backend:t,attrs:{shape:x}})}else b=Te({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),h!=null&&t.disposeIntermediateTensorInfo(c),b}const d7={kernelName:pc,backendName:"webgl",kernelFunc:h7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p7=gb+`
  return min(a, b);
`,f7=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Oo+`
  return result;
`,m7=Sn({opSnippet:p7,packedOpSnippet:f7,cpuKernelImpl:e6}),g7={kernelName:Ja,backendName:"webgl",kernelFunc:m7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let x7=class{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((h,c)=>h[0]+e[c]+h[1]);const r=e.length,i=$t(r),o=t.map(h=>h[0]).join(","),a=t.map((h,c)=>h[0]+e[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b7{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,g)=>f[0]+e[g]+f[1]);const r=e.length,i=$t(r),o=t.map(f=>f[0]).join(","),a=t.map((f,g)=>f[0]+e[g]).join(","),u=Fn("rc",r),l=Fn("source",r),h=`${u[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${l.slice(-2).join()})`,d=s==="reflect"?0:1;let p="";if(r===1){const f=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${u[r-1]} += 1;
        if(${h}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
      `}else{const f=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${u[r-1]} += 1;
        if(${h}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
        rc = outputLoc;
        ${u[r-2]} += 1;
        if(${u[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${l.join()}), ${c});
          ${u[r-1]} += 1;
          if(${h}) {
            ${f}
            result[3] = getChannel(getX(${l.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y7=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:i}=t,o=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new b7(s.shape,r,i):new x7(s.shape,r,i);return e.runWebGLProgram(o,[s],s.dtype)},w7={kernelName:fc,backendName:"webgl",kernelFunc:y7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v7=`if (b == 0.0) return NAN;
  return mod(a, b);`,C7=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Oo+`
  return result;
`,S7=Sn({opSnippet:v7,packedOpSnippet:C7}),I7={kernelName:eu,backendName:"webgl",kernelFunc:S7};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $7=class{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k7=`
if (a == b) {
  return 1.0;
};
return a / b;`,T7=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Y$=Sn({opSnippet:k7,packedOpSnippet:T7,checkOutOfBounds:!0}),E7={kernelName:Ma,backendName:"webgl",kernelFunc:Y$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s1="return a - b;",Z$=Sn({opSnippet:s1,packedOpSnippet:s1,supportsComplex:!0,cpuKernelImpl:v6}),R7={kernelName:gu,backendName:"webgl",kernelFunc:Z$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q$(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,o=Qe([i],r.shape),a=q$({inputs:{x:r},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),u=qt(a.shape,o),l=Te({inputs:{x:a},backend:t,attrs:{shape:u}}),h=Z$({inputs:{a:r,b:l},backend:t}),c=K$({inputs:{x:h},backend:t}),d=ff({inputs:{x:c},backend:t,attrs:{axis:o,keepDims:!1}}),p=Te({inputs:{x:d},backend:t,attrs:{shape:u}}),f=Y$({inputs:{a:c,b:p},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}const N7={kernelName:Dc,backendName:"webgl",kernelFunc:Q$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _7(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s,u=a?r:Q$({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),l=u.shape[0],h=u.shape[1],c=new $7(l,h,i),d=[[o]],p=t.runWebGLProgram(c,[u],"int32",d);return a||t.disposeIntermediateTensorInfo(u),p}const D7={kernelName:Dg,backendName:"webgl",kernelFunc:_7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A7=Os+`
  return -x;
`,F7=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function P7(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId),[o,a]=n6(i.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,o)}let r;return ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new ci(s.shape,F7):r=new xr(s.shape,A7),t.runWebGLProgram(r,[s],s.dtype)}const L7={kernelName:mc,backendName:"webgl",kernelFunc:P7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O7=Ep;function M7(n){ps("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u}=s,l=t.readSync(r.dataId),h=t.readSync(i.dataId),{selectedIndices:c}=O7(l,h,o,a,u);return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}const z7={kernelName:ap,backendName:"webgl",kernelFunc:M7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B7=kx;function V7(n){ps("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=s,h=t.readSync(r.dataId),c=t.readSync(i.dataId),{selectedIndices:d,validOutputs:p}=B7(h,c,o,a,u,l);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const U7={kernelName:Ag,backendName:"webgl",kernelFunc:V7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G7=Rp;function W7(n){ps("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=s,h=t.readSync(r.dataId),c=t.readSync(i.dataId),d=o,p=a,f=u,g=l,{selectedIndices:m,selectedScores:b}=G7(h,c,d,p,f,g);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const H7={kernelName:up,backendName:"webgl",kernelFunc:W7};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let K7=class{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j7=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:o,onValue:a,offValue:u}=s,l=Q(r.shape),h=new K7(l,o,a,u),c=Te({inputs:{x:r},backend:t,attrs:{shape:[l]}}),d=t.runWebGLProgram(h,[c],i);t.disposeIntermediateTensorInfo(c);const p=[...r.shape,o],f=Te({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(d),f},X7={kernelName:bc,backendName:"webgl",kernelFunc:j7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yd(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=th({inputs:{input:s},backend:t}),i=yd({inputs:{x:r},backend:t}),o=mf({inputs:{input:s},backend:t}),a=yd({inputs:{x:o},backend:t}),u=Di({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),u}else return nh({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const q7={kernelName:Pc,backendName:"webgl",kernelFunc:yd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=th({inputs:{input:s},backend:t}),i=J$({inputs:{x:r},backend:t}),o=mf({inputs:{input:s},backend:t}),a=yd({inputs:{x:o},backend:t}),u=Di({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),u}else return nh({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const Y7={kernelName:xc,backendName:"webgl",kernelFunc:J$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z7(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return jm({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(h=>{Fd(i,h.shape,"All tensors passed to stack must have matching shapes"),L(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=e.map(h=>{const c=jm({inputs:{input:h},backend:t,attrs:{dim:r}});return a.push(c),c}),l=M$({inputs:u,backend:t,attrs:{axis:r}});return a.forEach(h=>t.disposeIntermediateTensorInfo(h)),l}const Q7={kernelName:yc,backendName:"webgl",kernelFunc:Z7};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let J7=class{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,h)=>l[0]+e[h]+l[1]);const r=e.length,i=$t(r),o=t.map(l=>l[0]).join(","),a=t.map((l,h)=>l[0]+e[h]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eq{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((g,m)=>g[0]+e[m]+g[1]);const r=e.length,i=$t(r),o=t.map(g=>g[0]).join(","),a=t.map((g,m)=>g[0]+e[m]).join(","),u=Fn("rc",r),l=Fn("source",r),h=`${u[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${i} rc = outputLoc;`,`${u[r-1]} += 1;
       if(${h}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${u[r-2]} += 1;
       if(${u[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${u[r-1]} += 1;
         if(${h}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let g=0,m=r===1?2:4;g<m;g++)f+=`
        ${d[g]}
        if (${p}) {
          result[${g}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${g}] = getChannel(getX(${l.join()}), ${c});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ek=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:o}=s;if(Q(r.shape)===0){const l=i.map((h,c)=>h[0]+r.shape[c]+h[1]);return nh({backend:t,attrs:{shape:l,value:o,dtype:r.dtype}})}const a=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new eq(r.shape,i,o):new J7(r.shape,i,o),u=[[o]];return t.runWebGLProgram(a,[r],r.dtype,u)},tq={kernelName:wc,backendName:"webgl",kernelFunc:ek};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nq=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,sq=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Oo+`
  return result;
`,rq=Sn({opSnippet:nq,packedOpSnippet:sq}),iq={kernelName:nu,backendName:"webgl",kernelFunc:rq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oq(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,u=[],l=Qe(i,r.shape);let h=l;const c=kt(h,a);let d=r;c!=null&&(d=zn({inputs:{x:r},backend:t,attrs:{perm:c}}),h=_t(h.length,a),u.push(d)),tn("prod",h,a);let p;if(t.shouldExecuteOnCPU([d])){const f=t.texData.get(d.dataId).values,{outVals:g,outShape:m,outDtype:b}=r6(d.shape,d.dtype,f,h);p=t.makeTensorInfo(m,b,g)}else{const[f,g]=Yt(d.shape,h),m=Q(g),b=Te({inputs:{x:d},backend:t,attrs:{shape:[-1,m]}}),x=yp(r.dtype),v=Mo(b,x,"prod",t);p=Te({inputs:{x:v},backend:t,attrs:{shape:f}}),u.push(b),u.push(v)}if(o){u.push(p);const f=qt(p.shape,l);p=Te({inputs:{x:p},backend:t,attrs:{shape:f}})}return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const aq={kernelName:Cc,backendName:"webgl",kernelFunc:oq};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uq(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=s,u=r.map(b=>t.readSync(b.dataId)),l=r.map(b=>b.shape),h=t.readSync(i.dataId),c=t.readSync(o.dataId),[d,p,f]=i6(u,l,h,i.shape,i.dtype,c,o.shape,a),g=d.map(b=>t.makeTensorInfo([b.length],"int32",b)),m=t.makeTensorInfo(f,i.dtype,p);return g.concat([m])}const lq={kernelName:Mw,backendName:"webgl",kernelFunc:uq};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cq(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,o=t.readSync(s.dataId),a=t.readSync(r.dataId),u=t.readSync(i.dataId),[l,h]=o6(o,s.shape,s.dtype,a,r.shape,u,i.shape),c=t.makeTensorInfo([l.length],"int32",l),d=t.makeTensorInfo([h.length],s.dtype,h);return[c,d]}const hq={kernelName:zw,backendName:"webgl",kernelFunc:cq};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dq(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:u}=s,l=t.readSync(r.dataId),h=t.readSync(i.dataId),c=t.readSync(o.dataId),d=a.map(m=>t.readSync(m.dataId)),p=a.map(m=>m.shape),[f,g]=a6(l,r.shape,h,i.shape,i.dtype,c,o.shape,d,p,u);return t.makeTensorInfo(f,i.dtype,g)}const pq={kernelName:Bw,backendName:"webgl",kernelFunc:dq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tk=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:o}=t,a=u6(s,r,i,o);return e.makeTensorInfo([a.length],o,a)},fq={kernelName:lp,backendName:"webgl",kernelFunc:tk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mq="return 1.0 / x;",gq=xt({opSnippet:mq}),xq={kernelName:su,backendName:"webgl",kernelFunc:gq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bq=Os+`
  return (x < 0.0) ? 0.0 : x;
`,yq=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,wq=xt({opSnippet:bq,packedOpSnippet:yq}),vq={kernelName:ru,backendName:"webgl",kernelFunc:wq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cq=Os+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Sq=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Iq=xt({opSnippet:Cq,packedOpSnippet:Sq}),$q={kernelName:iu,backendName:"webgl",kernelFunc:Iq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let kq=class{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,u,l]=e;this.outputShape=[o,t,s,l];const h=[r&&t>1?a-1:a,r&&s>1?u-1:u],c=[r&&t>1?t-1:t,r&&s>1?s-1:s];let d;i?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/c[0]},
          ${h[1]/c[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tq{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,u,l]=e;this.outputShape=[o,t,s,l];const h=[r&&t>1?a-1:a,r&&s>1?u-1:u],c=[r&&t>1?t-1:t,r&&s>1?s-1:s];let d;i?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/c[0]},
          ${h[1]/c[1]},
          ${h[1]/c[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eq(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[u,l]=a,h=ne().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Tq(r.shape,u,l,i,o):new kq(r.shape,u,l,i,o);return t.runWebGLProgram(h,[r],"float32")}const Rq={kernelName:$c,backendName:"webgl",kernelFunc:Eq};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Nq=class{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,o,a]=e,u=[s&&o>1?r-1:r,s&&a>1?i-1:i],l=[s&&o>1?o-1:o,s&&a>1?a-1:a],h=u[0]/l[0],c=u[1]/l[1],d=1/h,p=1/c,f=Math.ceil(d)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${c});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _q(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,a=new Nq(i.shape,r.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const Dq={kernelName:dp,backendName:"webgl",kernelFunc:_q};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Aq=class{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,u,l]=e;this.outputShape=[o,t,s,l];const h=[r&&t>1?a-1:a,r&&s>1?u-1:u],c=[r&&t>1?t-1:t,r&&s>1?s-1:s],d=r?"0.5":"0.0";let p;i?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/c[0]},
          ${h[1]/c[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fq{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,u,l]=e;this.outputShape=[o,t,s,l];const h=[r&&t>1?a-1:a,r&&s>1?u-1:u],c=[r&&t>1?t-1:t,r&&s>1?s-1:s],d=r?"0.5":"0.0";let p;i?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/c[0]},
          ${h[1]/c[1]},
          ${h[1]/c[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pq(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[u,l]=a,h=ne().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Fq(r.shape,u,l,i,o):new Aq(r.shape,u,l,i,o);return t.runWebGLProgram(h,[r],r.dtype)}const Lq={kernelName:Ic,backendName:"webgl",kernelFunc:Pq};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Oq=class{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,o,a]=e,u=[s&&o>1?r-1:r,s&&a>1?i-1:i],l=[s&&o>1?o-1:o,s&&a>1?a-1:a],h=u[0]/l[0],c=u[1]/l[1],d=1/h,p=1/c,f=Math.ceil(d)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${c});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mq(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,a=new Oq(i.shape,r.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const zq={kernelName:hp,backendName:"webgl",kernelFunc:Mq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Bq=class{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,i=e.map((a,u)=>r(u)).join(","),o=$t(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vq{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=Fn("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,a=$t(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(r.slice())};
          if(${i}){
            result.g = ${l(r.slice())};
          }
          if(${o}) {
            result.b = ${h(r.slice())};
            if(${i}) {
              result.a = ${c(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return d(f)}function l(f){return f[s-1]="("+f[s-1]+" + 1)",d(f)}function h(f){return f[s-2]="("+f[s-2]+" + 1)",d(f)}function c(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",d(f)}function d(f){const g=e.map((x,v)=>p(v,f)),m=g.join(","),b=g.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${b}))`}function p(f,g){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${g[f]} - 1`:`${g[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uq(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,o=r.shape.length,a=Qe(i,r.shape);if(o===0)return us({inputs:{x:r},backend:t});const u=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Vq(r.shape,a):new Bq(r.shape,a);return t.runWebGLProgram(u,[r],r.dtype)}const Gq={kernelName:kc,backendName:"webgl",kernelFunc:Uq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Wq=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hq={kernelName:xp,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=e,a=t,u=new Wq(s.shape,i),[l,h]=Lp(o,s.shape[1],s.shape[2]),c=[[l,h,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(u,[s],s.dtype,c)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kq=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,jq=xt({opSnippet:Kq}),Xq={kernelName:ou,backendName:"webgl",kernelFunc:jq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qq="return inversesqrt(x);",Yq=xt({opSnippet:qq,cpuKernelImpl:l6}),Zq={kernelName:au,backendName:"webgl",kernelFunc:Yq};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yb=class{constructor(e,t,s,r,i,o,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=$t(i.length),h=$t(o.length);let c="";s===1?c="i":s===2&&(c="i, j");const d=`getIndices(${c})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let g="";u&&(g="coords[0], coords[1]");const m=`getDefaultValue(${g})`,b=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${i});

        void main() {
          ${h} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${b};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qq{constructor(e,t,s,r,i,o,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const l=$t(i.length),h=$t(o.length);let c="";s===1?c="i":s===2&&(c="i, j");const d=`getIndices(${c})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let g="";u&&(g="coords[0], coords[1]");const m=`getDefaultValue(${g})`,b=t>1?"strides[j]":"strides",x=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${i});

        void main() {
          ${h} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${b};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${x};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jq(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:u,sliceSize:l,strides:h,outputSize:c}=_r(i,r,o),d=[c/l,l];if(c===0)return t.makeTensorInfo(o,r.dtype);const p=Te({inputs:{x:r},backend:t,attrs:{shape:[u,a]}}),f=Te({inputs:{x:i},backend:t,attrs:{shape:[u,l]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0]));let m;ne().getBool("WEBGL_PACK")?m=new Qq(u,a,p.shape.length,f.shape.length,h,d):m=new yb(u,a,p.shape.length,f.shape.length,h,d);const b=t.runWebGLProgram(m,[f,p,g],f.dtype),x=Te({inputs:{x:b},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(g),x}const eY={kernelName:Fg,backendName:"webgl",kernelFunc:Jq};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tY=class{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=ne().getNumber("WEBGL_VERSION")===2?i:o,u=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nY(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:o}=s,a=new tY(r.shape[0],r.shape[1],i.shape[1],o),u=[[r.shape[1]]];return t.runWebGLProgram(a,[r,i],"int32",u)}const sY={kernelName:Lg,backendName:"webgl",kernelFunc:nY};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rY=class{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let h=0;h<t.length;h++)l.push(`${a[h]}`),h<e&&u.push(`${a[h]}`);r=u.join(),i=l.join()}const o=$t(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iY(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,o=new rY(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(o,[s,r,i],mn(r.dtype,i.dtype))}const oY={kernelName:Tc,backendName:"webgl",kernelFunc:iY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aY=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Vc};
  float scale = ${Uc};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,uY=xt({opSnippet:aY}),lY={kernelName:uu,backendName:"webgl",kernelFunc:uY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cY=Au+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,hY=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,dY=xt({opSnippet:cY,packedOpSnippet:hY,cpuKernelImpl:h6}),pY={kernelName:du,backendName:"webgl",kernelFunc:dY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fY=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,mY=xt({opSnippet:fY}),gY={kernelName:hu,backendName:"webgl",kernelFunc:mY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xY=Au+`
  return sin(x);
`,bY=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Oo}
  return result;
`,yY=xt({opSnippet:xY,packedOpSnippet:bY}),wY={kernelName:lu,backendName:"webgl",kernelFunc:yY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vY=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,CY=xt({opSnippet:vY}),SY={kernelName:cu,backendName:"webgl",kernelFunc:CY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IY=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,$Y=xt({opSnippet:IY}),kY={kernelName:pu,backendName:"webgl",kernelFunc:$Y};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TY=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:o}=s;L(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((b,x)=>b*x),u=[[0,0]];u.push(...o);for(let b=1+i.length;b<r.shape.length;++b)u.push([0,0]);const l=[],h=ek({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),c=No(h.shape,i,a,!1),d=_o(c.length,i.length,!1),p=Do(h.shape,i,a,!1),f=Te({inputs:{x:h},backend:t,attrs:{shape:c}}),g=zn({inputs:{x:f},backend:t,attrs:{perm:d}}),m=Te({inputs:{x:g},backend:t,attrs:{shape:p}});return l.push(h),l.push(f),l.push(g),l.forEach(b=>t.disposeIntermediateTensorInfo(b)),m},EY={kernelName:Nc,backendName:"webgl",kernelFunc:TY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RY(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(s.dataId),u=t.readSync(r.dataId),l=t.readSync(i.dataId),h=t.readSync(o.dataId)[0],[c,d,p,f,g]=p6(a,s.shape,s.dtype,u,r.dtype,l,h);return[t.makeTensorInfo(d,s.dtype,c),t.makeTensorInfo([d[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),t.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const NY={kernelName:Vw,backendName:"webgl",kernelFunc:RY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Y(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.readSync(r.dataId)),a=t.readSync(s.dataId),u=Array.from(t.readSync(i.dataId)),[l,h,c]=f6(a,s.shape,s.dtype,o,u);return[t.makeTensorInfo(h,s.dtype,l),t.makeTensorInfo([c.length],i.dtype,new Int32Array(c))]}const DY={kernelName:Uw,backendName:"webgl",kernelFunc:_Y};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AY(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=t.readSync(s.dataId),a=t.readSync(r.dataId),u=t.readSync(i.dataId),[l,h]=$$(o,s.shape,s.dtype,a,u,!0);return t.makeTensorInfo(h,s.dtype,l)}const FY={kernelName:Og,backendName:"webgl",kernelFunc:AY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PY(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=t.readSync(s.dataId),a=t.readSync(r.dataId),u=t.readSync(i.dataId),[l,h]=$$(o,s.shape,s.dtype,a,u);return t.makeTensorInfo(h,s.dtype,l)}const LY={kernelName:Mg,backendName:"webgl",kernelFunc:PY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OY(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:u,numUpdates:l,sliceSize:h,strides:c,outputSize:d}=_r(i,r,a),p=!1;if(i.dtype==="string"){const b=t.bufferSync(r),x=t.bufferSync(i),v=Xs(t.readSync(o.dataId)[0]),w=c6(b,x,a,d,h,l,u,c,v,p);return t.makeTensorInfo(a,w.dtype,w.values)}const f=new yb(l,u,r.shape.length,i.shape.length,c,[d,1],p),g=t.runWebGLProgram(f,[i,r,o],i.dtype),m=Te({inputs:{x:g},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(g),m}const MY={kernelName:zg,backendName:"webgl",kernelFunc:OY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=Qe(o,r.shape)[0],u=Yp(r,i,a),l=r.shape.length,h=new Array(l).fill(0),c=r.shape.slice();return u.map(d=>{const p=[...c];p[a]=d;const f=Fu({inputs:{x:r},backend:t,attrs:{begin:h,size:p}});return h[a]+=d,f})}const BY={kernelName:_c,backendName:"webgl",kernelFunc:zY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r1="return sqrt(x);",VY=xt({opSnippet:r1,packedOpSnippet:r1,cpuKernelImpl:m6}),UY={kernelName:fu,backendName:"webgl",kernelFunc:VY};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GY="return x * x;",WY=xt({opSnippet:GY}),HY={kernelName:pp,backendName:"webgl",kernelFunc:WY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i1="return (a - b) * (a - b);",KY=Sn({opSnippet:i1,packedOpSnippet:i1}),jY={kernelName:mu,backendName:"webgl",kernelFunc:KY};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(r.dataId),o=Ys(i),a=g6(o,"string",s);return t.makeTensorInfo(r.shape,"string",a)}const qY={kernelName:Bg,backendName:"webgl",kernelFunc:XY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YY({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=Os+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new xr(s.shape,r);return t.runWebGLProgram(i,[s],s.dtype)}const ZY={kernelName:wu,backendName:"webgl",kernelFunc:YY};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let QY=class{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=$t(s.length),o=$t(s.length);let a="";if(r===1)a="coords * strides + begin";else{let u=0;a=s.map((l,h)=>(u++,s.length===1?`coords * strides[${h}] + begin[${h}]`:`coords[${u-1}] * strides[${h}] + begin[${h}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:o,strides:a,beginMask:u,endMask:l,ellipsisMask:h,newAxisMask:c,shrinkAxisMask:d}=s,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:x,end:v,strides:w}=Ap(r.shape,i,o,a,u,l,h,c,d);let S;if(g)S=Te({inputs:{x:r},backend:t,attrs:{shape:f}});else if(m||b){L(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const E=Dp(x,v,w),I=Fu({inputs:{x:r},backend:t,attrs:{begin:x,size:E}});S=Te({inputs:{x:I},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(I)}else if(t.shouldExecuteOnCPU([r])){const I=t.readSync(r.dataId),C=Je(r.shape,r.dtype,I),T=x6(p,C,w,x);S=t.makeTensorInfo(f,r.dtype,T.values)}else{const I=new QY(x,w,p);S=t.runWebGLProgram(I,[r],r.dtype)}const k=Te({inputs:{x:S},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(S),k}const eZ={kernelName:fp,backendName:"webgl",kernelFunc:JY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tZ(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:u,preserveShortSequences:l}=s,{data:h,dataSplits:c}=e,d=t.readSync(h.dataId),p=t.readSync(c.dataId),[f,g]=b6(d,p,r,i,o,a,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(c.shape,"int32",g)]}const nZ={kernelName:Vg,backendName:"webgl",kernelFunc:tZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sZ(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(i.dataId),u=t.readSync(o.dataId)[0],[l,h,c]=y6(a,u,r),d=h.length;return[t.makeTensorInfo([d,2],"int32",l),t.makeTensorInfo([d],"string",h),t.makeTensorInfo([2],"int32",new Int32Array(c))]}const rZ={kernelName:Gw,backendName:"webgl",kernelFunc:sZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iZ(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(i.dataId),a=w6(o,r);return t.makeTensorInfo(i.shape,"int32",a)}const oZ={kernelName:Ww,backendName:"webgl",kernelFunc:iZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aZ="return tan(x);",uZ=xt({opSnippet:aZ}),lZ={kernelName:xu,backendName:"webgl",kernelFunc:uZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cZ=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,hZ=xt({opSnippet:cZ}),dZ={kernelName:bu,backendName:"webgl",kernelFunc:hZ};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pZ(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:o}=e,{sliceRank:a,numUpdates:u,sliceSize:l,strides:h,outputSize:c}=_r(o,i,r.shape),d=[c/l,l];if(c===0)return t.makeTensorInfo(r.shape,i.dtype);const p=Te({inputs:{x:i},backend:t,attrs:{shape:[u,a]}}),f=Te({inputs:{x:o},backend:t,attrs:{shape:[u,l]}}),g=Te({inputs:{x:r},backend:t,attrs:{shape:d}}),m=new yb(u,a,p.shape.length,f.shape.length,h,d,!1,!0),b=t.runWebGLProgram(m,[f,p,g],g.dtype),x=Te({inputs:{x:b},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(b),x}const fZ={kernelName:Pg,backendName:"webgl",kernelFunc:pZ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mZ=class{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[o]*t[o];this.outputShape=s,this.rank=s.length;const r=$t(this.rank),i=gZ(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}};function gZ(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nk(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const u=t.readSync(r.dataId),l=r.dtype==="string"?u.map(d=>Xs(d)):u,h=Je(r.shape,r.dtype,l),c=C6(h,i);return t.makeTensorInfo(c.shape,c.dtype,c.values)}const o=new mZ(r.shape,i);return t.runWebGLProgram(o,[r],r.dtype)}const xZ={kernelName:yu,backendName:"webgl",kernelFunc:nk};let bZ=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},yZ=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bi(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function o1(n){let e=1;for(;e<n;)e*=2;return e}function wZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:o}=s,a=ne().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=ne().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=r.shape,h=l[l.length-1];if(t.shouldExecuteOnCPU([r])||h<a||i>u){const T=t.readSync(r.dataId),[R,P]=S6(T,l,r.dtype,i,o);return[t.makeTensorInfo(R.shape,R.dtype,R.values),t.makeTensorInfo(P.shape,P.dtype,P.values)]}if(i===0)return l[l.length-1]=0,[t.makeTensorInfo(l,r.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(h===1)return[r,nh({attrs:{shape:l,dtype:"int32",value:0},backend:t})];const c=t.texData.get(r.dataId),d=c!==null&&c.isPacked,p=d?t.unpackTensor(r):r,g=Q(l)/h,m=Te({inputs:{x:p},attrs:{shape:[g,h]},backend:t});d&&Bi(t,p);const b=o1(i),x=o1(h);let v=null;const w=()=>v===null?[m,m]:[m,v],S=(T,R,P)=>{const D=w(),F=new bZ(P),_=[[h],[v===null?1:0],[Number.NEGATIVE_INFINITY],[T],[R]],B=v;v=t.runWebGLProgram(F,D,"int32",_),Bi(t,B)};for(let T=1;T<b;T*=2){const R=T*2;for(let P=T;P>=1;P/=2)S(R,P,[g,x])}for(let T=x;T>b;T/=2){const R=w(),P=new yZ([g,T/2]),F=[[h],[v===null?1:0],[b]],z=v;v=t.runWebGLProgram(P,R,"int32",F),Bi(t,z);const _=b/2,B=_*2;for(let N=_;N>=1;N/=2)S(B,N,v.shape)}let k=v;v=Fu({inputs:{x:v},backend:t,attrs:{begin:0,size:[g,i]}}),Bi(t,k);let E=X$({inputs:{x:m,indices:v},backend:t,attrs:{axis:1,batchDims:1}});Bi(t,m);const I=l.slice(0,-1);I.push(i),k=v,v=Te({inputs:{x:v},attrs:{shape:I},backend:t}),Bi(t,k);const C=E;return E=Te({inputs:{x:E},attrs:{shape:I},backend:t}),Bi(t,C),[E,v]}const vZ={kernelName:mp,backendName:"webgl",kernelFunc:wZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let CZ=class{constructor(e,t,s,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=s==="nearest"?1:2;let u;switch(r){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SZ(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:u,outputShape:l}=s,[h,c,d,p]=r.shape,[f,g]=l??[c,d],m=[h,f,g,p],b=new CZ(c,d,o,a,u,m);return t.runWebGLProgram(b,[r,i],"float32")}const IZ={kernelName:gp,backendName:"webgl",kernelFunc:SZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Z(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;Jc(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:a,outputShape:u,indices:l}=I6(o,r,i.shape,i.dtype);return[s.makeTensorInfo(u,i.dtype,a),s.makeTensorInfo([l.length],"int32",l)]}const kZ={kernelName:Ug,backendName:"webgl",kernelFunc:$Z};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TZ(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,a=o.shape.length,u=r.shape[i],l=new Array(a-1);let h=0;for(let g=0;g<a;g++)g!==i&&(l[h++]=o.shape[g]);const c=[],d=new Array(a).fill(0),p=o.shape.slice();p[i]=1;const f=new Array(u);for(let g=0;g<f.length;g++){d[i]=g;const m=Fu({inputs:{x:o},backend:t,attrs:{begin:d,size:p}}),b=Te({inputs:{x:m},backend:t,attrs:{shape:l}});f[g]=b,c.push(m)}return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const EZ={kernelName:Ac,backendName:"webgl",kernelFunc:TZ};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RZ{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,i=e.inSize,o=e.numSegments,a=o*Math.ceil(i/s);this.outputShape=[r,a];const u="0.0",l="sumValue",h=Math.floor(s/4)*4,c=s%4,d=`
        sumValue += dot(values, segFilter);
    `;let p="";i%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let f="";i%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${h};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:o}=s,a=r.shape.length,u=[];let l=0;const h=kt([l],a);let c=r;h!=null&&(c=zn({inputs:{x:r},backend:t,attrs:{perm:h}}),u.push(c),l=_t(1,a)[0]);const d=Ax(c.shape,l,o),p=Q([c.shape[l]]),f=Te({inputs:{x:c},backend:t,attrs:{shape:[-1,p]}});u.push(f);const g=yp(r.dtype),m=(w,S,k,E,I)=>{const C=w.shape[0],T=w.shape[1],R=L2(T,I),P={windowSize:R,inSize:T,batchSize:C,numSegments:I},D=new RZ(P,S),F=t.compileAndRun(D,[w,k],E);if(u.push(F),F.shape[1]===I)return F;const z=tk({backend:t,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),_=nk({inputs:{x:z},backend:t,attrs:{reps:[T/R]}});return u.push(z),u.push(_),m(F,S,_,E,I)},b=m(f,"unsortedSegmentSum",i,g,o),x=Te({inputs:{x:b},backend:t,attrs:{shape:d}});let v=x;if(h!=null){u.push(x);const w=Nr(h);v=zn({inputs:{x:v},backend:t,attrs:{perm:w}})}return u.forEach(w=>t.disposeIntermediateTensorInfo(w)),v}const _Z={kernelName:Fc,backendName:"webgl",kernelFunc:NZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DZ=[m5,x5,w5,S5,$5,E5,N5,D5,L5,M5,V5,W5,j5,Z5,ej,nj,rj,uj,cj,dj,gj,Sj,$j,Rj,_j,Oj,zj,Gj,Q6,Kj,Zj,t8,a8,c8,d8,f8,g8,w8,S8,k8,E8,N8,D8,P8,O8,V8,G8,K8,q8,Z8,tX,iX,lX,dX,mX,gX,bX,wX,CX,IX,kX,NX,AX,LX,MX,VX,WX,XX,QX,Z6,e9,qj,s9,o9,l9,e5,p9,x9,y9,S9,k9,N9,A9,O9,V9,W9,K9,Y9,Q9,e7,r7,o7,u7,c7,d7,g7,w7,I7,D7,s5,L7,z7,U7,H7,Aj,X7,Y7,Q7,tq,iq,n5,aq,lq,hq,pq,fq,Fj,E7,xq,vq,$q,i5,Rq,Dq,Lq,zq,Gq,Hq,Xq,Zq,eY,sY,oY,lY,pY,gY,wY,SY,vj,N7,kY,EY,NY,DY,FY,LY,MY,BY,UY,HY,jY,qY,ZY,eZ,nZ,rZ,oZ,R7,d5,lZ,dZ,fZ,xZ,vZ,IZ,p5,kZ,EZ,_Z,q7];for(const n of DZ)Wg(n);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vs=ne();vs.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);vs.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);vs.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);vs.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);vs.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);vs.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);vs.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);vs.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);vs.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);vs.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);vs.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);vs.registerFlag("WEBGPU_PRINT_SHADER",()=>"");vs.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AZ{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FZ{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,s=!1,r=!0){let i;const o=a1(e,t);return r?(this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).length>0?(i=this.freeBuffers.get(o).pop(),this.numFreeBuffers--):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e)):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e),this.usedBuffers.has(o)||this.usedBuffers.set(o,[]),this.usedBuffers.get(o).push(i),this.numUsedBuffers++,this.numBytesUsed+=e,i}releaseBuffer(e,t=!0){if(this.freeBuffers.size===0)return;const s=e.size,r=e.usage,i=a1(s,r),o=this.usedBuffers.get(i),a=o.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");o[a]=o[o.length-1],o.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,t?(this.freeBuffers.get(i).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function a1(n,e){return`${n}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PZ{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,s,r){const i=l1(s),o=e*t*i,a=u1(e,t,s,r);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=o,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const l=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(l),l}this.numBytesAllocated+=o;const u=this.device.createTexture({size:[e,t],format:s,usage:r});return this.usedTextures.get(a).push(u),u}releaseTexture(e){if(this.freeTextures.size===0)return;const t=e.width,s=e.height,r=e.format,i=e.usage,o=u1(t,s,r,i);this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.freeTextures.get(o).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(o),u=a.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(u,1);const l=l1(r),h=t*s*l;this.numBytesUsed-=h}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function u1(n,e,t,s){return`${n}_${e}_${t}_${s}`}function l1(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LZ(n,e){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const t=n.length,s="xyzwuv",r=n.map(o=>`${e}.${s[o]}`),i=new Array(t-1);i[t-2]=r[t-1];for(let o=t-3;o>=0;--o)i[o]=`(${i[o+1]} * ${r[o+1]})`;return i}const Ai=(n,e,t)=>t==="int32"?`atomicAdd(${n}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Sa;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(Sa||(Sa={}));const OZ=(n,e,t,s,r)=>{const i={dtype:s.dtype,shape:s.shape},o=zZ(t,i,e),a=n.createShaderModule({code:o,label:e.constructor.name});let u=ne().get("WEBGPU_PRINT_SHADER");if(u!==""){u=u.toLowerCase();const l=u.split(",");(u==="all"||l.some(h=>e.shaderKey.toLowerCase().includes(h)))&&(console.group(e.shaderKey),console.debug(o),console.groupEnd())}return r?n.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},nt=(n,e="f32")=>{switch(n){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component ${e} is not supported.`)}};function Kt(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Wr(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function Ie(...n){let e;switch(n.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function c1(n,e){let t;return t=`
     ${MZ(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,t}function MZ(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function zZ(n,e,t){const s=[],r=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(t.outputComponent=t.outputComponent?t.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${sk(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${r}u +
                localIndex);
        `}
      }
    `),t.pixelsOpType!=null){const f=t.pixelsOpType===Sa.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Xi(e.dtype,t.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Xi(n[0].dtype,t.outputComponent)}>;`,g=e.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${g},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${f}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const m=d1(t);return[h1,s.join(`
`),Oh(e.shape),t.getUserCode(),c1(m,t)].join(`
`)}let i,o,a="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((f,g)=>{const m=Kt(n[g].shape.length);a+=`${f.charAt(0).toLowerCase()+f.slice(1)}Shape : ${m}, `,i=n[g].shape.length-1,o=Kt(i),a+=`${f.charAt(0).toLowerCase()+f.slice(1)}ShapeStrides: ${o}, `});const u=Kt(e.shape.length);a+=`outShape : ${u}, `,i=e.shape.length-1,o=Kt(i),a+=`
         outShapeStrides: ${o}, `,t.size&&(a+="size : i32, "),t.uniforms&&(a+=t.uniforms),a+="};",a=XZ(a),s.push(a),t.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Xi(e.dtype,t.outputComponent)}>;
    `),t.variableNames.forEach((f,g)=>{s.push(`
      @group(0) @binding(${1+g}) var<storage, read> ${f}: array<${t.variableComponents?Xi(n[g].dtype,t.variableComponents[g]):Xi(n[g].dtype,t.outputComponent)}>;
        `)}),a!==""&&s.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const l=HZ(e.shape,t.dispatchLayout),h=[h1,s.join(`
`)+VZ,Oh(e.shape),l,KZ(e.shape.length)];t.atomic||h.push(jZ(e.shape,e.dtype,t.outputComponent)),t.variableNames.forEach((f,g)=>{h.push(`${Oh(n[g].shape,f)}`)});const c=n.map((f,g)=>WZ(f,e.shape,t.variableComponents?t.variableComponents[g]:t.outputComponent,t.dispatchLayout.x.length===e.shape.length)).join(`
`);h.push(c),h.push(t.getUserCode());const d=d1(t);return h.push(c1(d,t)),h.join(`
`)}function BZ(n,e,t){let s=n.shaderKey;if(n.pixelsOpType!=null)return s;const r=[],i=[];e.forEach(h=>{r.push(h.shape),i.push(h.dtype)}),r.push(t.shape),i.push(t.dtype);const o=e.map(h=>xi(h.shape,t.shape)),a=e.map(h=>ct(h.shape,t.shape)).join("_"),u=o.map(h=>h.join("_")).join(";"),l=sk(n)?"flatDispatch":"";return s+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+r.map(h=>h.length).join(",")+i.join(",")+n.variableNames.join(",")+u+a+l,s}const h1=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,VZ=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function Oh(n,e=""){const t=n.length,s=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",r=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(t<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const i=Be(n),o=Kt(t),a=[];for(let l=0;l<t;l++)a.push(`d${l}`);if(i.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${r}; let d1 = index - d0 * uniforms.${r};
      return vec2<i32>(d0, d1);
    }`;let u;return u="var index2 = index;"+i.map((l,h)=>{const c=`let ${a[h]} = index2 / uniforms.${r}.${Wr(h)}`,d=h===i.length-1?`let ${a[h+1]} = index2 - ${a[h]} * uniforms.${r}.${Wr(h)}`:`index2 = index2 - ${a[h]} * uniforms.${r}.${Wr(h)}`;return`${c}; ${d};`}).join(""),`
    fn ${s}(index : i32) -> ${o} {
      ${u}
      return ${o}(${a.join(",")});
    }
  `}function UZ(n,e){const t=n.name,s=n.shape.length,r=Kt(s),i="get"+t.charAt(0).toUpperCase()+t.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=o.map(h=>`${h} : i32`).join(", ");if(s<1)return`
      fn ${i}() -> ${nt(e)} {
        return ${nt(e)}(${t}[0]);
      }
    `;const u=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`;let l=`${s}D`;return s===0&&(l="1D"),`
    fn ${i}(${a}) -> ${nt(e)} {
      return ${nt(e)}(${t}[getIndexFromCoords${l}(${r}(${o.join(",")}),
        ${u})${e===1?"":` / ${e}`}]);
    }
   `}function GZ(n,e,t,s){const r=n.name,i=r.charAt(0).toUpperCase()+r.slice(1),o="get"+i+"ByOutput",a=n.shape.length,u=e.length,l=Kt(u);if(ct(n.shape,e)&&s)return`
    fn ${o}Index(globalIndex : i32) -> ${nt(t)} {
      return ${nt(t)}(${r}[globalIndex]);
    }

    fn ${o}Coords(coords : ${l}) -> ${nt(t)} {
      return ${nt(t)}(${r}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}${t===1?"":` / ${t}`}]);
    }
    `;const h=xi(n.shape,e),c=u-a;let d="";if(a===0)return`
    fn ${o}Index(globalIndex : i32) -> ${nt(t)}{
      return get${i}();
    }

    fn ${o}Coords(coords : ${l}) -> ${nt(t)}{
      return get${i}();
    }
  `;u<2&&h.length>=1?d="coords = 0;":d=h.map(m=>`coords.${Wr(m+c)} = 0;`).join(`
`);let p="";if(u<2&&a>0)p="coords";else if(u>1){const m=Kt(a),b=n.shape.map((x,v)=>`coords.${Wr(v+c)}`).join(", ");p=`${m}(${b})`}else p="coords";const f=`uniforms.${r.charAt(0).toLowerCase()+r.slice(1)}Shape`,g=`${a}D`;return`
  fn ${o}Index(globalIndex : i32) -> ${nt(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${d}
    return ${nt(t)}(${r}[getIndexFromCoords${g}(${p}, ${f})${t===1?"":` / ${t}`}]);
  }

  fn ${o}Coords(coordsIn : ${l}) -> ${nt(t)} {
    var coords = coordsIn;
    ${d}
    return ${nt(t)}(${r}[getIndexFromCoords${g}(${p}, ${f})${t===1?"":` / ${t}`}]);
  }
`}function WZ(n,e,t,s){let r=UZ(n,t);return n.shape.length<=e.length&&(r+=GZ(n,e,t,s)),r}function HZ(n,e){const{x:t,y:s=[],z:r=[]}=e,i=n.length,o=t.length+s.length+r.length;if(o!==i)return"";if(t.length===i)return`fn getOutputCoords() -> ${Kt(i)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const u=[t,s,r];for(let d=0;d<u.length;d++){const p=u[d];if(p.length!==0)if(p.length===1)a+=`let d${p[0]} = i32(globalId[${d}]);`;else{const f=LZ(p,"uniforms.outShape");a+=`var index${d} = i32(globalId[${d}]);`;for(let g=0;g<f.length;g++)a+=`let d${p[g]} = index${d} / ${f[g]};`,g===f.length-1?a+=`let d${p[g+1]} = index${d} - d${p[g]} * ${f[g]};`:a+=`index${d} = index${d} - d${p[g]} * ${f[g]};`}}const l=[];for(let d=0;d<o;d++)l.push(`d${d}`);const h=Kt(o);let c=`fn getOutputCoords() -> ${h} {
  ${a}
`;return l.length===0?c+=`return ${h}(0); }`:c+=`return ${h}(${l.join(",")}); }`,c}function KZ(n){let e="";switch(n){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:L(!1,()=>`Unsupported ${n}D shape`);break}return e}function sk(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function Xi(n,e=1){if(n==="float32")return nt(e,"f32");if(n==="int32"||n==="bool")return nt(e,"i32");throw new Error(`type ${n} is not supported.`)}function jZ(n,e,t){const s=n.length,r=Xi(e,t);let i=`fn setOutputAtIndex(flatIndex : i32, value : ${nt(t)}) {
      result[flatIndex] = ${r}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${nt(t,"i32")}) {
      result[flatIndex] = ${r}(value);
    }
    `;if(s>=2){const o=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=Kt(s);i+=`
      fn setOutputAtCoords(${o.map(u=>`${u} : i32`).join(", ")}, value : ${nt(t)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndex(flatIndex${t===1?"":` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${o.map(u=>`${u} : i32`).join(", ")}, value : ${nt(t,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndexI32(flatIndex${t===1?"":` / ${t}`}, value);
      }
    `}return i}function XZ(n){const e=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(e,s=>"@align(16) "+s);const t=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(t,(s,r,i)=>`vec${r}, @align(16) ${i}`),n}function d1(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const io=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e};function $e(n,e,t=[1,1,1],s=[1,1,1]){const[r,i,o]=[Math.ceil(io(n.x.map(a=>e[a]))/(t[0]*s[0])),n.y?Math.ceil(io(n.y.map(a=>e[a]))/(t[1]*s[1])):1,n.z?Math.ceil(io(n.z.map(a=>e[a]))/(t[2]*s[2])):1];return[r,i,o]}function qZ(n,e,t,s=!1){const r=[8,8,1],i=[4,4,1];return s||(n<=8&&(i[1]=1),e<=16&&t<=16&&(r[0]=4)),{workgroupSize:r,elementsPerThread:i}}function rk(n,e,t=!1){if(t)return[8,8,1];const s=io(n.x.map(i=>e[i])),r=io(n.y.map(i=>e[i]));return s<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function ik(n,e,t=!1){if(t)return[4,4,1];const s=io(n.x.map(i=>e[i])),r=io(n.y.map(i=>e[i]));return s<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function _e(n){return{x:n.map((e,t)=>t)}}function p1(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function ok(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function ak(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&L(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var ir;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(ir||(ir={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YZ=ne().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),ZZ=(n,e)=>{const t=n.limits.maxComputeWorkgroupsPerDimension,s=e.dispatchLayout,r=e.dispatch;if(r.every(o=>o<=t))return r;L(r[0]>t&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(r[0]));return i>t?(i=Math.ceil(Math.cbrt(r[0])),L(i<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]};class gf extends Ad{nextDataId(){return gf.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!ok())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new AZ(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new FZ(this.device),this.textureManager=new PZ(this.device),this.tensorMap=new yg(this,ds()),ne().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const s=this.tensorMap.get(e);return t?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(!(!t||!t.resource)){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){const t=this.tensorMap.get(e);t.refCount--}}write(e,t,s){if(s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:s,shape:t,values:e,refCount:1}),r}move(e,t,s,r,i){if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:s,values:t,refCount:i})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map((t,s)=>{this.pipelineCache[t]=e[s]})}async getBufferData(e){if(ne().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,s=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,t),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const r=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),ne().getBool("WEBGPU_USE_PROFILE_TOOL")&&(L(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(e,t){const s=this.tensorMap.get(e);return s.values=t,s.values}readSync(e){const t=this.tensorMap.get(e),{values:s,complexTensorInfos:r}=t;if(s!=null||t.dtype==="string")return s;if(t.dtype==="complex64"){const g=this.readSync(r.real.dataId),m=this.readSync(r.imag.dataId),b=Fh(qs(g,m).buffer,"float32");return this.convertAndCacheOnCPU(e,b),b}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const i=["opaque","premultiplied"],o=t.resource,a=o.size;L(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const u=a/4,l=new ArrayBuffer(a),h=256,c=256,d=i.map(g=>new OffscreenCanvas(h,c)),p=new OffscreenCanvas(h,c);this.endComputePassEncoder(),d.map((g,m)=>{const b=g.getContext("webgpu");return b.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:i[m]}),b.getCurrentTexture()}).map((g,m)=>{const b=h*4,x=(I,C,T)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:o,bytesPerRow:b,offset:T},{texture:g},{width:I,height:C}),this.submitQueue();const R=p.getContext("2d",{willReadFrequently:!0});R.clearRect(0,0,I,C),R.drawImage(d[m],0,0);const P=R.getImageData(0,0,I,C).data,D=i[m],F=new Uint8ClampedArray(l,T,I*C*4);for(let z=0;z<F.length;z+=4)if(D==="premultiplied")F[z+3]=P[z+3];else{const _=P[z];F[z]=P[z+2],F[z+1]=P[z+1],F[z+2]=_}},v=Math.floor(u/(h*c));let w=h,S=c,k=0;for(let I=0;I<v;I++)x(w,S,k),k+=h*c*4;const E=u%(h*c);S=Math.floor(E/h),S>0&&(x(w,S,k),k+=S*(h*4)),w=E%h,w>0&&x(w,1,k)});const f=Fh(l,t.dtype);return this.convertAndCacheOnCPU(e,f),f}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:s}=t;if(s!=null)return s;let r;if(t.dtype==="complex64"){const i=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),o=i[0],a=i[1];r=qs(o,a)}else{const i=await this.getBufferData(t.resource);r=Fh(i,t.dtype)}return this.convertAndCacheOnCPU(e,r),r}copyBuffer(e){const t=e.size,s=e.usage,r=this.bufferManager.acquireBuffer(t,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),r}createTensorFromGPUData(e,t,s){let r=e.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const i={id:this.nextDataId()};this.tensorMap.set(i,{dtype:s,shape:t,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(i),a=p1(o.dtype)*Q(o.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(r=this.copyBuffer(r)),o.resource=r,ds().makeTensorFromDataId(i,t,s,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:s,dtype:r,shape:i,resource:o}=t;if(r==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(o==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=o,u=a.size,l=a.usage,h=this.bufferManager.acquireBuffer(u,l);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,h,0,u),this.submitQueue();const c=this.makeTensorInfo(i,r),d=ds().makeTensorFromTensorInfo(c),p=this.tensorMap.get(c.dataId);return p.resource=h,{tensorRef:d,buffer:h}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Xs(r));return Je(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Je(e.shape,e.dtype,t)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=Xr(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=Xr(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(i);return a.kernelMs=_w(u),a.getExtraProfileInfo=()=>u.map((l,h)=>({name:o[h],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,t,s){return t==="string"&&s!=null&&s.length>0&&Ia(s[0])&&(s=s.map(i=>Ur(i))),{dataId:this.write(s,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const s=this.tensorMap.get(e.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resource!=null)return;const s=p1(t.dtype)*Q(t.shape);let r;const i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(r=this.bufferManager.acquireBuffer(s,i,!0),r.mapState==="unmapped"){const o=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=o.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),o.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,r,0,s),this.stagingPendingDisposal.push(o)}else{const o=r.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(o).set(t.values):new Float32Array(o).set(t.values),r.unmap()}t.values=null}else r=this.bufferManager.acquireBuffer(s,i);t.resource=r}makeUniforms(e){let t=0,s=0;const r=[];let i=1;e.forEach(u=>{u.data.length===0&&(u.data=[1]);let l;switch(u.data.length){case 1:l=4;break;case 2:l=8;break;case 3:l=16;break;case 4:l=16;break;case 5:l=16;break;case 6:l=16;break;default:L(!1,()=>`Unsupported ${u.data.length}D shape`)}(s===5||s===6)&&(l=16),l>i&&(i=l),t=Math.ceil(t/l)*l,s=u.data.length,r.push(t),t+=u.data.length*4}),t=Math.ceil(t/i)*i;const o=new ArrayBuffer(t);e.forEach((u,l)=>{const h=r[l];u.type==="int32"?new Int32Array(o,h,u.data.length).set(u.data):u.type==="uint32"?new Uint32Array(o,h,u.data.length).set(u.data):new Float32Array(o,h,u.data.length).set(u.data)});const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,o,0,t),this.uniformPendingDisposal.push(a),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,s,r,i){if(i||(i=this.makeTensorInfo(e.outputShape,s)),Q(i.shape)===0)return this.tensorMap.get(i.dataId).values=fn(i.dtype,0),i;this.uploadToGPU(i.dataId),e.dispatch=ZZ(this.device,e);const o=t.map((u,l)=>{if(u.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(u.dataId),{dtype:this.tensorMap.get(u.dataId).dtype,shape:u.shape,name:e.variableNames[l]}});e.shaderKey=BZ(e,o,i);const a=ne().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=OZ(this.device,e,o,i,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,i,t,r),i}recordAndSubmit(e,t,s,r){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let i=[],o=[];const a="int32";if(e.pixelsOpType==null){i.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),o=s.concat(t).map(p=>p.shape);const d="int32";o.map(p=>{i.push({type:d,data:p});const f=Be(p);i.push({type:d,data:f})})}else{const d=Be(t.shape);i.push({type:a,data:d})}if(e.size){const d=Q(e.outputShape);i.push({type:a,data:[e.outputComponent?d/e.outputComponent:d]})}r&&(i=[...i,...r]);const u=[this.tensorToBinding(t),...s.map(d=>this.tensorToBinding(d)),this.makeUniforms(i)];s.forEach(d=>{this.commandQueueOwnedIds.add(d.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const l=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:u.map((d,p)=>({binding:p,resource:d}))}),h=this.activeTimers!=null;this.ensureCommandEncoderReady();const c={};h&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),c.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(c)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(c)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,l),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(h||ne().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===Sa.DRAW)&&(this.endComputePassEncoder(),h?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),s=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),s}shouldExecuteOnCPU(e,t=YZ){return ne().getBool("WEBGPU_CPU_FORWARD")&&e.every(s=>this.tensorMap.get(s.dataId).resource==null&&Q(s.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}gf.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ok()&&Kg("webgpu",async()=>{const n={powerPreference:ne().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(n),t={},s=[];e.features.has("timestamp-query")&&s.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),t.requiredFeatures=s;const r=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup};const i=await e.requestDevice(t),o="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new gf(i,o)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var qe;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(qe||(qe={}));const QZ="let resultTemp = a + b;",JZ="let resultTemp = atan2(a, b);",eQ="let resultTemp = areal * breal - aimag * bimag;",tQ="let resultTemp = areal * bimag + aimag * breal;",nQ="let resultTemp = a / b;",sQ="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",rQ=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,iQ=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,oQ=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,aQ=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,uQ=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,lQ=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,cQ="return f32(a >= 1.0 && b >= 1.0);",hQ=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,dQ="return f32(a >= 1.0 || b >= 1.0);",pQ=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,fQ="let resultTemp = max(a, b);",mQ="let resultTemp = min(a, b);",gQ=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,xQ=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,bQ="let resultTemp = a * b;",yQ=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,wQ=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,vQ=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,CQ=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,SQ="if (a < 0.0) { return b * a; }  return a;",IQ=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,$Q="let resultTemp = (a - b) * (a - b);",kQ="let resultTemp = a - b;";function wb(n,e){let t;do{switch(n){case qe.ATAN2:t=JZ;break;case qe.MAX:t=fQ;break;case qe.MIN:t=mQ;break;case qe.MOD:t=e?xQ:gQ;break;case qe.NOT_EQUAL:t=e?wQ:yQ;break;case qe.POW:t=e?CQ:vQ;break;default:continue}let s,r,i;return e?(s="isnanVec4",r="vec4<f32>",i="vec4<bool>"):(s="isnan",r="f32",i="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${r}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${r}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${r}(valueForNaN),
            ${i}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case qe.ADD:t=QZ;break;case qe.COMPLEX_MULTIPLY_IMAG:t=tQ;break;case qe.COMPLEX_MULTIPLY_REAL:t=eQ;break;case qe.DIV:t=nQ;break;case qe.ELU_DER:t=sQ;break;case qe.EQUAL:t=rQ;break;case qe.FLOOR_DIV:t=iQ;break;case qe.GREATER:t=oQ;break;case qe.GREATER_EQUAL:t=aQ;break;case qe.LESS:t=uQ;break;case qe.LESS_EQUAL:t=lQ;break;case qe.LOGICAL_AND:return e?hQ:cQ;case qe.LOGICAL_OR:return e?pQ:dQ;case qe.MUL:t=bQ;break;case qe.PRELU:return e?IQ:SQ;case qe.SQUARED_DIFFERENCE:t=$Q;break;case qe.SUB:t=kQ;break}return`
    ${t}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ve;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(ve||(ve={}));const TQ="return abs(a);",EQ=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,RQ=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,NQ=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,_Q="return asinh(a);",DQ=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,AQ=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,FQ="return ceil(a);",PQ="return cos(a);",LQ=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,OQ="return exp(a) - 1.0;",MQ="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",zQ=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,BQ=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${zp};
  let a1 = ${Bp};
  let a2 = ${Vp};
  let a3 = ${Up};
  let a4 = ${Gp};
  let a5 = ${Wp};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,VQ="return exp(a);",UQ="return floor(a);",GQ="return f32(!isnan(a) && !isinf(a));",WQ="return f32(isinf(a));",HQ="return f32(isnan(a));",KQ="return a;",jQ=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,XQ=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,qQ="return f32(!(a >= 1.0));",YQ="return -a;",ZQ="if (a < 0.0) { return uniforms.alpha * a; } return a;",QQ=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,JQ="return 1.0 / a;",eJ="return select(a, 0.0, a < 0.0);",tJ="return clamp(a, 0.0, 6.0);",nJ="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",sJ=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,rJ="return round(a);",iJ="return inverseSqrt(a);",oJ=`
  if (a >= 0.0) {
    return ${Uc} * a;
  } else {
    return ${Vc} * (exp(a) - 1.0);
  }
`,aJ="return 1.0 / (1.0 + exp(-1.0 * a));",uJ="return sign(a);",lJ="return sin(a);",cJ=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,hJ=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,dJ="return sqrt(a);",pJ="return a * a;",fJ=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,mJ="return tan(a);",gJ=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,xJ="return f32(i32((a)));";function Wi(n,e){switch(n){case ve.ABS:return TQ;case ve.ACOS:return EQ;case ve.ACOSH:return RQ;case ve.ASIN:return NQ;case ve.ASINH:return _Q;case ve.ATAN:return DQ;case ve.ATANH:return AQ;case ve.COS:return PQ;case ve.COSH:return LQ;case ve.CEIL:return FQ;case ve.ELU:return e?zQ:MQ;case ve.ERF:return BQ;case ve.EXP:return VQ;case ve.EXPM1:return OQ;case ve.FLOOR:return UQ;case ve.IS_FINITE:return GQ;case ve.IS_INF:return WQ;case ve.IS_NAN:return HQ;case ve.LINEAR:return KQ;case ve.LOG:return jQ;case ve.LOG1P:return XQ;case ve.LOGICAL_NOT:return qQ;case ve.NEG:return YQ;case ve.LEAKYRELU:return e?QQ:ZQ;case ve.RECIPROCAL:return JQ;case ve.RELU:return e?sJ:eJ;case ve.RELU6:return e?nJ:tJ;case ve.ROUND:return rJ;case ve.RSQRT:return iJ;case ve.SELU:return oJ;case ve.SIGMOID:return aJ;case ve.SIGN:return uJ;case ve.SIN:return lJ;case ve.SINH:return cJ;case ve.SOFTPLUS:return hJ;case ve.SQRT:return dJ;case ve.SQUARE:return pJ;case ve.STEP:return fJ;case ve.TAN:return mJ;case ve.TANH:return gJ;case ve.TO_INT:return xJ;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei(n,e=!1,t=!1,s=3){if(n===null)return"";let r="";if(n==="linear")r=Wi(ve.LINEAR);else if(n==="relu")r=Wi(ve.RELU,t);else if(n==="elu")r=Wi(ve.ELU,t);else if(n==="relu6")r=Wi(ve.RELU6,t);else if(n==="prelu")r=wb(qe.PRELU,t);else if(n==="sigmoid")r=Wi(ve.SIGMOID,t);else if(n==="leakyrelu")r=Wi(ve.LEAKYRELU,t);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const o=nt(t?4:1);let a="";return e?a=`
      fn activation(a : ${o}, coords : vec${s}<i32>) -> ${o} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${r}
      }`:a=`
      fn activation(a : ${o}, coords : vec${s}<i32>) -> ${o} {
        ${r}
      }`,a}function zo(n,e){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uk(n,e,t=!1,s=!1,r=!1,i=1){L(n&&i===1||!n,()=>`transposeA ${n} is not compatible with component size ${i}`);const o=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${nt(i)} {
    var value = ${nt(i)}(0.0);
    ${t&&r?o:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${o}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${nt(i)} {
    var value = ${nt(i)}(0.0);
    ${a}
    return value;
  }
  `}function vb(n,e,t,s,r=!1,i=!1,o=!1,a=1){return`
  ${uk(t,s,r,i,o,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${nt(a)}) {
    ${r&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${zo(n,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const bJ=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,yJ=(n,e,t,s)=>{if(n)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let r="",i="";for(let o=0;o<e;o++)r+=`let BCached${o} = mm_Bsub[k * ${e} + ${o}][tileCol];`,i+=`acc[i] = fma(BCached${o}, vec4<f32>(ACached[${o}]), acc[i]);`;return`
      for (var k = 0; k < ${s/e}; k++) {
        ${r}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${i}
        }
      }`}};function xf(n,e,t=!1,s=32,r=!1,i=32,o=!1){const a=e[1]*n[1],u=e[0]*n[0],l=t?a:s,h=t?s:a,c=l/e[0],d=s/e[1],p=n[1],f=n[0];return L((t&&c===4&&n[1]===4||!t&&(c===3||c===4))&&l%e[0]===0&&s%e[1]===0&&n[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${c} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${c} must be 3 or 4.
      tileAWidth ${l} must be divisible by workgroupSize[0]${e[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${c}<f32>, ${l/c}>, ${h}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/n[0]}>, ${s}>;

  ${Ie()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${p};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${p};
    let globalCol = i32(globalId.x) * ${f};
    let batch = ${r?"0":"i32(globalId.z)"};
    let batchA = ${r||!o?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${r||!o?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${r?`${Math.ceil(i/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${r?`i32(globalId.z) * ${i}`:"0"};

    var acc: array<vec4<f32>, ${p}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${d};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${bJ(t,c)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${yJ(t,c,p,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const f1=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,wJ=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function bf(n,e,t=!1,s=32,r=!1,i=32,o=!1,a=!1){const u=n[1]*e[1],l=n[0]*e[0],h=t?u:s,c=t?s:u;L(c%e[1]===0&&h%e[0]===0&&s%e[1]===0,()=>`tileAHight ${c} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${h} must be divisible by workgroupSize[0]${e[0]}, tileInner ${s} must be divisible by workgroupSize[1]${e[1]}`);const d=c/e[1],p=h/e[0],f=s/e[1],g=n[1],m=n[0],b=o?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${u};
      let globalColStart = i32(workgroupId.x) * ${l};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${c}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${e[0]}) {
            ${f1(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${m}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${m}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${m}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${g};
  let tileCol = i32(localId.x) * ${m};

  let globalRow = i32(globalId.y) * ${g};
  let globalCol = i32(globalId.x) * ${m};
  let globalRowStart = i32(workgroupId.y) * ${u};

  let tileRowA = i32(localId.y) * ${d};
  let tileColA = i32(localId.x) * ${p};
  let tileRowB = i32(localId.y) * ${f};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
      for (var innerCol = 0; innerCol < ${p}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${f1(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
      for (var innerCol = 0; innerCol < ${m}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${m}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${m}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        ${wJ(t)}
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${g}; innerRow++) {
    for (var innerCol = 0; innerCol < ${m}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${h}>, ${c}>;
    var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${s}>;

    ${Ie()} {
      let batch = ${r?"0":"i32(globalId.z)"};
      let batchA = ${r||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${r||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${r?`${Math.ceil(i/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${r?`i32(globalId.z) * ${i}`:"0"};

      var acc : array<array<f32, ${m}>, ${g}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${b}
    }
  `}const vJ=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function CJ(n,e=!1){L(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const t=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${Ie()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${vJ(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t/4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class SJ{constructor(e,t,s=!1,r=!1,i=null,o=null,a=null,u=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const l=s?e[1]:e[2];if(this.isVec4=(l%4===0&&!s||t[1]%4===0&&s)&&t[2]%4===0&&!r,this.outputComponent=this.isVec4?4:1,this.isVectorA=t[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const d=qZ(t[1],l,t[2],s);this.workgroupSize=d.workgroupSize,this.elementsPerThread=d.elementsPerThread}this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const h=i!=null,c=a!=null;h&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=u,this.transposeA=s,this.transposeB=r,this.addBias=h,this.activation=o,this.hasPreluActivationWeights=c,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],l),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,s){const r=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=i;const o=e%r===0,a=t%i===0,u=s%this.tileInner===0;return[o,a,u]}getUserCode(){return`
      ${ei(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${vb(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?xf(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?CJ(this.workgroupSize,this.transposeA):bf(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IJ(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${Ie()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class $J{constructor(e,t=!1,s=!1,r=null,i=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=r!=null,u=o!=null;a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=s,this.addBias=a,this.activation=i,this.hasPreluActivationWeights=u,this.shaderKey=`matMulReduce_${this.activation}_${t}_${s}`}getUserCode(){return`
      ${ei(this.activation,this.hasPreluActivationWeights)}
      ${vb(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${IJ(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kJ(n){const e=n[1],t=n[0],s=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Ie()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class TJ{constructor(e,t,s,r=!1,i=!1,o=null,a=null,u=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const l=o!=null;l&&this.variableNames.push("bias");const h=u!=null;h&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=l,this.activation=a,this.hasPreluActivationWeights=h,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${i}`}getUserCode(){return`
      ${ei(this.activation,this.hasPreluActivationWeights)}
      ${vb(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${kJ(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EJ{constructor(e,t,s=!1,r=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,L(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const i=(s&&this.outputShape[1]%4===0||!s&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=i?4:1,i||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=$e(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=r,this.shaderKey=`matMulSplitK_${s}_${r}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${uk(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${nt(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Ai("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?xf(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):bf(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class RJ{constructor(e,t=null,s=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=r!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${ei(this.activation,this.hasPreluActivationWeights)}
    ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${zo(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NJ{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Ie("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yn(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||So(r),i==="string"){const o=Wt(i,Q(s));return o.fill(r),e.makeTensorInfo(s,i,o)}else{const o=new NJ(s),a=[{type:"float32",data:[r]}];return e.runWebGPUProgram(o,[],i,a)}}const _J={kernelName:ep,backendName:"webgpu",kernelFunc:Yn};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oe(n){const{inputs:e,attrs:t}=n,{x:s}=e,{shape:r}=t,i=Q(s.shape),o=vg(r,i),a=Q(o);return L(i===a,()=>`The new shape (${o}) has ${a} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(s.dataId),{dataId:s.dataId,shape:o,dtype:s.dtype}}const DJ={kernelName:Sc,backendName:"webgpu",kernelFunc:Oe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yf({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:u=null}){const l=n.shape.length,h=e.shape.length,c=t?n.shape[l-2]:n.shape[l-1],d=s?e.shape[h-1]:e.shape[h-2],p=t?n.shape[l-1]:n.shape[l-2],f=s?e.shape[h-2]:e.shape[h-1],g=n.shape.slice(0,-2),m=e.shape.slice(0,-2),b=Q(g),x=Q(m),w=Ke(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);L(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const S=t?[b,c,p]:[b,p,c],k=s?[x,f,d]:[x,d,f],E=Oe({inputs:{x:n},backend:r,attrs:{shape:S}}),I=Oe({inputs:{x:e},backend:r,attrs:{shape:k}}),C=[E,I],T=Math.max(b,x),R=[E,I],P=[{type:"int32",data:[p]},{type:"int32",data:[f]},{type:"int32",data:[c]}];let D,F;const z=[T,p,f];let _=ne().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(_<0){const N=ne().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),O=N>0?N:r.thresholdToIncreaseWorkgroups,K=T*Math.ceil(p/32)*Math.ceil(f/32);K<=O||p<=8&&K<=O*2?T*p*f<=128?_=ir.MatMulReduceProgram:T===1&&d>=2e3?_=ir.MatMulSplitKProgram:_=ir.MatMulSmallOutputSizeProgram:_=ir.MatMulPackedProgram}switch(_){case ir.MatMulReduceProgram:D=new $J(z,t,s,i,u,o);break;case ir.MatMulSplitKProgram:{if(F=Yn({backend:r,attrs:{shape:z,value:0,dtype:n.dtype}}),D=new EJ(z,d,t,s),i||u){F=r.runWebGPUProgram(D,R,n.dtype,P,F);const O=new RJ(F.shape,i,u,o);let K=null;const U=[F];i&&U.push(i),o&&U.push(o),u==="leakyrelu"&&(K=[{type:"float32",data:[a]}],O.uniforms+=" alpha : f32,");const X=r.runWebGPUProgram(O,U,F.dtype,K);C.push(F);const te=Oe({inputs:{x:X},backend:r,attrs:{shape:w}});C.push(X);for(const ie of C)r.disposeData(ie.dataId);return te}break}case ir.MatMulSmallOutputSizeProgram:D=new TJ(S,k,z,t,s,i,u,o);break;case ir.MatMulPackedProgram:const N=r.adapterInfo.isIntel();D=new SJ(S,z,t,s,i,u,o,N);break;default:throw new Error(`Unsupported MatMulProgramType ${_}.`)}i&&R.push(i),o&&R.push(o),u==="leakyrelu"&&(P.push({type:"float32",data:[a]}),D.uniforms+=" alpha : f32,"),F=r.runWebGPUProgram(D,R,n.dtype,P,F);const B=Oe({inputs:{x:F},backend:r,attrs:{shape:w}});C.push(F);for(const N of C)r.disposeData(N.dataId);return B}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AJ(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:h,leakyreluAlpha:c}=s;return yf({a:r,b:i,transposeA:u,transposeB:l,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:c,activation:h})}const FJ={kernelName:ml,backendName:"webgpu",kernelFunc:AJ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m1{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=Ke(t,s),this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${wb(this.op,!1)}
      }

      ${Ie("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wd{constructor(e,t,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=Ke(t,s),this.dispatchLayout=_e(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&s.length>1&&t[0]<128,this.useSharedMemoryWithB=s.length<=1&&t.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const r=t.length>0&&t[t.length-1]%4===0,i=s.length>0&&s[s.length-1]%4===0;r&&i?(this.outputComponent=4,this.variableComponents=[4,4]):r&&(Sy(s)||s[s.length-1]===1)||i&&(Sy(t)||t[t.length-1]===1)?(this.outputComponent=4,this.variableComponents=r?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${wb(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const r=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${r}];`:`let a = sharedBuf[${r}];
          let b = getBByOutputIndex(index);`;e=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Ie("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${i}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${s}
       ${Ie("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ls(n){const{inputs:e}=n,{x:t}=e;return n.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const PJ={kernelName:Ka,backendName:"webgpu",kernelFunc:ls};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bo(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),o=t.tensorMap.get(i.dataId),a=ls({inputs:{x:s},backend:t}),u=ls({inputs:{x:r},backend:t});return o.complexTensorInfos={real:a,imag:u},i}const LJ={kernelName:Vd,backendName:"webgpu",kernelFunc:Bo};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pu{constructor(e,t,s=""){this.variableNames=["A"],this.size=!0;const r=128;this.workgroupSize=[r,1,1],this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Wi(this.op,!1)}
      }
      ${Ie("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bt({opType:n,cpuKernelImpl:e,dtype:t}){return({inputs:s,backend:r})=>{const{x:i}=s,o=r,a=t||i.dtype;if(o.shouldExecuteOnCPU([i])&&e!=null){const l=o.tensorMap.get(i.dataId),h=e(l.values,a);return o.makeTensorInfo(i.shape,a,h)}const u=new Pu(i.shape,n);return o.runWebGPUProgram(u,[i],a)}}function xn({opType:n,cpuKernelImpl:e,supportsComplex:t=!1,dtype:s}){return({inputs:r,backend:i})=>{const{a:o,b:a}=r,u=i;if(t&&o.dtype==="complex64"){const c=u.tensorMap.get(o.dataId),d=u.tensorMap.get(a.dataId);let p,f;if(n!==qe.MUL)[p,f]=[[c.complexTensorInfos.real,d.complexTensorInfos.real],[c.complexTensorInfos.imag,d.complexTensorInfos.imag]].map(m=>{const[b,x]=m,v={dataId:b.dataId,dtype:b.dtype,shape:o.shape},w={dataId:x.dataId,dtype:x.dtype,shape:a.shape},S=new wd(n,o.shape,a.shape);return u.runWebGPUProgram(S,[v,w],mn(b.dtype,x.dtype))});else{const m=new m1(qe.COMPLEX_MULTIPLY_REAL,o.shape,a.shape),b=new m1(qe.COMPLEX_MULTIPLY_IMAG,o.shape,a.shape),x=[{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:o.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:a.shape},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:a.shape}];p=u.runWebGPUProgram(m,x,"float32"),f=u.runWebGPUProgram(b,x,"float32")}const g=Bo({inputs:{real:p,imag:f},backend:u});return u.disposeData(p.dataId),u.disposeData(f.dataId),g}const l=s||mn(o.dtype,a.dtype);if((o.dtype==="string"||a.dtype==="string"||u.shouldExecuteOnCPU([o,a]))&&e!=null){const c=u.tensorMap.get(o.dataId).values,d=u.tensorMap.get(a.dataId).values,p=o.dtype==="string"?Ys(c):c,f=o.dtype==="string"?Ys(d):d,[g,m]=e(o.shape,a.shape,p,f,l);return u.makeTensorInfo(m,l,g)}const h=new wd(n,o.shape,a.shape);return u.runWebGPUProgram(h,[o,a],l)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:OJ,castImpl:MJ,ceilImpl:zJ,concatImpl:BJ,equalImpl:VJ,expImpl:UJ,expm1Impl:GJ,floorImpl:WJ,floorDivImpl:HJ,gatherNdImpl:KJ,gatherV2Impl:jJ,greaterEqualImpl:XJ,greaterImpl:qJ,lessEqualImpl:YJ,lessImpl:ZJ,logImpl:QJ,maxImpl:JJ,maximumImpl:eee,minimumImpl:tee,multiplyImpl:nee,negImpl:see,notEqualImpl:ree,prodImpl:iee,rangeImpl:oee,rsqrtImpl:aee,scatterImpl:uee,simpleAbsImpl:lee,sliceImpl:cee,stridedSliceImpl:hee,stringNGramsImpl:dee,subImpl:pee,tileImpl:fee,topKImpl:mee,transposeImpl:gee}=qI;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xee=bt({opType:ve.ABS,cpuKernelImpl:lee}),bee={kernelName:Ll,backendName:"webgpu",kernelFunc:xee};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yee=bt({opType:ve.ACOS}),wee={kernelName:ka,backendName:"webgpu",kernelFunc:yee};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vee=bt({opType:ve.ACOSH}),Cee={kernelName:Ta,backendName:"webgpu",kernelFunc:vee};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const See=xn({opType:qe.ADD,cpuKernelImpl:OJ,supportsComplex:!0}),Iee={kernelName:Io,backendName:"webgpu",kernelFunc:See};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $ee{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(r=>{e.push(`let v${r} = get${r}ByOutputCoords(coords);`)});const t=this.variableNames.map(r=>`v${r}`).join(" + ");return`
      ${Ie("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kee(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return ls({inputs:{x:s[0]},backend:t});const r=s.map(a=>a.dtype).reduce((a,u)=>mn(a,u)),i=s.map(a=>a.shape),o=new $ee(i);return t.runWebGPUProgram(o,s,r)}const Tee={kernelName:Pd,backendName:"webgpu",kernelFunc:kee};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eee{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[t[r]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){L(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${Ie()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ree{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[t[r]];this.outputShape=s,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=Kt(this.outputShape.length),t=lk(this.newDim);return`
      ${Ie("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}}function lk(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=new Array(e);for(let s=0;s<n.length;s++)t[n[s]]=`coords.${Wr(s)}`;return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rr(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,o=t,a=r.shape.length,u=new Array(a);for(let h=0;h<u.length;h++)u[h]=r.shape[i[h]];if(t.shouldExecuteOnCPU([r])){const c=o.tensorMap.get(r.dataId).values,d=gee(c,r.shape,r.dtype,i,u);return t.makeTensorInfo(u,r.dtype,d)}if(r.shape.length===2&&ct(i,[1,0])){const h=new Eee(r.shape,i);return o.runWebGPUProgram(h,[r],r.dtype)}const l=new Ree(r.shape,i);return o.runWebGPUProgram(l,[r],r.dtype)}const Nee={kernelName:to,backendName:"webgpu",kernelFunc:Rr};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ee{constructor(e,t,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[r]=Yt(this.inputShape,[1]);this.outputShape=r.length===0?[1]:r,e.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const r=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Ie("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${r}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dee={mean:"float32",all:"bool",any:"bool"};function Vo(n,e,t,s,r){const i=n.shape.length,o=[],a=Qe(e,n.shape);let u=a;const l=kt(u,i);let h=n;l!=null&&(h=Rr({inputs:{x:n},attrs:{perm:l},backend:r}),u=_t(u.length,i),o.push(h)),tn(s,u,i);const[c,d]=Yt(h.shape,u);let p=c;t&&(p=qt(c,a));let f;if((s==="max"||s==="prod")&&r.shouldExecuteOnCPU([h])){const g=r.tensorMap.get(h.dataId).values;switch(s){case"max":const m=JJ(g,Q(d),p,n.dtype);f=r.makeTensorInfo(p,n.dtype,m);break;case"prod":const{outVals:b,outShape:x,outDtype:v}=iee(h.shape,h.dtype,g,u);f=r.makeTensorInfo(x,v,b);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const g=Q(d),b=Q(h.shape)/g,x={windowSize:g,inSize:g,batchSize:b,outSize:1},v=Dee[s]||yp(n.dtype),w=[{type:"int32",data:[g]}],S=new _ee(x,s,r.device.limits.maxComputeWorkgroupSizeX),k=r.runWebGPUProgram(S,[h],v,w);o.push(k),f=Oe({inputs:{x:k},attrs:{shape:p},backend:r})}return o.forEach(g=>r.disposeData(g.dataId)),f}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{keepDims:i,axis:o}=s;return Vo(r,o,i,"all",t)}const Fee={kernelName:Ld,backendName:"webgpu",kernelFunc:Aee};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{keepDims:i,axis:o}=s;return Vo(r,o,i,"any",t)}const Lee={kernelName:Od,backendName:"webgpu",kernelFunc:Pee};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ck{constructor(e,t,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[t];this.op=s==="min"?"<":">";const[i,o]=Yt(e,r);this.outputShape=i.length===0?[1]:i,this.dispatchLayout=_e(this.outputShape),Q(o)<32?(this.type="plain",this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=$e(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Wr(this.inputShape.length-1)}`,s=()=>{let r="";if(this.outputShape.length===1)this.inputShape.length!==1&&(r+="outputCoords,");else for(let i=0;i<this.outputShape.length;i++)r+=`outputCoords.${Wr(i)},`;return r};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${Ie("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=Qe(i,r.shape);const a=kt(o,r.shape.length);let u=r;const l=[];a!=null&&(u=Rr({inputs:{x:r},backend:t,attrs:{perm:a}}),l.push(u),o=_t(o.length,u.shape.length)),tn("argMax",[o[0]],u.shape.length);const h=new ck(u.shape,o[0],"max"),c=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],d=t.runWebGPUProgram(h,[u],"int32",c);return l.forEach(p=>t.disposeData(p.dataId)),d}const Mee={kernelName:Ol,backendName:"webgpu",kernelFunc:Oee};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=Qe(i,r.shape);const a=kt(o,r.shape.length);let u=r;const l=[];a!=null&&(u=Rr({inputs:{x:r},backend:t,attrs:{perm:a}}),l.push(u),o=_t(o.length,u.shape.length)),tn("argMin",[o[0]],u.shape.length);const h=new ck(u.shape,o[0],"min"),c=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],d=t.runWebGPUProgram(h,[u],"int32",c);return l.forEach(p=>t.disposeData(p.dataId)),d}const Bee={kernelName:Ml,backendName:"webgpu",kernelFunc:zee};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vee=bt({opType:ve.ASIN}),Uee={kernelName:Ea,backendName:"webgpu",kernelFunc:Vee};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gee=bt({opType:ve.ASINH}),Wee={kernelName:Ra,backendName:"webgpu",kernelFunc:Gee};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hee=bt({opType:ve.ATAN}),Kee={kernelName:Na,backendName:"webgpu",kernelFunc:Hee};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jee=xn({opType:qe.ATAN2}),Xee={kernelName:Da,backendName:"webgpu",kernelFunc:jee};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qee=bt({opType:ve.ATANH}),Yee={kernelName:_a,backendName:"webgpu",kernelFunc:qee};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zee{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nl{constructor(e,t,s=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool2D_${t}_${s}_${r}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}class Cb{constructor(e,t,s=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool3D_${t}_${s}_${r}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hk(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:o}=s;return Vo(r,i,o,"max",t)}const Qee={kernelName:lc,backendName:"webgpu",kernelFunc:hk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dk(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{keepDims:i,axis:o}=s;return Vo(r,o,i,"mean",t)}const Jee={kernelName:dc,backendName:"webgpu",kernelFunc:dk};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pk(n,e,t,s){if(e.filterWidth===1&&e.filterHeight===1&&ct(e.inShape,e.outShape))return ls({inputs:{x:n},backend:s});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const o=n.shape.length,a=Oe({inputs:{x:n},backend:s,attrs:{shape:[n.shape[o-3]*n.shape[o-2],n.shape[o-1]]}});let u;t==="avg"?u=dk({inputs:{x:a},backend:s,attrs:{axis:0,keepDims:!1}}):(L(t==="max",()=>`Invalid pool type ${t}`),u=hk({inputs:{x:a},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const l=Oe({inputs:{x:u},backend:s,attrs:{shape:e.outShape}});return s.disposeData(a.dataId),s.disposeData(u.dataId),l}let r;const i=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?r=new Zee(e):(t==="avg"?r=new Nl(e,"avg"):(L(t==="max",()=>`Invalid pool type ${t}`),r=new Nl(e,"max")),i.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),s.runWebGPUProgram(r,[n],n.dtype,i)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ete(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:u}=s,h=kn(r.shape,i,o,1,a,u);return pk(r,h,"avg",t)}const tte={kernelName:zl,backendName:"webgpu",kernelFunc:ete};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dataFormat:u,dimRoundingMode:l}=s,h=[1,1,1],c=bs(r.shape,i,o,h,a,l,u),d=new Cb(c,"avg"),p=[{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.inDepth,c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth]}];return t.runWebGPUProgram(d,[r],r.dtype,p)}const ste={kernelName:Bl,backendName:"webgpu",kernelFunc:nte};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rte{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class ite{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ote(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:a,strides:u,pad:l,dimRoundingMode:h}=s,c=bs(o.shape,a,u,1,l,h),d=new ite(c),p=1/(c.filterDepth*c.filterHeight*c.filterWidth),f=[{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterDepth-1-c.padInfo.front,c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"float32",data:[p]}];return t.runWebGPUProgram(d,[r],o.dtype,f)}const ate={kernelName:zd,backendName:"webgpu",kernelFunc:ote};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ute(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i;ak([r,i],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=s,h=kn(o.shape,a,u,1,l),c=new rte(h),d=1/(h.filterHeight*h.filterWidth),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[d]}];return t.runWebGPUProgram(c,[r],o.dtype,p)}const lte={kernelName:Md,backendName:"webgpu",kernelFunc:ute};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cte(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;return yf({a:r,b:i,transposeA:o,transposeB:a,backend:t})}const hte={kernelName:Vl,backendName:"webgpu",kernelFunc:cte};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dte{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Kt(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Kt(this.rank),t=pte(this.rank);let s;return this.start.length===1?s=this.outputShape.map((i,o)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((i,o)=>`sourceLoc.${Xm[o]} = uniforms.start.${Wr(o)} + coords.${Xm[o]};`),`
      ${Ie("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}}const Xm=["x","y","z","w","u","v"];function pte(n){if(n===1)return"sourceLoc";if(n<=6)return Xm.slice(0,n).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lu(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:o}=s,[a,u]=Bc(r,i,o);if(_p(r,a,u),t.shouldExecuteOnCPU([r])||r.dtype==="string"){const c=t.tensorMap.get(r.dataId),d=cee(c.values,a,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,d)}if(Q(u)===0)return t.makeTensorInfo(u,r.dtype,[]);const l=new dte(a,u),h=[{type:"int32",data:a}];return t.runWebGPUProgram(l,[r],r.dtype,h)}const fte={kernelName:Ec,backendName:"webgpu",kernelFunc:Lu};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mte=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:o}=s;L(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=i.reduce((x,v)=>x*v),u=No(r.shape,i,a),l=_o(u.length,i.length),h=Do(r.shape,i,a),c=Op(o,i.length),d=Mp(h,o,i.length),p=[],f=Oe({inputs:{x:r},backend:t,attrs:{shape:u}}),g=Rr({inputs:{x:f},backend:t,attrs:{perm:l}}),m=Oe({inputs:{x:g},backend:t,attrs:{shape:h}}),b=Lu({inputs:{x:m},backend:t,attrs:{begin:c,size:d}});return p.push(f),p.push(g),p.push(m),p.forEach(x=>t.disposeData(x.dataId)),b},gte={kernelName:Ul,backendName:"webgpu",kernelFunc:mte};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xte=`
  fn bincount_write(index: i32, value: f32) {
    ${Ai("&result[index]","value","float32")}
  }
`,bte=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class fk{constructor(e,t,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?bte:xte}
  ${Ie("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o}=s,a=Q(r.shape),l=Q(i.shape)>0,h=[o],c=i.dtype,d=Yn({backend:t,attrs:{shape:h,value:0,dtype:c}}),p=new fk([a],l),f=[{type:"int32",data:[o]}],g=l?[r,i]:[r];return t.runWebGPUProgram(p,g,c,f,d)}const wte={kernelName:Bd,backendName:"webgpu",kernelFunc:yte};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vte{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${Ie("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cte(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e;if(t.shouldExecuteOnCPU([s,r])){const h=t.tensorMap.get(s.dataId),c=t.tensorMap.get(r.dataId),d=h.values,p=c.values,f=Ke(Array.from(d),Array.from(p));return t.makeTensorInfo([f.length],"int32",Int32Array.from(f))}const i=Q(s.shape),o=Q(r.shape),a=Math.max(i,o),u=new vte(a),l=[{type:"int32",data:[i]},{type:"int32",data:[o]}];return t.runWebGPUProgram(u,[s,r],"int32",l)}const Ste={kernelName:Tg,backendName:"webgpu",kernelFunc:Cte};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mk=xn({opType:qe.NOT_EQUAL,dtype:"bool",cpuKernelImpl:ree}),Ite={kernelName:gc,backendName:"webgpu",kernelFunc:mk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sh(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.tensorMap.get(s.dataId);return ls({inputs:{x:r.complexTensorInfos.real},backend:t})}const $te={kernelName:cp,backendName:"webgpu",kernelFunc:sh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kte(n,e){const t=new Pu(n.shape,ve.TO_INT),s=e.runWebGPUProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qm(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return ls({inputs:{x:r},backend:t});const o=rn(r.shape),a=qm({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),u=Bo({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeData(a.dataId),u}if(r.dtype==="complex64"){const o=sh({inputs:{input:r},backend:t}),a=qm({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeData(o.dataId),a}if(!Cg(r.dtype,i)){const o=ls({inputs:{x:r},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const o=t.tensorMap.get(r.dataId).values,[a,u,l]=MJ(o,r.shape,r.dtype,i);return t.makeTensorInfo(a,u,l)}if(i==="int32")return kte(r,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",fn("bool",1)),u=mk({inputs:{a:r,b:o},backend:t});return t.disposeData(o.dataId),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const Tte={kernelName:Aa,backendName:"webgpu",kernelFunc:qm};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ete=bt({opType:ve.CEIL,cpuKernelImpl:zJ}),Rte={kernelName:Fa,backendName:"webgpu",kernelFunc:Ete};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nte{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Ie("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _te{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Ie("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:o}=s;let a;const u=[{type:"float32",data:[i]},{type:"float32",data:[o]}];return Q(r.shape)%4===0?a=new Nte(r.shape):a=new _te(r.shape),t.runWebGPUProgram(a,[r],r.dtype,u)}const Ate={kernelName:Pa,backendName:"webgpu",kernelFunc:Dte};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fte{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${Ie("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g1(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function Pte(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.tensorMap.get(s.dataId),i=new Fte(s.shape),o=[g1(s,r.complexTensorInfos.real),g1(s,r.complexTensorInfos.imag)];return t.runWebGPUProgram(i,o,o[0].dtype)}const Lte={kernelName:Gl,backendName:"webgpu",kernelFunc:Pte};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ote{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=qn(e,1),this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let i=1;i<this.offsetLength;i++)e.push(`else if (yC < uniforms.offset${[i]}){ setOutputAtCoords(coords.x, coords.y, getT${i}(yR, yC - uniforms.offset${i-1})); }`);const s=this.offsetLength,r=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${r})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${Ie("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wf(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.tensorMap.get(s.dataId);return ls({inputs:{x:r.complexTensorInfos.imag},backend:t})}const Mte={kernelName:sp,backendName:"webgpu",kernelFunc:wf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yu(n,e,t){const s=n[0].dtype;if(s==="complex64"){const f=n.map(v=>sh({inputs:{input:v},backend:t})),g=n.map(v=>wf({inputs:{input:v},backend:t})),m=Yu(f,e,t),b=Yu(g,e,t),x=Bo({inputs:{real:m,imag:b},backend:t});return f.forEach(v=>t.disposeData(v.dataId)),g.forEach(v=>t.disposeData(v.dataId)),t.disposeData(m.dataId),t.disposeData(b.dataId),x}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const f=n.map(S=>{const E=[-1,Q(S.shape.slice(e))];return Oe({inputs:{x:S},backend:t,attrs:{shape:E}})}),g=f.map(S=>({vals:t.readSync(S.dataId),shape:S.shape})),m=qn(f.map(S=>S.shape),1),b=f[0].shape[0]===1,x=BJ(g,m,s,b),v=qn(n.map(S=>S.shape),e),w=t.makeTensorInfo(v,s,x);return f.forEach(S=>t.disposeData(S.dataId)),w}const i=t.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>i){const f=[];for(let m=0;m<n.length;m+=i){const b=n.slice(m,m+i);f.push(Yu(b,e,t))}const g=Yu(f,e,t);for(const m of f)t.disposeData(m.dataId);return g}const{tensors2D:o,outShape:a}=zte(n,e,t),u=o.map(f=>f.shape),l=new Ote(u),h=[],c=new Array(u.length-1);if(c.length>0){c[0]=u[0][1],h.push({type:"int32",data:[c[0]]});for(let f=1;f<c.length;f++)c[f]=c[f-1]+u[f][1],h.push({type:"int32",data:[c[f]]})}const d=t.runWebGPUProgram(l,o,o[0].dtype,h);o.forEach(f=>t.disposeData(f.dataId));const p=Oe({inputs:{x:d},backend:t,attrs:{shape:a}});return t.disposeData(d.dataId),p}function zte(n,e,t){const s=qn(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>Oe({inputs:{x:i},backend:t,attrs:{shape:[Q(i.shape.slice(0,e)),Q(i.shape.slice(e))]}})),outShape:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gk(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=Qe(r,e[0].shape)[0],o=e.map(l=>l.shape);Fp(o,i);const a=qn(e.map(l=>l.shape),i);if(Q(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const u=e.filter(l=>Q(l.shape)>0);return u.length===1?ls({inputs:{x:u[0]},backend:t}):Yu(u,i,t)}const Bte={kernelName:Wl,backendName:"webgpu",kernelFunc:gk};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vte(n,e,t,s,r=!1,i=null,o=!1,a=4,u=4,l=4){const h=C=>{switch(C){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${C} is not supported.`)}},c=C=>{switch(C){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${C} is not supported.`)}},d=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,p=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,f=n?"uniforms.xShape[1]":"uniforms.xShape[2]",g=n?"uniforms.xShape[2]":"uniforms.xShape[3]",m=n?"row":"col",b=n?"col":"row",x=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${m} / outWidth;
      let outCol = ${m} % outWidth;

      let WRow = ${b} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${b} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${b} % inChannels;
      var resData = ${nt(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${g}) {
        ${d}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${h(a)}
      }
      return resData;`,v=n?e&&s?`
      ${x}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${x}
      }
      return ${nt(a)}(0.0);`:s&&t?`
      ${x}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${x}
      }
      return ${nt(a)}(0.0);`,w=`${c(u)}`,S=nt(l),k=nt(n?a:u),E=nt(n?u:a);return`
      ${ei(i,o,l===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${k} {
        ${n?v:w}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${E} {
        ${n?w:v}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${S}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${p}
        ${zo(r,i)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class Ute{constructor(e,t,s,r,i=!1,o=null,a=!1,u=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=rk(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=ik(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),i&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=u,this.addBias=i,this.activation=o,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=r%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?xf(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):bf(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${Vte(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gte{constructor(e,t=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=s,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${ei(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${zo(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${Ie("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wte{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${Ie("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${r};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${i};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vd(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function Hte({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const u=t.dataFormat==="channelsLast",l=!u,h=!1,c=u&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",d=[];let p,f;if(c){const b=t.inHeight*t.inWidth*t.inChannels;p=Oe({inputs:{x:n},backend:s,attrs:{shape:[1,t.batchSize,b]}}),f=Oe({inputs:{x:e},backend:s,attrs:{shape:[1,b,t.outChannels]}})}else p=Oe({inputs:{x:n},backend:s,attrs:{shape:u?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),f=Oe({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(d.push(p),d.push(f),i!=null){const b=vd(i.shape,u);b!=null&&(i=Oe({inputs:{x:i},backend:s,attrs:{shape:b}}),d.push(i))}if(r!=null){const b=vd(r.shape,u);b!=null&&(r=Oe({inputs:{x:r},backend:s,attrs:{shape:b}}),d.push(r))}const g=yf({a:u?p:f,b:u?f:p,transposeA:l,transposeB:h,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),m=Oe({inputs:{x:g},backend:s,attrs:{shape:t.outShape}});d.push(g);for(const b of d)s.disposeData(b.dataId);return m}function Kte({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:h,strideWidth:c,strideHeight:d,padInfo:p,outWidth:f,outHeight:g,dilationWidth:m,dilationHeight:b,dataFormat:x}=t,v=x==="channelsLast",w=u*l*h,S=g*f,k=v?[t.batchSize,S,w]:[t.batchSize,w,S],E=new Wte(k,v),I=[{type:"int32",data:[p.top,p.left]},{type:"int32",data:[d,c]},{type:"int32",data:[b,m]},{type:"int32",data:[f]},{type:"int32",data:[h*u]},{type:"int32",data:[h]}],C=s.runWebGPUProgram(E,[n],n.dtype,I),T=[];T.push(C);const R=Oe({inputs:{x:e},backend:s,attrs:{shape:[1,w,-1]}});if(T.push(R),i!=null){const _=vd(i.shape,v);_!=null&&(i=Oe({inputs:{x:i},backend:s,attrs:{shape:_}}),T.push(i))}if(r!=null){const _=vd(r.shape,v);_!=null&&(r=Oe({inputs:{x:r},backend:s,attrs:{shape:_}}),T.push(r))}const F=yf({a:v?C:R,b:v?R:C,transposeA:!v,transposeB:!1,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),z=Oe({inputs:{x:F},backend:s,attrs:{shape:t.outShape}});T.push(F);for(const _ of T)s.disposeData(_.dataId);return z}function xk({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const u=r!=null,l=i!=null,h=t.dataFormat==="channelsLast",c=h&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",d=ne().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!d&&(c||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return Hte({x:n,filter:e,convInfo:t,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o});const p=ne().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),f=p>-1?p:s.thresholdToIncreaseWorkgroups,g=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if(ne().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=f)return Kte({x:n,filter:e,convInfo:t,backend:s,bias:r,preluActivationWeights:i,leakyreluAlpha:o,activation:a});let m;const b=[t.padInfo.top,t.padInfo.left],x=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...b]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(d)m=new Gte(t,u,a,l);else{const k=h?t.outHeight*t.outWidth:t.outChannels,E=h?t.outChannels:t.outHeight*t.outWidth,I=t.filterHeight*t.filterWidth*t.inChannels;x.push({type:"int32",data:[k]},{type:"int32",data:[E]},{type:"int32",data:[I]});const C=s.adapterInfo.isIntel();m=new Ute(t,k,E,I,u,a,l,C)}const v=[],w=[n,e];u&&(!h&&r.shape.length===1&&(r=Oe({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),v.push(r)),w.push(r)),l&&(!h&&i.shape.length===1&&(i=Oe({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),v.push(i)),w.push(i)),a==="leakyrelu"&&(x.push({type:"float32",data:[o]}),m.uniforms+=" alpha : f32,");const S=s.runWebGPUProgram(m,w,n.dtype,x);for(const k of v)s.disposeData(k.dataId);return S}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jte(n){const{inputs:e,attrs:t,backend:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:u,dilations:l,dimRoundingMode:h}=t,c=hs(u),d=Ot(r.shape,i.shape,o,l,a,h,!1,c);return xk({x:r,filter:i,convInfo:d,backend:s})}const Xte={kernelName:Hl,backendName:"webgpu",kernelFunc:jte};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qte{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,r=`
    ${Ie()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${r}
    `:`
    ${Ie("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class Yte{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${Ie("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class Zte{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${Ie("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class Qte{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${Ie("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:h}=s,c=hs(u),d=Ot(r.shape,h,o,1,a,l,!1,c),p=new Yte(d),f=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return t.runWebGPUProgram(p,[r,i],r.dtype,f)}const ene={kernelName:Ud,backendName:"webgpu",kernelFunc:Jte};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tne(n=4){const e=i=>{switch(i){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${i} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${nt(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${nt(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${nt(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${nt(n)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${nt(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${nt(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${nt(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class nne{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,L(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=rk(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=ik(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?xf(this.elementsPerThread,this.workgroupSize):bf(this.elementsPerThread,this.workgroupSize);return`
    ${tne(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sne(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:u,dataFormat:l,dimRoundingMode:h}=s,c=hs(l),d=Ot(o,i.shape,a,1,u,h,!1,c),p=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize,d.outHeight,d.outWidth,d.outChannels]}];let f;if(ne().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||d.dataFormat!=="channelsLast")f=new qte(d);else{f=new nne(d);const g=d.inHeight*d.inWidth,m=d.inChannels,b=d.filterHeight*d.filterWidth*d.outChannels;p.push({type:"uint32",data:[g]},{type:"uint32",data:[m]},{type:"uint32",data:[b]})}return t.runWebGPUProgram(f,[r,i],"float32",p)}const rne={kernelName:Kl,backendName:"webgpu",kernelFunc:sne};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ine{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function one(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:u}=s,l=tr(r.shape,i.shape,o,u,a),h=[l.padInfo.front,l.padInfo.top,l.padInfo.left],c=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[...h]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationDepth,l.dilationHeight,l.dilationWidth]}],d=new ine(l),p=mn(r.dtype,i.dtype);return t.runWebGPUProgram(d,[r,i],p,c)}const ane={kernelName:jl,backendName:"webgpu",kernelFunc:one};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function une(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:u}=s,l=tr(r.shape,u,o,1,a),h=new Zte(l),c=[{type:"int32",data:[l.padInfo.front,l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inDepth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]}];return t.runWebGPUProgram(h,[r,i],i.dtype,c)}const lne={kernelName:Gd,backendName:"webgpu",kernelFunc:une};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cne(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,pad:a,inputShape:u}=s,l=tr(u,i.shape,o,1,a),h=new Qte(l),c=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[l.filterDepth-1-l.padInfo.front,l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels]}];return t.runWebGPUProgram(h,[r,i],r.dtype,c)}const hne={kernelName:Wd,backendName:"webgpu",kernelFunc:cne};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dne=bt({opType:ve.COS}),pne={kernelName:La,backendName:"webgpu",kernelFunc:dne};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fne=bt({opType:ve.COSH}),mne={kernelName:Oa,backendName:"webgpu",kernelFunc:fne};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gne{constructor(e,t,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=t;this.outputShape=[i,s[0],s[1],e],this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=r==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,r,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[o,a,u]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${o});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${r};
        let width_scale = ${a};
        let in_y = ${i};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xne=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:u,extrapolationValue:l}=s,h=new gne(r.shape[3],i.shape,a,u),c=[{type:"float32",data:[l]}];return t.runWebGPUProgram(h,[r,i,o],"float32",c)},bne={kernelName:Kd,backendName:"webgpu",kernelFunc:xne};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var _l;(function(n){n.Prod="*",n.Sum="+"})(_l||(_l={}));class x1{constructor(e,t,s,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===_l.Prod?"1.0":"0.0",s=this.exclusive?t:`getX(${b1(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let i="",o="";return this.exclusive?(i=this.reverse?`end != ${r-1}`:"end != 0",o=this.reverse?"end + 1":"end - 1"):(i=this.reverse?`end + pow2 < ${r}`:"end >= pow2",o=this.reverse?"end + pow2":"end - pow2"),`
      ${Ie("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${y1(e,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${i}) {
           let idx = ${o};
           ${y1(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${b1(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function b1(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function y1(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bk(n,e,t,s,r,i){const o=e.shape.length,a=kt([s],o);let u=e;a!=null&&(u=Rr({inputs:{x:e},backend:t,attrs:{perm:a}}));const l=_t(1,o)[0];if(l!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const h=u.shape[l];let c=ls({inputs:{x:u},backend:t});for(let d=0;d<=Math.ceil(Math.log2(h))-1;d++){const p=new x1(n,u.shape,!1,i),f=c,g=[{type:"float32",data:[d]}];c=t.runWebGPUProgram(p,[c],c.dtype,g),t.disposeData(f.dataId)}if(r){const d=new x1(n,u.shape,r,i),p=c,f=[{type:"float32",data:[0]}];c=t.runWebGPUProgram(d,[c],c.dtype,f),t.disposeData(p.dataId)}if(a!=null){const d=Nr(a),p=Rr({inputs:{x:c},backend:t,attrs:{perm:d}});return t.disposeData(c.dataId),t.disposeData(u.dataId),p}return c}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;return bk(_l.Prod,r,t,i,o,a)}const wne={kernelName:Hd,backendName:"webgpu",kernelFunc:yne};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;return bk(_l.Sum,r,t,i,o,a)}const Cne={kernelName:Xl,backendName:"webgpu",kernelFunc:vne};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s,u=r.shape.length===1,h=Q(i.shape)>0,c=i.dtype,d=u?[r.shape[0]]:[r.shape[0],r.shape[1]],p=u?[o]:[r.shape[0],o],f=Yn({backend:t,attrs:{shape:p,value:0,dtype:c}}),g=new fk(d,h,a),m=[{type:"int32",data:[o]}],b=h?[r,i]:[r];return t.runWebGPUProgram(g,b,c,m,f)}const Ine={kernelName:jd,backendName:"webgpu",kernelFunc:Sne};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $ne{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:o}=s,a=r.shape[0],u=o==="NHWC"?r.shape[1]:r.shape[2],l=o==="NHWC"?r.shape[2]:r.shape[3],h=o==="NHWC"?r.shape[3]:r.shape[1],c=u*i,d=l*i,p=h/(i*i),f=o==="NHWC"?[a,c,d,p]:[a,p,c,d],g=[{type:"int32",data:[i]}],m=new $ne(f,o);return t.runWebGPUProgram(m,[r],r.dtype,g)}const Tne={kernelName:Xd,backendName:"webgpu",kernelFunc:kne};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ene{constructor(e,t,s,r=!1,i=null,o=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=i,this.hasPreluActivation=o,this.filterHeight=t,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`
      ${ei(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Ie()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${zo(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yk{constructor(e,t=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const i=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=_e(i),this.dispatch=$e(this.dispatchLayout,i,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),L(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${ei(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${Ie("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${zo(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wk{constructor(e,t=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${ei(this.activation,this.hasPreluActivation,!1,4)}

      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${zo(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:u,dilations:l,dimRoundingMode:h}=s,c=hs(u);let d=l;d==null&&(d=[1,1]);const p=Ot(r.shape,i.shape,o,d,a,h,!0,c),f=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}],g=p.dataFormat==="channelsLast";let m;return!g&&p.inHeight>16&&p.inWidth>16&&p.strideHeight===1&&p.strideWidth===1&&p.dilationWidth===1&&p.dilationHeight===1&&p.inChannels===p.outChannels?m=new Ene(p.outShape,p.filterHeight,p.filterWidth):g&&p.outHeight>4&&p.outWidth>4&&p.strideWidth<=2&&p.inChannels===p.outChannels&&p.dilationHeight===1&&p.dilationWidth===1&&p.inChannels%4===0?(m=new yk(p),f.push({type:"int32",data:[m.virtualWidth]})):(m=new wk(p),f.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),t.runWebGPUProgram(m,[r,i],r.dtype,f)}const Nne={kernelName:ql,backendName:"webgpu",kernelFunc:Rne};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ne{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class Dne{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ane(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,dilations:a,pad:u,dimRoundingMode:l,filterShape:h}=s,c=Ot(r.shape,h,o,a,u,l,!0),d=new _ne(c),p=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outChannels/c.inChannels]}];return t.runWebGPUProgram(d,[r,i],"float32",p)}const Fne={kernelName:qd,backendName:"webgpu",kernelFunc:Ane};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pne(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:u,dimRoundingMode:l,inputShape:h}=s,c=Ot(h,i.shape,o,a,u,l,!0),d=new Dne(c),p=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels/c.inChannels]}];return t.runWebGPUProgram(d,[r,i],r.dtype,p)}const Lne={kernelName:Yd,backendName:"webgpu",kernelFunc:Pne};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class One{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mne(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=Q(s.shape),o=Oe({inputs:{x:s},backend:t,attrs:{shape:[i]}}),a=new One(i),u=t.runWebGPUProgram(a,[o],o.dtype),l=Oe({inputs:{x:u},backend:t,attrs:{shape:r}});return t.disposeData(o.dataId),t.disposeData(u.dataId),l}const zne={kernelName:Eg,backendName:"webgpu",kernelFunc:Mne};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bne{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${Ie("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:u}=s,l=ki(r.shape,i.shape,o,a,"NHWC",u),h=[l.padInfo.top,l.padInfo.left],c=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...h]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],d=new Bne(l);return t.runWebGPUProgram(d,[r,i],r.dtype,c)}const Une={kernelName:Yl,backendName:"webgpu",kernelFunc:Vne};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gne{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=_e(e.outShape),this.dispatch=$e(this.dispatchLayout,e.outShape,this.workgroupSize),t!=="float32"&&t!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${Ie("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Ai("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class Wne{constructor(e,t,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=_e(e.outShape),this.dispatch=$e(this.dispatchLayout,e.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${Ie("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Ai("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,dy:o}=e,{strides:a,pad:u,dilations:l}=s,h=ki(r.shape,i.shape,a,u,"NHWC",l),c=i.dtype,d=new Wne(h,i.shape,c),p=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[Q(h.outShape)]}],f=Yn({backend:t,attrs:{shape:i.shape,value:0,dtype:c}});return t.runWebGPUProgram(d,[r,i,o],c,p,f)}const Kne={kernelName:jh,backendName:"webgpu",kernelFunc:Hne};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,dy:o}=e,{strides:a,pad:u,dilations:l}=s,h=ki(r.shape,i.shape,a,u,"NHWC",l),c=r.dtype,d=new Gne(h,c),p=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[Q(h.outShape)]}],f=Yn({backend:t,attrs:{shape:h.inShape,value:0,dtype:c}});return t.runWebGPUProgram(d,[r,i,o],c,p,f)}const Xne={kernelName:Kh,backendName:"webgpu",kernelFunc:jne};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qne{constructor(e,t,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=Sa.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=s,this.shaderKey=`draw_${t}_${s}`}getUserCode(){let e;const t=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${Ie("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yne(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:o}=s,[a,u]=r.shape.slice(0,2),{imageOptions:l}=o||{},h=(l==null?void 0:l.alpha)||1,c=t.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",d=[a,u],p=new qne(d,r.dtype,c);i.width=u,i.height=a;const f="webgpu";let g=i.getContext(f),m;g||(m=new OffscreenCanvas(u,a),g=m.getContext(f));const b=r.shape.length===3?r.shape[2]:1;g.configure({device:t.device,format:c,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const x="int32",v=t.makeTensorInfo(d,x),w=t.tensorMap.get(v.dataId);w.resource=g.getCurrentTexture(),w.external=!0;const S=[{type:"uint32",data:[b]},{type:"float32",data:[h]}];if(t.runWebGPUProgram(p,[r],x,S,v),m){const k=i.getContext("2d");if(!k)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");k.drawImage(m,0,0)}return t.disposeData(v.dataId),r}const Zne={kernelName:Ow,backendName:"webgpu",kernelFunc:Yne};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vk=xn({opType:qe.MUL,cpuKernelImpl:nee,supportsComplex:!0}),Qne={kernelName:tu,backendName:"webgpu",kernelFunc:vk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ck(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;return Vo(r,i,o,"sum",t)}const Jne={kernelName:Rc,backendName:"webgpu",kernelFunc:Ck};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ese(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:u}=Hp(r,i.length);jp(o.length,u,i);const{path:l,steps:h}=Xp(a,u),c=h.length;let d=null,p=o.length;const f=[];for(let g=0;g<c;++g){for(const m of h[g]){const{permutationIndices:b,expandDims:x}=Kp(p,u[m]);let v;qp(b)?v=i[m]:(v=Rr({inputs:{x:i[m]},backend:t,attrs:{perm:b}}),f.push(v));const w=v.shape.slice();for(let S=0;S<x.length;++S)w.splice(x[S],0,1);ct(v.shape,w)||(v=Oe({inputs:{x:v},backend:t,attrs:{shape:w}}),f.push(v)),d===null?d=v:(d=vk({inputs:{a:v,b:d},backend:t}),f.push(d))}g<c-1&&(l[g]>=0&&(d=Ck({inputs:{x:d},backend:t,attrs:{axis:l[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&t.disposeData(g.dataId);return d}const tse={kernelName:Zd,backendName:"webgpu",kernelFunc:ese};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nse=bt({opType:ve.ELU}),sse={kernelName:za,backendName:"webgpu",kernelFunc:nse};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rse=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=new wd(qe.ELU_DER,s.shape,r.shape);return t.runWebGPUProgram(i,[s,r],s.dtype)},ise={kernelName:Qd,backendName:"webgpu",kernelFunc:rse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ose=xn({opType:qe.EQUAL,dtype:"bool",cpuKernelImpl:VJ}),ase={kernelName:Zl,backendName:"webgpu",kernelFunc:ose};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const use=bt({opType:ve.ERF}),lse={kernelName:Ba,backendName:"webgpu",kernelFunc:use};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cse=bt({opType:ve.EXP,cpuKernelImpl:UJ,dtype:"float32"}),hse={kernelName:Va,backendName:"webgpu",kernelFunc:cse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ym(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,o=i.shape.length,a=i.shape.slice();let u=r;return r<0&&(L(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+r+1),a.splice(u,0,1),Oe({inputs:{x:i},backend:s,attrs:{shape:a}})}const dse={kernelName:Ql,backendName:"webgpu",kernelFunc:Ym};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pse=bt({opType:ve.EXPM1,cpuKernelImpl:GJ}),fse={kernelName:Ua,backendName:"webgpu",kernelFunc:pse};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w1{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sk(n,e,t){const s=t.tensorMap.get(n.dataId),r=Q(n.shape),i=n.shape[n.shape.length-1],o=r/i,a=[],u=Oe({inputs:{x:n},backend:t,attrs:{shape:[o,i]}});a.push(u);const l=u.shape,h=new w1("real",l),c=new w1("imag",l),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],p=e?2*Math.PI:-2*Math.PI,f=e?l[1]:1,g=[{type:"float32",data:[p]},{type:"float32",data:[f]}],m=t.runWebGPUProgram(h,d,"float32",g);a.push(m);const b=t.runWebGPUProgram(c,d,"float32",g);a.push(b);const x=Bo({inputs:{real:m,imag:b},backend:t});a.push(x);const v=Oe({inputs:{x},backend:t,attrs:{shape:n.shape}});return a.forEach(w=>t.disposeData(w.dataId)),v}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mse(n){const{inputs:e,backend:t}=n,{input:s}=e;return Sk(s,!1,t)}const gse={kernelName:Jd,backendName:"webgpu",kernelFunc:mse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xse{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bse={kernelName:tp,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new xse(t.shape);return s.runWebGPUProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yse=bt({opType:ve.FLOOR,cpuKernelImpl:WJ}),wse={kernelName:Ga,backendName:"webgpu",kernelFunc:yse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vse=xn({opType:qe.FLOOR_DIV,cpuKernelImpl:HJ,dtype:"int32"}),Cse={kernelName:Wa,backendName:"webgpu",kernelFunc:vse};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sse{constructor(e,t,s=!1){this.pixelsOpType=Sa.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${Ie("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ise={kernelName:Hw,backendName:"webgpu",kernelFunc:$se};let Xo,Qf=ne().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function $se(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s;if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,u=typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&r instanceof OffscreenCanvas,l=typeof ImageBitmap<"u"&&r instanceof ImageBitmap,[h,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[c,h,i],p=ne().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&o,f=o||a;if(l||u||f){let x;if(p)x=t.device.importExternalTexture({source:r});else{if(f){const D=ne().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Xo==null||D!==Qf)&&(Qf=D,Xo=document.createElement("canvas").getContext("2d",{willReadFrequently:Qf})),Xo.canvas.width=h,Xo.canvas.height=c,Xo.drawImage(r,0,0,h,c),r=Xo.canvas}const T=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,P=t.textureManager.acquireTexture(d[1],d[0],"rgba8unorm",T);t.queue.copyExternalImageToTexture({source:r},{texture:P},[d[1],d[0]]),x=P}const v=Q(d),w=Be(d),S=new Sse(d,i,p),k=[{type:"uint32",data:[v]},{type:"uint32",data:[i]},{type:"uint32",data:[...w]}],E=t.makeTensorInfo([c,h],"int32"),I=t.tensorMap.get(E.dataId);I.resource=x;const C=t.runWebGPUProgram(S,[E],"int32",k);return t.disposeData(E.dataId),C}const g=r.data;let m=g;if(i!=null&&i!==4){m=new Uint8Array(r.width*r.height*i);const x=g.length;let v=0;for(let w=0;w<x;w++)w%4<i&&(m[v++]=g[w])}const b=t.makeTensorInfo(d,"int32",new Int32Array(m));return t.uploadToGPU(b.dataId),b}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kse{constructor(e,t,s,r,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],Ke(e,t),Ke(e,s),this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),r!=null&&(Ke(e,r),this.variableNames.push("offset")),i!=null&&(Ke(e,i),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${Ie("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tse={kernelName:Jl,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s,scale:r,offset:i,mean:o,variance:a}=n,{varianceEpsilon:u}=e,l=t,h=[s,o,a];let c=null;i!=null&&(c=i.shape,h.push(i));let d=null;r!=null&&(d=r.shape,h.push(r));const p=new kse(s.shape,o.shape,a.shape,c,d),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(p,h,s.dtype,f)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ese(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:h,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,g=hs(h),m=Ot(r.shape,i.shape,u,c,l,d,!1,g);return xk({x:r,filter:i,convInfo:m,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:f,activation:p})}const Rse={kernelName:gl,backendName:"webgpu",kernelFunc:Ese};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:h,dimRoundingMode:c,activation:d,leakyreluAlpha:p}=s;let f=h;f==null&&(f=[1,1]),L(gn(u,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${f}'`);const g=Ot(r.shape,i.shape,u,f,l,c,!0),m=[r,i],b=o!=null,x=a!=null;b&&m.push(o),x&&m.push(a);const v=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];let w;return g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&g.dilationHeight===1&&g.dilationWidth===1&&g.inChannels%4===0?(w=new yk(g,b,d,x),v.push({type:"int32",data:[w.virtualWidth]})):(w=new wk(g,b,d,x),v.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),d==="leakyrelu"&&(v.push({type:"float32",data:[p]}),w.uniforms+=" alpha : f32,"),t.runWebGPUProgram(w,m,"float32",v)}const _se={kernelName:Gg,backendName:"webgpu",kernelFunc:Nse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dse{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Kt(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ase(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,o=i[i.length-1],a=Q(s.shape),[u,l,h,c]=Np(s,r),d=Oe({inputs:{x:r},backend:t,attrs:{shape:[l,o]}}),p=Oe({inputs:{x:s},backend:t,attrs:{shape:[Q(s.shape)/h,h]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const x=t.readSync(r.dataId),v=t.bufferSync(s),w=KJ(x,v,s.dtype,l,o,h,c,s.shape,a);return t.makeTensorInfo(u,s.dtype,w.values)}const f=new Dse(o,[l,h]),g=[{type:"int32",data:[o]},{type:"int32",data:c}],m=t.runWebGPUProgram(f,[p,d],p.dtype,g),b=Oe({inputs:{x:m},backend:t,attrs:{shape:u}});return t.disposeData(d.dataId),t.disposeData(p.dataId),t.disposeData(m.dataId),b}const Fse={kernelName:Rg,backendName:"webgpu",kernelFunc:Ase};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pse{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=Lse(this.aShape);return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function Lse(n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let s=0;s<n.length;s++)s===2?t.push("indexZ"):t.push(`${e[s]}`);return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ik(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:o,batchDims:a}=s,u=Qe(o,r.shape)[0],l=Zp(r,i,u,a),h=Q(i.shape),c=[],d=Oe({inputs:{x:r},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=Oe({inputs:{x:i},backend:t,attrs:{shape:[l.batchSize,h/l.batchSize]}});c.push(d),c.push(p);const f=[l.batchSize,l.outerSize,h/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([r,i])){const v=t.tensorMap.get(p.dataId).values,w=Je(p.shape,p.dtype,v),k=t.tensorMap.get(d.dataId).values,E=Je(d.shape,d.dtype,k),I=jJ(E,w,f);return c.forEach(C=>t.disposeData(C.dataId)),t.makeTensorInfo(l.outputShape,I.dtype,I.values)}const g=new Pse(d.shape,f),m=t.runWebGPUProgram(g,[d,p],d.dtype);c.push(m);const b=Oe({inputs:{x:m},backend:t,attrs:{shape:l.outputShape}});return c.forEach(x=>t.disposeData(x.dataId)),b}const Ose={kernelName:ec,backendName:"webgpu",kernelFunc:Ik};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mse=xn({opType:qe.GREATER,cpuKernelImpl:qJ,dtype:"bool"}),zse={kernelName:tc,backendName:"webgpu",kernelFunc:Mse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bse=xn({opType:qe.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:XJ}),Vse={kernelName:Ha,backendName:"webgpu",kernelFunc:Bse};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Use(n){const{inputs:e,backend:t}=n,{input:s}=e;return Sk(s,!0,t)}const Gse={kernelName:np,backendName:"webgpu",kernelFunc:Use};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wse=bt({opType:ve.IS_FINITE,dtype:"bool"}),Hse={kernelName:ja,backendName:"webgpu",kernelFunc:Wse};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kse=bt({opType:ve.IS_INF,dtype:"bool"}),jse={kernelName:Xa,backendName:"webgpu",kernelFunc:Kse};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xse=bt({opType:ve.IS_NAN,dtype:"bool"}),qse={kernelName:qa,backendName:"webgpu",kernelFunc:Xse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,o=[{type:"float32",data:[i]}],a=new Pu(r.shape,ve.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(a,[r],"float32",o)}const Zse={kernelName:nc,backendName:"webgpu",kernelFunc:Yse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qse=xn({opType:qe.LESS,dtype:"bool",cpuKernelImpl:ZJ}),Jse={kernelName:sc,backendName:"webgpu",kernelFunc:Qse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ere=xn({opType:qe.LESS_EQUAL,dtype:"bool",cpuKernelImpl:YJ}),tre={kernelName:rc,backendName:"webgpu",kernelFunc:ere};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nre{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sre(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,o=(r-s)/(i-1),a=new nre(i),u=[{type:"float32",data:[s]},{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],"float32",u)}const rre={kernelName:Ng,backendName:"webgpu",kernelFunc:sre};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ire=bt({opType:ve.LOG,cpuKernelImpl:QJ}),ore={kernelName:Ya,backendName:"webgpu",kernelFunc:ire};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const are=bt({opType:ve.LOG1P}),ure={kernelName:Za,backendName:"webgpu",kernelFunc:are};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lre=xn({opType:qe.LOGICAL_AND,dtype:"bool"}),cre={kernelName:ic,backendName:"webgpu",kernelFunc:lre};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hre=bt({opType:ve.LOGICAL_NOT}),dre={kernelName:oc,backendName:"webgpu",kernelFunc:hre};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pre=xn({opType:qe.LOGICAL_OR}),fre={kernelName:ac,backendName:"webgpu",kernelFunc:pre};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $k=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class mre{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${$k}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class gre{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,L(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=$e(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${Ie()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${$k}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:u}=s;let l;i>16?l=new mre(r.shape):l=new gre(r.shape,i);const h=[{type:"int32",data:[i]},{type:"float32",data:[o]},{type:"float32",data:[a]},{type:"float32",data:[u]}];return t.runWebGPUProgram(l,[r],r.dtype,h)}const bre={kernelName:uc,backendName:"webgpu",kernelFunc:xre};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yre{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:u,alpha:l,beta:h}=s,c=new yre(r.shape),d=[{type:"int32",data:[a]},{type:"float32",data:[u]},{type:"float32",data:[l]},{type:"float32",data:[h]}];return t.runWebGPUProgram(c,[r,i,o],r.dtype,d)}const vre={kernelName:rp,backendName:"webgpu",kernelFunc:wre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cre=xn({opType:qe.MAX,cpuKernelImpl:eee}),Sre={kernelName:Qa,backendName:"webgpu",kernelFunc:Cre};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ire(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:u}=s,h=kn(r.shape,i,o,1,a,u);return pk(r,h,"max",t)}const $re={kernelName:cc,backendName:"webgpu",kernelFunc:Ire};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dataFormat:u,dimRoundingMode:l}=s,h=[1,1,1],c=bs(r.shape,i,o,h,a,l,u),d=new Cb(c,"max"),p=[{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.inDepth,c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth]}];return t.runWebGPUProgram(d,[r],r.dtype,p)}const Tre={kernelName:hc,backendName:"webgpu",kernelFunc:kre};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ere{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class Rre{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nre(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:a,strides:u,pad:l,dimRoundingMode:h}=s,c=[1,1,1],d=bs(o.shape,a,u,c,l,h),p=new Cb(d,"max",!0);let f=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];const g=t.runWebGPUProgram(p,[o],"int32",f),m=new Rre(d);f=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const b=t.runWebGPUProgram(m,[r,g],o.dtype,f);return t.disposeData(g.dataId),b}const _re={kernelName:op,backendName:"webgpu",kernelFunc:Nre};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dre(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:o}=e,a=i;ak([i,o],"maxPoolGrad");const{filterSize:u,strides:l,pad:h,dimRoundingMode:c}=s,d=kn(a.shape,u,l,1,h,c),p=new Nl(d,"max",!0);let f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];const g=t.runWebGPUProgram(p,[a],"int32",f),m=new Ere(d);f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const b=t.runWebGPUProgram(m,[r,g],a.dtype,f);return t.disposeData(g.dataId),b}const Are={kernelName:ip,backendName:"webgpu",kernelFunc:Dre};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fre(n){const{inputs:e,backend:t,attrs:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=s,{x:u}=e;L(u.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`);const l=[1,1];L(gn(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const h=kn(u.shape,r,i,l,o),c=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]}];let d=new Nl(h,"max",!1);const p=t.runWebGPUProgram(d,[u],u.dtype,c);d=new Nl(h,"max",!0,!0,a);const f=t.runWebGPUProgram(d,[u],"int32",c);return[p,f]}const Pre={kernelName:_g,backendName:"webgpu",kernelFunc:Fre};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;return Vo(r,i,o,"min",t)}const Ore={kernelName:pc,backendName:"webgpu",kernelFunc:Lre};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mre=xn({opType:qe.MIN,cpuKernelImpl:tee}),zre={kernelName:Ja,backendName:"webgpu",kernelFunc:Mre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bre{constructor(e,t,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((r,i)=>r[0]+e[i]+r[1]),this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((r,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map((l,h)=>`uniforms.pad${h}[0]`).join(","),s=this.xShape.map((l,h)=>`uniforms.pad${h}[0] + uniforms.xShape${e>1?`[${h}]`:""}`).join(","),r=e===1?"start":"start[i]",i=e===1?"end":"end[i]",o=e===1?"outC":"outC[i]",a=Kt(e),u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${t});
          let end = ${a}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${o} < ${r}) {
              ${o} = ${r} * 2 - ${o} - ${this.offset};
            } else if(${o} >= ${i}) {
              ${o} = (${i} - 1) * 2 - ${o} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vre={kernelName:fc,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{paddings:r,mode:i}=e,o=t,a=r.map(h=>({type:"int32",data:[h[0],h[1]]})),u=new Bre(s.shape,r,i);return o.runWebGPUProgram(u,[s],s.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ure=xn({opType:qe.MOD}),Gre={kernelName:eu,backendName:"webgpu",kernelFunc:Ure};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wre{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hre{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${Ie("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kk(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,o=Oe({inputs:{x:r},backend:t,attrs:{shape:[Q(r.shape)/r.shape[i],r.shape[i]]}}),a=new Hre(o.shape),u=t.runWebGPUProgram(a,[o],r.dtype),l=Oe({inputs:{x:u},backend:t,attrs:{shape:r.shape}});return t.disposeData(o.dataId),t.disposeData(u.dataId),l}const Kre={kernelName:Dc,backendName:"webgpu",kernelFunc:kk};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jre(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s,u=a?r:kk({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),l=u.shape[0],h=u.shape[1],c=new Wre(l,i),d=[{type:"float32",data:[o]},{type:"int32",data:[h]}],p=t.runWebGPUProgram(c,[u],"int32",d);return a||t.disposeData(u.dataId),p}const Xre={kernelName:Dg,backendName:"webgpu",kernelFunc:jre};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qre(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.tensorMap.get(s.dataId),[o,a]=see(i.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,o)}const r=new Pu(s.shape,ve.NEG);return t.runWebGPUProgram(r,[s],s.dtype)}const Yre={kernelName:mc,backendName:"webgpu",kernelFunc:qre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zre(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u}=s,l=t.readSync(r.dataId),h=t.readSync(i.dataId),{selectedIndices:c}=Ep(l,h,o,a,u);return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}const Qre={kernelName:ap,backendName:"webgpu",kernelFunc:Zre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jre(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=s,h=t.readSync(r.dataId),c=t.readSync(i.dataId),d=o,p=a,f=u,g=l,{selectedIndices:m,selectedScores:b}=Rp(h,c,d,p,f,g);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const eie={kernelName:up,backendName:"webgpu",kernelFunc:Jre};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tie{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${Ie("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nie(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:o,onValue:a,offValue:u}=s,l=Q(r.shape),h=new tie(l,o),c=Oe({inputs:{x:r},backend:t,attrs:{shape:[l]}}),d=[{type:"float32",data:[a]},{type:"float32",data:[u]}],p=t.runWebGPUProgram(h,[c],i,d);t.disposeData(c.dataId);const f=[...r.shape,o],g=Oe({inputs:{x:p},backend:t,attrs:{shape:f}});return t.disposeData(p.dataId),g}const sie={kernelName:bc,backendName:"webgpu",kernelFunc:nie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cd(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=sh({inputs:{input:s},backend:t}),i=Cd({inputs:{x:r},backend:t}),o=wf({inputs:{input:s},backend:t}),a=Cd({inputs:{x:o},backend:t}),u=Bo({inputs:{real:i,imag:a},backend:t});return t.disposeData(r.dataId),t.disposeData(i.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),u}else return Yn({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const rie={kernelName:Pc,backendName:"webgpu",kernelFunc:Cd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tk(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=sh({inputs:{input:s},backend:t}),i=Tk({inputs:{x:r},backend:t}),o=wf({inputs:{input:s},backend:t}),a=Cd({inputs:{x:o},backend:t}),u=Bo({inputs:{real:i,imag:a},backend:t});return t.disposeData(r.dataId),t.disposeData(i.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),u}else return Yn({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const iie={kernelName:xc,backendName:"webgpu",kernelFunc:Tk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oie(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return Ym({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(h=>{Fd(i,h.shape,"All tensors passed to stack must have matching shapes"),L(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=e.map(h=>{const c=Ym({inputs:{input:h},backend:t,attrs:{dim:r}});return a.push(c),c}),l=gk({inputs:u,backend:t,attrs:{axis:r}});return a.forEach(h=>t.disposeData(h.dataId)),l}const aie={kernelName:yc,backendName:"webgpu",kernelFunc:oie};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ek(n,e=!1){const t=n.length,s=Kt(t),r=n.map((c,d)=>`uniforms.pad${d}[0]`).join(","),i=n.map((c,d)=>`uniforms.pad${d}[0] + uniforms.xShape${t>1?`[${d}]`:""}`).join(","),o=t>1?`${s}(${r})`:`${r}`,a=t>1?`${s}(${i})`:`${i}`,u=t>1?"any(paddedCoords < start)":"paddedCoords < start",l=t>1?"any(paddedCoords >= end)":"paddedCoords >= end",h=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
        let start = ${o};
        let end = ${a};
        if (${u} || ${l}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${h}));
        }
  `}class uie{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((s,r)=>s[0]+e[r]+s[1]),this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((s,r)=>{this.uniforms+=` pad${r} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${Ek(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lie=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:o}=s;if(i.every(l=>ct(l,[0,0])))return ls({inputs:{x:r},backend:t});if(Q(r.shape)===0){const l=i.map((h,c)=>h[0]+r.shape[c]+h[1]);return Yn({backend:t,attrs:{shape:l,value:o,dtype:r.dtype}})}const a=[{type:"float32",data:[o]}];i.map(l=>a.push({type:"int32",data:[l[0],l[1]]}));const u=new uie(r.shape,i);return t.runWebGPUProgram(u,[r],r.dtype,a)},cie={kernelName:wc,backendName:"webgpu",kernelFunc:lie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hie=xn({opType:qe.POW}),die={kernelName:nu,backendName:"webgpu",kernelFunc:hie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pie(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=new wd(qe.PRELU,s.shape,r.shape);return t.runWebGPUProgram(i,[s,r],"float32")}const fie={kernelName:vc,backendName:"webgpu",kernelFunc:pie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;return Vo(r,i,o,"prod",t)}const gie={kernelName:Cc,backendName:"webgpu",kernelFunc:mie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xie=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:o}=t,a=oee(s,r,i,o);return e.makeTensorInfo([a.length],o,a)},bie={kernelName:lp,backendName:"webgpu",kernelFunc:xie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yie=xn({opType:qe.DIV}),wie={kernelName:Ma,backendName:"webgpu",kernelFunc:yie};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vie=bt({opType:ve.RECIPROCAL}),Cie={kernelName:su,backendName:"webgpu",kernelFunc:vie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sie=bt({opType:ve.RELU}),Iie={kernelName:ru,backendName:"webgpu",kernelFunc:Sie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ie=bt({opType:ve.RELU6}),kie={kernelName:iu,backendName:"webgpu",kernelFunc:$ie};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tie{constructor(e,t,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eie(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,size:o,halfPixelCenters:a}=s,[u,l]=o,h=i&&u>1?1:0,c=i&&l>1?1:0,p=[{type:"float32",data:[h,c]},{type:"float32",data:[a?.5:0]}],f=new Tie(r.shape,u,l);return t.runWebGPUProgram(f,[r],"float32",p)}const Rie={kernelName:$c,backendName:"webgpu",kernelFunc:Eie};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nie{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ie(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,[,a,u]=r.shape,[,l,h]=i.shape,c=[o&&l>1?a-1:a,o&&h>1?u-1:u],d=[o&&l>1?l-1:l,o&&h>1?h-1:h],p=c[0]/d[0],f=c[1]/d[1],g=1/p,m=1/f,b=Math.ceil(g)*2+2,x=Math.ceil(m)*2+2,v=new Nie(r.shape,o),w=[{type:"int32",data:c},{type:"int32",data:d},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"float32",data:[g]},{type:"float32",data:[m]},{type:"int32",data:[b]},{type:"int32",data:[x]}];return t.runWebGPUProgram(v,[i],i.dtype,w)}const Die={kernelName:dp,backendName:"webgpu",kernelFunc:_ie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Aie{constructor(e,t,s,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fie(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[u,l]=a,h=i&&u>1?1:0,c=i&&l>1?1:0,p=[{type:"float32",data:[h,c]},{type:"float32",data:[i?.5:0]}],f=new Aie(r.shape,u,l,o);return t.runWebGPUProgram(f,[r],r.dtype,p)}const Pie={kernelName:Ic,backendName:"webgpu",kernelFunc:Fie};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lie{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oie(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,[,a,u]=r.shape,[,l,h]=i.shape,c=[o&&l>1?a-1:a,o&&h>1?u-1:u],d=[o&&l>1?l-1:l,o&&h>1?h-1:h],p=c[0]/d[0],f=c[1]/d[1],g=1/p,m=1/f,b=Math.ceil(g)*2+2,x=Math.ceil(m)*2+2,v=new Lie(r.shape,o),w=[{type:"int32",data:c},{type:"int32",data:d},{type:"float32",data:[g]},{type:"float32",data:[m]},{type:"int32",data:[b]},{type:"int32",data:[x]}];return t.runWebGPUProgram(v,[i],i.dtype,w)}const Mie={kernelName:hp,backendName:"webgpu",kernelFunc:Oie};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zie{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,o=r.shape.length;if(o===0)return ls({inputs:{x:r},backend:t});const a=r.shape,u=[1,1,1,1];a.forEach((m,b)=>{const x=b+4-o;u[x]=m});const l=Qe(i,r.shape),h=[0,0,0,0];l.forEach(m=>{const b=m+4-o;h[b]=1});const c=[{type:"int32",data:h}],d=Oe({inputs:{x:r},backend:t,attrs:{shape:u}}),p=new zie(u),f=t.runWebGPUProgram(p,[d],d.dtype,c);t.disposeData(d.dataId);const g=Oe({inputs:{x:f},backend:t,attrs:{shape:a}});return t.disposeData(f.dataId),g}const Vie={kernelName:kc,backendName:"webgpu",kernelFunc:Bie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uie{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Ie("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gie={kernelName:xp,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=e,a=t,u=new Uie(s.shape,i),[l,h]=Lp(o,s.shape[1],s.shape[2]),c=[{type:"float32",data:[l]},{type:"float32",data:[h]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];return typeof i=="number"?c.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):c.push({type:"float32",data:i}),a.runWebGPUProgram(u,[s],s.dtype,c)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wie=bt({opType:ve.ROUND}),Hie={kernelName:ou,backendName:"webgpu",kernelFunc:Wie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kie=bt({opType:ve.RSQRT,cpuKernelImpl:aee}),jie={kernelName:au,backendName:"webgpu",kernelFunc:Kie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ul{constructor(e,t,s,r,i,o,a,u=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=o,this.type=a,this.sumDupeIndices=u,this.dispatchLayout=_e(e),this.dispatch=$e(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${s}_${r}_${this.sliceDimGreaterThanOne}_${a}_${u}_${i.length}`;const l=Kt(i.length);this.uniforms=`sliceDim : i32, strides: ${l}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=s}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",i="";this.dispatchLayout.x.length===1?(r="flattenedIndex",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(r="vec2<i32>(flattenedIndex, coords[1])",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(l,h)=>`coords[${h}]`).join(", ")})`;return`
    ${i}
      ${Ie("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${Xi(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${r});

          ${this.sumDupeIndices?Ai("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xie(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:u,sliceSize:l,strides:h,outputSize:c}=_r(i,r,o),d=[c/l,l];if(c===0)return t.makeTensorInfo(o,r.dtype);const p=Oe({inputs:{x:r},backend:t,attrs:{shape:[u,a]}}),f=Oe({inputs:{x:i},backend:t,attrs:{shape:[u,l]}}),g=f.dtype,m=Yn({backend:t,attrs:{shape:d,value:0,dtype:g}}),b=Q(f.shape),x=[{type:"int32",data:[a]},{type:"int32",data:h},{type:"int32",data:[b]}],v=new ul(f.shape,a,p.shape.length,f.shape.length,h,d,g),w=t.runWebGPUProgram(v,[f,p],g,x,m),S=Oe({inputs:{x:w},backend:t,attrs:{shape:o}});return t.disposeData(p.dataId),t.disposeData(f.dataId),t.disposeData(w.dataId),S}const qie={kernelName:Fg,backendName:"webgpu",kernelFunc:Xie};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yie{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zie(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:o}=s,a=new Yie([i.shape[0],i.shape[1]],o),u=[{type:"int32",data:[r.shape[1]]}];return t.runWebGPUProgram(a,[r,i],"int32",u)}const Qie={kernelName:Lg,backendName:"webgpu",kernelFunc:Zie};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jie{constructor(e,t,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=s,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const r=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],o=[];for(let a=0;a<this.outputShape.length;a++)o.push(`${r[a]}`),a<this.cRank&&i.push(`${r[a]}`);e=i.join(),t=o.join()}return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eoe(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,o=new Jie(s.shape.length,r.shape,r.shape.length);return t.runWebGPUProgram(o,[s,r,i],mn(r.dtype,i.dtype))}const toe={kernelName:Tc,backendName:"webgpu",kernelFunc:eoe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const noe=bt({opType:ve.SELU}),soe={kernelName:uu,backendName:"webgpu",kernelFunc:noe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const roe=bt({opType:ve.SIGMOID}),ioe={kernelName:du,backendName:"webgpu",kernelFunc:roe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ooe=bt({opType:ve.SIGN}),aoe={kernelName:hu,backendName:"webgpu",kernelFunc:ooe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uoe=bt({opType:ve.SIN}),loe={kernelName:lu,backendName:"webgpu",kernelFunc:uoe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const coe=bt({opType:ve.SINH}),hoe={kernelName:cu,backendName:"webgpu",kernelFunc:coe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const doe=bt({opType:ve.SOFTPLUS}),poe={kernelName:pu,backendName:"webgpu",kernelFunc:doe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class foe{constructor(e,t,s,r,i,o){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(r.length);for(let u=0;u<a.length;u++)a[u]=r[i[u]];this.outputShape=a,this.newDim=i,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${Kt(r.length)}, paddedXShapeStrides : ${Kt(o)}, `,s.map((u,l)=>{this.uniforms+=` pad${l} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${i}`}getUserCode(){const e=Kt(this.outputShape.length),t=lk(this.newDim);return`
      ${Oh(this.paddedXShape,"PaddedX")}
      ${Ie("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${Ek(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const moe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:o}=s;L(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=i.reduce((x,v)=>x*v),u=[[0,0]];u.push(...o);for(let x=1+i.length;x<r.shape.length;++x)u.push([0,0]);const l=u.map((x,v)=>x[0]+r.shape[v]+x[1]),h=No(l,i,a,!1),c=_o(h.length,i.length,!1),d=Do(l,i,a,!1),p=Be(l),f=new foe(r.shape,l,u,h,c,p.length),g=[{type:"int32",data:h},{type:"int32",data:p}];u.map(x=>g.push({type:"int32",data:[x[0],x[1]]}));const m=t.runWebGPUProgram(f,[r],r.dtype,g),b=Oe({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeData(m.dataId),b},goe={kernelName:Nc,backendName:"webgpu",kernelFunc:moe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xoe{constructor(e,t,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=s,this.dispatchLayout=_e([t]),this.dispatch=$e(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${Ie("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Ai("&result[outIndex]","value",this.type)}
      }
    }
  `}}class boe{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=_e(t),this.dispatch=$e(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${Ie("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Ai("&result[segmentId]","1","int32")}
      }
    }
  `}}class yoe{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=_e(e),this.dispatch=$e(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${Ie("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rk(n,e,t,s=!1,r){const o=Q(n.shape)/n.shape[0],a=n.dtype,u=Q(e.shape),l=r.readSync(t.dataId),c=u>0?l[u-1]+1:0;let d;const p=n.shape.slice();p[0]=c;const f=u*o,g=Yn({backend:r,attrs:{shape:p,value:0,dtype:a}});d=new xoe(p,f,a);let m=[{type:"int32",data:[o]},{type:"int32",data:[f]}];const b=r.runWebGPUProgram(d,[n,e,t],a,m,g);if(s)return b;const x=Yn({backend:r,attrs:{shape:[c],value:0,dtype:"int32"}});d=new boe(c,t.shape);const v=r.runWebGPUProgram(d,[t],"int32",null,x),w=Yn({backend:r,attrs:{shape:p,value:0,dtype:a}});d=new yoe(p,a),m=[{type:"int32",data:[o]}];const S=r.runWebGPUProgram(d,[b,v],a,m,w);return r.disposeData(b.dataId),r.disposeData(v.dataId),S}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function woe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;return Rk(s,r,i,!1,t)}const voe={kernelName:Og,backendName:"webgpu",kernelFunc:woe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Coe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;return Rk(s,r,i,!0,t)}const Soe={kernelName:Mg,backendName:"webgpu",kernelFunc:Coe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ioe{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[r]*t[r];this.outputShape=s,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=$oe(this.rank,"uniforms.");return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function $oe(n,e=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${e}aShape)`;const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n;r++)s.push(`(${t[r]} % ${e}aShape[${r}])`);return s.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sb(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(t.shouldExecuteOnCPU([r])||r.dtype==="string"||r.shape.length>=5){const u=t.readSync(r.dataId),l=r.dtype==="string"?u.map(d=>Xs(d)):u,h=Je(r.shape,r.dtype,l),c=fee(h,i);return t.makeTensorInfo(c.shape,c.dtype,c.values)}const o=new Ioe(r.shape,i);return t.runWebGPUProgram(o,[r],r.dtype)}const koe={kernelName:yu,backendName:"webgpu",kernelFunc:Sb};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Toe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:u,numUpdates:l,sliceSize:h,strides:c,outputSize:d}=_r(i,r,a),p=!1;if(i.dtype==="string"){const I=t.bufferSync(r),C=t.bufferSync(i),T=Xs(t.readSync(o.dataId)[0]),R=uee(I,C,a,d,h,l,u,c,T,p);return t.makeTensorInfo(a,R.dtype,R.values)}const f=[d/h,h],g=Oe({inputs:{x:r},backend:t,attrs:{shape:[l,u]}}),m=i.shape.length?Oe({inputs:{x:i},backend:t,attrs:{shape:[l,h]}}):ls({inputs:{x:i},backend:t}),b=m.dtype,x=t.makeTensorInfo([],b,Cn(1,b)),v=Oe({inputs:{x:o},backend:t,attrs:{shape:Array(f.length).fill(1)}}),w=Sb({inputs:{x:v},backend:t,attrs:{reps:f}}),S=Q([l,h]),k=[{type:"int32",data:[u]},{type:"int32",data:c},{type:"int32",data:[S]}];switch(l){case 0:break;case 1:{const I=new ul([l,h],u,g.shape.length,m.shape.length,c,f,b,p);t.runWebGPUProgram(I,[m,g],b,k,w)}break;default:{const I=new ul([l,h],u,g.shape.length,x.shape.length,c,f,b,p);t.runWebGPUProgram(I,[x,g],b,k,w)}{const I=new ul([l,h],u,g.shape.length,m.shape.length,c,f,b);t.runWebGPUProgram(I,[m,g],b,k,w)}}const E=Oe({inputs:{x:w},backend:t,attrs:{shape:a}});return t.disposeData(g.dataId),t.disposeData(m.dataId),t.disposeData(v.dataId),t.disposeData(x.dataId),t.disposeData(w.dataId),E}const Eoe={kernelName:zg,backendName:"webgpu",kernelFunc:Toe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Roe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=Qe(o,r.shape)[0],u=Yp(r,i,a),l=r.shape.length,h=new Array(l).fill(0),c=r.shape.slice();return u.map(d=>{const p=[...c];p[a]=d;const f=Lu({inputs:{x:r},backend:t,attrs:{begin:h,size:p}});return h[a]+=d,f})}const Noe={kernelName:_c,backendName:"webgpu",kernelFunc:Roe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _oe=bt({opType:ve.SQRT}),Doe={kernelName:fu,backendName:"webgpu",kernelFunc:_oe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aoe={kernelName:pp,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e,r=new Pu(t.shape,ve.SQUARE);return s.runWebGPUProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Foe=xn({opType:qe.SQUARED_DIFFERENCE}),Poe={kernelName:mu,backendName:"webgpu",kernelFunc:Foe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Loe({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=new Pu(s.shape,ve.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(r,[s],s.dtype,i)}const Ooe={kernelName:wu,backendName:"webgpu",kernelFunc:Loe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Moe{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=Kt(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let r=0;t=this.outputShape.map((i,o)=>(r++,this.outputShape.length===1?`coords * uniforms.strides[${o}] + uniforms.begin[${o}]`:`coords[${r-1}] * uniforms.strides[${o}] + uniforms.begin[${o}]`)).join(",")}return`
       ${Ie("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zoe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:o,strides:a,beginMask:u,endMask:l,ellipsisMask:h,newAxisMask:c,shrinkAxisMask:d}=s,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:x,end:v,strides:w}=Ap(r.shape,i,o,a,u,l,h,c,d);let S;if(g)S=Oe({inputs:{x:r},backend:t,attrs:{shape:f}});else if(m||b){L(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const k=Dp(x,v,w),E=Lu({inputs:{x:r},backend:t,attrs:{begin:x,size:k}});S=Oe({inputs:{x:E},backend:t,attrs:{shape:f}}),t.disposeData(E.dataId)}else if(t.shouldExecuteOnCPU([r])){const E=t.readSync(r.dataId),I=Je(r.shape,r.dtype,E),C=hee(p,I,w,x);S=t.makeTensorInfo(f,r.dtype,C.values)}else{const E=new Moe(p),I=[{type:"int32",data:x},{type:"int32",data:w}],C=t.runWebGPUProgram(E,[r],r.dtype,I);S=Oe({inputs:{x:C},backend:t,attrs:{shape:f}}),t.disposeData(C.dataId)}return S}const Boe={kernelName:fp,backendName:"webgpu",kernelFunc:zoe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Voe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:u,preserveShortSequences:l}=s,{data:h,dataSplits:c}=e,d=t.readSync(h.dataId),p=t.readSync(c.dataId),[f,g]=dee(d,p,r,i,o,a,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(c.shape,"int32",g)]}const Uoe={kernelName:Vg,backendName:"webgpu",kernelFunc:Voe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Goe=xn({opType:qe.SUB,cpuKernelImpl:pee,supportsComplex:!0}),Woe={kernelName:gu,backendName:"webgpu",kernelFunc:Goe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hoe=bt({opType:ve.TAN}),Koe={kernelName:xu,backendName:"webgpu",kernelFunc:Hoe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const joe=bt({opType:ve.TANH}),Xoe={kernelName:bu,backendName:"webgpu",kernelFunc:joe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qoe(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:o}=e,{sliceRank:a,numUpdates:u,sliceSize:l,strides:h,outputSize:c}=_r(o,i,r.shape),d=[c/l,l];if(c===0)return t.makeTensorInfo(r.shape,i.dtype);const p=[],f=Oe({inputs:{x:i},backend:t,attrs:{shape:[u,a]}});p.push(f);const g=Oe({inputs:{x:o},backend:t,attrs:{shape:[u,l]}});p.push(g);const m=Oe({inputs:{x:r},backend:t,attrs:{shape:d}});p.push(m);const b=Sb({inputs:{x:m},backend:t,attrs:{reps:Array(d.length).fill(1)}}),x=new ul([u,l],a,f.shape.length,g.shape.length,h,d,r.dtype,!1),v=Q([u,l]),w=[{type:"int32",data:[a]},{type:"int32",data:h},{type:"int32",data:[v]}],S=t.runWebGPUProgram(x,[g,f],m.dtype,w,b);p.push(S);const k=Oe({inputs:{x:S},backend:t,attrs:{shape:r.shape}});return p.forEach(E=>t.disposeData(E.dataId)),k}const Yoe={kernelName:Pg,backendName:"webgpu",kernelFunc:qoe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zoe{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${Ie("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class Qoe{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${Ie("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qo(n,e){e!==null&&n.disposeData(e.dataId)}function v1(n){let e=1;for(;e<n;)e*=2;return e}function Joe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:o}=s,a=r.shape,u=a[a.length-1];if(t.shouldExecuteOnCPU([r])){const S=t.readSync(r.dataId),[k,E]=mee(S,a,r.dtype,i,o);return[t.makeTensorInfo(k.shape,k.dtype,k.values),t.makeTensorInfo(E.shape,E.dtype,E.values)]}if(i===0)return a[a.length-1]=0,[t.makeTensorInfo(a,r.dtype,[]),t.makeTensorInfo(a,"int32",[])];if(u===1)return[r,Yn({attrs:{shape:a,dtype:"int32",value:0},backend:t})];const h=Q(a)/u,c=Oe({inputs:{x:r},attrs:{shape:[h,u]},backend:t}),d=v1(i),p=v1(u);let f=null;const g=()=>f===null?[c,c]:[c,f],m=(S,k,E)=>{const I=g(),C=new Zoe(E),R=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[S]},{type:"int32",data:[k]}],P=f;f=t.runWebGPUProgram(C,I,"int32",R),qo(t,P)};for(let S=1;S<d;S*=2){const k=S*2;for(let E=S;E>=1;E/=2)m(k,E,[h,p])}for(let S=p;S>d;S/=2){const k=g(),E=new Qoe([h,S/2]),C=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"int32",data:[d]}],T=f;f=t.runWebGPUProgram(E,k,"int32",C),qo(t,T);const R=d/2,P=R*2;for(let D=R;D>=1;D/=2)m(P,D,f.shape)}let b=f;f=Lu({inputs:{x:f},backend:t,attrs:{begin:0,size:[h,i]}}),qo(t,b);let x=Ik({inputs:{x:c,indices:f},backend:t,attrs:{axis:1,batchDims:1}});qo(t,c);const v=a.slice(0,-1);v.push(i),b=f,f=Oe({inputs:{x:f},attrs:{shape:v},backend:t}),qo(t,b);const w=x;return x=Oe({inputs:{x},attrs:{shape:v},backend:t}),qo(t,w),[x,f]}const eae={kernelName:mp,backendName:"webgpu",kernelFunc:Joe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tae{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=_e(this.outputShape),this.dispatch=$e(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Ie("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nae(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:u,outputShape:l}=s,[h,c,d,p]=r.shape,[f,g]=l??[c,d],m=[h,f,g,p],b=new tae(m),x=o==="nearest"?1:2;let v;switch(a){case"constant":v=1;break;case"reflect":v=2;break;case"wrap":v=3;break;case"nearest":v=4;break;default:v=1;break}const w=[{type:"int32",data:[x]},{type:"int32",data:[v]},{type:"float32",data:[u]}];return t.runWebGPUProgram(b,[r,i],"float32",w)}const sae={kernelName:gp,backendName:"webgpu",kernelFunc:nae};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rae(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,a=o.shape.length,u=r.shape[i],l=new Array(a-1);let h=0;for(let g=0;g<a;g++)g!==i&&(l[h++]=o.shape[g]);const c=[],d=new Array(a).fill(0),p=o.shape.slice();p[i]=1;const f=new Array(u);for(let g=0;g<f.length;g++){d[i]=g;const m=Lu({inputs:{x:o},backend:t,attrs:{begin:d,size:p}}),b=Oe({inputs:{x:m},backend:t,attrs:{shape:l}});f[g]=b,c.push(m)}return c.forEach(g=>t.disposeData(g.dataId)),f}const iae={kernelName:Ac,backendName:"webgpu",kernelFunc:rae};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oae{constructor(e,t,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=_e(e),this.dispatch=$e(this.dispatchLayout,e,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${Ie("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Ai("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:o}=s,a=r.shape.length,u=[];let l=0;const h=kt([l],a);let c=r;h!=null&&(c=Rr({inputs:{x:r},backend:t,attrs:{perm:h}}),u.push(c),l=_t(1,a)[0]);const d=Ax(c.shape,l,o),p=Q([c.shape[l]]),f=Oe({inputs:{x:c},backend:t,attrs:{shape:[-1,p]}});u.push(f);const g=r.dtype,m=[f.shape[0],o],b=Yn({backend:t,attrs:{shape:m,value:0,dtype:g}}),x=new oae(f.shape,m,g),v=[{type:"int32",data:[o]},{type:"int32",data:[Q(f.shape)]}],w=t.runWebGPUProgram(x,[f,i],g,v,b),S=Oe({inputs:{x:w},backend:t,attrs:{shape:d}});u.push(w);let k=S;if(h!=null){u.push(S);const E=Nr(h);k=Rr({inputs:{x:k},backend:t,attrs:{perm:E}})}return u.forEach(E=>t.disposeData(E.dataId)),k}const uae={kernelName:Fc,backendName:"webgpu",kernelFunc:aae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lae=[FJ,bee,wee,Cee,Iee,Tee,Fee,Lee,Mee,Bee,Uee,Wee,Kee,Xee,Yee,tte,ste,ate,lte,hte,gte,wte,Ste,Tte,Rte,Ate,LJ,Lte,Bte,Xte,ene,rne,ane,lne,hne,pne,mne,bne,wne,Cne,Ine,Tne,Fne,Lne,Nne,zne,Une,Kne,Xne,Zne,tse,sse,ise,ase,lse,hse,dse,fse,gse,_J,bse,Ise,wse,Cse,Tse,Rse,_se,Fse,Ose,zse,Vse,PJ,Gse,Mte,Hse,jse,qse,Zse,Jse,tre,rre,ure,ore,cre,dre,fre,bre,vre,Qee,Sre,$re,Are,Tre,_re,Pre,Jee,Ore,zre,Vre,Gre,Xre,Qne,Yre,Qre,eie,Ite,sie,iie,aie,cie,die,fie,gie,bie,$te,wie,Cie,Iie,kie,DJ,Rie,Die,Pie,Mie,Vie,Gie,Hie,jie,qie,Qie,toe,soe,ioe,aoe,loe,hoe,fte,Ooe,Boe,Uoe,Kre,poe,goe,voe,Soe,Eoe,Noe,Doe,Aoe,Poe,Woe,Jne,Koe,Xoe,Yoe,koe,eae,sae,Nee,iae,uae,rie];for(const n of lae)Wg(n);async function cae(n){await pv("webgpu"),await fv(),console.log(` TensorFlow.js : ${$N()}`);const e=3;let t=n,s=tx(e),r=await t.array();const i=10,o=1e-10;for(let u=0;u<i;u++){let l=!0;for(let h=0;h<e-1;h++)for(let c=h+1;c<e;c++){const d=r[h][c],p=r[h][h],f=r[c][c];if(Math.abs(d)>o){l=!1;const g=.5*Math.atan2(2*d,f-p),m=Math.cos(g),b=Math.sin(g),x=ol(Array.from({length:e},(v,w)=>Array.from({length:e},(S,k)=>w===h&&k===h||w===c&&k===c?m:w===h&&k===c?-b:w===c&&k===h?b:w===k?1:0)));[t,s]=se(()=>{const v=x.transpose(),w=ft(ft(v,t),x),S=ft(s,x);return[w,S]}),r=await t.array()}}if(l)break}return{eigenValues:Array.from({length:e},(u,l)=>r[l][l]),eigenVectors:await s.array()}}async function hae(n,e){await pv("webgpu"),await fv();const t=n.data.length/4;let s=0,r=0,i=0,o=0,a=0,u=0,l=0,h=0,c=0;for(let g=0;g<t;g++){const m=g*4,b=n.data[m],x=n.data[m+1],v=n.data[m+2],w=b-s,S=x-r,k=v-i;s+=w/(g+1),r+=S/(g+1),i+=k/(g+1);const E=b-s,I=x-r,C=v-i;g>0&&(o+=w*E,a+=w*I,u+=w*C,l+=S*I,h+=S*C,c+=k*C)}const d=t-1;o/=d,a/=d,u/=d,l/=d,h/=d,c/=d;const p=ol([[o,a,u],[a,l,h],[u,h,c]]);return e=(await ai(cae)(p)).eigenVectors,p.dispose(),e}function dae(){let n=[];for(let e=0;e<3;e++)n[e]=[0,0,0];return n}async function pae(n){let e=dae();return e=await ai(hae)(n,e),{output:await LR(n,e),eigenVectors:e}}const fae=`// ---  ---\r
@group(0) @binding(0) var<storage, read> target_pixels: array<vec4<f32>>;\r
@group(0) @binding(1) var<storage, read> input_pixels: array<vec4<f32>>;\r
@group(0) @binding(2) var<storage, read_write> projected_values: array<f32>;\r
@group(0) @binding(3) var<storage, read_write> output_pixels: array<vec4<f32>>;\r
@group(0) @binding(4) var<uniform> eigen_vectors: mat3x3<f32>;\r
@group(0) @binding(5) var<uniform> params: Params;\r
\r
struct Params {\r
    operation: u32,\r
    k: u32,\r
    j: u32,\r
    padded_element_count: u32,\r
    total_invocations: u32,\r
    input_element_count: u32,\r
    target_element_count: u32,\r
};\r
\r
\r
// ---  ---\r
\r
fn do_projection(global_id: vec3<u32>) {\r
    // \r
    if (global_id.x >= params.padded_element_count) {\r
        return;\r
    }\r
    let pixel_index = global_id.x;\r
    let out_index = pixel_index * 3u;\r
\r
    if (pixel_index < params.target_element_count) {\r
        let pixel_rgb = target_pixels[pixel_index].rgb;\r
        // eigen_vectorsCPUeigenVectors\r
        // CPU: dot(pixel_rgb, eigenVectors[row])\r
        // GPU: dot(pixel_rgb, vec3(eigen_vectors[0][row], eigen_vectors[1][row], eigen_vectors[2][row]))\r
        let projected_r = dot(pixel_rgb, vec3(eigen_vectors[0][0], eigen_vectors[1][0], eigen_vectors[2][0]));\r
        let projected_g = dot(pixel_rgb, vec3(eigen_vectors[0][1], eigen_vectors[1][1], eigen_vectors[2][1]));\r
        let projected_b = dot(pixel_rgb, vec3(eigen_vectors[0][2], eigen_vectors[1][2], eigen_vectors[2][2]));\r
        projected_values[out_index] = projected_r;\r
        projected_values[out_index + 1u] = projected_g;\r
        projected_values[out_index + 2u] = projected_b;\r
    } else {\r
        // \r
        let infinity = 3.402823466e+38; // f32 max\r
        projected_values[out_index] = infinity;\r
        projected_values[out_index + 1u] = infinity;\r
        projected_values[out_index + 2u] = infinity;\r
    }\r
}\r
\r
fn do_sort(global_id: vec3<u32>) {\r
    let thread_index = global_id.x;\r
    for (var i = thread_index; i < params.padded_element_count; i = i + params.total_invocations) {\r
        let ix = i;\r
        let jx = ix ^ params.j;\r
\r
        if (jx < ix) { continue; }\r
\r
        let direction = ((ix & params.k) == 0u);\r
        let ix3 = ix * 3u;\r
        let jx3 = jx * 3u;\r
\r
        // R \r
        if (direction == (projected_values[ix3] > projected_values[jx3])) {\r
            let temp = projected_values[ix3];\r
            projected_values[ix3] = projected_values[jx3];\r
            projected_values[jx3] = temp;\r
        }\r
        // G \r
        if (direction == (projected_values[ix3 + 1u] > projected_values[jx3 + 1u])) {\r
            let temp = projected_values[ix3 + 1u];\r
            projected_values[ix3 + 1u] = projected_values[jx3 + 1u];\r
            projected_values[jx3 + 1u] = temp;\r
        }\r
        // B \r
        if (direction == (projected_values[ix3 + 2u] > projected_values[jx3 + 2u])) {\r
            let temp = projected_values[ix3 + 2u];\r
            projected_values[ix3 + 2u] = projected_values[jx3 + 2u];\r
            projected_values[jx3 + 2u] = temp;\r
        }\r
    }\r
}\r
\r
fn erf(x: f32) -> f32 {\r
    let a1 = 0.254829592; let a2 = -0.284496736; let a3 = 1.421413741;\r
    let a4 = -1.453152027; let a5 = 1.061405429; let p = 0.3275911;\r
    let sign = select(1.0, -1.0, x < 0.0);\r
    let abs_x = abs(x);\r
    let t = 1.0 / (1.0 + p * abs_x);\r
    let y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-abs_x * abs_x);\r
    return sign * y;\r
}\r
\r
fn mapValue(value: f32, channel_offset: u32) -> f32 {\r
    // \r
    // CPURindex\r
    let target_size = params.target_element_count;\r
    let U = 0.5 + 0.5 * erf(value / sqrt(2.0));\r
    let index = u32(floor(U * f32(target_size)));\r
    let clamped_index = min(index, target_size - 1u);\r
    return projected_values[clamped_index * 3u + channel_offset];\r
}\r
\r
fn do_mapping(global_id: vec3<u32>) {\r
    let pixel_index = global_id.x;\r
    let input_rgb = input_pixels[pixel_index].rgb;\r
\r
    let mapped_r = mapValue(input_rgb.r, 0u);\r
    let mapped_g = mapValue(input_rgb.g, 1u);\r
    let mapped_b = mapValue(input_rgb.b, 2u);\r
\r
    // CPU\r
    // eigen_vectorsCPUeigenVectorsevT\r
    // CPU: dot(mapped_rgb, evT[row])\r
    // GPU: dot(mapped_rgb, eigen_vectors[row].xyz)\r
    let final_r = dot(vec3<f32>(mapped_r, mapped_g, mapped_b), eigen_vectors[0].xyz);\r
    let final_g = dot(vec3<f32>(mapped_r, mapped_g, mapped_b), eigen_vectors[1].xyz);\r
    let final_b = dot(vec3<f32>(mapped_r, mapped_g, mapped_b), eigen_vectors[2].xyz);\r
    let final_rgb = vec3<f32>(final_r, final_g, final_b);\r
\r
    output_pixels[pixel_index] = vec4<f32>(final_rgb, input_pixels[pixel_index].a);\r
}\r
\r
\r
// ---  ---\r
@compute @workgroup_size(256)\r
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r
    let operation = params.operation;\r
\r
    if (operation == 0u) {\r
        do_projection(global_id);\r
    } else if (operation == 1u) {\r
        do_sort(global_id);\r
    } else if (operation == 2u) {\r
        do_mapping(global_id);\r
    }\r
}`;function Jf(n,e){return n[0]*e[0]+n[1]*e[1]+n[2]*e[2]}function mae(n,e,t){let s=[],r=[],i=[];for(let u=0;u<e.height;++u)for(let l=0;l<e.width;++l){const h=(u*e.width+l)*4;let c=[e.data[h],e.data[h+1],e.data[h+2]];const d=Jf(c,t[0]),p=Jf(c,t[1]),f=Jf(c,t[2]);s[l+u*e.width]=d,r[l+u*e.width]=p,i[l+u*e.width]=f}s=Array.from(Float32Array.from(s).sort()),r=Array.from(Float32Array.from(r).sort()),i=Array.from(Float32Array.from(i).sort());const o=n.width*n.height,a=new Array(o*4);for(let u=0;u<o;u++){const l=n.data[u*4],h=n.data[u*4+1],c=n.data[u*4+2],d=S=>{var k=.254829592,E=-.284496736,I=1.421413741,C=-1.453152027,T=1.061405429,R=.3275911,P=S<0?-1:1;S=Math.abs(S);var D=1/(1+R*S),F=1-((((T*D+C)*D+I)*D+E)*D+k)*D*Math.exp(-S*S);return P*F},p=(S,k)=>{var E=.5+.5*d(S/Math.sqrt(2)),I=Math.floor(E*s.length);return I=Math.min(I,s.length-1),{mappedValue:k[I],U:E,index:I}},f=p(l,s),g=p(h,r),m=p(c,i),b=f.mappedValue,x=g.mappedValue,v=m.mappedValue,w=[[t[0][0],t[1][0],t[2][0]],[t[0][1],t[1][1],t[2][1]],[t[0][2],t[1][2],t[2][2]]];a[u*4]=b*w[0][0]+x*w[0][1]+v*w[0][2],a[u*4+1]=b*w[1][0]+x*w[1][1]+v*w[1][2],a[u*4+2]=b*w[2][0]+x*w[2][1]+v*w[2][2],a[u*4+3]=n.data[u*4+3]}return{data:a,width:n.width,height:n.height}}const gae=n=>(n&n-1)===0&&n!==0,xae=n=>{if(n<=0)return 1;let e=1;for(;e<n;)e<<=1;return e};async function bae(n,e,t){const s=await Dd(),r=s.createShaderModule({code:fae}),i=await s.createComputePipelineAsync({layout:"auto",compute:{module:r,entryPoint:"main"}}),o=e.width*e.height,a=n.width*n.height,u=gae(o)?o:xae(o),l=new Float32Array(e.data),h=new Float32Array(n.data),c=[t[0][0],t[1][0],t[2][0],0,t[0][1],t[1][1],t[2][1],0,t[0][2],t[1][2],t[2][2],0],d=new Float32Array(c),p=s.createBuffer({size:l.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),f=s.createBuffer({size:h.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),g=s.createBuffer({size:d.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),m=s.createBuffer({size:u*3*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),b=s.createBuffer({size:h.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(p,0,l),s.queue.writeBuffer(f,0,h),s.queue.writeBuffer(g,0,d);const x=s.createCommandEncoder(),v=s.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),w=new Uint32Array([0,0,0,u,0,a,o]);s.queue.writeBuffer(v,0,w);const S=s.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:p}},{binding:1,resource:{buffer:f}},{binding:2,resource:{buffer:m}},{binding:3,resource:{buffer:b}},{binding:4,resource:{buffer:g}},{binding:5,resource:{buffer:v}}]}),k=x.beginComputePass();k.setPipeline(i),k.setBindGroup(0,S),k.dispatchWorkgroups(Math.ceil(u/256)),k.end();const E=Math.ceil(u/256)*256;for(let z=2;z<=u;z<<=1)for(let _=z>>1;_>0;_=_>>1){const B=s.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),N=new Uint32Array([1,z,_,u,E,a,o]);s.queue.writeBuffer(B,0,N);const O=s.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:p}},{binding:1,resource:{buffer:f}},{binding:2,resource:{buffer:m}},{binding:3,resource:{buffer:b}},{binding:4,resource:{buffer:g}},{binding:5,resource:{buffer:B}}]}),K=x.beginComputePass();K.setPipeline(i),K.setBindGroup(0,O),K.dispatchWorkgroups(Math.ceil(u/256)),K.end()}const I=s.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),C=new Uint32Array([2,0,0,u,0,a,o]);s.queue.writeBuffer(I,0,C);const T=s.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:p}},{binding:1,resource:{buffer:f}},{binding:2,resource:{buffer:m}},{binding:3,resource:{buffer:b}},{binding:4,resource:{buffer:g}},{binding:5,resource:{buffer:I}}]}),R=x.beginComputePass();R.setPipeline(i),R.setBindGroup(0,T),R.dispatchWorkgroups(Math.ceil(a/256)),R.end(),s.queue.submit([x.finish()]),await s.queue.onSubmittedWorkDone();const P=s.createBuffer({size:b.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),D=s.createCommandEncoder();D.copyBufferToBuffer(b,0,P,0,b.size),s.queue.submit([D.finish()]),await P.mapAsync(GPUMapMode.READ);const F=new Float32Array(P.getMappedRange().slice(0));return P.unmap(),p.destroy(),f.destroy(),g.destroy(),m.destroy(),b.destroy(),P.destroy(),{data:F,width:n.width,height:n.height}}async function yae(n,e,t){try{const s={...n,data:new Float32Array(n.data)},r={...e,data:new Float32Array(e.data)},i=await bae(s,r,t);return{...i,data:Array.from(i.data)}}catch(s){return console.error(s),mae(n,e,t)}}const wae=n=>{let e=n;return e=e^61^e>>16,e*=9,e=e^e>>4,e*=668265261,e=e^e>>15,e},vae=wae;function Cae(n,e,t,s,r,i){let o=0;if(n>=t/2&&n<t/2+r){let a=1-Math.floor(Math.abs(e-.5*(s-1)))/(s/2-1),u=1-a;o=a/Math.sqrt(a*a+u*u)}else if(e>=s/2&&e<s/2+i){let a=1-Math.floor(Math.abs(n-.5*(t-1)))/(t/2-1),u=1-a;o=a/Math.sqrt(a*a+u*u)}else{let a=e>=s/2+i?e-i:e,u=n>=t/2+r?n-r:n,l=1-Math.floor(Math.abs(u-.5*(t-1)))/(t/2-1),h=1-Math.floor(Math.abs(a-.5*(s-1)))/(s/2-1),c=(1-l)*(1-h),d=l*(1-h),p=(1-l)*h,f=l*h;o=l*h/Math.sqrt(c*c+d*d+p*p+f*f)}return o}function Sae(n,e,t,s,r){let{tileCountWidth:i,tileCountHeight:o,tileWidth:a,tileHeight:u,restWidth:l,restHeight:h}=t;for(let c=-1;c<i-1+(o-1);++c){let d=c<i-1?c:-1,p=c>=i-1?c-(i-1):-1,{tileCenterWidth:f,tileCenterHeight:g,cumulativeOffsetWidth:m,cumulativeOffsetHeight:b}=_ae(d,p,i,o,l,h),x=Math.floor((e.width-(a+f))*I1()),v=Math.floor((e.height-(u+g))*I1());for(let w=0;w<u+g;++w)for(let S=0;S<a+f;++S){let k=Cae(S,w,a,u,f,g),E=Zm(S+d*a/2+m,s),I=Zm(w+p*u/2+b,r),C=(S+x)%s,T=(w+v)%r;const R=(I*n.width+E)*4,P=R+1,D=R+2,F=(T*e.width+C)*4,z=F+1,_=F+2;n.data[R]+=k*e.data[F],n.data[P]+=k*e.data[z],n.data[D]+=k*e.data[_]}}return n}const Iae=`struct Uniforms {\r
  targetWidth: f32,\r
  targetHeight: f32,\r
  borderSize: f32\r
}\r
\r
@group(0) @binding(0) var<storage, read> inputData: array<f32>;\r
@group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\r
@group(0) @binding(2) var<uniform> uniforms: Uniforms;\r
\r
// \r
fn remapValue(value: f32, low1: f32, high1: f32, low2: f32, high2: f32) -> f32 {\r
  return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\r
}\r
\r
@compute @workgroup_size(16, 16, 1)\r
fn main(@builtin(global_invocation_id) global_id: vec3u) {\r
  let x = global_id.x;\r
  let y = global_id.y;\r
  \r
  // \r
  if (f32(x) >= uniforms.targetWidth || f32(y) >= uniforms.targetHeight) {\r
    return;\r
  }\r
  \r
  let targetWidth = u32(uniforms.targetWidth);\r
  let targetHeight = u32(uniforms.targetHeight);\r
  let borderSize = uniforms.borderSize;\r
  \r
  //  (RGB3)\r
  let pixelIndex = y * targetWidth + x;\r
  let rgbIndex = pixelIndex * 3u;\r
  \r
  // \r
  var w = min(remapValue(f32(x), 0.0, borderSize, 0.0, 1.0), 1.0); // Left border\r
  w *= min(remapValue(f32(x), uniforms.targetWidth - 1.0, uniforms.targetWidth - 1.0 - borderSize, 0.0, 1.0), 1.0); // Right border\r
  w *= min(remapValue(f32(y), 0.0, borderSize, 0.0, 1.0), 1.0); // Top border\r
  w *= min(remapValue(f32(y), uniforms.targetHeight - 1.0, uniforms.targetHeight - 1.0 - borderSize, 0.0, 1.0), 1.0); // Bottom border\r
  \r
  let w_inv = 1.0 - w;\r
  w = w / sqrt(w * w + w_inv * w_inv);\r
  \r
  // RGB\r
  outputData[rgbIndex] = w * inputData[rgbIndex];         // R\r
  outputData[rgbIndex + 1u] = w * inputData[rgbIndex + 1u]; // G\r
  outputData[rgbIndex + 2u] = w * inputData[rgbIndex + 2u]; // B\r
}`,C1=16,S1=(n,e,t)=>{if(!e||e.length===0)throw new Error(": 0");const s=n.createBuffer({size:e.byteLength,usage:t,mappedAtCreation:!0});return new Float32Array(s.getMappedRange()).set(e),s.unmap(),s},$ae=async(n,e,t,s,r)=>{if(!Number.isInteger(t)||t<=0)throw new Error(`Invalid targetWidth: ${t}. It must be a positive integer.`);if(!Number.isInteger(s)||s<=0)throw new Error(`Invalid targetHeight: ${s}. It must be a positive integer.`);if(r<=0)throw new Error(`Invalid borderSize: ${r}. It must be a positive number.`);if(!e||!(e.data instanceof Float32Array))throw new Error("Invalid imageInputGaussian: It must be an object with data as Float32Array.");const i=t*s*3;if(e.data.length!==i)throw new Error(`Data length mismatch. Expected ${i}, got ${e.data.length}`);const o=n.createShaderModule({code:Iae}),a=new Float32Array([t,s,r]),u=S1(n,a,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),l=S1(n,e.data,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),h=e.data.byteLength,c=n.createBuffer({size:h,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),d=n.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),p=n.createBindGroup({layout:d,entries:[{binding:0,resource:{buffer:l}},{binding:1,resource:{buffer:c}},{binding:2,resource:{buffer:u}}]}),f=n.createComputePipeline({layout:n.createPipelineLayout({bindGroupLayouts:[d]}),compute:{module:o,entryPoint:"main"}}),g=n.createCommandEncoder(),m=g.beginComputePass();m.setPipeline(f),m.setBindGroup(0,p);const b=Math.ceil(t/C1),x=Math.ceil(s/C1);m.dispatchWorkgroups(b,x),m.end();const v=n.createBuffer({size:h,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});g.copyBufferToBuffer(c,0,v,0,h),n.queue.submit([g.finish()]),await n.queue.onSubmittedWorkDone(),await v.mapAsync(GPUMapMode.READ);const w=new Float32Array(v.getMappedRange().slice(0));return v.unmap(),{data:w,width:t,height:s}},kae=async(n,e,t,s)=>{const r=await Dd();return await $ae(r,n,e,t,s)};var or=0;const Tae=()=>{or^=or<<13,or^=or>>17,or^=or<<5,or=Zm(or,4294967296)},I1=()=>(Tae(),or*(1/4294967296)),Eae=n=>{or=vae(n)},Zm=(n,e)=>{let t=n%e;return t<0&&(t+=e),t},Rae=(n,e)=>{const t=n/100;return Math.max(Math.floor(t*Math.min(e.width,e.height)/2),2)},Nae=(n,e,t)=>{let s=Math.floor(n/t),r=t,i=n-r*s;r+=Math.floor(i/s),i=n-r*s;let o=Math.floor(e/t),a=t,u=e-a*o;a+=Math.floor(u/o),u=e-a*o;let l=r*2,h=a*2;return{tileCountWidth:s,tileRadiusWidth:r,restWidth:i,tileCountHeight:o,tileRadiusHeight:a,restHeight:u,tileWidth:l,tileHeight:h}},_ae=(n,e,t,s,r,i)=>{let o=0,a=0,u=0,l=0;return n>t-2-r?(o=1,u=n-1-(t-2-r)):e>s-2-i&&(a=1,l=e-1-(s-2-i)),{tileCenterWidth:o,tileCenterHeight:a,cumulativeOffsetWidth:u,cumulativeOffsetHeight:l}},Dae=(n,e,t)=>{const s=e*t,r=new Float32Array(s*4);for(let i=0;i<s;i++){const o=i*3,a=i*4;r[a]=n[o],r[a+1]=n[o+1],r[a+2]=n[o+2],r[a+3]=255}return r},Aae=(n,e,t)=>{const s=e*t,r=new Float32Array(s*3);for(let i=0;i<s;i++){const o=i*4,a=i*3;r[a]=n[o],r[a+1]=n[o+1],r[a+2]=n[o+2]}return r},Nk=async(n,e,t)=>{const s=performance.now();Eae(4256);const r=Rae(e,yy(n)),i=yy(n),o=i.width,a=i.height,u=Nae(o,a,r),l=performance.now();console.log(`setSeed: ${l-s} ms`);let h=wR(o,a);const c=await ai(pae)(i),{eigenVectors:d}=c,p=c.output,f=performance.now();console.log(`setSeed: ${f-s} ms`);const g=new Float32Array(p.data),m=Aae(g,p.width,p.height),b=await ai(kae)({data:m,width:p.width,height:p.height},o,a,r),x=Dae(b.data,o,a);h.data=Array.from(x),ai(Sae)(h,p,u,o,a),h=await ai(yae)(h,i,d);const v=new ImageData(new Uint8ClampedArray(h.data),h.width,h.height),w=performance.now();return console.log(`setSeed: ${w-s} ms`),v},Fae=async()=>{try{const n={video:{facingMode:"environment",width:{ideal:1920},height:{ideal:1080}},audio:!1};try{return await navigator.mediaDevices.getUserMedia(n)}catch(e){console.warn(":",e);const t={video:{facingMode:"user",width:{ideal:1920},height:{ideal:1080}},audio:!1};try{return await navigator.mediaDevices.getUserMedia(t)}catch(s){console.warn(":",s);const r={video:{width:{ideal:1920},height:{ideal:1080}},audio:!1};return await navigator.mediaDevices.getUserMedia(r)}}}catch(n){throw console.error(":",n),n}},Pae=async(n,e)=>new Promise((t,s)=>{try{e.srcObject=n,e.oncanplay=()=>{e.play();const r=document.createElement("canvas");r.width=e.videoWidth,r.height=e.videoHeight;const i=r.getContext("2d");if(!i){s(new Error("canvas"));return}i.drawImage(e,0,0,r.width,r.height);const o=new Image;o.onload=()=>{n.getTracks().forEach(a=>a.stop()),t(o)},o.onerror=()=>{s(new Error(""))},o.src=r.toDataURL("image/jpeg")},e.onerror=()=>{s(new Error(""))}}catch(r){s(r)}}),Lae={key:1,class:"relative w-full aspect-video bg-black rounded-xl overflow-hidden shadow-glass group"},Oae={key:0,class:"absolute bottom-8 left-0 right-0 flex justify-center gap-4 z-[60]"},Mae=["disabled"],zae={key:1,class:"absolute bottom-4 left-0 right-0 flex justify-center gap-3 z-10 opacity-0 group-hover:opacity-100 transition-opacity duration-300"},Bae=["disabled"],Vae=vo({__name:"CameraComponent",props:{modelValue:{type:Boolean,default:!1}},emits:["update:modelValue","photo-captured","error"],setup(n,{emit:e}){const t=n,s=e,r=tt(),i=tt(),o=tt(null),a=tt(""),u=tt([]),l=tt(!1),h=tt(!1),c=tt(!1),d=tt(!1),p=fl({get:()=>t.modelValue,set:U=>s("update:modelValue",U)}),f=fl(()=>u.value.length>1),g=tt(!1),m=tt(!1),b=()=>{g.value=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),m.value="ontouchstart"in window||navigator.maxTouchPoints>0},x=()=>{const U=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),X="capture"in document.createElement("input");d.value=U&&X},v=()=>!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia),w=()=>v()?location.protocol!=="https:"&&location.hostname!=="localhost"&&location.hostname!=="127.0.0.1"?{compatible:!1,reason:"HTTPS"}:/iPad|iPhone|iPod/.test(navigator.userAgent)&&parseFloat((/CPU.*OS ([0-9_]{3,4})/.exec(navigator.userAgent)||["",""])[1].replace("_","."))<11?{compatible:!1,reason:"iOS 11+"}:/Android/.test(navigator.userAgent)&&parseFloat((/Android ([0-9\.]+)/.exec(navigator.userAgent)||["",""])[1])<6?{compatible:!1,reason:"Android 6.0+"}:{compatible:!0}:{compatible:!1,reason:"API"},S=async()=>{try{if(!v())throw new Error("");const U=await navigator.mediaDevices.enumerateDevices();u.value=U.filter(X=>X.kind==="videoinput")}catch(U){throw console.error(":",U),U}},k=async()=>{try{const U=w();if(!U.compatible)throw new Error(U.reason||"");await S();const X=await Fae();if(o.value=X,r.value){r.value.srcObject=X,r.value.muted=!0,r.value.playsInline=!0,r.value.setAttribute("playsinline","true"),r.value.setAttribute("webkit-playsinline","true");try{await new Promise((te,ie)=>{const re=setTimeout(()=>{ie(new Error(""))},5e3),he=()=>{r.value&&r.value.readyState>=2?(clearTimeout(re),te()):setTimeout(he,100)};he()}),await r.value.play(),console.log("")}catch(te){console.warn(":",te),s("error","");const ie=async()=>{var re;try{await((re=r.value)==null?void 0:re.play()),console.log("")}catch(he){console.warn(":",he)}};r.value.removeEventListener("click",ie),r.value.removeEventListener("touchstart",ie),r.value.addEventListener("click",ie,{once:!0}),r.value.addEventListener("touchstart",ie,{once:!0})}}p.value=!0}catch(U){console.error(":",U);let X="";U instanceof Error?U.name==="NotAllowedError"?X="":U.name==="NotFoundError"?X="":U.name==="NotReadableError"?X="":U.name==="OverconstrainedError"?X="":U.name==="NotSupportedError"?X="HTTPS":X=`: ${U.message}`:X=": ",s("error",X)}},E=()=>{o.value&&(o.value.getTracks().forEach(U=>U.stop()),o.value=null),r.value&&(r.value.srcObject=null),p.value=!1},I=async()=>{if(!f.value)return;const X=(u.value.findIndex(te=>te.deviceId===a.value)+1)%u.value.length;a.value=u.value[X].deviceId,E(),await k()},C=async()=>{if(!(!r.value||l.value||!o.value)){l.value=!0;try{const U=await Pae(o.value,r.value),X=document.createElement("canvas");X.width=U.width||r.value.videoWidth,X.height=U.height||r.value.videoHeight;const te=X.getContext("2d");if(!te)throw new Error("canvas");te.drawImage(U,0,0,X.width,X.height);const ie=X.toDataURL("image/jpeg",.9);s("photo-captured",ie),E()}catch(U){console.error(":",U),s("error",`: ${U instanceof Error?U.message:""}`)}finally{l.value=!1}}},T=()=>{const U=document;c.value=!!(U.fullscreenEnabled||U.webkitFullscreenEnabled||U.mozFullScreenEnabled||U.msFullscreenEnabled)},R=()=>{const U=document;h.value=!!(U.fullscreenElement||U.webkitFullscreenElement||U.mozFullScreenElement||U.msFullscreenElement)},P=async()=>{if(!c.value||!r.value){s("error","");return}try{const U=r.value;U.requestFullscreen?await U.requestFullscreen():U.webkitRequestFullscreen?await U.webkitRequestFullscreen():U.mozRequestFullScreen?await U.mozRequestFullScreen():U.msRequestFullscreen&&await U.msRequestFullscreen()}catch(U){console.error(":",U),s("error","")}},D=async()=>{if(h.value)try{const U=document;U.exitFullscreen?await U.exitFullscreen():U.webkitExitFullscreen?await U.webkitExitFullscreen():U.mozCancelFullScreen?await U.mozCancelFullScreen():U.msExitFullscreen&&await U.msExitFullscreen()}catch(U){console.error(":",U)}},F=U=>{U.preventDefault(),h.value&&D()},z=U=>{U.preventDefault(),h.value&&D()},_=async()=>{var U,X;if(console.log(""),console.log(":",(U=r.value)==null?void 0:U.videoWidth,"x",(X=r.value)==null?void 0:X.videoHeight),r.value&&g.value)try{await r.value.play(),console.log("")}catch(te){console.warn(":",te)}},B=U=>{console.error(":",U),s("error","")},N=()=>{i.value&&i.value.click()},O=U=>{var ie;const X=U.target,te=(ie=X.files)==null?void 0:ie[0];if(te){const re=new FileReader;re.onload=he=>{var xe;const Se=(xe=he.target)==null?void 0:xe.result;s("photo-captured",Se),E()},re.onerror=()=>{s("error","")},re.readAsDataURL(te)}X.value=""},K=async U=>{U&&!p.value?await k():!U&&p.value&&E()};return Al(()=>{b(),x(),T(),document.addEventListener("fullscreenchange",R),document.addEventListener("webkitfullscreenchange",R),document.addEventListener("mozfullscreenchange",R),document.addEventListener("MSFullscreenChange",R),t.modelValue&&k()}),Fl(()=>{document.removeEventListener("fullscreenchange",R),document.removeEventListener("webkitfullscreenchange",R),document.removeEventListener("mozfullscreenchange",R),document.removeEventListener("MSFullscreenChange",R),E()}),Vr(()=>t.modelValue,K),(U,X)=>d.value?(lt(),dt(ks,{key:0},[Ve("input",{ref_key:"fileInputRef",ref:i,type:"file",accept:"image/*",capture:"environment",onChange:O,style:{display:"none"}},null,544),Ve("button",{onClick:N,class:"glass-btn w-full flex-center gap-2 bg-green-500/20 hover:bg-green-500/30 border-green-500/30"},[...X[0]||(X[0]=[Ve("div",{class:"i-carbon-camera text-lg"},null,-1),Ve("span",null,"Take Photo",-1)])])],64)):(lt(),dt("div",Lae,[Ve("template",null,[Ve("video",{ref_key:"videoRef",ref:r,autoplay:"",muted:"",playsinline:"","webkit-playsinline":"",class:In(["w-full h-full object-cover",{"fixed inset-0 z-50":h.value}]),onLoadedmetadata:_,onError:B,onClick:F,onTouchstart:z},null,34),h.value?(lt(),dt("div",Oae,[Ve("button",{onClick:C,disabled:l.value,class:"w-16 h-16 rounded-full border-4 border-white bg-white/20 backdrop-blur-md flex-center active:scale-95 transition-transform"},[...X[1]||(X[1]=[Ve("div",{class:"w-12 h-12 rounded-full bg-white"},null,-1)])],8,Mae),f.value?(lt(),dt("button",{key:0,onClick:I,class:"absolute right-8 bottom-4 glass-btn rounded-full p-3"},[...X[2]||(X[2]=[Ve("div",{class:"i-carbon-camera-action text-xl"},null,-1)])])):yn("",!0),Ve("button",{onClick:D,class:"absolute left-8 bottom-4 glass-btn rounded-full p-3"},[...X[3]||(X[3]=[Ve("div",{class:"i-carbon-minimize text-xl"},null,-1)])])])):(lt(),dt("div",zae,[Ve("button",{onClick:C,disabled:l.value,class:"glass-btn rounded-full p-3 bg-white/20 hover:bg-white/30 border-white/40"},[...X[4]||(X[4]=[Ve("div",{class:"i-carbon-camera text-xl"},null,-1)])],8,Bae),f.value?(lt(),dt("button",{key:0,onClick:I,class:"glass-btn rounded-full p-3"},[...X[5]||(X[5]=[Ve("div",{class:"i-carbon-camera-action text-xl"},null,-1)])])):yn("",!0),c.value?(lt(),dt("button",{key:1,onClick:P,class:"glass-btn rounded-full p-3"},[...X[6]||(X[6]=[Ve("div",{class:"i-carbon-maximize text-xl"},null,-1)])])):yn("",!0)]))])]))}}),Uae={class:"flex flex-col w-full gap-3"},Gae=["onMouseenter","onMouseleave","aria-label","aria-disabled","aria-readonly","aria-valuemin","aria-valuemax","aria-valuenow","aria-valuetext"],Wae=["innerHTML"],Hae={key:2,class:"absolute inset-0 pointer-events-none"},Kae={class:"bg-gray-900 text-white px-2 py-1 rounded shadow-lg text-sm whitespace-nowrap"},jae=["id","value","min","max","step","disabled","readonly","onInput","onChange","onKeydown","onMouseenter","onMouseleave"],Xae=["id","onMousedown","onTouchstart","onKeydown","onMouseenter","onMouseleave","tabindex","aria-label","aria-disabled","aria-readonly","aria-valuemin","aria-valuemax","aria-valuenow","aria-valuetext"],qae=vo({__name:"Slider",props:{items:{type:Array,required:!0,default:()=>[]}},emits:["updateValue"],setup(n,{emit:e}){const t={toInteger(_,B){const N=Math.pow(10,B);return Math.round(_*N)},fromInteger(_,B){const N=Math.pow(10,B);return _/N},add(_,B,N){const O=this.toInteger(_,N),K=this.toInteger(B,N);return this.fromInteger(O+K,N)},subtract(_,B,N){const O=this.toInteger(_,N),K=this.toInteger(B,N);return this.fromInteger(O-K,N)},multiply(_,B,N){const O=this.toInteger(_,N),K=this.toInteger(B,N),U=Math.pow(10,N);return O*K/(U*U)},divide(_,B,N){if(B===0)return 0;const O=this.toInteger(_,N),K=this.toInteger(B,N);return O/K},round(_,B){const N=this.toInteger(_,B);return this.fromInteger(N,B)},getPrecisionFromStep(_){if(_>=1)return 0;const B=_.toString();if(B.indexOf(".")!==-1){const N=B.split(".")[1];return N?N.length:0}if(B.indexOf("e-")!==-1){const N=B.split("e-")[1];return N?parseInt(N,10):0}return 0}},s=n,r=e,i=tt(new Map),o=tt(new Map),a=tt(new Set),u=tt(null),l=_=>{const B=_.value;let N=_.precision!==void 0?_.precision:0;N===0&&_.step&&_.step<1&&(N=t.getPrecisionFromStep(_.step));const O=t.round(B,N);return N>0?O.toFixed(N):O.toString()},h=(_,B)=>{if(B.step===void 0||B.step<=0)return _;const N=B.step,O=B.min;let K=B.precision!==void 0?B.precision:t.getPrecisionFromStep(N);const U=t.subtract(_,O,K),X=t.round(t.divide(U,N,K),0)*N,te=t.add(O,X,K);return Math.max(B.min,Math.min(B.max,te))},c=(_,B)=>{const N=B.target,O=s.items.find(K=>K.id===_);if(O){let K=Number(N.value);K=h(K,O),O.liveUpdate!==!1&&r("updateValue",{id:_,value:K})}},d=(_,B)=>{const N=B.target,O=s.items.find(K=>K.id===_);if(O&&O.liveUpdate===!1){let K=Number(N.value);K=h(K,O),r("updateValue",{id:_,value:K})}},p=(_,B)=>{const N=s.items.find(U=>U.id===_);if(!N||!N.keyboardSupport)return;let O=N.value;const K=N.step||1;switch(B.key){case"ArrowLeft":case"ArrowDown":O=Math.max(N.min,O-K);break;case"ArrowRight":case"ArrowUp":O=Math.min(N.max,O+K);break;case"Home":O=N.min;break;case"End":O=N.max;break;case"PageDown":O=Math.max(N.min,O-K*10);break;case"PageUp":O=Math.min(N.max,O+K*10);break;default:return}B.preventDefault(),O=h(O,N),r("updateValue",{id:_,value:O})},f=_=>{const B=_.min,N=_.max;let O=(_.value-B)/(N-B)*100;return _.reverse&&(O=100-O),O},g=_=>_.vertical?{backgroundImage:`
        repeating-linear-gradient(0deg, rgba(255, 255, 255, 0.5) 0, rgba(255, 255, 255, 0.5) 1px, transparent 1px, transparent 10%),
        repeating-linear-gradient(0deg, rgba(255, 255, 255, 0.3) 0, rgba(255, 255, 255, 0.3) 1px, transparent 1px, transparent 2%)
      `,backgroundSize:"8px 100%, 5px 100%",backgroundPosition:"top left, top left",backgroundRepeat:"no-repeat"}:{backgroundImage:`
      repeating-linear-gradient(90deg, rgba(255, 255, 255, 0.5) 0, rgba(255, 255, 255, 0.5) 1px, transparent 1px, transparent 10%),
      repeating-linear-gradient(90deg, rgba(255, 255, 255, 0.3) 0, rgba(255, 255, 255, 0.3) 1px, transparent 1px, transparent 2%)
    `,backgroundSize:"100% 8px, 100% 5px",backgroundPosition:"top left, top left",backgroundRepeat:"no-repeat"},m=(_,B)=>{let N=(B.value-_.min)/(_.max-_.min)*100;return _.reverse&&(N=100-N),_.vertical?{bottom:`${N}%`,left:"50%",...B.style}:{left:`${N}%`,top:"50%",...B.style}},b=_=>{const B=f(_);return _.vertical?{bottom:`${B}%`}:{left:`${B}%`}},x=_=>_.tooltipFormatter?_.tooltipFormatter(_.value,_.label):`${_.label}: ${_.value}`,v=_=>{const B=f(_),N=_.tooltipPosition||"top",O={},K=document.getElementById(_.id);if(K){const U=K.getBoundingClientRect(),X=window.pageYOffset||document.documentElement.scrollTop,te=window.pageXOffset||document.documentElement.scrollLeft;N==="top"?(O.left=`${U.left+te+U.width*B/100}px`,O.top=`${U.top+X-8}px`,O.transform="translateX(-50%) translateY(-100%)"):N==="bottom"?(O.left=`${U.left+te+U.width*B/100}px`,O.top=`${U.top+X+U.height+8}px`,O.transform="translateX(-50%)"):N==="left"?(O.left=`${U.left+te+U.width*B/100-8}px`,O.top=`${U.top+X+U.height/2}px`,O.transform="translateX(-100%) translateY(-50%)"):N==="right"&&(O.left=`${U.left+te+U.width*B/100+8}px`,O.top=`${U.top+X+U.height/2}px`,O.transform="translateY(-50%)")}return O},w=_=>{a.value.add(_)},S=_=>{a.value.delete(_)};Vr(()=>s.items,_=>{_.forEach(B=>{const N=i.value.get(B.id);N&&N.value!==String(B.value)&&(N.value=String(B.value))})},{deep:!0});const k=(_,B)=>{B?i.value.set(_,B):i.value.delete(_)},E=(_,B)=>{B?o.value.set(_,B):o.value.delete(_)},I=(_,B)=>{const N=o.value.get(_.id);if(!N)return _.value;const O=N.getBoundingClientRect(),K=B-O.top,U=Math.max(0,Math.min(1,1-K/O.height));let X=_.precision!==void 0?_.precision:0;X===0&&_.step&&_.step<1&&(X=t.getPrecisionFromStep(_.step));const te=t.subtract(_.max,_.min,X);let ie=t.add(_.min,t.multiply(U,te,X),X);return ie=h(ie,_),Math.max(_.min,Math.min(_.max,ie))},C=(_,B)=>{const N=s.items.find(K=>K.id===_);if(!N||N.disabled||N.readonly)return;B.preventDefault(),u.value=_;const O=I(N,B.clientY);r("updateValue",{id:_,value:O}),document.addEventListener("mousemove",R),document.addEventListener("mouseup",D)},T=(_,B)=>{const N=s.items.find(K=>K.id===_);if(!N||N.disabled||N.readonly)return;B.preventDefault(),u.value=_;const O=B.touches[0];if(O){const K=I(N,O.clientY);r("updateValue",{id:_,value:K})}document.addEventListener("touchmove",P,{passive:!1}),document.addEventListener("touchend",F)},R=_=>{if(!u.value)return;const B=s.items.find(O=>O.id===u.value);if(!B)return;const N=I(B,_.clientY);r("updateValue",{id:u.value,value:N})},P=_=>{if(!u.value)return;_.preventDefault();const B=s.items.find(O=>O.id===u.value);if(!B)return;const N=_.touches[0];if(N){const O=I(B,N.clientY);r("updateValue",{id:u.value,value:O})}},D=()=>{u.value=null,document.removeEventListener("mousemove",R),document.removeEventListener("mouseup",D)},F=()=>{u.value=null,document.removeEventListener("touchmove",P),document.removeEventListener("touchend",F)},z=(_,B)=>{const N=s.items.find(U=>U.id===_);if(!N||!N.keyboardSupport||N.disabled||N.readonly)return;let O=N.value;const K=N.step||1;switch(B.key){case"ArrowUp":O=Math.min(N.max,O+K);break;case"ArrowDown":O=Math.max(N.min,O-K);break;case"Home":O=N.max;break;case"End":O=N.min;break;case"PageUp":O=Math.min(N.max,O+K*10);break;case"PageDown":O=Math.max(N.min,O-K*10);break;default:return}B.preventDefault(),O=h(O,N),r("updateValue",{id:_,value:O})};return Fl(()=>{document.removeEventListener("mousemove",R),document.removeEventListener("mouseup",D),document.removeEventListener("touchmove",P),document.removeEventListener("touchend",F)}),(_,B)=>(lt(),dt("div",Uae,[(lt(!0),dt(ks,null,qb(n.items,N=>(lt(),dt("div",{key:N.id,class:"w-full"},[Ve("div",{class:In(["relative rounded-lg overflow-hidden bg-[#333] group",{"w-full h-9":!N.vertical,"h-48 w-9":N.vertical,"opacity-50 cursor-not-allowed":N.disabled,"cursor-ew-resize":!N.disabled&&!N.vertical,"cursor-ns-resize":!N.disabled&&N.vertical}]),onMouseenter:()=>w(N.id),onMouseleave:()=>S(N.id),"aria-label":N.ariaLabel||N.label,"aria-disabled":N.disabled,"aria-readonly":N.readonly,"aria-valuemin":N.min,"aria-valuemax":N.max,"aria-valuenow":N.value,"aria-valuetext":`${N.label}: ${l(N)}`},[Ve("div",{class:In(["absolute inset-0 z-10",{"w-full h-full":!N.vertical,"h-full w-full":N.vertical}]),style:lr({background:N.gradient})},[N.backgroundSvg?(lt(),dt("div",{key:0,class:"absolute inset-0 opacity-50 pointer-events-none",innerHTML:N.backgroundSvg},null,8,Wae)):yn("",!0),N.showRuler?(lt(),dt("div",{key:1,class:In(["absolute inset-0 pointer-events-none opacity-0 transition-opacity duration-200 ease-in-out",{"opacity-100":N.showRuler&&N.rulerMode==="always","group-hover:opacity-100":N.showRuler&&N.rulerMode==="hover"}]),style:lr(g(N))},null,6)):yn("",!0),N.marks&&N.marks.length>0?(lt(),dt("div",Hae,[(lt(!0),dt(ks,null,qb(N.marks,O=>(lt(),dt("div",{key:O.value,class:In(["absolute w-2 h-2 bg-white rounded-full transform -translate-x-1/2 -translate-y-1/2",{"w-1 h-1":N.size==="small","w-3 h-3":N.size==="large"}]),style:lr(m(N,O))},[O.label?(lt(),dt("span",{key:0,class:In(["absolute text-xs text-white whitespace-nowrap",{"top-4 left-1/2 transform -translate-x-1/2":!N.vertical,"left-4 top-1/2 transform -translate-y-1/2":N.vertical}]),style:lr(O.style)},mr(O.label),7)):yn("",!0)],6))),128))])):yn("",!0),Ve("div",{class:In(["absolute bg-white/90 pointer-events-none z-20",{"top-0 bottom-0 w-0.5 -translate-x-1/2":!N.vertical,"left-0 right-0 h-0.5 -translate-y-1/2":N.vertical}]),style:lr(b(N))},null,6)],6),Ve("div",{class:In(["absolute inset-0 flex justify-between items-center px-3 z-30 pointer-events-none box-border",{"w-full h-full flex-row":!N.vertical,"h-full w-full flex-col":N.vertical}])},[Ve("span",{class:In(["text-sm font-medium text-white/90",{"text-xs":N.size==="small","text-base":N.size==="large"}]),style:{"text-shadow":"0 1px 2px rgba(0,0,0,0.6)"}},mr(N.label),3),Ve("span",{class:In(["font-semibold font-mono text-white/90",{"text-sm":N.size==="small","text-lg":N.size==="large","text-base":!N.size||N.size==="medium"}]),style:{"text-shadow":"0 1px 2px rgba(0,0,0,0.6)"}},mr(l(N)),3)],2),(lt(),Iw(WT,{to:"body"},[N.showTooltip?(lt(),dt("div",{key:0,class:In(["absolute z-[200] pointer-events-none transition-opacity duration-200 ease-in-out opacity-0",{"opacity-100":N.tooltipMode==="always"||a.value.has(N.id)}]),style:lr(v(N))},[Ve("div",Kae,mr(x(N)),1)],6)):yn("",!0)])),N.vertical?(lt(),dt("div",{key:1,id:N.id,class:In(["absolute inset-0 opacity-0 z-[100] m-0 p-0",{"h-full w-full":N.vertical,"cursor-not-allowed":N.disabled,"cursor-ns-resize":!N.disabled&&N.vertical}]),ref_for:!0,ref:O=>E(N.id,O),onMousedown:O=>C(N.id,O),onTouchstart:O=>T(N.id,O),onKeydown:O=>z(N.id,O),onMouseenter:()=>w(N.id),onMouseleave:()=>S(N.id),tabindex:N.disabled||N.readonly?-1:0,"aria-label":N.ariaLabel||N.label,"aria-disabled":N.disabled,"aria-readonly":N.readonly,"aria-valuemin":N.min,"aria-valuemax":N.max,"aria-valuenow":N.value,"aria-valuetext":`${N.label}: ${l(N)}`},null,42,Xae)):(lt(),dt("input",{key:0,id:N.id,value:N.value,type:"range",class:In(["absolute inset-0 opacity-0 z-[100] m-0 p-0",{"w-full h-full":!N.vertical,"cursor-not-allowed":N.disabled,"cursor-ew-resize":!N.disabled&&!N.vertical}]),min:N.min,max:N.max,step:N.step||1,disabled:N.disabled,readonly:N.readonly,ref_for:!0,ref:O=>k(N.id,O),onInput:O=>c(N.id,O),onChange:O=>d(N.id,O),onKeydown:O=>p(N.id,O),onMouseenter:()=>w(N.id),onMouseleave:()=>S(N.id)},null,42,jae))],42,Gae)]))),128))]))}}),Yo=n=>({type:"button-click",detail:{action:n}}),Vi=(n,e)=>({type:"update-data",detail:{action:n,data:e}}),Yae={class:"flex flex-col gap-4"},Zae={class:"flex flex-col gap-2"},Qae={class:"flex items-center justify-between"},Jae={class:"flex gap-2"},eue=["disabled"],tue=["disabled"],nue={class:"glass-input flex items-center justify-between cursor-pointer hover:bg-glass-300 group"},sue={class:"text-sm truncate opacity-80 group-hover:opacity-100"},rue={key:0,class:"flex flex-col gap-4 animate-fade-in"},iue={class:"bg-darkglass-200 rounded-xl p-3 border border-glass-100"},oue={class:"grid grid-cols-2 gap-3"},aue=["disabled"],uue={key:0,class:"i-carbon-circle-dash animate-spin"},lue={key:1,class:"i-carbon-magic-wand"},_k=vo({__name:"Controls",props:{isProcessing:{type:Boolean},cameraActive:{type:Boolean},supportsNativeCamera:{type:Boolean},originalImage:{},processedImage:{},maxResolution:{},borderSize:{},splitPosition:{},magnifierEnabled:{type:Boolean},zoomLevel:{}},emits:["controlEvent"],setup(n,{emit:e}){const t=n,s=fl(()=>{const v=[];return t.originalImage&&(v.push({id:"max-resolution",label:"Max Res",value:t.maxResolution,min:512,max:4096,step:128,valuePosition:"after",showRuler:!1}),v.push({id:"border-size",label:"Border (%)",value:t.borderSize,min:5,max:100,step:1,valuePosition:"after",showRuler:!1}),v.push({id:"zoom-level",label:"Zoom",value:t.zoomLevel,min:.01,max:5,step:.01,valuePosition:"after",showRuler:!1})),t.processedImage&&v.push({id:"split-position",label:"Split Pos",value:t.splitPosition,min:0,max:1,step:.01,valuePosition:"after",showRuler:!1}),v}),r=e,i=v=>{r("controlEvent",Vi("image-upload",v))},o=()=>{r("controlEvent",Yo("load-sample-image"))},a=()=>{r("controlEvent",Yo("toggle-camera"))},u=v=>{r("controlEvent",Vi("photo-captured",v))},l=v=>{r("controlEvent",Vi("camera-error",v))},h=v=>{r("controlEvent",Vi("max-resolution",v))},c=v=>{r("controlEvent",Vi("border-size",v))},d=()=>{r("controlEvent",Yo("process-image"))},p=v=>{r("controlEvent",Vi("split-position",v))},f=()=>{r("controlEvent",Yo("toggle-magnifier"))},g=v=>{r("controlEvent",Vi("zoom-level",v))},m=({id:v,value:w})=>{switch(v){case"max-resolution":h(w);break;case"border-size":c(w);break;case"split-position":p(w);break;case"zoom-level":g(w);break}},b=()=>{r("controlEvent",Yo("reset-zoom"))},x=()=>{r("controlEvent",Yo("save-result"))};return(v,w)=>(lt(),dt("div",Yae,[Ve("div",Zae,[Ve("div",Qae,[w[0]||(w[0]=Ve("span",{class:"text-sm font-medium text-gray-200"},"Image Source",-1)),Ve("div",Jae,[Ve("button",{onClick:o,disabled:n.isProcessing,class:"glass-btn text-xs py-1 px-3"}," Sample ",8,eue),n.supportsNativeCamera?yn("",!0):(lt(),dt("button",{key:0,onClick:a,disabled:n.isProcessing,class:"glass-btn text-xs py-1 px-3 bg-green-500/20 hover:bg-green-500/30 border-green-500/30"},mr(n.cameraActive?"Close Cam":"Open Cam"),9,tue))])]),Ve("label",nue,[Ve("span",sue,mr(n.originalImage?"Change Image":"Select Image"),1),w[1]||(w[1]=Ve("div",{class:"i-carbon-image text-lg opacity-80"},null,-1)),Ve("input",{type:"file",accept:"image/*",onChange:i,class:"hidden"},null,32)])]),Ln(Vae,{modelValue:n.cameraActive,"onUpdate:modelValue":a,onPhotoCaptured:u,onError:l,class:"rounded-xl overflow-hidden shadow-glass"},null,8,["modelValue"]),n.originalImage||n.processedImage?(lt(),dt("div",rue,[Ve("div",iue,[Ln(hg(qae),{items:s.value,onUpdateValue:m},null,8,["items"])]),Ve("div",oue,[n.originalImage?(lt(),dt("button",{key:0,onClick:d,disabled:n.isProcessing||!n.originalImage,class:"glass-btn bg-blue-500/20 hover:bg-blue-500/30 border-blue-500/30 w-full flex-center gap-2"},[n.isProcessing?(lt(),dt("div",uue)):(lt(),dt("div",lue)),Ve("span",null,mr(n.isProcessing?"Processing...":"Make Seamless"),1)],8,aue)):yn("",!0),n.originalImage?(lt(),dt("button",{key:1,onClick:b,class:"glass-btn w-full flex-center gap-2"},[...w[2]||(w[2]=[Ve("div",{class:"i-carbon-center-circle"},null,-1),Ve("span",null,"Reset Zoom",-1)])])):yn("",!0)]),n.processedImage?(lt(),dt("button",{key:0,onClick:x,class:"glass-btn w-full flex-center gap-2 bg-green-500/20 hover:bg-green-500/30 border-green-500/30"},[...w[3]||(w[3]=[Ve("div",{class:"i-carbon-save"},null,-1),Ve("span",null,"Save Result",-1)])])):yn("",!0),n.processedImage?(lt(),dt("button",{key:1,onClick:f,class:In(["glass-btn w-full flex-center gap-2",n.magnifierEnabled?"bg-purple-500/20 border-purple-500/30":""])},[w[4]||(w[4]=Ve("div",{class:"i-carbon-zoom-in"},null,-1)),Ve("span",null,mr(n.magnifierEnabled?"Disable Magnifier":"Enable Magnifier"),1)],2)):yn("",!0)])):yn("",!0)]))}});var Uo=class{createTimeoutPromise(n,e=3e4){return Promise.race([n,new Promise((t,s)=>{setTimeout(()=>{s(Error(`Image loading timeout after ${e}ms`))},e)})])}loadImageElement(n,e){return new Promise((t,s)=>{let r=new Image;e!=null&&e.crossOrigin&&(r.crossOrigin=e.crossOrigin),r.onload=()=>{t(r)},r.onerror=i=>{s(Error(`Failed to load image from ${n}: ${i}`))},r.src=n})}loadImageFromBlob(n,e){return new Promise((t,s)=>{let r=URL.createObjectURL(n);this.loadImageElement(r,e).then(i=>{URL.revokeObjectURL(r),t(i)}).catch(i=>{URL.revokeObjectURL(r),s(i)})})}loadImageFromArrayBuffer(n,e="image/jpeg",t){let s=new Blob([n],{type:e});return this.loadImageFromBlob(s,t)}validateImageElement(n){if(!n||n.width===0||n.height===0)throw Error("Invalid image: zero width or height")}validateCanvasElement(n){if(!n||n.width===0||n.height===0)throw Error("Invalid canvas: zero width or height")}createProgressFetch(n,e){return new Promise((t,s)=>{fetch(n).then(r=>{if(!r.ok)throw Error(`HTTP error! status: ${r.status}`);if(!r.body){t(r);return}let i=r.headers.get("content-length"),o=i?parseInt(i,10):0,a=0,u=r.body.getReader(),l=[],h=()=>{u.read().then(({done:c,value:d})=>{if(c){let p=l.reduce((b,x)=>b+x.length,0),f=new Uint8Array(p),g=0;for(let b of l)f.set(b,g),g+=b.length;let m=new Blob([f]);t(new Response(m,{status:r.status,statusText:r.statusText,headers:r.headers}));return}l.push(d),a+=d.length,e&&o>0&&e({progress:a/o,loaded:a,total:o}),h()}).catch(s)};h()}).catch(s)})}},cue=class extends Uo{constructor(...n){super(...n),this.name="UrlImageLoader"}canLoad(n){return typeof n=="string"&&(n.startsWith("http://")||n.startsWith("https://")||n.startsWith("data:image/")||n.startsWith("blob:")||n.startsWith("file:"))}async load(n,e){if(!this.canLoad(n))throw Error(`UrlImageLoader cannot load source: ${n}`);let t=this.loadImageElement(n,e);if(e!=null&&e.timeout)return this.createTimeoutPromise(t,e.timeout);let s=await t;return this.validateImageElement(s),s}},hue=class extends Uo{constructor(...n){super(...n),this.name="FileImageLoader"}canLoad(n){return n instanceof File}async load(n,e){if(!this.canLoad(n))throw Error(`FileImageLoader cannot load source: ${n}`);if(!this.isImageFile(n))throw Error(`Unsupported file type: ${n.type}. Expected an image file.`);let t=this.loadImageFromBlob(n,e);if(e!=null&&e.timeout)return this.createTimeoutPromise(t,e.timeout);let s=await t;return this.validateImageElement(s),s}isImageFile(n){return["image/jpeg","image/jpg","image/png","image/gif","image/webp","image/bmp","image/svg+xml","image/x-icon","image/vnd.microsoft.icon"].some(e=>n.type===e)}},due=class extends Uo{constructor(...n){super(...n),this.name="BlobImageLoader"}canLoad(n){return n instanceof Blob}async load(n,e){if(!this.canLoad(n))throw Error(`BlobImageLoader cannot load source: ${n}`);if(!this.isImageBlob(n))throw Error(`Unsupported blob type: ${n.type}. Expected an image blob.`);let t=this.loadImageFromBlob(n,e);if(e!=null&&e.timeout)return this.createTimeoutPromise(t,e.timeout);let s=await t;return this.validateImageElement(s),s}isImageBlob(n){return n.type?["image/jpeg","image/jpg","image/png","image/gif","image/webp","image/bmp","image/svg+xml","image/x-icon","image/vnd.microsoft.icon"].some(e=>n.type===e):!0}},pue=class extends Uo{constructor(...n){super(...n),this.name="ArrayBufferImageLoader"}canLoad(n){return n instanceof ArrayBuffer||n instanceof Uint8Array||n instanceof Uint8ClampedArray||n instanceof DataView}async load(n,e){if(!this.canLoad(n))throw Error(`ArrayBufferImageLoader cannot load source: ${n}`);let t;if(n instanceof ArrayBuffer)t=n;else if(n instanceof Uint8Array||n instanceof Uint8ClampedArray)t=n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength);else if(n instanceof DataView)t=n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength);else throw Error("Unsupported array buffer type");let s=(e==null?void 0:e.mimeType)||this.detectImageFormat(t);if(!s)if(e!=null&&e.width&&(e!=null&&e.height))s="image/raw-rgba";else throw Error("Unable to detect image format. Please specify mimeType option, or provide width/height for raw pixel data.");let r;if(s==="image/raw-rgba"){if(!(e!=null&&e.width)||!(e!=null&&e.height))throw Error("Width and height are required for raw RGBA data");r=this.loadRawRGBAData(t,e.width,e.height,e)}else r=this.loadImageFromArrayBuffer(t,s,e);if(e!=null&&e.timeout)return this.createTimeoutPromise(r,e.timeout);let i=await r;return this.validateImageElement(i),i}detectImageFormat(n){if(n.byteLength<3)return null;let e=new Uint8Array(n);if(e[0]===255&&e[1]===216&&e[2]===255)return"image/jpeg";if(n.byteLength>=8&&e[0]===137&&e[1]===80&&e[2]===78&&e[3]===71&&e[4]===13&&e[5]===10&&e[6]===26&&e[7]===10)return"image/png";if(n.byteLength>=4&&e[0]===71&&e[1]===73&&e[2]===70&&e[3]===56)return"image/gif";if(n.byteLength>=12&&e[0]===82&&e[1]===73&&e[2]===70&&e[3]===70&&e[8]===87&&e[9]===69&&e[10]===66&&e[11]===80)return"image/webp";if(n.byteLength>=2&&e[0]===66&&e[1]===77)return"image/bmp";let t=new TextDecoder("utf-8").decode(e.slice(0,Math.min(100,n.byteLength)));return t.includes("<svg")||t.includes("<?xml")?"image/svg+xml":null}async loadRawRGBAData(n,e,t,s){let r=e*t*4;if(n.byteLength<r)throw Error(`Buffer too small for ${e}x${t} RGBA image. Expected ${r} bytes, got ${n.byteLength}`);let i=document.createElement("canvas");i.width=e,i.height=t;let o=i.getContext("2d");if(!o)throw Error("Failed to get 2D context from canvas");let a=o.createImageData(e,t),u=new Uint8Array(n);return a.data.set(u.slice(0,r)),o.putImageData(a,0,0),new Promise((l,h)=>{let c=new Image;c.onload=()=>{l(c)},c.onerror=d=>{h(Error(`Failed to create image from canvas: ${d}`))},c.src=i.toDataURL("image/png")})}},fue=class extends Uo{constructor(...n){super(...n),this.name="ElementImageLoader"}canLoad(n){return n instanceof HTMLImageElement||n instanceof HTMLCanvasElement}async load(n,e){if(!this.canLoad(n))throw Error(`ElementImageLoader cannot load source: ${n}`);if(n instanceof HTMLImageElement)return n.complete||await new Promise((t,s)=>{let r=()=>{n.removeEventListener("load",r),n.removeEventListener("error",i),t()},i=o=>{n.removeEventListener("load",r),n.removeEventListener("error",i),s(Error(`Image failed to load: ${o}`))};n.addEventListener("load",r),n.addEventListener("error",i)}),this.validateImageElement(n),n;if(n instanceof HTMLCanvasElement)return this.validateCanvasElement(n),n;throw Error("Unsupported element type")}};function Dk(n){return typeof n=="object"&&!!n&&n.type==="texture"&&n.texture&&typeof n.texture=="object"&&n.device&&typeof n.device=="object"}function Ak(n){return typeof n=="object"&&!!n&&n.type==="buffer"&&n.buffer&&typeof n.buffer=="object"&&n.device&&typeof n.device=="object"&&typeof n.width=="number"&&typeof n.height=="number"}function mue(n){return Dk(n)||Ak(n)}var fr=class{static isSupported(){return"gpu"in navigator}static async getAdapter(n){if(!this.isSupported())throw Error("WebGPU is not supported in this browser");return await navigator.gpu.requestAdapter(n)}static async getDevice(n,e){let t=n||await this.getAdapter();if(!t)throw Error("Failed to get WebGPU adapter");return await t.requestDevice(e)}static async textureToCanvas(n,e,t){if(!n||!e)throw Error("Invalid texture or device");let s=document.createElement("canvas");s.width=n.width,s.height=n.height;let r=s.getContext("2d");if(!r)throw Error("Failed to get 2D context from canvas");try{let i=n.width*n.height*4,o=e.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"ReadbackBuffer"});try{let a=e.createCommandEncoder();a.copyTextureToBuffer({texture:n},{buffer:o,bytesPerRow:n.width*4},[n.width,n.height,1]),e.queue.submit([a.finish()]),await e.queue.onSubmittedWorkDone(),await o.mapAsync(GPUMapMode.READ);let u=o.getMappedRange(),l=new ImageData(new Uint8ClampedArray(u.slice(0)),n.width,n.height);return o.unmap(),r.putImageData(l,0,0),s}finally{o.destroy()}}catch(i){throw Error(`Failed to convert texture to canvas: ${i}`)}}static async bufferToCanvas(n,e,t,s,r,i){if(!n||!e)throw Error("Invalid buffer or device");let o=document.createElement("canvas");o.width=t,o.height=s;let a=o.getContext("2d");if(!a)throw Error("Failed to get 2D context from canvas");let u;try{let l=e.createBuffer({size:n.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"ReadbackBuffer"});try{let c=e.createCommandEncoder();c.copyBufferToBuffer(n,0,l,0,n.size),e.queue.submit([c.finish()]),await e.queue.onSubmittedWorkDone(),await l.mapAsync(GPUMapMode.READ),u=l.getMappedRange().slice(0),l.unmap()}finally{l.destroy()}let h=new ImageData(new Uint8ClampedArray(u),t,s);return a.putImageData(h,0,0),o}catch(l){throw Error(`Failed to convert buffer to canvas: ${l}`)}}static getFormatBytesPerPixel(n){switch(n){case"rgba8unorm":case"rgba8unorm-srgb":case"bgra8unorm":case"bgra8unorm-srgb":return 4;case"rgb9e5ufloat":case"rgb10a2unorm":case"rg11b10ufloat":return 4;case"depth32float":return 4;case"depth24plus":case"depth24plus-stencil8":return 4;default:return 4}}},gue=class extends Uo{constructor(...n){super(...n),this.name="WebGPUTextureLoader"}canLoad(n){return Dk(n)}async load(n,e){if(!this.canLoad(n))throw Error(`WebGPUTextureLoader cannot load source: ${n}`);if(!fr.isSupported())throw Error("WebGPU is not supported in this browser");let{texture:t,device:s}=n;if(!t||!s)throw Error("Invalid WebGPU texture source: missing texture or device");try{let r=await fr.textureToCanvas(t,s,e);return this.validateCanvasElement(r),r}catch(r){throw Error(`Failed to load WebGPU texture: ${r}`)}}async loadWithDetails(n,e){if(!this.canLoad(n))throw Error(`WebGPUTextureLoader cannot load source: ${n}`);if(!fr.isSupported())throw Error("WebGPU is not supported in this browser");let{texture:t,device:s}=n;if(!t||!s)throw Error("Invalid WebGPU texture source: missing texture or device");let r=n.width||t.width,i=n.height||t.height,o=n.format||t.format||"rgba8unorm";try{let a=await fr.textureToCanvas(t,s,e);this.validateCanvasElement(a);let u={canvas:a,device:s,metadata:{width:r,height:i,format:o,sourceType:"texture"}};return e!=null&&e.preserveWebGPUObject&&(u.webGPUObject=t),u}catch(a){throw Error(`Failed to load WebGPU texture: ${a}`)}}static createSource(n,e,t){return{type:"texture",texture:n,device:e,width:(t==null?void 0:t.width)||n.width,height:(t==null?void 0:t.height)||n.height,format:(t==null?void 0:t.format)||n.format}}static async createTextureFromCanvas(n,e,t){if(!e)throw Error("Invalid GPU device");let s=(t==null?void 0:t.format)||"rgba8unorm",r=(t==null?void 0:t.usage)||GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,i=n.getContext("2d");if(!i)throw Error("Failed to get 2D context from canvas");let o=i.getImageData(0,0,n.width,n.height),a;try{a=e.createTexture({size:[n.width,n.height,1],format:s,usage:r,label:"CanvasTexture"})}catch(l){throw Error(`Failed to create GPU texture: ${l}`)}if(!a)throw Error("Failed to create GPU texture");let u;try{u=e.createBuffer({size:o.data.length,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,label:"CanvasTextureBuffer"})}catch(l){throw a.destroy(),Error(`Failed to create GPU buffer: ${l}`)}if(!u)throw a.destroy(),Error("Failed to create GPU buffer");try{e.queue.writeBuffer(u,0,o.data);let l=e.createCommandEncoder();l.copyBufferToTexture({buffer:u,bytesPerRow:n.width*4},{texture:a,mipLevel:0},[n.width,n.height,1]),e.queue.submit([l.finish()])}catch(l){throw u.destroy(),a.destroy(),Error(`Failed to create texture from canvas: ${l}`)}finally{u.destroy()}return a}},xue=class extends Uo{constructor(...n){super(...n),this.name="WebGPUBufferLoader"}canLoad(n){return Ak(n)}async load(n,e){if(!this.canLoad(n))throw Error(`WebGPUBufferLoader cannot load source: ${n}`);if(!fr.isSupported())throw Error("WebGPU is not supported in this browser");let{buffer:t,device:s,width:r,height:i,format:o}=n;if(!t||!s)throw Error("Invalid WebGPU buffer source: missing buffer or device");if(!r||!i)throw Error("Invalid WebGPU buffer source: missing width or height");try{let a=await fr.bufferToCanvas(t,s,r,i,o,e);return this.validateCanvasElement(a),a}catch(a){throw Error(`Failed to load WebGPU buffer: ${a}`)}}async loadWithDetails(n,e){if(!this.canLoad(n))throw Error(`WebGPUBufferLoader cannot load source: ${n}`);if(!fr.isSupported())throw Error("WebGPU is not supported in this browser");let{buffer:t,device:s,width:r,height:i,format:o}=n;if(!t||!s)throw Error("Invalid WebGPU buffer source: missing buffer or device");if(!r||!i)throw Error("Invalid WebGPU buffer source: missing width or height");try{let a=await fr.bufferToCanvas(t,s,r,i,o,e);this.validateCanvasElement(a);let u={canvas:a,device:s,metadata:{width:r,height:i,format:o,sourceType:"buffer"}};return e!=null&&e.preserveWebGPUObject&&(u.webGPUObject=t),u}catch(a){throw Error(`Failed to load WebGPU buffer: ${a}`)}}static createSource(n,e,t,s,r,i){let o=fr.getFormatBytesPerPixel(r),a=Math.ceil(t*o/256)*256;return{type:"buffer",buffer:n,device:e,width:t,height:s,format:r,bytesPerRow:(i==null?void 0:i.bytesPerRow)||a,rowsPerImage:(i==null?void 0:i.rowsPerImage)||s}}static async createBufferFromCanvas(n,e,t="rgba8unorm",s){if(!e)throw Error("Invalid GPU device");let r=n.getContext("2d");if(!r)throw Error("Failed to get 2D context from canvas");let i=r.getImageData(0,0,n.width,n.height),o=GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.STORAGE,a=(s==null?void 0:s.usage)||o,u;try{u=e.createBuffer({size:i.data.length,usage:a,label:"CanvasBuffer"})}catch(l){throw Error(`Failed to create GPU buffer: ${l}`)}if(!u)throw Error("Failed to create GPU buffer");try{if(a&GPUBufferUsage.MAP_WRITE){await u.mapAsync(GPUMapMode.WRITE);let l=u.getMappedRange();new Uint8Array(l).set(i.data),u.unmap()}else e.queue.writeBuffer(u,0,i.data)}catch(l){throw u.destroy(),Error(`Failed to write data to buffer: ${l}`)}return u}static createBufferFromArrayBuffer(n,e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC){let s=e.createBuffer({size:n.byteLength,usage:t});return e.queue.writeBuffer(s,0,n),s}static createBufferFromTypedArray(n,e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC){let s=e.createBuffer({size:n.byteLength,usage:t});return e.queue.writeBuffer(s,0,n.buffer),s}static async createTextureFromBuffer(n,e,t,s,r,i){if(!(n.usage&GPUBufferUsage.COPY_SRC))throw Error("Buffer must have COPY_SRC usage flag for copyBufferToTexture operation");let o=fr.getFormatBytesPerPixel(r),a=Math.ceil(t*o/256)*256,u=(i==null?void 0:i.bytesPerRow)||a,l=(i==null?void 0:i.usage)||GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,h=e.createTexture({size:[t,s,1],format:r,usage:l}),c=e.createCommandEncoder();return c.copyBufferToTexture({buffer:n,bytesPerRow:u},{texture:h,mipLevel:0},[t,s,1]),e.queue.submit([c.finish()]),h}},Qi,Qm,ar=(Qi=class{static getLoader(e){for(let t of this.loaders)if(t.canLoad(e))return t;return null}static async loadImage(e,t){let s=this.getLoader(e);if(!s)throw Error(`No suitable loader found for source: ${typeof e}`);try{return await s.load(e,t)}catch(r){throw Error(`Failed to load image with ${s.name}: ${r}`)}}static canLoad(e){return this.getLoader(e)!==null}static getAllLoaders(){return[...this.loaders]}static registerLoader(e,t=this.loaders.length){let s=this.loaders.findIndex(r=>r.name===e.name);s===-1?this.loaders.splice(t,0,e):this.loaders[s]=e}static removeLoader(e){let t=this.loaders.findIndex(s=>s.name===e);return t===-1?!1:(this.loaders.splice(t,1),!0)}static getSupportedTypes(){return["string (URL, Data URL, Blob URL)","HTMLImageElement","HTMLCanvasElement","File","Blob","ArrayBuffer","Uint8Array","Uint8ClampedArray","DataView","WebGPUTextureSource","WebGPUBufferSource"]}static isWebGPUSupported(){return"gpu"in navigator}static isWebGPUSource(e){return mue(e)}},Qm=new WeakMap,Bb(Qi,Qm,Qi.loaders=[new fue,new hue,new due,new pue,new gue,new xue,new cue]),Qi),bue=class{constructor(n,e){this.leftImg=null,this.rightImg=null,this.animationFrameId=null,this.listeners=new Map,this.boundHandlers={},this.isDragging=!1,this.mouseX=0,this.mouseY=0,this.isMouseOver=!1,this.scale=1,this.offsetX=0,this.offsetY=0,this.isPinching=!1,this.lastPinchDistance=0,this.sceneNeedsRedraw=!0,this.canvas=n;let t=n.getContext("2d");if(!t)throw Error("Could not get 2D context");this.ctx=t,this.offscreenCanvas=document.createElement("canvas");let s=this.offscreenCanvas.getContext("2d");if(!s)throw Error("Could not get offscreen 2D context");this.offscreenCtx=s,this.config=this.normalizeConfig(e),this.currentSplitPosition=this.config.splitPosition,this.initEvents(),this.loadImages()}normalizeConfig(n){return{leftImage:n.leftImage,rightImage:n.rightImage,width:n.width,height:n.height,splitPosition:n.splitPosition??.5,splitDirection:n.splitDirection??"vertical",magnifier:{enabled:!1,size:150,zoomLevel:2,followCursor:!0,...n.magnifier}}}update(n){let e=this.config.leftImage,t=this.config.rightImage,s=this.config.splitPosition;this.config=this.normalizeConfig({...this.config,...n}),s!==this.config.splitPosition&&(this.currentSplitPosition=this.config.splitPosition,this.sceneNeedsRedraw=!0),(this.canvas.width!==this.config.width||this.canvas.height!==this.config.height)&&(this.canvas.width=this.config.width,this.canvas.height=this.config.height),e!==this.config.leftImage||t!==this.config.rightImage?this.loadImages():this.sceneNeedsRedraw&&this.render()}async loadImages(){try{let n=async s=>{if(s&&typeof s=="object"&&"source"in s&&"width"in s&&"height"in s){let{source:r,width:i,height:o,mimeType:a}=s;return ar.loadImage(r,{width:i,height:o,mimeType:a})}return ar.loadImage(s)},[e,t]=await Promise.all([n(this.config.leftImage),n(this.config.rightImage)]);this.leftImg=e,this.rightImg=t,this.canvas.width=this.config.width,this.canvas.height=this.config.height,this.sceneNeedsRedraw=!0,this.render(),this.emit("image-load","all")}catch(n){console.error("Failed to load images",n),this.emit("image-load","error")}}initEvents(){let n=a=>{let u=this.canvas.getBoundingClientRect(),l="touches"in a&&a.touches&&a.touches[0]?a.touches[0].clientX:a.clientX,h="touches"in a&&a.touches&&a.touches[0]?a.touches[0].clientY:a.clientY;return{x:l-u.left,y:h-u.top}},e=a=>{let u=this.canvas.getBoundingClientRect(),l="touches"in a&&a.touches&&a.touches[0]?a.touches[0].clientX:a.clientX,h="touches"in a&&a.touches&&a.touches[0]?a.touches[0].clientY:a.clientY;return{x:l-u.left,y:h-u.top}},t=a=>Math.hypot(a.touches[0].clientX-a.touches[1].clientX,a.touches[0].clientY-a.touches[1].clientY),s=a=>{let u=this.canvas.getBoundingClientRect();return{x:(a.touches[0].clientX+a.touches[1].clientX)/2-u.left,y:(a.touches[0].clientY+a.touches[1].clientY)/2-u.top}},r=a=>{if(window.TouchEvent&&a instanceof TouchEvent&&a.touches.length===2){this.isPinching=!0,this.isDragging=!1,this.lastPinchDistance=t(a),a.preventDefault();return}let{x:u,y:l}=n(a);this.isDragging=!0,this.handleMove(u,l)},i=a=>{let{x:u,y:l}=n(a);this.mouseX=u,this.mouseY=l,this.isMouseOver=!0,this.emit("mouse-move",u,l),this.isDragging?this.handleMove(u,l):this.config.magnifier.enabled&&this.config.magnifier.followCursor&&(this.render(),this.emit("magnifier-move",u,l))},o=()=>{this.isDragging=!1,this.isPinching=!1};this.boundHandlers={mousedown:r,touchstart:r,windowMouseMove:a=>{if(this.isDragging){let{x:u,y:l}=e(a);this.mouseX=u,this.mouseY=l,this.isMouseOver=!1,this.emit("mouse-move",u,l),this.handleMove(u,l)}},windowTouchMove:a=>{if(this.isPinching&&a.touches.length===2){a.preventDefault();let u=t(a),l=s(a);if(this.lastPinchDistance>0){let h=u/this.lastPinchDistance,c=this.scale*h;if(c>=.01&&c<=1e3){let d=l.x,p=l.y,f=(d-this.offsetX)/this.scale,g=(p-this.offsetY)/this.scale;this.offsetX=d-f*c,this.offsetY=p-g*c,this.scale=c,this.sceneNeedsRedraw=!0,this.render()}}this.lastPinchDistance=u;return}if(this.isDragging){let{x:u,y:l}=e(a);this.mouseX=u,this.mouseY=l,this.isMouseOver=!1,this.handleMove(u,l)}},windowMouseUp:o,windowTouchEnd:o,canvasMouseMove:a=>{this.isDragging||i(a)},canvasTouchMove:a=>{this.isDragging||i(a)},canvasMouseLeave:()=>{this.isMouseOver=!1,this.isDragging=!1,this.render()},handleWheel:this.handleWheel.bind(this)},this.canvas.addEventListener("mousedown",this.boundHandlers.mousedown),this.canvas.addEventListener("touchstart",this.boundHandlers.touchstart),this.canvas.addEventListener("mousemove",this.boundHandlers.canvasMouseMove),this.canvas.addEventListener("touchmove",this.boundHandlers.canvasTouchMove),this.canvas.addEventListener("mouseleave",this.boundHandlers.canvasMouseLeave),window.addEventListener("mousemove",this.boundHandlers.windowMouseMove),window.addEventListener("touchmove",this.boundHandlers.windowTouchMove),window.addEventListener("mouseup",this.boundHandlers.windowMouseUp),window.addEventListener("touchend",this.boundHandlers.windowTouchEnd),this.canvas.addEventListener("wheel",this.boundHandlers.handleWheel,{passive:!1})}handleWheel(n){n.preventDefault();let e=this.canvas.getBoundingClientRect(),t=n.clientX-e.left,s=n.clientY-e.top,r=.1,i=n.deltaY<0?1+r:1/(1+r),o=this.scale*i;if(o<.01||o>1e3)return;let a=(t-this.offsetX)/this.scale,u=(s-this.offsetY)/this.scale;this.offsetX=t-a*o,this.offsetY=s-u*o,this.scale=o,this.sceneNeedsRedraw=!0,this.render()}handleMove(n,e){this.config.splitDirection==="vertical"?this.currentSplitPosition=Math.max(0,Math.min(1,n/this.config.width)):this.currentSplitPosition=Math.max(0,Math.min(1,e/this.config.height)),this.sceneNeedsRedraw=!0,this.render(),this.emit("split-change",this.currentSplitPosition)}render(){!this.leftImg||!this.rightImg||((this.offscreenCanvas.width!==this.config.width||this.offscreenCanvas.height!==this.config.height)&&(this.offscreenCanvas.width=this.config.width,this.offscreenCanvas.height=this.config.height,this.sceneNeedsRedraw=!0),this.sceneNeedsRedraw&&(this.sceneNeedsRedraw=(this.offscreenCtx.clearRect(0,0,this.config.width,this.config.height),this.drawSceneToContext(this.offscreenCtx,this.scale,this.offsetX,this.offsetY),!1)),this.ctx.clearRect(0,0,this.config.width,this.config.height),this.ctx.drawImage(this.offscreenCanvas,0,0),this.config.magnifier.enabled&&this.isMouseOver&&this.drawMagnifier())}drawSceneToContext(n,e,t,s){let r=this.config.width,i=this.config.height,o=this.config.splitDirection==="vertical"?r*this.currentSplitPosition:i*this.currentSplitPosition;this.drawTiledImageToContext(n,this.leftImg,r,i,e,t,s),n.save(),n.beginPath(),this.config.splitDirection==="vertical"?n.rect(o,0,r-o,i):n.rect(0,o,r,i-o),n.clip(),this.drawTiledImageToContext(n,this.rightImg,r,i,e,t,s),n.restore(),n.beginPath(),n.strokeStyle="#fff",n.lineWidth=2,this.config.splitDirection==="vertical"?(n.moveTo(o,0),n.lineTo(o,i)):(n.moveTo(0,o),n.lineTo(r,o)),n.stroke()}drawTiledImageToContext(n,e,t,s,r,i,o){let a=(0-i)/r,u=(0-o)/r,l=(t-i)/r,h=(s-o)/r,c=e.width,d=e.height;if(r<.5){let b=n.createPattern(e,"repeat");if(!b)return;n.save(),n.translate(i,o),n.scale(r,r),n.fillStyle=b;let x=a,v=u,w=l-a,S=h-u;n.fillRect(x,v,w,S),n.restore();return}let p=Math.floor(a/c),f=Math.floor(l/c),g=Math.floor(u/d),m=Math.floor(h/d);for(let b=p;b<=f;b++)for(let x=g;x<=m;x++){let v=b*c*r+i,w=x*d*r+o,S=c*r,k=d*r;v+S<0||v>t||w+k<0||w>s||n.drawImage(e,v,w,S,k)}}drawMagnifier(){let{size:n,zoomLevel:e}=this.config.magnifier,t=n/2,s=this.mouseX,r=this.mouseY;this.ctx.save(),this.ctx.beginPath(),this.ctx.arc(s,r,t,0,Math.PI*2),this.ctx.clip(),this.ctx.fillStyle="#fff",this.ctx.fill();let i=n/e,o=s-i/2,a=r-i/2;this.ctx.drawImage(this.offscreenCanvas,o,a,i,i,s-t,r-t,n,n),this.ctx.restore(),this.ctx.beginPath(),this.ctx.arc(s,r,t,0,Math.PI*2),this.ctx.strokeStyle="rgba(255, 255, 255, 0.8)",this.ctx.lineWidth=3,this.ctx.stroke(),this.ctx.shadowColor="rgba(0,0,0,0.3)",this.ctx.shadowBlur=10,this.ctx.stroke()}on(n,e){this.listeners.has(n)||this.listeners.set(n,new Set),this.listeners.get(n).add(e)}off(n,e){var t;(t=this.listeners.get(n))==null||t.delete(e)}setSplitPosition(n){let e=Math.max(0,Math.min(1,n));this.currentSplitPosition!==e&&(this.currentSplitPosition=e,this.sceneNeedsRedraw=!0,this.render(),this.emit("split-change",this.currentSplitPosition))}getSplitPosition(){return this.currentSplitPosition}setMagnifierPosition(n,e){this.mouseX=Math.max(0,Math.min(this.config.width,n)),this.mouseY=Math.max(0,Math.min(this.config.height,e)),this.config.magnifier.enabled&&(this.isMouseOver=!0,this.render(),this.emit("magnifier-move",this.mouseX,this.mouseY))}getMagnifierPosition(){return{x:this.mouseX,y:this.mouseY}}setZoom(n,e,t){let s=Math.max(.01,Math.min(1e3,n)),r=e===void 0?this.config.width/2:e,i=t===void 0?this.config.height/2:t,o=(r-this.offsetX)/this.scale,a=(i-this.offsetY)/this.scale;this.offsetX=r-o*s,this.offsetY=i-a*s,this.scale=s,this.sceneNeedsRedraw=!0,this.render()}getZoom(){return this.scale}setOffset(n,e){this.offsetX=n,this.offsetY=e,this.sceneNeedsRedraw=!0,this.render()}getOffset(){return{x:this.offsetX,y:this.offsetY}}resetZoom(){this.scale=1,this.offsetX=0,this.offsetY=0,this.sceneNeedsRedraw=!0,this.render()}emit(n,...e){var t;(t=this.listeners.get(n))==null||t.forEach(s=>s(...e))}destroy(){this.boundHandlers.mousedown&&this.canvas.removeEventListener("mousedown",this.boundHandlers.mousedown),this.boundHandlers.touchstart&&this.canvas.removeEventListener("touchstart",this.boundHandlers.touchstart),this.boundHandlers.canvasMouseMove&&this.canvas.removeEventListener("mousemove",this.boundHandlers.canvasMouseMove),this.boundHandlers.canvasTouchMove&&this.canvas.removeEventListener("touchmove",this.boundHandlers.canvasTouchMove),this.boundHandlers.canvasMouseLeave&&this.canvas.removeEventListener("mouseleave",this.boundHandlers.canvasMouseLeave),this.boundHandlers.handleWheel&&this.canvas.removeEventListener("wheel",this.boundHandlers.handleWheel),this.boundHandlers.windowMouseMove&&window.removeEventListener("mousemove",this.boundHandlers.windowMouseMove),this.boundHandlers.windowTouchMove&&window.removeEventListener("touchmove",this.boundHandlers.windowTouchMove),this.boundHandlers.windowMouseUp&&window.removeEventListener("mouseup",this.boundHandlers.windowMouseUp),this.boundHandlers.windowTouchEnd&&window.removeEventListener("touchend",this.boundHandlers.windowTouchEnd),this.listeners.clear(),this.leftImg=null,this.rightImg=null,this.animationFrameId!==null&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=null)}},yue=((n,e)=>{let t=n.__vccOpts||n;for(let[s,r]of e)t[s]=r;return t})(vo({__name:"SplitViewer",props:{leftImage:{},rightImage:{},width:{},height:{},splitPosition:{default:.5},splitDirection:{default:"vertical"},magnifier:{default:()=>({enabled:!1,size:150,zoomLevel:2,followCursor:!0})}},emits:["split-change","magnifier-move","image-load","mouse-move","webgpu-error"],setup(n,{expose:e,emit:t}){let s=n,r=t,i=tt(null),o=null,a=()=>{if(!i.value)return;let u=h=>ar.isWebGPUSource(h)&&!ar.isWebGPUSupported()?(r("webgpu-error","WebGPU is not supported in this browser"),!1):!0;if(!u(s.leftImage)||!u(s.rightImage))return;let l={leftImage:ht(s.leftImage),rightImage:ht(s.rightImage),width:s.width,height:s.height,splitPosition:s.splitPosition,splitDirection:s.splitDirection,magnifier:ht(s.magnifier)};try{o=new bue(i.value,l),o.on("split-change",h=>r("split-change",h)),o.on("magnifier-move",(h,c)=>r("magnifier-move",h,c)),o.on("image-load",h=>r("image-load",h)),o.on("mouse-move",(h,c)=>r("mouse-move",h,c))}catch(h){throw(ar.isWebGPUSource(s.leftImage)||ar.isWebGPUSource(s.rightImage))&&r("webgpu-error",`Failed to initialize WebGPU viewer: ${h}`),h}};return Vr(()=>s,u=>{if(o){let l=h=>ar.isWebGPUSource(h)&&!ar.isWebGPUSupported()?(r("webgpu-error","WebGPU is not supported in this browser"),!1):!0;if(!l(u.leftImage)||!l(u.rightImage))return;try{o.update({leftImage:ht(u.leftImage),rightImage:ht(u.rightImage),width:u.width,height:u.height,splitPosition:u.splitPosition,splitDirection:u.splitDirection,magnifier:ht(u.magnifier)})}catch(h){throw(ar.isWebGPUSource(u.leftImage)||ar.isWebGPUSource(u.rightImage))&&r("webgpu-error",`Failed to update WebGPU viewer: ${h}`),h}}},{deep:!0}),Al(()=>{a()}),Fl(()=>{o&&(o=(o.destroy(),null))}),e({setSplitPosition:u=>{o&&o.setSplitPosition(u)},getSplitPosition:()=>o?o.getSplitPosition():0,setMagnifierPosition:(u,l)=>{o&&o.setMagnifierPosition(u,l)},getMagnifierPosition:()=>o?o.getMagnifierPosition():{x:0,y:0},setZoom:(u,l,h)=>{o&&o.setZoom(u,l,h)},getZoom:()=>o?o.getZoom():1,setOffset:(u,l)=>{o&&o.setOffset(u,l)},getOffset:()=>o?o.getOffset():{x:0,y:0},resetZoom:()=>{o&&o.resetZoom()}}),(u,l)=>(lt(),dt("div",{class:"split-viewer-container",style:lr({width:n.width+"px",height:n.height+"px"})},[Ve("canvas",{ref_key:"canvasRef",ref:i},null,512)],4))}}),[["__scopeId","data-v-7082c7df"]]);const wue={class:"relative w-full h-full flex-center bg-darkglass-100"},vue={key:0,class:"w-full h-full relative"},Cue={key:1,class:"absolute inset-0 z-10 flex-col-center bg-black/50 backdrop-blur-sm text-white"},Sue={key:2,class:"absolute top-4 left-4 right-4 z-20 p-4 bg-red-500/20 border border-red-500/40 rounded-xl backdrop-blur-md text-red-200 flex items-center gap-3 animate-fade-in"},Iue={key:3,class:"flex-col-center text-white/30 gap-4"},Fk=vo({__name:"Viewer",props:{originalImage:{},processedImage:{},splitPosition:{},magnifierEnabled:{type:Boolean},isProcessing:{type:Boolean},errorMessage:{},zoomLevel:{}},emits:["update:splitPosition","image-load"],setup(n,{expose:e,emit:t}){const s=n,r=t,i=tt(),o=fl(()=>({enabled:s.magnifierEnabled,size:150,zoomLevel:2,followCursor:!0})),a=c=>{r("update:splitPosition",c)},u=async c=>{console.log("Image loaded:",c),(c==="all"||c==="left")&&(await Rh(),i.value&&i.value.setZoom(s.zoomLevel))},l=async()=>{await Rh(),i.value&&i.value.setZoom(s.zoomLevel)},h=async()=>{await Rh(),i.value&&i.value.resetZoom()};return Vr(()=>s.zoomLevel,l),e({resetZoom:h}),(c,d)=>(lt(),dt("div",wue,[n.originalImage?(lt(),dt("div",vue,[Ln(hg(yue),{ref_key:"splitViewerRef",ref:i,leftImage:n.originalImage,rightImage:n.processedImage||n.originalImage,width:1e3,height:600,splitPosition:n.splitPosition,magnifier:o.value,onSplitChange:a,onImageLoad:u,class:"w-full h-full"},null,8,["leftImage","rightImage","splitPosition","magnifier"])])):yn("",!0),n.isProcessing?(lt(),dt("div",Cue,[...d[0]||(d[0]=[Ve("div",{class:"i-carbon-circle-dash animate-spin text-4xl mb-4 text-blue-400"},null,-1),Ve("div",{class:"text-lg font-medium tracking-wide"},"Processing Image...",-1)])])):yn("",!0),n.errorMessage?(lt(),dt("div",Sue,[d[1]||(d[1]=Ve("div",{class:"i-carbon-warning-filled text-xl text-red-400"},null,-1)),Ve("span",null,mr(n.errorMessage),1)])):yn("",!0),!n.originalImage&&!n.isProcessing?(lt(),dt("div",Iue,[...d[2]||(d[2]=[Ve("div",{class:"i-carbon-image text-6xl"},null,-1),Ve("div",{class:"text-lg"},"No Image Selected",-1)])])):yn("",!0)]))}}),$ue={class:"mobile-container flex flex-col"},kue={class:"flex-1 relative overflow-hidden flex flex-col"},Tue={class:"flex-1 relative z-0 overflow-hidden m-4 mt-0 rounded-3xl shadow-inner bg-darkglass-200"},Eue={class:"z-20 p-4 glass-panel m-4 mt-0 max-h-[40vh] overflow-y-auto scrollbar-hide"},Rue=vo({__name:"App",setup(n){const e=tt(null),t=tt(null),s=tt(null),r=tt(20),i=tt(4096),o=tt(.5),a=tt(!1),u=tt(""),l=tt(),h=tt(!1),c=tt(!1),d=tt(!1),p=tt(1),f=tt(!0),g=()=>{const P=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);d.value=P;const D="capture"in document.createElement("input");c.value=P&&D};Al(()=>{g()});const m=P=>{const{type:D,detail:F}=P;if(D==="button-click")switch(F.action){case"load-sample-image":x();break;case"toggle-camera":v();break;case"process-image":I();break;case"toggle-magnifier":C();break;case"reset-zoom":T();break;case"save-result":R();break}else if(D==="update-data")switch(F.action){case"image-upload":b(F.data);break;case"photo-captured":w(F.data);break;case"camera-error":S(F.data);break;case"max-resolution":i.value=F.data;break;case"border-size":r.value=F.data;break;case"split-position":o.value=F.data;break;case"zoom-level":p.value=F.data;break}},b=P=>{var z;const F=(z=P.target.files)==null?void 0:z[0];if(F){const _=new FileReader;_.onload=B=>{var N;t.value=(N=B.target)==null?void 0:N.result,s.value=null,u.value=""},_.readAsDataURL(F)}},x=()=>{t.value="https://picsum.photos/seed/texture/512/512.jpg",s.value=null,u.value=""},v=()=>{h.value=!h.value},w=P=>{t.value=P,s.value=null,u.value=""},S=P=>{u.value=P},k=(P,D)=>{const F=document.createElement("canvas"),z=F.getContext("2d"),_=Math.max(P.width,P.height);if(_<=D)return F.width=P.width,F.height=P.height,z.drawImage(P,0,0),F;const B=D/_,N=Math.round(P.width*B),O=Math.round(P.height*B);return F.width=N,F.height=O,z.imageSmoothingEnabled=!0,z.imageSmoothingQuality="high",z.drawImage(P,0,0,N,O),F},E=P=>new Promise((D,F)=>{const z=new Image;z.crossOrigin="anonymous",z.onload=()=>D(z),z.onerror=F,z.src=P});Vr([t,i],async([P,D])=>{if(!P){e.value=null;return}try{const F=await E(P),z=k(F,D);e.value=z.toDataURL()}catch(F){console.error(":",F),u.value=""}});const I=async()=>{if(e.value){a.value=!0,u.value="";try{const P=new Image;P.crossOrigin="anonymous",await new Promise((N,O)=>{P.onload=N,P.onerror=O,P.src=e.value});const D=k(P,i.value),F=D.getContext("2d").getImageData(0,0,D.width,D.height),z=await Nk(F,r.value,null),_=document.createElement("canvas");_.width=z.width,_.height=z.height,_.getContext("2d").putImageData(z,0,0),s.value=_.toDataURL()}catch(P){console.error(":",P),u.value=`: ${P instanceof Error?P.message:""}`}finally{a.value=!1}}},C=()=>{f.value=!f.value},T=()=>{p.value=1,l.value&&l.value.resetZoom()},R=()=>{if(!s.value)return;const P=document.createElement("a");P.href=s.value,P.download=`seamless-texture-${Date.now()}.png`,document.body.appendChild(P),P.click(),document.body.removeChild(P)};return(P,D)=>(lt(),dt("div",$ue,[D[1]||(D[1]=Ve("a",{href:"https://github.com/leolee9086/seamless-texture-generator",target:"_blank",rel:"noopener noreferrer",class:"fixed top-4 left-4 z-30 w-10 h-10 flex items-center justify-center bg-gradient-to-br from-gray-700/80 to-gray-900/80 text-white rounded-full shadow-md transition-all duration-300 hover:shadow-lg hover:scale-110 active:scale-95backdrop-blur-sm",title:"View on GitHub"},[Ve("div",{class:"i-carbon-logo-github text-xl"})],-1)),Ve("main",kue,[Ve("div",Tue,[Ln(Fk,{ref_key:"viewerRef",ref:l,"original-image":e.value,"processed-image":s.value,"split-position":o.value,"onUpdate:splitPosition":D[0]||(D[0]=F=>o.value=F),"magnifier-enabled":f.value,"is-processing":a.value,"error-message":u.value,"zoom-level":p.value,class:"w-full h-full object-contain"},null,8,["original-image","processed-image","split-position","magnifier-enabled","is-processing","error-message","zoom-level"])]),Ve("div",Eue,[Ln(_k,{"is-processing":a.value,"camera-active":h.value,"supports-native-camera":c.value,"original-image":e.value,"processed-image":s.value,"max-resolution":i.value,"border-size":r.value,"split-position":o.value,"magnifier-enabled":f.value,"zoom-level":p.value,onControlEvent:m},null,8,["is-processing","camera-active","supports-native-camera","original-image","processed-image","max-resolution","border-size","split-position","magnifier-enabled","zoom-level"])])]),D[2]||(D[2]=Ve("div",{class:"fixed top-0 right-0 z-50 opacity-50 hover:opacity-100 pointer-events-none"},null,-1))]))}}),Nue={class:"w-screen h-screen bg-gradient-to-br from-gray-900 to-black text-white font-sans relative overflow-hidden flex flex-row"},_ue={class:"flex-1 relative z-0 overflow-hidden m-4 rounded-3xl shadow-inner bg-darkglass-200"},Due={class:"z-20 p-4 glass-panel m-4 ml-0 w-96 min-w-96 overflow-y-auto scrollbar-hide"},Aue=vo({__name:"Desktop",setup(n){const e=tt(null),t=tt(null),s=tt(null),r=tt(20),i=tt(4096),o=tt(.5),a=tt(!1),u=tt(""),l=tt(),h=tt(!1),c=tt(!1),d=tt(!1),p=tt(1),f=tt(!0),g=()=>{const P=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);d.value=P;const D="capture"in document.createElement("input");c.value=P&&D};Al(()=>{g()});const m=P=>{const{type:D,detail:F}=P;if(D==="button-click")switch(F.action){case"load-sample-image":x();break;case"toggle-camera":v();break;case"process-image":I();break;case"toggle-magnifier":C();break;case"reset-zoom":T();break;case"save-result":R();break}else if(D==="update-data")switch(F.action){case"image-upload":b(F.data);break;case"photo-captured":w(F.data);break;case"camera-error":S(F.data);break;case"max-resolution":i.value=F.data;break;case"border-size":r.value=F.data;break;case"split-position":o.value=F.data;break;case"zoom-level":p.value=F.data;break}},b=P=>{var z;const F=(z=P.target.files)==null?void 0:z[0];if(F){const _=new FileReader;_.onload=B=>{var N;t.value=(N=B.target)==null?void 0:N.result,s.value=null,u.value=""},_.readAsDataURL(F)}},x=()=>{t.value="https://picsum.photos/seed/texture/512/512.jpg",s.value=null,u.value=""},v=()=>{h.value=!h.value},w=P=>{t.value=P,s.value=null,u.value=""},S=P=>{u.value=P},k=(P,D)=>{const F=document.createElement("canvas"),z=F.getContext("2d"),_=Math.max(P.width,P.height);if(_<=D)return F.width=P.width,F.height=P.height,z.drawImage(P,0,0),F;const B=D/_,N=Math.round(P.width*B),O=Math.round(P.height*B);return F.width=N,F.height=O,z.imageSmoothingEnabled=!0,z.imageSmoothingQuality="high",z.drawImage(P,0,0,N,O),F},E=P=>new Promise((D,F)=>{const z=new Image;z.crossOrigin="anonymous",z.onload=()=>D(z),z.onerror=F,z.src=P});Vr([t,i],async([P,D])=>{if(!P){e.value=null;return}try{const F=await E(P),z=k(F,D);e.value=z.toDataURL()}catch(F){console.error(":",F),u.value=""}});const I=async()=>{if(e.value){a.value=!0,u.value="";try{const P=new Image;P.crossOrigin="anonymous",await new Promise((N,O)=>{P.onload=N,P.onerror=O,P.src=e.value});const D=k(P,i.value),F=D.getContext("2d").getImageData(0,0,D.width,D.height),z=await Nk(F,r.value,null),_=document.createElement("canvas");_.width=z.width,_.height=z.height,_.getContext("2d").putImageData(z,0,0),s.value=_.toDataURL()}catch(P){console.error(":",P),u.value=`: ${P instanceof Error?P.message:""}`}finally{a.value=!1}}},C=()=>{f.value=!f.value},T=()=>{p.value=1,l.value&&l.value.resetZoom()},R=()=>{if(!s.value)return;const P=document.createElement("a");P.href=s.value,P.download=`seamless-texture-${Date.now()}.png`,document.body.appendChild(P),P.click(),document.body.removeChild(P)};return(P,D)=>(lt(),dt("div",Nue,[D[1]||(D[1]=Ve("a",{href:"https://github.com/leolee9086/seamless-texture-generator",target:"_blank",rel:"noopener noreferrer",class:"fixed top-4 left-4 z-30 w-10 h-10 flex items-center justify-center bg-gradient-to-br from-gray-700/80 to-gray-900/80 text-white rounded-full shadow-md transition-all duration-300 hover:shadow-lg hover:scale-110 active:scale-95 backdrop-blur-sm",title:"View on GitHub"},[Ve("div",{class:"i-carbon-logo-github text-xl"})],-1)),Ve("div",_ue,[Ln(Fk,{ref_key:"viewerRef",ref:l,"original-image":e.value,"processed-image":s.value,"split-position":o.value,"onUpdate:splitPosition":D[0]||(D[0]=F=>o.value=F),"magnifier-enabled":f.value,"is-processing":a.value,"error-message":u.value,"zoom-level":p.value,class:"w-full h-full object-contain"},null,8,["original-image","processed-image","split-position","magnifier-enabled","is-processing","error-message","zoom-level"])]),Ve("div",Due,[Ln(_k,{"is-processing":a.value,"camera-active":h.value,"supports-native-camera":c.value,"original-image":e.value,"processed-image":s.value,"max-resolution":i.value,"border-size":r.value,"split-position":o.value,"magnifier-enabled":f.value,"zoom-level":p.value,onControlEvent:m},null,8,["is-processing","camera-active","supports-native-camera","original-image","processed-image","max-resolution","border-size","split-position","magnifier-enabled","zoom-level"])])]))}}),Fue=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),Pue=Fue?Rue:Aue;xR(Pue).mount("#app");
//# sourceMappingURL=index-C8LHO0sd.js.map
