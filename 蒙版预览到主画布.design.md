# 蒙版预览到主画布功能设计

## 需求
每个调整面板都应该有能力临时替换主要画布的显示，特别是LUT调整面板需要能在主画布预览蒙版。

## 设计方案 (更新版)

### 1. 添加previewOverlay状态

在`useTextureGenerator.ts`中：
```typescript
// 定义overlay数据接口
interface PreviewOverlayData {
  data: any  // 传递给组件的数据
  component: Component  // Vue组件
}

// interface中添加
previewOverlay: Ref<PreviewOverlayData | null>

// 实现中添加
const previewOverlay = ref<PreviewOverlayData | null>(null)

// 添加设置方法
const setPreviewOverlay = (data: any, component: Component) => {
  if (!data || !component) {
    previewOverlay.value = null
  } else {
    previewOverlay.value = { data, component }
  }
}

// 添加清除方法
const clearPreviewOverlay = () => {
  previewOverlay.value = null
}

// return中添加
return {
  // ... 现有的
  previewOverlay,
  setPreviewOverlay,
  clearPreviewOverlay
}
```

### 2. 修改Viewer组件

Viewer支持overlay组件显示：
```vue
<template>
  <div class="viewer-container">
    <!-- 原有的图像查看器 -->
    <div v-if="!previewOverlay" class="image-viewer">
      <!-- 现有的Viewer内容 -->
    </div>
    
    <!-- Overlay层 -->
    <div v-else class="preview-overlay">
      <component :is="previewOverlay.component" v-bind="previewOverlay.data" />
      
      <!-- 退出按钮 -->
      <button @click="clearOverlay" class="exit-overlay-btn">
        <div class="i-carbon-close"></div>
        退出预览
      </button>
    </div>
  </div>
</template>

<script setup>
const props = defineProps({
  previewOverlay: Object  // PreviewOverlayData | null
})

const emit = defineEmits(['clear-overlay'])

const clearOverlay = () => {
  emit('clear-overlay')
}
</script>
```

### 3. 创建MaskPreview组件

在`components/previews/MaskPreview.vue`：
```vue
<template>
  <div class="mask-preview-container">
    <div class="preview-header">
      <h3>蒙版预览</h3>
      <div class="layer-info">
        <span>当前图层: {{ activeLayerName }}</span>
        <span>可见图层: {{ visibleLayerCount }}</span>
      </div>
    </div>
    
    <div class="preview-content">
      <img :src="maskPreviewImage" alt="Mask Preview" />
    </div>
    
    <div class="preview-legend">
      <div class="legend-item">
        <div class="color-box red"></div>
        <span>LUT应用区域</span>
      </div>
      <div class="legend-item">
        <div class="color-box transparent"></div>
        <span>不应用LUT</span>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
interface Props {
  maskPreviewImage: string  // canvas.toDataURL()
  activeLayerName?: string
  visibleLayerCount?: number
  layers?: any[]
}

const props = defineProps<Props>()
</script>
```

### 4. 在ColorBlockSelector中添加预览逻辑

```vue
<script setup>
import { ref } from 'vue'
import MaskPreview from '../previews/MaskPreview.vue'

const maskPreviewMode = ref(false)

const toggleMaskPreview = async () => {
  if (maskPreviewMode.value) {
    // 退出预览
    emit('set-preview-overlay', null, null)
    maskPreviewMode.value = false
  } else {
    // 进入预览
    const maskImage = await generateMaskPreviewImage(props.originalImage)
    if (maskImage) {
      emit('set-preview-overlay', {
        maskPreviewImage: maskImage,
        activeLayerName: activeLayer.value?.name,
        visibleLayerCount: props.layers.filter(l => l.visible).length,
        layers: props.layers
      }, MaskPreview)
      maskPreviewMode.value = true
    }
  }
}
</script>

<template>
  <!-- 预览按钮 -->
  <button @click="toggleMaskPreview" class="preview-btn">
    <div :class="maskPreviewMode ? 'i-carbon-view-off' : 'i-carbon-view'"></div>
    {{ maskPreviewMode ? '退出预览' : '在画布预览' }}
  </button>
</template>
```

### 5. 事件流

```
ColorBlockSelector 
  -> emit('set-preview-overlay', data, MaskPreview) 
  -> LUTPanel
  -> emit('control-event', { 
       type: 'set-preview-overlay', 
       data: data,
       component: MaskPreview 
     })  
  -> useTextureGenerator.handleControlEvent
  -> setPreviewOverlay(data, component)
  -> Viewer渲染<component :is="component" v-bind="data" />
```

## 实现步骤

1. ✅ useTextureGenerator添加PreviewOverlayData接口和相关方法
2. ✅ Viewer组件支持动态组件渲染
3. ✅ 创建MaskPreview组件
4. ✅ useColorBlockSelector添加generateMaskPreviewImage方法
5. ✅ ColorBlockSelector添加预览按钮和逻辑
6. ✅ LUTPanel转发预览事件
7. ✅ controlEventHandler处理set-preview-overlay事件类型

## 优势

这个设计的优势：
1. **灵活性**: 可以传递任意数据和自定义组件
2. **可扩展**: 其他面板也可以用同样的方式实现预览
3. **隔离性**: 预览UI完全由传入的组件决定，不影响Viewer本身
4. **交互性**: 预览组件可以是交互式的（比如显示图层列表、调整参数等）

## 通用性示例

未来其他面板也可以这样用：

```typescript
// 裁剪预览
import CropPreview from './CropPreview.vue'
setPreviewOverlay({ 
  cropArea: { x, y, width, height },
  originalImage: imageUrl 
}, CropPreview)

// LUT对比预览
import LUTCompare from './LUTCompare.vue'
setPreviewOverlay({
  original: originalUrl,
  lutApplied: lutAppliedUrl,
  lutName: 'vintage-34.cube'
}, LUTCompare)
```
